! function(t) {
    function e(s) {
        if (i[s]) return i[s].exports;
        var n = i[s] = {
            i: s,
            l: !1,
            exports: {}
        };
        return t[s].call(n.exports, n, n.exports, e), n.l = !0, n.exports
    }
    var i = {};
    e.m = t, e.c = i, e.d = function(t, i, s) {
        e.o(t, i) || Object.defineProperty(t, i, {
            configurable: !1,
            enumerable: !0,
            get: s
        })
    }, e.n = function(t) {
        var i = t && t.__esModule ? function e() {
            return t.default
        } : function e() {
            return t
        };
        return e.d(i, "a", i), i
    }, e.o = function(t, e) {
        return Object.prototype.hasOwnProperty.call(t, e)
    }, e.p = "", e(e.s = 57)
}([function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(5);
    e.MyRand = s.MyRand, e.UiStrUtil = s.UiStrUtil;
    var n = i(41);
    e.Drawing = n.Drawing;
    var a = i(19);
    e.NapeUtil = a.NapeUtil;
    var o = i(67);
    e.GameCore = o.GameCore;
    var r = i(68);
    e.GameObject = r.GameObject;
    var h = i(69);
    e.IDisposed = h.IDisposed;
    var l = i(70);
    e.IUpdated = l.IUpdated;
    var c = i(71);
    e.ISafed = c.ISafed;
    var u = i(72);
    e.IRestarted = u.IRestarted;
    var d = i(73);
    e.IActivatable = d.IActivatable;
    var p = i(42);
    e.GamePhysics = p.GamePhysics;
    var f = i(43);
    e.NapePhysics = f.NapePhysics;
    var g = i(74);
    e.GameView = g.GameView;
    var y = i(44);
    e.RaceCamera = y.RaceCamera;
    var m = i(33);
    e.CameraPathes = m.CameraPathes;
    var v = i(75);
    e.CarParams = v.CarParams;
    var b = i(76);
    e.CarUpgrades = b.CarUpgrades;
    var x = i(77);
    e.RaceCars = x.RaceCars;
    var _ = i(78);
    e.WeaponParams = _.WeaponParams;
    var w = i(45);
    e.Inventory = w.Inventory;
    var C = i(79);
    e.LeagueVO = C.LeagueVO;
    var P = i(80);
    e.MapVO = P.MapVO;
    var T = i(81);
    e.RaceData = T.RaceData;
    var S = i(82);
    e.BgElVo = S.BgElVo;
    var A = i(83);
    e.ShopCarVO = A.ShopCarVO;
    var E = i(46);
    e.CarsData = E.CarsData;
    var I = i(35);
    e.GameData = I.GameData;
    var M = i(34);
    e.RacesData = M.RacesData;
    var O = i(84);
    e.ShopData = O.ShopData;
    var B = i(85);
    e.CarBuilder = B.CarBuilder;
    var R = i(87);
    e.RaceBuilder = R.RaceBuilder;
    var k = i(88);
    e.FrameGraphic = k.FrameGraphic;
    var D = i(49);
    e.GroundPartClip = D.GroundPartClip;
    var L = i(48);
    e.SmokePartClip = L.SmokePartClip;
    var F = i(89);
    e.TrailPart = F.TrailPart;
    var G = i(90);
    e.WheelGraphic = G.WheelGraphic;
    var U = i(91);
    e.BgEl = U.BgEl;
    var N = i(92);
    e.LandscapeShape = N.LandscapeShape;
    var j = i(50);
    e.CarObject = j.CarObject;
    var W = i(93);
    e.BikeObject = W.BikeObject;
    var X = i(94);
    e.CorpseObject = X.CorpseObject;
    var H = i(95);
    e.DriverObject = H.DriverObject;
    var V = i(96);
    e.FrameObject = V.FrameObject;
    var Y = i(97);
    e.PartObject = Y.PartObject;
    var q = i(98);
    e.WheelObject = q.WheelObject;
    var z = i(99);
    e.BgObject = z.BgObject;
    var K = i(100);
    e.DecorActObject = K.DecorActObject;
    var J = i(101);
    e.DecorMultiObject = J.DecorMultiObject;
    var Z = i(51);
    e.DecorObject = Z.DecorObject;
    var Q = i(102);
    e.VectorDecor = Q.VectorDecor;
    var $ = i(39);
    e.CarExplodeObject = $.CarExplodeObject;
    var tt = i(52);
    e.GlassExplodeObject = tt.GlassExplodeObject;
    var et = i(38);
    e.TrailParticlesSystem = et.TrailParticlesSystem;
    var it = i(47);
    e.TrailPartObject = it.TrailPartObject;
    var st = i(103);
    e.GlassBlock = st.GlassBlock;
    var nt = i(53);
    e.GlassBlockPart = nt.GlassBlockPart;
    var at = i(104);
    e.GroundObject = at.GroundObject;
    var ot = i(105);
    e.PlankObject = ot.PlankObject;
    var rt = i(106);
    e.ShaperObject = rt.ShaperObject;
    var ht = i(107);
    e.WaterObject = ht.WaterObject;
    var lt = i(109);
    e.BoostObject = lt.BoostObject;
    var ct = i(55);
    e.DynamicBodyObject = ct.DynamicBodyObject;
    var ut = i(110);
    e.FinishObject = ut.FinishObject;
    var dt = i(111);
    e.MotorObject = dt.MotorObject;
    var pt = i(112);
    e.MoverPatherObject = pt.MoverPatherObject;
    var ft = i(113);
    e.PivotObject = ft.PivotObject;
    var gt = i(114);
    e.RemovedBodyObjects = gt.RemovedBodyObjects;
    var yt = i(115);
    e.SafePointObject = yt.SafePointObject;
    var mt = i(116);
    e.SpikesObject = mt.SpikesObject;
    var vt = i(117);
    e.TntObject = vt.TntObject;
    var bt = i(118);
    e.ToggleObject = bt.ToggleObject;
    var xt = i(119);
    e.CameraZone = xt.CameraZone;
    var _t = i(120);
    e.WaypointObject = _t.WaypointObject;
    var wt = i(1);
    e.ObjectTypes = wt.ObjectTypes;
    var Ct = i(11);
    e.CbTypes = Ct.CbTypes;
    var Pt = i(7);
    e.Filters = Pt.Filters;
    var Tt = i(9);
    e.Materials = Tt.Materials;
    var St = i(121);
    e.MaxPhysics = St.MaxPhysics;
    var At = i(122);
    e.BodyEffector = At.BodyEffector;
    var Et = i(123);
    e.BoostEffector = Et.BoostEffector;
    var It = i(124);
    e.PlayerController = It.PlayerController;
    var Mt = i(56);
    e.CarController = Mt.CarController;
    var Ot = i(6);
    e.GraphicUtil = Ot.GraphicUtil;
    var Bt = i(54);
    e.PhysicUtil = Bt.PhysicUtil;
    var Rt = i(2);
    e.MaxGameView = Rt.MaxGameView
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.BG = 0, t.LANDSCAPE = 1, t.LANDSCAPE_SHAPE = 9, t.CAR = 2, t.BULLET = 3, t.FRONT = 4, t.OBJECT = 5, t.EFFECT = 6, t.CAR_PART = 7, t.LANDSCAPE_BACK = 8, t
    }();
    e.ObjectTypes = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(20),
        o = i(1),
        r = Phaser.SpriteBatch,
        h = i(8),
        l = i(5),
        c = i(36),
        u = i(3),
        d = function() {
            function t() {}
            return t
        }();
    e.default = d;
    var p = function() {
        function t(t, e, i) {
            this.target = i, this.method = e, this.key = t
        }
        return t
    }();
    e.RenderVO = p;
    var f = function() {
        function t() {}
        return t.BG = [["Bg0_0", "0Bg1_0", "0Bg2_0"], ["Bg0_0", "Bg1_0", "Bg2_0"], ["Bg0_0", "Bg1_0", "Bg2_0"]], t.ROAD_LINE = [["line", "RoadLine0_1", "RoadLine1_4", "RoadLine0_3", "RoadLine0_4", "Plank0", "RoadLine0_0", "RoadLine0_7", "RoadLine0_8", "line_ivy", "UnLine0", "UnLine1", "LineChain", "CandyGround", "RoadLine0_Bg"], ["line", "RoadLine0_1", "RoadLine1_4", "RoadLine0_3", "RoadLine0_4", "Plank0", "RoadLine0_0", "RoadLine0_7", "RoadLine0_8", "line_ivy", "UnLine0", "UnLine1", "LineChain", "CandyGround", "RoadLine0_Bg"]], t.PILLAR_LINE = [["RoadPillar0_0", "RoadPillar0_1", "RoadPillar0_2"], ["RoadPillar0_0", "RoadPillar0_1", "RoadPillar0_2"]], t.ROAD_TILE = ["RoadTile0", "RoadTile0", "RoadTile0"], t.ROAD_SHAPE = [["RoadTile0_1", "RoadTile1_1", "RoadTile0", "UnTile0", "UnTile1", "UnTile2", "RoadTile0_Bg"], ["RoadTile0_1", "RoadTile1_1", "RoadTile0", "UnTile0", "UnTile1", "UnTile2", "RoadTile0_Bg"]], t.DECORS = [["Dec0", "Dec2_0", "Dec1_1", "Dec1_2", "Dec1_0", "Dec1", "Dec2", "Dec3", "Dec4", "Dec5", "Dec6", "Dec7", "Dec8", "Dec9", "Dec10", "Dec11", "Dec12", "Dec13", "Dec14", "Dec15", "Dec16", "Dec17", "Dec18", "Dec19", "Dec29", "Sign1", "Sign2", "Sign15", "Sign21", "SignPillar", "PillarTop0_0", "PillarTop0_1", "PillarTop0_2", "PillarBot0_0", "PillarBot0_1", "PillarBot0_2", "GlassCrashed0_0", "GlassCrashed0_1", "GlassCrashed0_2", "GlassCrashed0_3", "GlassCrashed0_4", "GlassCrashed0_5", "BoostAnim", "RocketAnim", "Pivot0", "particle_boost", "GeyserBase", "geyser_anim", "PlankCandy0", "PlankCandy1"], ["Dec1_1", "Dec1_2", "Dec1_0", "Dec11", "Dec17", "Dec18", "Dec19", "Dec29", "Sign1", "Sign2", "Sign15", "Sign21", "SignPillar", "PillarTop0_0", "PillarTop0_1", "PillarTop0_2", "PillarBot0_0", "PillarBot0_1", "PillarBot0_2", "GlassCrashed0_0", "GlassCrashed0_1", "GlassCrashed0_2", "GlassCrashed0_3", "GlassCrashed0_4", "GlassCrashed0_5", "BoostAnim", "RocketAnim", "Pivot0", "particle_boost", "GeyserBase", "geyser_anim", "PlankCandy0", "PlankCandy1"]], t.OBJECTS = [["Tnt1", "BarrelE", "SpikesE", "Removed0", "Removed1", "Plank0", "GlassCrashed0", "GlassCrashed1", "BoostE", "PlankCandy", "PlankBone"], ["Tnt1", "BarrelE", "SpikesE", "Removed0", "Removed1", "Plank0", "GlassCrashed0", "GlassCrashed1", "BoostE", "PlankCandy", "PlankBone"], ["Tnt1", "BarrelE", "SpikesE", "Removed0", "Removed1", "Plank0", "GlassCrashed0", "GlassCrashed1", "BoostE", "PlankCandy", "PlankBone"]], t.FRAMES_ANCHORX = [.48, .493, .45, 0, .52], t.FRAMES_ANCHORY = [.65, .65, .62, 0, .65], t.SUSPEND_BACK_ANCHORX = [.05, 0, .05, 0, 0], t.SUSPEND_BACK_ANCHORY = [.5, .5, .5, 0, .5], t.SUSPEND_FRONT_ANCHORX = [.8, .8, .74, 0, .95], t.SUSPEND_FRONT_ANCHORY = [.2, .5, .5, 0, .5], t.WHEELS = [["Wheel_1_0"], ["Wheel_2_0"], ["Wheel_3_0"], ["Wheel_4_0"], ["Wheel_5_0"]], t
    }();
    e.AssetsList = f;
    var g = function() {
        function t() {
            this.storage = {}
        }
        return t.prototype.getByKey = function(t) {
            return this.storage[t]
        }, t.prototype.add = function(t, e) {
            this.storage[t] = e
        }, t.prototype.dispose = function() {
            for (var t in this.storage) this.storage[t] && (this.storage[t] = null)
        }, Object.defineProperty(t, "instance", {
            get: function() {
                return null === t._instance && (t._instance = new t), t._instance
            },
            enumerable: !0,
            configurable: !0
        }), t._instance = null, t
    }();
    e.AssetsStorage = g;
    var y = function(t) {
        function e(e) {
            var i = t.call(this, e) || this;
            return i.gamePadLayer = null, i.bg = new r(i.game, i.game.world), i.bg.interactive = !1, i.bg.scale.set(2), i.race = new r(i.game, i.game.world), i.race.interactive = !1, i.landscapeShapes = new r(i.game, i.race), i.landscape = new r(i.game, i.race), i.objects = new r(i.game, i.race), i.front = new r(i.game, i.race), i.raceCamera = new n.RaceCamera, i.raceCamera.setup(i.race, a.default.GAME_W, a.default.GAME_H, u.MaxGameCore.instance), i.gamePadLayer = i.game.add.spriteBatch(i.game.world), c.default.instance.init(i.gamePadLayer, i.game), i
        }
        return s(e, t), e.prototype.start = function() {
            t.prototype.start.call(this), this.game.world.addChild(this.bg), this.game.world.addChild(this.race), this.game.world.addChild(this.gamePadLayer), this.raceCamera.setup(this.race, a.default.GAME_W, a.default.GAME_H, u.MaxGameCore.instance)
        }, e.prototype.add = function(t) {
            t.type === o.ObjectTypes.BG ? this.bg.addChild(t.graphic) : t.type === o.ObjectTypes.LANDSCAPE ? (this.landscape.addChild(t.graphic), t.bgShape && this.landscapeShapes.addChild(t.bgShape)) : t.type === o.ObjectTypes.LANDSCAPE_SHAPE ? this.landscapeShapes.addChild(t.graphic) : t.type === o.ObjectTypes.LANDSCAPE_BACK ? this.landscape.addChildAt(t.graphic, 0) : t.type === o.ObjectTypes.CAR ? this.objects.addChild(t.graphic) : t.type === o.ObjectTypes.OBJECT ? this.objects.addChild(t.graphic) : t.type === o.ObjectTypes.BULLET ? this.objects.addChild(t.graphic) : t.type === o.ObjectTypes.EFFECT ? this.front.addChild(t.graphic) : t.type === o.ObjectTypes.CAR_PART ? this.front.addChildAt(t.graphic, 0) : t.type === o.ObjectTypes.FRONT && this.front.addChild(t.graphic)
        }, e.prototype.update = function(e, i, s, a) {
            if (t.prototype.update.call(this, e, i, s, a), s) {
                var o = n.RacesData.TARGET_X,
                    r = n.RacesData.TARGET_Y;
                n.CameraZone.focusedOnPoint ? this.raceCamera.focusOnPoint(o, r) : n.CameraZone.current ? this.raceCamera.focusOnCameraZone(o, r) : this.raceCamera.focusOnCar(o, r, e)
            }
        }, e.prototype.release = function() {
            this.raceCamera.release(), this.raceCamera = null, this.bg = null, this.landscape = null, this.landscapeShapes = null, this.objects = null, this.front = null
        }, e
    }(n.GameView);
    e.MaxGameView = y;
    var m = function() {
        function t() {
            this.complete = new h.Signal
        }
        return Object.defineProperty(t, "instance", {
            get: function() {
                return null === t._instance && (t._instance = new t), t._instance
            },
            enumerable: !0,
            configurable: !0
        }), t.prototype.start = function() {
            this.theme = n.RacesData.map.settings.theme % 3, this.theme > 1 && (this.theme = 0);
            var t = null,
                e = 0,
                i = "",
                s = g.instance,
                a = f.BG[this.theme];
            for (s.add("Bg0", a[0]), a[1] && s.add("Bg1", a[1]), a[2] && s.add("Bg2", a[2]), t = f.ROAD_LINE[this.theme], e = 0; e < t.length; e++) i = t[e], s.add("road_line" + e.toString(), i);
            for (t = f.PILLAR_LINE[this.theme], e = 0; e < t.length; e++) i = t[e], s.add("pillar_line" + e.toString(), i);
            for (i = f.ROAD_TILE[this.theme], s.add("road_tile", i), t = f.ROAD_SHAPE[this.theme], e = 0; e < t.length; e++) i = t[e], s.add("road" + e.toString(), i);
            for (t = f.DECORS[this.theme], e = 0; e < t.length; e++) i = t[e], s.add(i, i);
            for (t = f.OBJECTS[this.theme], e = 0; e < t.length; e++) i = t[e], this.addObject(i);
            s.add("smoke_part", "smoke_part_anim"), s.add("ground_part", "ground_part_anim"), s.add("car_exp_anim", "CarExplode"), s.add("cloud_anim", "DestCloud"), s.add("SafePointAnim", "SafePointAnim"), s.add("Motor0", "Motor0"), s.add("Motor1", "Motor1"), s.add("glass_exp_anim", "GlassExplode"), this.addCar(n.CarsData.params, !1)
        }, t.prototype.addObject = function(t, e) {
            void 0 === e && (e = "");
            var i = t,
                s = n.CarsData.geomObj[i];
            return g.instance.add(i + "_data", s), g.instance.add(i, i), s
        }, t.prototype.addCar = function(t, e) {
            var i, s = g.instance,
                a = n.Inventory.instance.skin;
            n.RacesData.data.skinId = a;
            var o;
            o = f.WHEELS[a - 1][t.wheels], i = o, s.getByKey(i + "b") || (s.add(i + "b", o), s.add(i + "f", o)), i = "car_wheel" + a.toString(), s.getByKey(i) || s.add(i, o), s.add(o, o), s.add("suspend_back", "suspend_back"), s.add("suspend_front", "suspend_front"), s.add("Car" + a.toString() + "FrameExploded", "Car" + a.toString() + "FrameExploded"), i = "bike_" + a.toString() + "_base", s.getByKey(i) || s.add(i, i), i = "driver_shin", this.parsePart(i), i = "driver_hip", this.parsePart(i), i = "driver_corpse", this.parsePart(i), i = "driver_arm", this.parsePart(i), i = "driver_forearm", this.parsePart(i), i = "driver_head", this.parsePart(i), this.complete.dispatch(this)
        }, t.prototype.parsePart = function(t) {
            var e = {
                x: 0,
                y: 0,
                r: 0 * l.default.TO_RAD,
                w: 1,
                h: 1
            };
            return g.instance.add(t, t), e
        }, t.prototype.dispose = function() {
            this.complete.removeAll()
        }, t._instance = null, t
    }();
    e.RaceAssetsLoader = m;
    var v = function() {
        function t(t) {
            void 0 === t && (t = "bg0000"), this.nameTex = "", this._bitmapData = null, this._rect = new Phaser.Rectangle(0, 0, 1, 1), this.nameTex = t + "0000"
        }
        return Object.defineProperty(t.prototype, "bitmapData", {
            get: function() {
                return this._bitmapData = n.GraphicUtil.game.make.sprite(0, 0, n.GraphicUtil.currentAtlass, this.nameTex), this._bitmapData
            },
            enumerable: !0,
            configurable: !0
        }), Object.defineProperty(t.prototype, "rect", {
            get: function() {
                return this._rect = new Phaser.Rectangle(0, 0, this._bitmapData.width, this._bitmapData.height), this._rect
            },
            enumerable: !0,
            configurable: !0
        }), t
    }();
    e.SpriteData = v
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(43),
        a = i(0),
        o = i(2),
        r = i(37),
        h = i(33),
        l = i(10),
        c = i(4),
        u = i(17),
        d = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.car = null, e.carBuilder = null, e.paused = !1, e.drive = !1, e.finished = !1, e.playerController = null, e.countdown = 0, e.countdownTotal = 0, e.timer = 0, e.signalFinish = null, e.signalLoaded = null, e.pitchPlaying = !1, e.prevPart = 0, e.prevAccel = !1, e.enginePitch = null, e.engineGazNum = 0, e.engineGaz = null, e.engineStart = null, e.engineLoop = null, e.gamePadLayer = null, e
            }
            return s(e, t), Object.defineProperty(e, "instance", {
                get: function() {
                    return null === e._instance && (e._instance = new e), e._instance
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.init = function(e) {
                t.prototype.init.call(this, e), this.physics = new a.MaxPhysics, this.signalFinish && this.signalFinish.removeAll(), this.pitchPlaying = !1, this.prevPart = 0, this.engineGazNum = Math.round(3 * Math.random()), this.signalFinish = new Phaser.Signal, this.signalLoaded = new Phaser.Signal, this.view = new a.MaxGameView(this.game)
            }, e.prototype.add = function(i) {
                if (null !== i) {
                    if (t.prototype.add.call(this, i), i.isActive) {
                        var s = e.activatables[i.id];
                        s || (s = [], e.activatables[i.id] = s), s[s.length] = i
                    }
                    i.review && (i instanceof a.DriverObject || (e.safed[e.safed.length] = i))
                }
            }, e.prototype.release = function() {
                this.playerController = null, this.playerCar = null, this.car = null, this.finished = !1, this.gamePadLayer = null;
                for (var i in e.activatables) e.activatables[i] && (e.activatables[i] = null);
                h.CameraPathes.instance.clear(), e.targets.splice(0, e.targets.length), e.safed.splice(0, e.safed.length), this.enginePitch && this.enginePitch.stop(), this.pitchPlaying = !1, this.prevPart = 0, this.enginePitch = null, this.stopAllSounds(), a.Drawing.release(), t.prototype.release.call(this)
            }, e.prototype.stopAllSounds = function() {
                this.engineGaz && this.engineGaz.stop(), this.engineGaz = null, this.engineLoop && this.engineLoop.stop(), this.engineLoop = null, this.engineStart && this.engineStart.stop(), this.engineStart = null
            }, e.prototype.activate = function(t, i) {
                var s = e.activatables[t.toString()];
                if (s)
                    for (var n = 0; n < s.length; n++) {
                        var a = s[n];
                        a.activate(i)
                    }
            }, e.prototype.start = function() {
                t.prototype.start.call(this), this.timer = 0, this.setMap(a.GameData.currentLevel)
            }, e.prototype.setDelayedMasks = function() {
                for (var t = 0; t < a.GraphicUtil.masks.length; t++) {
                    var e = a.GraphicUtil.masks[t];
                    a.GraphicUtil.maskOwners[t].mask = e
                }
                a.GraphicUtil.masks = [], a.GraphicUtil.maskOwners = [], this.signalLoaded.dispatch()
            }, e.prototype.calcEngineSound = function(t) {
                if (this.enginePitch) {
                    if (this.paused) return void(this.pitchPlaying && (this.pitchPlaying = !1, this.enginePitch.stop()));
                    var e = .1,
                        i = .5,
                        s = this.car.dead ? 0 : .5;
                    u.default.getInstance()
                        .sfx || (s = 0);
                    var n = t / 80;
                    n > 1 && (n = 1), n = this.prevPart + .2 * (n - this.prevPart), n < 0 && (n = 0), this.pitchPlaying ? (this.prevPart !== n && (this.enginePitch.volume = (.1 + .5 * n) * s), this.prevPart = n) : (this.enginePitch.play("", 0, (.1 + .5 * n) * s, !0), this.pitchPlaying = !0)
                }
            }, e.prototype.update = function(i) {
                if (!this.playerCar) {
                    if (!this.car) return;
                    this.playerCar = this.car
                }
                if (this.calcEngineSound(this.playerCar.backWheel.body.angularVel), null !== this.engineStart && (this.engineStart.isPlaying || null === this.engineLoop && (this.engineLoop = l.default.getInstance()
                        .play(c.Sounds.EngineFon, 1, !0))), this.paused) null !== this.engineLoop && (this.engineLoop.volume = 0), null !== this.engineStart && this.engineStart.isPlaying && (this.engineStart.volume = 0), null !== this.engineGaz && (this.engineGaz.stop(), this.engineGaz = null);
                else if (null !== this.engineLoop)
                    if (this.car.dead) this.engineLoop.volume = 0, null !== this.engineGaz && (this.engineGaz.stop(), this.engineGaz = null);
                    else {
                        if (this.engineLoop.volume = u.default.getInstance()
                            .sfx ? 1 : 0, null !== this.engineGaz && (this.engineGaz.volume = u.default.getInstance()
                                .sfx ? 1 : 0), !this.prevAccel && this.car.accell) {
                            null !== this.engineGaz && (this.engineGaz.stop(), this.engineGaz = null), this.engineGazNum++, 5 === this.engineGazNum && (this.engineGazNum = 1);
                            var s = "accel0" + this.engineGazNum;
                            this.engineGaz = l.default.getInstance()
                                .play(s)
                        }
                        this.prevAccel = this.car.accell
                    } this.paused || (a.RacesData.data.delayForMaks > 0 && (a.RacesData.data.delayForMaks -= i, a.RacesData.data.delayForMaks <= 0 && e.instance.setDelayedMasks()), this.updateIternal(i), t.prototype.update.call(this, i), this.view.update(this.car.speed, 0, !0, i), this.car.frame.graphic.update2(i))
            }, e.prototype.processFinish = function() {
                this.finished || (this.finished = !0, this.signalFinish.dispatch(1), l.default.getInstance()
                    .play(c.Sounds.Finish))
            }, e.prototype.updateIternal = function(t) {
                this.paused ? r.default.instance.hideTimer() : this.drive ? (this.timer += t, r.default.instance.showTimer()) : (this.playerCar.accell || 0 !== this.playerCar.tilt) && (this.drive = !0, r.default.instance.hideControlsHint()), a.RacesData.TARGET_X = this.playerCar.x, a.RacesData.TARGET_Y = this.playerCar.y
            }, e.prototype.setMap = function(t) {
                t.id = a.GameData.raceId, a.RacesData.map = t, this.prepareAssets()
            }, e.prototype.prepareAssets = function() {
                o.RaceAssetsLoader.instance.complete.add(this.assetsReady, this), o.RaceAssetsLoader.instance.start()
            }, e.prototype.assetsReady = function(t) {
                void 0 === t && (t = null), t && t.dispose(), a.RacesData.data.assetsReady = !0, this.buildLevel()
            }, e.prototype.buildLevel = function() {
                a.RacesData.data.restart();
                var t = new a.RaceBuilder;
                t.complete.add(this.buildReady, this), t.start()
            }, e.prototype.buildReady = function(t) {
                void 0 === t && (t = null), t && t.dispose(), this.createCars()
            }, e.prototype.createCars = function() {
                this.carBuilder || (this.carBuilder = new a.CarBuilder), this.carBuilder.complete.add(this.carsReady, this), this.carBuilder.createAllCars()
            }, e.prototype.carsReady = function() {
                null != this.carBuilder && this.carBuilder.dispose(), this.carBuilder = null, a.RacesData.data.camera = e.instance.view.raceCamera
            }, e.prototype.getSpace = function() {
                return n.NapePhysics.space
            }, e.prototype.restartFromSafePoint = function(t) {
                for (var i = 0; i < e.safed.length; i++) {
                    e.safed[i].review()
                }
            }, e.prototype.initialDeactivate = function() {
                for (var t in e.activatables)
                    if (e.activatables[t])
                        for (var i = e.activatables[t], s = 0; s < i.length; s++) {
                            var n = i[s];
                            n && (n.isActive || n.activate(!1))
                        }
            }, e._instance = null, e.activatables = {}, e.safed = [], e.targets = [], e
        }(a.GameCore);
    e.MaxGameCore = d
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(30);
    e.Images = s.default;
    var n = i(21);
    e.Constants = n.default;
    var a = i(22);
    e.Atlases = a.default;
    var o = i(25);
    e.Sounds = o.default;
    var r = i(31);
    e.JSONData = r.default
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.normalizeAngle = function(t) {
            return t > Math.PI ? t -= 2 * Math.PI : t < -Math.PI && (t += 2 * Math.PI), t
        }, t.normalizeAngle2 = function(t) {
            return t %= 2 * Math.PI, t > Math.PI ? t -= 2 * Math.PI : t < -Math.PI && (t += 2 * Math.PI), t
        }, t.normalizeVertices = function(e) {
            var i = {};
            i.className = e.className, i.params = {}, i.params.vertices = [];
            var s = e.params,
                n = s.x,
                a = s.y;
            for (var o in s) "vertices" !== o && (i.params[o] = s[o]);
            for (var r = t.TO_RAD * s.rotation, h = s.vertices, l = i.params.vertices, c = h.length, u = 0; u < c; u++) {
                var d = Math.round(h[u].x),
                    p = Math.round(h[u].y);
                if (l[u] = {}, 0 === d && 0 === p) l[u].x = n, l[u].y = a;
                else {
                    var f = void 0;
                    f = Math.atan2(p, d);
                    var g = Math.sqrt(d * d + p * p);
                    f += r, l[u].x = n + Math.cos(f) * g, l[u].y = a + Math.sin(f) * g
                }
            }
            return i.params.x = 0, i.params.y = 0, i.params.rotation = 0, i
        }, t.dist = function(t, e, i, s) {
            return Math.sqrt((t - i) * (t - i) + (e - s) * (e - s))
        }, t.TO_RAD = Math.PI / 180, t.TO_DEG = 180 / Math.PI, t.PIdiv2 = Math.PI / 0, t.PIdiv4 = Math.PI / 4, t.PIdiv4mul3 = 3 * Math.PI / 4, t
    }();
    e.default = s;
    var n = function() {
        function t() {}
        return t.rand = function(t, e) {
            return t - .5 * e + e * Math.random()
        }, t
    }();
    e.MyRand = n;
    var a = function() {
        function t() {}
        return t.formatPrice = function(e, i) {
            void 0 === i && (i = "$ ");
            for (var s = 0; e >= 1e3;) e /= 1e3, ++s;
            return i + e.toString() + t.RANKS[s] + t.PRICE_POSTFIX
        }, t.formatTime = function(t) {
            var e = t / 60 >> 0,
                i = e.toString();
            e < 10 && (i = "0" + i), t -= 60 * e, e = t >> 0;
            var s = e.toString();
            return e < 10 && (s = "0" + s), i + ":" + s
        }, t.PRICE_POSTFIX = "", t.RANKS = ["", "k", "m", "omg", "wtf"], t
    }();
    e.UiStrUtil = a
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(41),
        n = i(8),
        a = i(0),
        o = i(5),
        r = i(4),
        h = i(2),
        l = i(20),
        c = function() {
            function t() {}
            return t.createGround = function(e, i, a, o, r, c, u) {
                var d = t.game.add.group();
                d.x = e, d.y = i;
                var p = t.game.add.graphics(0, 0);
                d.addChild(p);
                var f = null;
                if (r && (f = h.AssetsStorage.instance.getByKey("road_tile"))) {
                    var g = a[0],
                        y = new n.Point(115e3, 115e3);
                    p.beginFill(16711935, 1), p.moveTo(g.x, c + l.default.GAME_H);
                    for (var m = a.length, v = 0; v < m; v++) a[v].x < y.x && (y.x = a[v].x), a[v].y < y.y && (y.y = a[v].y), g = a[v], p.lineTo(g.x, g.y);
                    p.lineTo(g.x, c + l.default.GAME_H), p.endFill();
                    var b = this.game.add.tileSprite(y.x, y.y, p.width, p.height, t.currentAtlass, 100 === u ? "finish0000" : "tile0000");
                    d.add(b), b.tilePosition.x = -e % 256, b.tilePosition.y = -i % 256, d.addChild(p), t.masks.push(p), t.maskOwners.push(b)
                }
                if (o) {
                    var x = null;
                    0 === u ? x = "line" : 1 === u ? x = h.RaceAssetsLoader.instance.theme > 0 ? "line_top" : "line_bg" : 2 === u ? x = "line_bg" : 3 === u && (x = "line_metal_g"), x && ("line" === x || 1 === u ? s.Drawing.drawBitmapPath(x, d, a) : s.Drawing.drawBitmapPath2(x, d, a))
                }
                return d
            }, t.createCarFrameGraphic = function(t, e) {
                return new a.FrameGraphic(t, e)
            }, t.createCarWheelGraphic = function(t, e, i) {
                return new a.WheelGraphic(t, i)
            }, t.createImageWithObj = function(e, i) {
                if (null === i) return null;
                var s;
                return s = t.game.add.sprite(0, 0, t.currentAtlass, i + "0000"), s.anchor.set(.5), e && (s.position.set(e.x, e.y), s.rotation = o.default.TO_RAD * e.rotation), s
            }, t.createMovieClip = function(e, i, s, n, a) {
                if (void 0 === s && (s = 12), void 0 === n && (n = !0), void 0 === a && (a = !1), null === i) return null;
                var r;
                return "SafePointAnim" === i || "CarExplode" === i ? (r = t.game.add.sprite(0, 0, t.currentAtlass, "bg0000"), r.animations.add(i, Phaser.Animation.generateFrameNames(i, 0, 28, "", 4)), r.anchor.set(.5), r.animations.getAnimation(i)
                    .play(30), r.animations.getAnimation(i)
                    .stop()) : "CarExplode" === i ? (r = t.game.add.sprite(0, 0, t.currentAtlass, i + "0000"), r.animations.add(i, Phaser.Animation.generateFrameNames(i, 0, 28, "", 4)), r.anchor.set(.5), r.animations.getAnimation(i)
                    .play(30), r.animations.getAnimation(i)
                    .stop()) : (r = t.game.add.sprite(0, 0, t.currentAtlass, "bg0000"), r.scale.set(.4)), e && (r.position.set(e.x, e.y), r.rotation = o.default.TO_RAD * e.rotation), r
            }, t.createImage = function(e, i, s, n) {
                if (null === n) return null;
                var r, l = n + "",
                    c = a.Inventory.instance.skin;
                return 0 === l.indexOf("driver") || 0 === l.indexOf("suspend") ? (2 === c && -1 !== l.indexOf("back") ? (r = t.game.add.sprite(0, 0, t.currentAtlass, l + "10000"), r.alpha = 0) : 4 === c && -1 !== l.indexOf("front") ? (r = t.game.add.sprite(0, 0, t.currentAtlass, l + "10000"), r.alpha = 0) : r = t.game.add.sprite(0, 0, t.currentAtlass, l + c + "0000"), 0 === l.indexOf("suspend") ? -1 !== l.indexOf("back") ? r.anchor.set(h.AssetsList.SUSPEND_BACK_ANCHORX[c - 1], h.AssetsList.SUSPEND_BACK_ANCHORY[c - 1]) : r.anchor.set(h.AssetsList.SUSPEND_FRONT_ANCHORX[c - 1], h.AssetsList.SUSPEND_FRONT_ANCHORY[c - 1]) : r.anchor.set(.5)) : -1 !== l.indexOf("FrameExploded") ? (r = t.game.add.sprite(0, 0, t.currentAtlass, l + "0000"), r.anchor.set(h.AssetsList.FRAMES_ANCHORX[c - 1], h.AssetsList.FRAMES_ANCHORY[c - 1])) : (r = t.game.add.sprite(0, 0, t.currentAtlass, l + "0000"), r.scale.set(.4)), r.rotation = s * o.default.TO_RAD, r
            }, t.createLandscapeShape = function(e, i, o) {
                var r = new a.LandscapeShape(e, i, o),
                    h = a.RacesData.map.settings.theme;
                r.x = e.params.x - i, r.y = e.params.y - o;
                var l = null;
                l = 1 === h ? "tile_stone" : "RoadTile0_1";
                var c = e.params.layer;
                1 === c ? l = 3 === h ? "tile_stone" : "tile_bg" : 2 === c ? l = "tile" : 3 === c ? l = 4 === h ? "tile_shape" : "tile_saw" : 4 === c ? l = 4 === h ? "tile_shape1" : "tile_rivet" : 5 === c ? l = 4 === h ? "tile_shape2" : "tile_rivet_bg" : 6 === c && (l = "tile_stone");
                var u = e.params.vertices,
                    d, p = null;
                0 === c ? 1 === h ? (p = "line_stone_shape", l = "tile_stone") : p = "RoadLine0_4" : 1 === c ? 3 === h || 0 === h ? (l = "tile_stone", p = "line_stone_shape") : (l = "tile_bg", p = "RoadLine0_Bg") : 2 === c ? 2 === h ? p = "line_top1" : !0 === e.params.line && (p = 3 === h ? "line" : 6 === h || 5 === h || 4 === h ? "line_top" : "line_top1") : 3 === c ? p = 4 === h ? "line_shape" : "UnLine0" : 4 === c ? p = 4 === h ? "line_shape1" : "line_rivet" : 5 === c ? 4 === h && (p = "line_shape2") : 6 === c && (p = "line_stone_shape");
                var f = new Array;
                (Math.abs(u[0].x - u[u.length - 1].x) > 4 || Math.abs(u[0].y - u[u.length - 1].y) > 4) && (d = new n.Point(.5 * (u[0].x + u[u.length - 1].x) + i, .5 * (u[0].y + u[u.length - 1].y) + o), f[0] = d);
                var g = new n.Graphics(this.game, 0, 0);
                r.addChildAt(g, 0);
                var y = new n.Point(115e3, 115e3),
                    m = u[0];
                g.beginFill(16776960, 1), g.moveTo(m.x + i, m.y + o);
                var v = u.length,
                    b = 0;
                for (b = 0; b < v; b++) m = u[b], m.x + i < y.x && (y.x = m.x + i), m.y + o < y.y && (y.y = m.y + o), g.lineTo(m.x + i, m.y + o), f && (f[f.length] = new n.Point(m.x + i, m.y + o));
                g.endFill();
                var x = this.game.add.tileSprite(y.x, y.y, g.width, g.height, t.currentAtlass, l + "0000");
                return x.tilePosition.x = -i % 256, x.tilePosition.y = -o % 256, r.addChildAt(x, 0), t.masks.push(g), t.maskOwners.push(x), p && (d && (f[f.length] = d), -1 === p.indexOf("Bg") && "line_top1" !== p ? s.Drawing.drawBitmapPath2(p, r, f) : s.Drawing.drawBitmapPath(p, r, f)), r
            }, t.game = null, t.currentAtlass = r.Atlases.Theme1, t.masks = [], t.maskOwners = [], t
        }();
    e.GraphicUtil = c
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.dynamics.InteractionFilter,
        n = function() {
            function t() {}
            return t.NOTHING = new s(0, 0, 0, 0, 0, 0), t.SENSOR = new s(0, 0, 1, 4369), t.SENS_ONLY_PLAYER = new s(0, 0, 1, 4368), t.TOGGLE = new s(0, 0, 1, 4369), t.WITH_EARTH_ONLY = new s(1, 4369, 0, 0), t.WHEEL = new s(4096, 272, 17, 4369), t.DRIVER_PART = new s(4096, 272), t.BODY_COLLIDER = new s(4096, 272, 17, 4369), t.GROUND = new s(17, 4369, 1, 4369), t.PLAYER_ONLY = new s(256, 4096, 1, 4369), t.WATER = new s(0, 0, 1, 4369), t
        }();
    e.Filters = n
}, function(t, e, i) {
    (function(e) {
        t.exports = e.Phaser = i(61)
    })
    .call(e, i(29))
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.phys.Material,
        n = function() {
            function t() {}
            return t.DEFAULT = new s, t.GROUND = new s, t.WIEGHTLESS = new s(0, 1, 2, .001), t.TUMBEWEED = new s(0, 1, 2, .5), t.GBARREL = new s(0, 1, 2, .5), t
        }();
    e.Materials = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(17),
        n = function() {
            function t(t) {
                this.music = null, this.audioInstances = {}, this.sound = t.sound
            }
            return t.getInstance = function(e) {
                if (null === t.instance) {
                    if (!e) throw new Error("Cant create a new instance without a game");
                    t.instance = new t(e)
                }
                return t.instance
            }, t.prototype.play = function(t, e, i) {
                return void 0 === e && (e = 1), void 0 === i && (i = !1), this.audioInstances.hasOwnProperty(t) || (this.audioInstances[t] = this.sound.add(t)), s.default.getInstance()
                    .sfx ? (this.audioInstances[t].play(void 0, void 0, e, i, !0), this.audioInstances[t]) : this.audioInstances[t].play(void 0, void 0, 0, i, !0)
            }, t.prototype.stop = function(t) {
                this.audioInstances.hasOwnProperty(t) && this.audioInstances[t].stop()
            }, t.prototype.playMusic = function(t) {
                if (!s.default.getInstance()
                    .music) return this.music = this.sound.play(t, .5, !0), void this.music.stop();
                null !== this.music && this.music.name === t || (null !== this.music && this.music.name !== t && this.music.stop(), this.music = this.sound.play(t, .5, !0))
            }, t.prototype.fadeMusicVolume = function(t, e) {
                this.music && this.music.fadeTo(t, e)
            }, t.prototype.stopMusic = function() {
                null !== this.music && this.music.isPlaying && this.music.stop()
            }, t.prototype.toggleSfx = function() {
                s.default.getInstance()
                    .sfx = !s.default.getInstance()
                    .sfx
            }, t.prototype.toggleMusic = function() {
                s.default.getInstance()
                    .music = !s.default.getInstance()
                    .music, s.default.getInstance()
                    .music ? this.music && this.music.play(void 0, void 0, 1, !0) : this.music && this.music.isPlaying && this.stopMusic()
            }, t.instance = null, t
        }();
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.callbacks.CbType,
        n = function() {
            function t() {}
            return t.WHEEL = new s, t.BODY_COLLIDER = new s, t.ZONE_FINISH = new s, t.COIN = new s, t.DESTOYED = new s, t.TOGGLE = new s, t.TOGGLE_OFF = new s, t.GROUND = new s, t.DRIVER = new s, t.DRIVER_PART = new s, t.SAFE_POINT = new s, t.SPIKES = new s, t.SAW = new s, t.BARREL = new s, t.WOOD = new s, t.WATER = new s, t.GLASS = new s, t.BOOST = new s, t.GEYSER = new s, t
        }();
    e.CbTypes = n
}, function(t, e, i) {
    (function(e) {
        t.exports = e.PIXI = i(60)
    })
    .call(e, i(29))
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(15),
        a = function(t) {
            function e(e, i, s, a, o, r) {
                void 0 === r && (r = null);
                var h = t.call(this, e) || this;
                return h._labelState = null, h._enable = !0, h._graphics = null, h._texts = null, h._dynamicScaleUp = 1.1, h._dynamicScaleDown = .9, h._sScale = 1, h._sLabelScale = 1, h.inputEnableChildren = !0, h._graphics = h.game.add.group(h), h._texts = h.game.add.group(h), h.btn = h.game.add.button(0, 0, r, a, o), h.btn.anchor.set(.5), h._graphics.addChild(h.btn), h.label = new n.default(h.game, 0, 2, i, s, 70, 40), h.label.anchor.set(.5), h._texts.addChild(h.label), null !== a ? (h.label.inputEnabled = !0, h.label.events.onInputDown.add(a, o), h._graphics.inputEnableChildren = !0, h._graphics.onChildInputOver.add(h.onOver, h), h._graphics.onChildInputDown.add(h.onDownLabel, h), h._graphics.onChildInputOut.add(h.onOut, h), h._graphics.onChildInputUp.add(h.onOut, h), h._texts.inputEnableChildren = !0, h._texts.onChildInputOver.add(h.onOver, h), h._texts.onChildInputDown.add(h.onDownLabel, h), h._texts.onChildInputOut.add(h.onOut, h)) : (h._graphics.inputEnableChildren = !1, h._texts.inputEnableChildren = !1, h.btn.inputEnabled = !1), h.game.add.existing(h), h
            }
            return s(e, t), Object.defineProperty(e.prototype, "labelState", {
                get: function() {
                    return this._labelState
                },
                set: function(t) {
                    this._labelState = t, this._texts.addChild(t), this._labelState.anchor.set(.5)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "sScale", {
                set: function(t) {
                    this._sScale = t, this._graphics.scale.set(this._sScale)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "sLabelScale", {
                set: function(t) {
                    this._sLabelScale = t, this._texts.scale.set(this._sLabelScale)
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "dynamicScaleDown", {
                set: function(t) {
                    this._dynamicScaleDown = t
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(e.prototype, "dynamicScaleUp", {
                set: function(t) {
                    this._dynamicScaleUp = t
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.onOver = function() {
                this._graphics.scale.set(this._sScale * this._dynamicScaleUp), this._texts.scale.set(this._sLabelScale * this._dynamicScaleUp)
            }, e.prototype.onDownLabel = function() {
                this._graphics.scale.set(this._sScale * this._dynamicScaleDown), this._texts.scale.set(this._sLabelScale * this._dynamicScaleDown)
            }, e.prototype.onOut = function() {
                this._graphics.scale.set(this._sScale), this._texts.scale.set(this._sLabelScale)
            }, e.prototype.setText = function(t) {
                this.label.setText(t)
            }, e.prototype.setFrames = function(t, e, i, s) {
                this.btn.setFrames(t, e, i, s)
            }, e.prototype.destroy = function(e) {
                this.id = null, this.label = null, this.btn = null, this._graphics = null, this._texts = null, this._labelState = null, t.prototype.destroy.call(this, e)
            }, Object.defineProperty(e.prototype, "enable", {
                get: function() {
                    return this._enable
                },
                set: function(t) {
                    this._enable !== t && (this._enable = t, this.btn.inputEnabled = this._enable, this._enable ? (this.btn.tint = 16777215, this.label.tint = 16777215) : (this.btn.tint = 10066329, this.label.tint = 10066329))
                },
                enumerable: !0,
                configurable: !0
            }), e
        }(Phaser.Group);
    e.default = a
}, function(t, e, i) {
    "use strict";
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = function(t) {
        function e(e, i, s, n, a, o, r) {
            var h = t.call(this, e, i, s, n, a) || this;
            return h.maxWidth = o, h.maxHeight = r, h.game.add.existing(h), h
        }
        return s(e, t), e.prototype.setText = function(e) {
            return t.prototype.setText.call(this, e), (this.maxWidth || this.maxHeight) && this.makeFontFit(), this
        }, e.prototype.setMaxSize = function(t, e) {
            this.maxWidth = t, this.maxHeight = e
        }, e.prototype.makeFontFit = function() {
            for (var t = 10, e; this.width > this.maxWidth || this.height > this.maxHeight;) {
                if ((e = parseInt(this.fontSize.toString()
                        .replace("px", ""), 10) - 1) < 10) {
                    e = 10, this.fontSize = e;
                    break
                }
                this.fontSize = e
            }
        }, e
    }(Phaser.Text);
    e.default = n
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(4),
        a = i(23),
        o = function(t) {
            function e(i, s, o, r) {
                var h = t.call(this, i) || this;
                h.alpha = 0, h.beginFill(s, 1), h.drawRect(0, 0, h.game.width, h.game.height), h.endFill(), a.default.Name !== o && (e.prevState = o);
                var l = h.game.add.text(h.game.width / 2, h.game.height / 2, "LOADING...", n.Constants.styleCredits0);
                l.anchor.set(.5), h.addChild(l), i.add.existing(h);
                var c = h.game.add.tween(h);
                return c.to({
                    alpha: 1
                }, 100), c.onComplete.add(function() {
                    i.state.start(o, !0, !1, r)
                }), c.start(), h
            }
            return s(e, t), e.prevState = "menu", e
        }(Phaser.Graphics);
    e.default = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(4),
        n = function() {
            function t(t, e, i) {
                var n = this;
                this.musicOn = !0, this.sfxOn = !0, this.game = t, this.callback = e, this.callbackContext = i, this.game.storage.getItem(s.Constants.STORAGE_KEY_SFX)
                    .then(function(t) {
                        null === t || void 0 === t ? (n.initFirstSave(), n.callback && n.callbackContext && n.callback.call(n.callbackContext)) : n.restore()
                    })
            }
            return t.prototype.initFirstSave = function() {
                this.sfxOn = !0, this.musicOn = !0, this.save()
            }, t.getInstance = function(e, i, s) {
                return t.instance ? s && i.call(s) : t.instance = new t(e, i, s), t.instance
            }, Object.defineProperty(t.prototype, "music", {
                get: function() {
                    return this.musicOn
                },
                set: function(t) {
                    this.musicOn = t, this.save()
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "sfx", {
                get: function() {
                    return this.sfxOn
                },
                set: function(t) {
                    this.sfxOn = t, this.save()
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.save = function() {
                var t = JSON.stringify({
                        m: this.musicOn,
                        sf: this.sfxOn
                    }),
                    e = this.hash(t);
                this.game.storage.setItem(s.Constants.STORAGE_KEY_SFX, t), this.game.storage.setItem(s.Constants.STORAGE_KEY_SFX + "h", e)
            }, t.prototype.restore = function() {
                var t = this,
                    e = this.game.storage.getItem(s.Constants.STORAGE_KEY_SFX),
                    i = this.game.storage.getItem(s.Constants.STORAGE_KEY_SFX + "h"),
                    n, a;
                Promise.all([e, i])
                    .then(function(e) {
                        if (n = e[0] || "", a = e[1] || "0", "" === n) return t.initFirstSave(), void(t.callback && t.callbackContext && t.callback.call(t.callbackContext));
                        if (a !== t.hash(n)) return t.initFirstSave(), void(t.callback && t.callbackContext && t.callback.call(t.callbackContext));
                        if (n && "" !== n) try {
                            var i = JSON.parse(n);
                            t.musicOn = i.m, t.sfxOn = i.sf
                        } catch (e) {
                            t.initFirstSave()
                        } else t.initFirstSave();
                        t.callback && t.callbackContext && t.callback.call(t.callbackContext)
                    })
            }, t.prototype.hash = function(t) {
                var e = 0,
                    i, s, n;
                if (0 === t.length) return e.toString();
                for (i = 0, n = t.length; i < n; i++) s = t.charCodeAt(i), e = (e << 5) - e + s, e |= 0;
                return e.toString()
            }, t
        }();
    e.default = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(4),
        n = i(0),
        a = i(14),
        o = function() {
            function t(t, e, i) {
                var n = this;
                this.carSaves = {}, this.game = t, this.callback = e, this.callbackContext = i, this.game && this.game.storage.getItem(s.Constants.STORAGE_KEY)
                    .then(function(t) {
                        null === t || void 0 === t ? (n.initFirstSave(), n.callback && n.callbackContext && n.callback.call(n.callbackContext)) : n.restore()
                    })
            }
            return t.prototype.initFirstSave = function() {
                n.Inventory.instance.init(), this.save()
            }, t.getInstance = function(e, i, s) {
                return t.instance ? s && i.call(s) : t.instance = new t(e, i, s), t.instance
            }, t.prototype.save = function() {
                var t = JSON.stringify({
                    invsav: n.Inventory.instance.save
                }),
                e = this.hash(t);
                this.game.storage.setItem(s.Constants.STORAGE_KEY, t), this.game.storage.setItem(s.Constants.STORAGE_KEY + "h", e)
                
            }, t.prototype.restore = function() {
                var t = this,
                    e = this.game.storage.getItem(s.Constants.STORAGE_KEY),
                    i = this.game.storage.getItem(s.Constants.STORAGE_KEY + "h"),
                    a, o;
                Promise.all([e, i])
                    .then(function(e) {
                        if (a = e[0] || "", o = e[1] || "0", "" === a) return t.initFirstSave(), void(t.callback && t.callbackContext && t.callback.call(t.callbackContext));
                        if (o !== t.hash(a)) return t.initFirstSave(), void(t.callback && t.callbackContext && t.callback.call(t.callbackContext));
                        if (a && "" !== a) try {
                            var i = JSON.parse(a);
                            n.Inventory.instance.save = i.invsav
                        } catch (e) {
                            t.initFirstSave()
                        } else t.initFirstSave();
                        t.callback && t.callbackContext && t.callback.call(t.callbackContext)
                    })
            }, t.prototype.hash = function(t) {
                var e = 0,
                    i, s, n;
                if (0 === t.length) return e.toString();
                for (i = 0, n = t.length; i < n; i++) s = t.charCodeAt(i), e = (e << 5) - e + s, e |= 0;
                return e.toString()
            }, t
        }();
    e.default = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(5),
        n = nape.constraint.PivotJoint,
        a = nape.geom.GeomPoly,
        o = nape.geom.GeomPolyList,
        r = nape.geom.Vec2,
        h = nape.phys.Body,
        l = nape.phys.BodyList,
        c = nape.phys.BodyType,
        u = nape.shape.Circle,
        d = nape.shape.Polygon,
        p = function() {
            function t() {}
            return t.disposeBody = function(e) {
                t.clearUserData(e), e.cbTypes.clear(), e.compound ? e.compound = null : e.space = null
            }, t.stopBody = function(t, e) {
                void 0 === e && (e = !0), t.type === c.DYNAMIC && (t.torque = 0), t.velocity.x = 0, t.velocity.y = 0, t.angularVel = 0, e || (t.allowMovement = t.allowRotation = e)
            }, t.setupStartPos = function(t) {
                t.userData.sx = t.position.x, t.userData.sy = t.position.y, t.userData.sr = t.rotation
            }, t.resetStartPos = function(t) {
                t.position.x = t.userData.sx, t.position.y = t.userData.sy, t.rotation = t.userData.sr
            }, t.clearUserData = function(t) {
                for (var e in t.userData) t.userData.hasOwnProperty(e) && (t.userData[e] = null)
            }, t.createRectBody = function(e, i, n, a, o, r) {
                void 0 === o && (o = null), void 0 === r && (r = null);
                var h = new d(d.box(a.width, a.height, !0), r, i);
                h.sensorEnabled = n;
                var l = t.createBody(e, a.x, a.y, s.default.TO_RAD * a.rotation, o);
                return l.shapes.add(h), l
            }, t.createRectBodyWH = function(e, i, s, n, a, o, r, h, l, c) {
                void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === h && (h = 0), void 0 === l && (l = null), void 0 === c && (c = null);
                var u = new d(d.box(n, a, !0), c, i);
                u.sensorEnabled = s;
                var p = t.createBody(e, o, r, h, l);
                return p.shapes.add(u), p
            }, t.createRegularBody = function(e, i, s, n, a, o, r, h, l, c, u) {
                void 0 === r && (r = 0), void 0 === h && (h = 0), void 0 === l && (l = 0), void 0 === c && (c = null), void 0 === u && (u = null);
                var p = new d(d.regular(.5 * n, .5 * a, o, 0, !0), u, i);
                p.sensorEnabled = s;
                var f = t.createBody(e, r, h, l, c);
                return f.shapes.add(p), f
            }, t.createBody = function(t, e, i, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = null);
                var a = new h(t, r.weak(e, i));
                return a.rotation = s, null != n && a.cbTypes.add(n), a
            }, t.createCircleBody = function(e, i, s, n, a, o, r, h, l) {
                void 0 === a && (a = 0), void 0 === o && (o = 0), void 0 === r && (r = 0), void 0 === h && (h = null), void 0 === l && (l = null);
                var c = new u(n, null, l, i);
                c.sensorEnabled = s;
                var d = t.createBody(e, a, o, r, h);
                return null != h && d.cbTypes.add(h), d.shapes.add(c), d
            }, t.bodiesInCircle = function(e, i, s, n, a) {
                return void 0 === n && (n = !1), void 0 === a && (a = null), t.bodyList.clear(), e.bodiesInCircle(i, s, n, a, t.bodyList), t.bodyList
            }, t.bodiesUnderPoint = function(e, i, s) {
                return void 0 === s && (s = null), t.bodyList.clear(), e.bodiesUnderPoint(i, s, t.bodyList), t.bodyList
            }, t.createPolyBody = function(e, i, s, n) {
                var o, l;
                e instanceof Array ? (l = e, o = new h(n)) : (l = e.vertices, o = new h(n, r.weak(e.x, e.y)));
                for (var c = l.length, u = [], p = 0; p < c; p++) u[p] = r.get(l[p].x, l[p].y);
                var f = new a(u);
                if (f.isConvex()) o.shapes.add(new d(f, i, s)), f.dispose();
                else
                    for (f.convexDecomposition(!1, t.geomPolyList), f.dispose(); !t.geomPolyList.empty();) f = t.geomPolyList.pop(), o.shapes.add(new d(f, i, s)), f.dispose();
                return o
            }, t.createPivot = function(t, e, i) {
                return new n(t, e, t.worldPointToLocal(i, !0), e.worldPointToLocal(i, !0))
            }, t.disposeJoint = function(t) {
                t.active = !1, t.space = null, t.body1 = null, t.body2 = null
            }, t.createPatherBody = function(t, e, i, s) {
                e = e.copy(), e.density = t.params.density;
                var n = new h(t.params.isStatic ? c.STATIC : c.DYNAMIC, r.weak(t.params.x, t.params.y)),
                    o = [r.get(), r.get(), r.get(), r.get()],
                    l = r.get(),
                    u = r.get(),
                    p = t.params.vertices,
                    f, g = p.length,
                    y;
                for (f = 0; f < g - 1; f++) {
                    if (l.setxy(p[f + 1].x - p[f].x, p[f + 1].y - p[f].y), 0 === f ? (y = l.angle + .5 * Math.PI, o[0].x = p[f].x - .5 * s * Math.cos(y), o[0].y = p[f].y - .5 * s * Math.sin(y), o[1].x = p[f].x + .5 * s * Math.cos(y), o[1].y = p[f].y + .5 * s * Math.sin(y)) : (o[0].x = o[3].x, o[0].y = o[3].y, o[1].x = o[2].x, o[1].y = o[2].y), f === g - 2) y = l.angle + .5 * Math.PI, o[3].x = p[f + 1].x - .5 * s * Math.cos(y), o[3].y = p[f + 1].y - .5 * s * Math.sin(y), o[2].x = p[f + 1].x + .5 * s * Math.cos(y), o[2].y = p[f + 1].y + .5 * s * Math.sin(y);
                    else {
                        l.muleq(-1 / l.length), u.setxy(p[f + 2].x - p[f + 1].x, p[f + 2].y - p[f + 1].y), u.muleq(1 / u.length);
                        var m = r.get(l.x + u.x, l.y + u.y);
                        y = m.angle, o[3].x = p[f + 1].x - .5 * s * Math.cos(y), o[3].y = p[f + 1].y - .5 * s * Math.sin(y), o[2].x = p[f + 1].x + .5 * s * Math.cos(y), o[2].y = p[f + 1].y + .5 * s * Math.sin(y), m.dispose()
                    }
                    var v = new a(o),
                        b = void 0;
                    if (v.isConvex()) b = new d(o, e, i), b.body = n;
                    else {
                        var x = o[3];
                        o[3] = o[2], o[2] = x, b = new d(o, e, i), b.body = n
                    }
                }
                return l.dispose(), u.dispose(), o[0].dispose(), o[1].dispose(), o[2].dispose(), o[3].dispose(), o = null, n.align(), n
            }, t.geomPolyList = new o, t.bodyList = new l, t
        }();
    e.NapeUtil = p
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.GAME_W = 720, t.GAME_H = 480, t.DISPLAY_W = 720, t.DISPLAY_H = 480, t.CAR_ED_SAVE = "mrce", t.ED_SAVE = "mre", t.FRONT_FLIP = "front_flip", t.BACK_FLIP = "back_flip", t.FLIP2 = "flip2", t.DEATH = "death", t.DEATH10 = "death10", t.IMMORTAL = "immortal", t.STAR3 = "star3", t.STAR25 = "star25", t.STAR50 = "star50", t.STAR75 = "star75", t.MAD_MAX = "evel", t.MARTIAN = "ninja", t.FIRE_HEAD = "ufo", t.ACH_KEYS = {
            front_flip: "5d666019fc04d7987a2a",
            back_flip: "f1464a11a34859ab2c9c",
            flip2: "cbee1b928b0c98b5b9d1",
            death: "152da14de795fcddaab7",
            death10: "b9a38dafbf599e020094",
            immortal: "65e17d538092d8c43e0e",
            star3: "65863075e64b84f5c348",
            star25: "3e5bdcc3b94051ef2310",
            star50: "c0412581c1acbe3650df",
            star75: "10080846ac4f1195e39f",
            evel: "0a1a7c20fb914e20ea97",
            ninja: "620eda42d4db8b272639",
            ufo: "90795a88309ed3985c17"
        }, t.ACH_NAMES = {
            front_flip: "Front Flip",
            back_flip: "Back Flip",
            flip2: "Double Flip",
            death: "First Death",
            death10: "Suicide Master",
            immortal: "Immortal",
            star3: "3 stars",
            star25: "22 stars",
            star50: "44 stars",
            star75: "All stars",
            evel: "Desert Rider",
            ninja: "Martian",
            ufo: "Firehead"
        }, t.ACH_DESCS = {
            front_flip: "Perform front flip",
            back_flip: "Perform back flip",
            flip2: "Perform double flip",
            death: "Die one time",
            death10: "Die 10 times in one race",
            immortal: "Complete level without death",
            star3: "Finish level with 3 stars",
            star25: "Collect 22 stars",
            star50: "Collect 44 stars",
            star75: "Collect 66 stars",
            evel: "Equip Desert Rider",
            ninja: "Equip Martian",
            ufo: "Equip Firehead"
        }, t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.VERSION = "1.0.1", t.GAME_SCALE = 1, t.CALCULATED_WIDTH = 0, t.CALCULATED_HEIGHT = 0, t.WIDTH = 720, t.HEIGHT = 480, t.LANDSCAPE_LOCKED = !0, t.PORTRAIT_LOCKED = !1, t.GAME_DISTRIBUTION_LOCAL_ID = "", t.STORAGE_KEY = "mx3m3sf2_vseigru", t.STORAGE_KEY_SFX = "mx3m3sf2sfx", t.styleMoney = {
            font: "25px Impact",
            fill: "#DDD9D7"
        }, t.styleBestTime = {
            font: "14px Impact",
            fill: "#FFFFFF"
        }, t.styleTime = {
            font: "15px Impact",
            fill: "#DDD9D7"
        }, t.styleTimer = {
            font: "20px Impact",
            fill: "#DDD9D7"
        }, t.styleHelp = {
            font: "20px Impact",
            fill: "#FFFFFF"
        }, t.stylePlay = {
            font: "80px CfCrackBold",
            fill: "#FF8F00"
        }, t.styleCreditsBtn = {
            font: "40px CfCrackBold",
            fill: "#FFFFFF"
        }, t.styleTrick = {
            font: "30px CfCrackBold",
            fill: "#FF8F00"
        }, t.stylePlace = {
            font: "24px CfCrackBold",
            fill: "#97F337"
        }, t.styleMSGUI = {
            font: "10px Impact",
            fill: "#FFFFFF"
        }, t.styleGarage = {
            font: "80px CfCrackBold",
            fill: "#FF8F00"
        }, t.styleGarage2 = {
            font: "33px CfCrackBold",
            fill: "#FFFFFF"
        }, t.styleGarage3 = {
            font: "50px CfCrackBold",
            fill: "#FFFFFF"
        }, t.stylePopBtn = {
            font: "30px CfCrackBold",
            fill: "#2C374E"
        }, t.stylePopBtn2 = {
            font: "25px CfCrackBold",
            fill: "#2C374E"
        }, t.styleChooseLevel = {
            font: "36px CfCrackBold",
            fill: "#FFFFFF"
        }, t.stylePause = {
            font: "40px CfCrackBold",
            fill: "#FFFFFF"
        }, t.styleFinish = {
            font: "30px CfCrackBold",
            fill: "#FF8F00"
        }, t.styleFinish1 = {
            font: "20px CfCrackBold",
            fill: "#FFFFFF"
        }, t.styleCredits0 = {
            font: "30px CfCrackBold",
            fill: "#FFFFFF"
        }, t.styleCreditsOK = {
            font: "50px CfCrackBold",
            fill: "#FF8F00"
        }, t.styleCredits1 = {
            font: "18px Impact",
            fill: "#FFFFFF"
        }, t.styleCredits2 = {
            font: "14px Impact",
            fill: "#FFFFFF"
        }, t.styleVersion = {
            font: 15 * t.GAME_SCALE + "px Impact",
            fill: "#FFFFFF"
        }, t.ACH_KEYS = {
            front_flip: "5d666019fc04d7987a2a",
            back_flip: "f1464a11a34859ab2c9c",
            flip2: "cbee1b928b0c98b5b9d1",
            death: "152da14de795fcddaab7",
            death10: "b9a38dafbf599e020094",
            immortal: "65e17d538092d8c43e0e",
            star3: "65863075e64b84f5c348",
            star22: "3e5bdcc3b94051ef2310",
            star44: "c0412581c1acbe3650df",
            star66: "10080846ac4f1195e39f",
            evel: "0a1a7c20fb914e20ea97",
            ninja: "620eda42d4db8b272639",
            ufo: "90795a88309ed3985c17"
        }, t.ACH_NAMES = {
            front_flip: "Front Flip",
            back_flip: "Back Flip",
            flip2: "Double Flip",
            death: "First Death",
            death10: "Suicide Master",
            immortal: "Immortal",
            star3: "3 stars",
            star22: "22 stars",
            star44: "44 stars",
            star66: "All stars",
            evel: "Desert Rider",
            ninja: "Martian",
            ufo: "Firehead"
        }, t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.Garage = "garage", t.Cars = "cars_game", t.Theme0 = "theme0", t.Theme1 = "theme1", t.Menu = "menu", t.Theme2 = "theme2", t.preloadList = [t.Cars], t.list = [t.Garage, t.Theme0, t.Theme1, t.Menu, t.Theme2], t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(13),
        a = i(22),
        o = i(21),
        r = i(24),
        h = i(28),
        l = i(10),
        c = i(25),
        u = i(18),
        d = i(40),
        p = i(16),
        f = i(35),
        g = i(46),
        y = i(0),
        m = i(2),
        v = i(15),
        b = i(14),
        x = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i.changeBike = null, i.priceTxt = null, i.btnLeft = null, i.btnRight = null, i.bike = null, i
            }
            return s(e, t), e.prototype.init = function() {
                this.game.world.removeAll(), y.GraphicUtil.game = this.game, l.default.getInstance()
                    .playMusic(c.default.MenuMusic)
            }, e.prototype.create = function() {
                t.prototype.create.call(this);
                var i = this.game.add.sprite(360, 240, a.default.Garage, "0popup_bg0000");
                i.anchor.set(.5);
                var s = null;
                this.background = this.game.add.sprite(0, 0, a.default.Garage, "bg0000"), s = this.game.add.sprite(0, 0, a.default.Garage, "0bg_garage0000"), s.alpha = 0, this.background.addChild(s), this.background.addChild(i);
                var r = new n.default(this.game, "GARAGE", o.default.styleGarage, null, null, a.default.Garage);
                r.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), r.position.set(o.default.WIDTH / 2, 40), this.background.addChild(r);
                var l = new n.default(this.game, y.Inventory.instance.getTotalStars() + "", o.default.styleMoney, null, null, a.default.Garage);
                l.setFrames("w_star0000", "w_star0000", "w_star0000", "w_star0000"), l.position.set(o.default.WIDTH - 30, 30), l.label.x = -30, this.game.width - o.default.WIDTH > 0 && (l.x += (this.game.width - o.default.WIDTH) / 2), this.background.addChild(l), r.label.stroke = "#000000", r.label.strokeThickness = 4;
                var c = new v.default(this.game, 0, 2, "GARAGE", o.default.stylePlay);
                c.anchor.set(.5), r.label.parent.addChildAt(c, 0), c.stroke = "#FFFFFF", c.strokeThickness = 7, this.playBtn = new n.default(this.game, "", o.default.stylePopBtn2, p.default.prevState === h.default.Name ? this.onMenu : this.onPlayDown, this, a.default.Garage), this.playBtn.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000");
                var u = this.game.add.sprite(0, -7, a.default.Garage, "next_btn0000");
                u.anchor.set(.5), u.scale.set(-1, 1), this.playBtn.label.parent.addChild(u), this.playBtn.x = 10 + this.playBtn.width / 2, this.playBtn.y = o.default.HEIGHT - 10 - this.playBtn.height / 2, this.btnLeft = new n.default(this.game, "", o.default.styleGarage, this.onPrev, this, a.default.Garage), this.btnLeft.setFrames("arrow_btn0000", "arrow_btn0000", "arrow_btn0001", "arrow_btn0000"), this.btnRight = new n.default(this.game, "", o.default.styleGarage, this.onNext, this, a.default.Garage), this.btnRight.setFrames("arrow_btn0000", "arrow_btn0000", "arrow_btn0001", "arrow_btn0000"), this.btnRight.rotation = Phaser.Math.degToRad(180), this.btnLeft.x = 10 + this.playBtn.width / 2, this.btnRight.x = o.default.WIDTH - 10 - this.playBtn.width / 2, this.btnLeft.y = o.default.HEIGHT / 2, this.btnRight.y = o.default.HEIGHT / 2, this.game.width - o.default.WIDTH > 0 && (this.playBtn.x -= (this.game.width - o.default.WIDTH) / 2, this.btnLeft.x -= (this.game.width - o.default.WIDTH) / 2, this.btnRight.x += (this.game.width - o.default.WIDTH) / 2), e.currCar = e.carList.indexOf(y.Inventory.instance.skin), f.GameData.carId = e.carList[e.currCar], y.Inventory.instance.skin = e.carList[e.currCar], this.setNewViewCar(), this.background.addChild(this.playBtn), this.background.addChild(this.btnLeft), this.background.addChild(this.btnRight), new d.default(this.game, 0, null), this.resize()
            }, e.prototype.getPrice = function() {
                var t = e.priceList[e.currCar] + "";
                return "0" === t && (t = "FREE"), t
            }, e.prototype.onPlayerChange = function() {
                e.currCar === e.carList.length - 1 ? this.btnRight.enable = !1 : this.btnRight.enable = !0, 0 === e.currCar ? this.btnLeft.enable = !1 : this.btnLeft.enable = !0
            }, e.prototype.saveCarId = function() {
                if (y.Inventory.instance.getTotalStars() >= e.priceList[e.currCar]) f.GameData.carId = e.carList[e.currCar], y.Inventory.instance.skin = e.carList[e.currCar], this.setNewViewCar(), u.default.getInstance()
                    .save();
                else {
                    this.priceTxt.y = o.default.HEIGHT - 70;
                    var t = this.game.add.tween(this.priceTxt);
                    t.to({
                        y: this.priceTxt.y - 15
                    }, 150, Phaser.Easing.Bounce.InOut, !1, 0, 3, !0), t.start()
                }
            }, e.prototype.onPlayDown = function() {
                new p.default(this.game, 0, r.default.Name)
            }, e.prototype.onMenu = function() {
                new p.default(this.game, 0, h.default.Name)
            }, e.prototype.onNext = function() {
                e.currCar < e.carList.length && e.currCar++, this.setNewViewCar()
            }, e.prototype.parseStaticGraphic = function(t, i) {
                if (t[i]) {
                    var s = null;
                    if (s = this.game.add.image(t[i].x, t[i].y, y.GraphicUtil.currentAtlass, t[i].g + "0000"), s.angle = t[i].r, -1 !== i.indexOf("base") ? s.anchor.set(m.AssetsList.FRAMES_ANCHORX[e.carList[e.currCar] - 1], m.AssetsList.FRAMES_ANCHORY[e.carList[e.currCar] - 1]) : -1 !== i.indexOf("suspend") ? -1 !== i.indexOf("front") ? s.anchor.set(.8, -1 !== t[i].g.indexOf("1") ? .2 : .5) : s.anchor.set(0, .5) : s.anchor.set(.5), this.bike.addChild(s), "driver_head" === i && 5 === e.carList[e.currCar]) {
                        var n = y.GraphicUtil.game.make.sprite(s.x + 6, s.y - 6, y.GraphicUtil.currentAtlass, "ghost_fire_head0000");
                        n.animations.add("ghost_fire_head", Phaser.Animation.generateFrameNames("ghost_fire_head", 0, 4, "", 4)), n.animations.getAnimation("ghost_fire_head")
                            .play(20, !0), n.anchor.set(.9, .48), this.bike.addChild(n)
                    }
                }
            }, e.prototype.setNewViewCar = function() {
                var t = e.carList[e.currCar];
                null !== this.bike ? (this.bike.destroy(), this.bike = this.game.add.group()) : this.bike = this.game.add.group();
                var i = g.CarsData.geomObj["bike" + t],
                    s = "Wheel0";
                this.parseStaticGraphic(i, s), s = "Wheel1", this.parseStaticGraphic(i, s), s = "suspend_back", this.parseStaticGraphic(i, s), 3 !== t && 2 !== t || (s = "suspend_front", this.parseStaticGraphic(i, s)), s = "base", this.parseStaticGraphic(i, s), s = "driver_shin", this.parseStaticGraphic(i, s), s = "driver_hip", this.parseStaticGraphic(i, s), s = "driver_corpse", this.parseStaticGraphic(i, s), s = "driver_arm", this.parseStaticGraphic(i, s), s = "driver_forearm", this.parseStaticGraphic(i, s), s = "driver_head", this.parseStaticGraphic(i, s), 3 !== t && 2 !== t && (s = "suspend_front", this.parseStaticGraphic(i, s)), this.bike.x = o.default.WIDTH / 2, this.bike.y = o.default.HEIGHT / 2, this.background.addChild(this.bike), this.changeBike && this.changeBike.destroy();
                var r = "EQUIPPED";
                e.carList[e.currCar] !== y.Inventory.instance.skin && (r = "EQUIP IT"), this.changeBike = new n.default(this.game, r, o.default.styleGarage2, this.saveCarId, this, a.default.Garage), this.changeBike.x = o.default.WIDTH / 2, this.changeBike.y = o.default.HEIGHT - 50, this.changeBike.setFrames("orange_btn_big0000", "orange_btn_big0000", "orange_btn_big0000", "orange_btn_big0000"), this.changeBike.label.setMaxSize(200, 40), this.changeBike.label.y = -6, this.changeBike.label.setShadow(1, 1, "rgba(0,0,0,0.8)", 5), this.priceTxt && this.priceTxt.destroy(), this.priceTxt = new n.default(this.game, "PRICE:", o.default.styleMoney, null, null, a.default.Garage), this.priceTxt.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.priceTxt.label.y = -15;
                var h = new v.default(this.game, 0, 15, this.getPrice(), o.default.styleMoney);
                if ("FREE" === this.getPrice()) h.anchor.set(.5);
                else {
                    h.anchor.set(1.05, .5);
                    var l = this.game.add.sprite(0, 15, a.default.Garage, "w_star0000");
                    l.anchor.set(.15, .5), this.priceTxt.label.parent.addChild(l)
                }
                this.priceTxt.label.parent.addChild(h), this.priceTxt.x = o.default.WIDTH - 110, this.game.width - o.default.WIDTH > 0 && (this.priceTxt.x += (this.game.width - o.default.WIDTH) / 2), this.priceTxt.y = o.default.HEIGHT - 70, this.background.addChild(this.priceTxt), this.background.addChild(this.changeBike), this.onPlayerChange()
            }, e.prototype.onPrev = function() {
                0 !== e.currCar && e.currCar--, this.setNewViewCar()
            }, e.prototype.shutdown = function() {
                this.background = null, this.changeBike = null, this.playBtn = null, this.btnLeft = null, this.btnRight = null, t.prototype.shutdown.call(this)
            }, e.prototype.resize = function() {
                t.prototype.resize.call(this);
                var e = 1;
                e = this.game.width / o.default.WIDTH, e = e > 1 ? 1 : e, this.background.scale.set(e), this.background.x = (this.game.width - 720) / 2
            }, e.prevNameState = "garage", e.Name = "garage", e.pause = !1, e.currCar = 0, e.carList = [1, 2, 3, 5], e.priceList = [0, 15, 30, 45], e
        }(Phaser.State);
    e.default = x
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(22),
        a = i(21),
        o = i(25),
        r = i(10),
        h = i(26),
        l = i(23),
        c = i(125),
        u = i(16),
        d = i(40),
        p = i(31),
        f = i(35),
        g = i(0),
        y = i(13),
        m = i(28),
        v = i(27),
        b = i(17),
        x = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i
            }
            return s(e, t), e.prototype.init = function() {
                this.game.world.removeAll(), r.default.getInstance()
                    .playMusic(o.default.MenuMusic)
            }, e.prototype.create = function() {
                t.prototype.create.call(this), g.Inventory.instance.signalUnlock.removeAll(), g.Inventory.instance.signalUnlock.addOnce(function() {
                    new u.default(this.game, 0, e.Name)
                }, this), this.scaleGroup = this.game.add.group();
                var i = this.game.add.sprite(0, 0, n.default.Garage, "0bg_garage0000"),
                    s = this.game.add.sprite(.5, 0, n.default.Garage, "0bg_garage_l0000"),
                    o = this.game.add.sprite(i.width - 1, 0, n.default.Garage, "0bg_garage_r0000");
                s.scale.set(-1, 1), this.scaleGroup.addChild(s), this.scaleGroup.addChild(o), s = this.game.add.sprite(-138.5, 0, n.default.Garage, "0bg_garage_l0000"), o = this.game.add.sprite(i.width + 138.5, 0, n.default.Garage, "0bg_garage_r0000"), o.scale.set(-1, 1), this.scaleGroup.addChild(s), this.scaleGroup.addChild(o), s = this.game.add.sprite(-138, 0, n.default.Garage, "0bg_garage_l0000"), o = this.game.add.sprite(i.width + 138, 0, n.default.Garage, "0bg_garage_r0000"), s.scale.set(-1, 1), this.scaleGroup.addChild(s), this.scaleGroup.addChild(o), this.scaleGroup.addChild(i);
                var r = this.game.add.sprite(660, 35, n.default.Garage, "mars_fun0000");
                this.scaleGroup.addChild(r), this.top_txt_bg = this.game.add.sprite(this.game.width, 0, n.default.Garage, "top_bg0000"), this.top_txt_bg.x = this.top_txt_bg.width, this.top_txt_bg.scale.set(-1, 1), this.top_txt_bg = this.game.add.sprite(0, 0, n.default.Garage, "top_bg0000"), this.top_txt_bg.x = this.game.width - this.top_txt_bg.width;
                var h = new y.default(this.game, "", null, this.onBackDown, this, n.default.Garage);
                h.setFrames("shop_btn0000", "shop_btn0000", "shop_btn0001", "shop_btn0000"), h.x = 45, h.y = 30, this.world.addChild(h), this.musicBtn = this.game.add.image(120, 25, n.default.Garage, "InGameMusicButton0000"), this.musicBtn.inputEnabled = !0, this.musicBtn.events.onInputUp.add(this.toggleMusic, this), this.musicBtn.events.onInputOver.add(this.onBtnOver, this), this.musicBtn.events.onInputOut.add(this.onBtnOut, this), this.musicBtn.anchor.set(.5), this.musicBtn.x = this.game.width - 28;
                var l = new y.default(this.game, g.Inventory.instance.getTotalStars() + "", a.default.styleMoney, null, null, n.default.Garage);
                l.setFrames("w_star0000", "w_star0000", "w_star0000", "w_star0000"), l.position.set(110, 30), l.label.x = 20, l.label.anchor.set(0, .5), this.world.addChild(l), this.updateSoundButtons(), this.createButtons(), this.playBtn1 = new y.default(this.game, "", a.default.stylePopBtn2, this.onMenu, this, n.default.Garage), this.playBtn1.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000");
                var c = this.game.add.sprite(0, -7, n.default.Garage, "next_btn0000");
                c.anchor.set(.5), c.scale.set(-1, 1), this.playBtn1.scale.set(.7), this.playBtn1.label.parent.addChild(c), this.playBtn1.x = 10 + this.playBtn1.width / 2, this.playBtn1.y = a.default.HEIGHT - 5 - this.playBtn1.height / 2, this.game.width - a.default.WIDTH > 0 && (this.playBtn1.x -= (this.game.width - a.default.WIDTH) / 2), this.scaleGroup.addChild(this.playBtn1), this.playBtn2 = new y.default(this.game, "", a.default.stylePopBtn2, this.onPlayNext, this, n.default.Garage), this.playBtn2.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000"), c = this.game.add.sprite(0, -7, n.default.Garage, "next_btn0000"), c.anchor.set(.5), this.playBtn2.scale.set(.7), this.playBtn2.label.parent.addChild(c), this.playBtn2.x = a.default.WIDTH - 10 - this.playBtn2.width / 2, this.playBtn2.y = a.default.HEIGHT - 5 - this.playBtn2.height / 2, this.game.width - a.default.WIDTH > 0 && (this.playBtn2.x += (this.game.width - a.default.WIDTH) / 2), this.scaleGroup.addChild(this.playBtn2);
                var p = {
                        font: "bold 20px Djvu",
                        fill: "#FFFFFF"
                    },
                    f;
                new d.default(this.game, 0, null), this.resize()
            }, e.prototype.onMenu = function() {
                r.default.getInstance()
                    .play(o.default.Click), new u.default(this.game, 0, m.default.Name)
            }, e.prototype.createButtons = function() {
                for (var t = 0; t < 22; t++) {
                    var e = g.CarsData.geomObj["point" + t].x,
                        i = g.CarsData.geomObj["point" + t].y + 10;
                    this.createButton(t, e, i, 0)
                }
            }, e.prototype.createButton = function(t, e, i, s) {
                void 0 === t && (t = 0);
                var a = t,
                    o = new c.default(this.game, a + ""),
                    r = "LeveMapItemLocked",
                    h = r + "0000";
                o.btn.setFrames(h, h, h, h), o.x = e, o.y = i, o.label.visible = !1, a + 1 < 10 ? o.label.setText("0" + (a + 1)) : o.label.setText(a + 1 + "");
                var l = 1;
                void 0 !== g.Inventory.instance.save[g.Inventory.RACE_PREFIX + (a + 1)
                    .toString() + g.Inventory.RACE_RESULT] && (l = Number(g.Inventory.instance.save[g.Inventory.RACE_PREFIX + (a + 1)
                    .toString() + g.Inventory.RACE_RESULT]) + 2, o.label.visible = !0);
                var u = this.game.add.sprite(0, 0, n.default.Garage, r + "000" + l);
                u.anchor.set(.5), this.scaleGroup.addChild(o), o.btn.parent.addChild(u), o.label.visible ? (o.signalSelect.addOnce(this.onPlayDown, this), this.lastEnabled = o) : o.enable = !1
            }, e.prototype.onPlayNext = function() {
                this.onPlayDown(this.lastEnabled)
            }, e.prototype.onPlayDown = function(t) {
                r.default.getInstance()
                    .play(o.default.Click);
                var i = p.default.list.indexOf(p.default.Level001),
                    s = Number(t.getID());
                switch (e.LevelNum = s, e.CurrentLevel = p.default.list[i + s], f.GameData.raceId = s + 1, f.GameData.currentLevel = this.game.cache.getJSON(e.CurrentLevel), f.GameData.currentLevel.settings.theme) {
                    case 0:
                        g.GraphicUtil.currentAtlass = n.default.Theme0;
                        break;
                    case 1:
                        g.GraphicUtil.currentAtlass = n.default.Theme1;
                        break;
                    case 2:
                        g.GraphicUtil.currentAtlass = n.default.Theme2
                }
                new u.default(this.game, 0, h.default.Name)
            }, e.prototype.onBackDown = function() {
                r.default.getInstance()
                    .play(o.default.Click), this.game.state.start(l.default.Name)
            }, e.prototype.onBtnOver = function(t) {
                t.scale.set(1.1)
            }, e.prototype.onBtnOut = function(t) {
                t.scale.set(1)
            }, e.prototype.toggleMusic = function() {
                b.default.getInstance()
                    .music ? r.default.getInstance()
                    .toggleMusic() : b.default.getInstance()
                    .sfx ? r.default.getInstance()
                    .toggleSfx() : (r.default.getInstance()
                        .toggleSfx(), r.default.getInstance()
                        .toggleMusic()), this.updateSoundButtons(), r.default.getInstance()
                    .play(o.default.Click)
            }, e.prototype.updateSoundButtons = function() {
                var t = b.default.getInstance()
                    .music ? 0 : 1;
                t += b.default.getInstance()
                    .sfx ? 0 : 1, this.musicBtn.loadTexture(n.default.Garage, "InGameMusicButton000" + t)
            }, e.prototype.shutdown = function() {
                this.scaleGroup = null, this.musicBtn = null, this.lastEnabled = null, this.scaleGroup = null, t.prototype.shutdown.call(this)
            }, e.prototype.resize = function() {
                var t = 1;
                t = this.game.width / a.default.WIDTH, t = t > 1 ? 1 : t, this.scaleGroup.scale.set(t), this.scaleGroup.alignIn(this.world.bounds, Phaser.BOTTOM_CENTER), this.top_txt_bg.x = this.game.width - this.top_txt_bg.width, this.musicBtn.x = this.game.width - 28, this.playBtn1.x = 10 + this.playBtn1.width / 2, this.playBtn1.y = a.default.HEIGHT - 5 - this.playBtn1.height / 2, this.game.width - a.default.WIDTH > 0 && (this.playBtn1.x -= (this.game.width - a.default.WIDTH) / 2), this.playBtn2.x = a.default.WIDTH - 10 - this.playBtn2.width / 2, this.playBtn2.y = a.default.HEIGHT - 5 - this.playBtn2.height / 2, this.game.width - a.default.WIDTH > 0 && (this.playBtn2.x += (this.game.width - a.default.WIDTH) / 2)
            }, e.Name = "choose_zone", e.pause = !1, e.CurrentLevel = "", e.LevelNum = 0, e
        }(Phaser.State);
    e.default = x
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.FlySound = function() {
            return Math.random() > .6 ? t.Fly1 : Math.random() > .3 ? t.Fly2 : t.Fly3
        }, t.FlipSound = function() {
            return "flip_0" + (Math.round(5 * Math.random()) + 1)
        }, t.DieSound = function() {
            return "dead_0" + (Math.round(5 * Math.random()) + 1)
        }, t.startSound = function() {
            return "accel0" + (Math.round(3 * Math.random()) + 1)
        }, t.MenuMusic = "menu_track", t.GameMusic = "game_track_0", t.Click = "button", t.Landing = "landing", t.DriverSpikes = "driver_spikes", t.SavePoint = "safepoint", t.Stones = "stones", t.Explode1 = "explode1", t.Explode2 = "explode2", t.Barrel1 = "barrel_hit0", t.Barrel2 = "barrel_hit1", t.Engine1 = "motor", t.EngineFon = "eng_loop", t.Fly1 = "fly_01", t.Fly2 = "fly_02", t.Fly3 = "fly_03", t.Flip1 = "flip_01", t.Flip2 = "flip_02", t.Flip3 = "flip_03", t.Flip4 = "flip_04", t.Flip5 = "flip_05", t.Flip6 = "flip_06", t.Dead1 = "dead_01", t.Dead2 = "dead_02", t.Dead3 = "dead_03", t.Dead4 = "dead_04", t.Dead5 = "dead_05", t.Dead6 = "dead_06", t.Start = "engine_start", t.Finish = "engine_finish", t.Start1 = "accel01", t.Start2 = "accel02", t.Start3 = "accel03", t.Start4 = "accel04", t.Wood = "wood_hit0", t.Wendy = "wendy", t.preloadList = [], t.list = [t.MenuMusic, t.GameMusic, t.Engine1, t.EngineFon, t.Explode1, t.Explode2, t.Barrel1, t.Barrel2, t.Wood, t.Wendy, t.Stones, t.SavePoint, t.DriverSpikes, t.Landing, t.Fly1, t.Fly2, t.Fly3, t.Flip1, t.Flip2, t.Flip3, t.Flip4, t.Flip5, t.Flip6, t.Dead1, t.Dead2, t.Dead3, t.Dead4, t.Dead5, t.Dead6, t.Finish, t.Start, t.Start1, t.Start2, t.Start3, t.Start4, t.Click], t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(4),
        a = i(24),
        o = i(22),
        r = i(13),
        h = i(18),
        l = i(10),
        c = i(16),
        u = i(3),
        d = i(0),
        p = i(30),
        f = i(15),
        g = i(37),
        y = i(23),
        m = i(2),
        v = i(27),
        b = i(17),
        x = i(14),
        _ = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i.popup = null, i.black = null, i.transition = null, i.bike = null, i.popupDelay = Phaser.Timer.SECOND, i._armatureDisplay = null, i
            }
            return s(e, t), e.prototype.onPlayNextLevel = function() {
                if (l.default.getInstance()
                    .play(n.Sounds.Click), a.default.LevelNum + 1 === 22) this.onChooseZone();
                else {
                    a.default.LevelNum++;
                    var t = n.JSONData.list.indexOf(n.JSONData.Level001),
                        i = a.default.LevelNum;
                    switch (a.default.CurrentLevel = n.JSONData.list[t + i], d.GameData.raceId = i + 1, d.GameData.currentLevel = this.game.cache.getJSON(a.default.CurrentLevel), d.GameData.currentLevel.settings.theme) {
                        case 0:
                            d.GraphicUtil.currentAtlass = o.default.Theme0;
                            break;
                        case 1:
                            d.GraphicUtil.currentAtlass = o.default.Theme1;
                            break;
                        case 2:
                            d.GraphicUtil.currentAtlass = o.default.Theme2
                    }
                    new c.default(this.game, 0, e.Name)
                }
            }, e.prototype.init = function() {
                var i = this;
                t.prototype.init.call(this), this.game.world.removeAll(), e.loadedLevel = !1, dragonBones.PhaserFactory.init(this.game);
                var s = this.game.cache.getJSON(n.JSONData.DBBike),
                    a = this.game.cache.getJSON(n.JSONData.DBBike_Texture),
                    o = this.game.cache.getImage(p.default.DBBike, !0)
                    .base;
                dragonBones.PhaserFactory.factory.parseDragonBonesData(s), dragonBones.PhaserFactory.factory.parseTextureAtlasData(a, o), this.initData(), this.game.time.advancedTiming = !0, d.GraphicUtil.game = this.game, u.MaxGameCore.instance.init(this.game), d.CarsData.geom[1] = this.game.cache.getJSON(n.JSONData.Bike), u.MaxGameCore.instance.signalFinish.add(this.onCallPopup, this), u.MaxGameCore.instance.start(), g.default.instance.init(this.game.add.group(), this.game), this.black = this.game.add.graphics(0, 0), this.black.beginFill(0, 1), this.black.drawRect(0, 0, this.game.width, this.game.height), this.black.endFill();
                var r = this.game.add.text(this.game.width / 2, this.game.height / 2, "LOADING...", n.Constants.styleCredits0);
                r.anchor.set(.5), this.black.addChild(r), this.transition = this.game.add.tween(this.black), this.transition.to({
                        alpha: 0
                    }, 100, Phaser.Easing.Linear.None, !1, 500), this.transition.onComplete.add(function() {
                        if (e.loadedLevel = !0, i.hardRestart(), i.black.destroy(), i.black = null, i.transition = null, i.game.device.desktop) {
                            i.game.input.keyboard.addKey(Phaser.Keyboard.SPACEBAR)
                                .onUp.add(i.onSpace, i);
                            i.game.input.keyboard.addKey(Phaser.Keyboard.P)
                                .onUp.add(i.onPause, i);
                            i.game.input.keyboard.addKey(Phaser.Keyboard.R)
                                .onUp.add(i.onR, i)
                        } else i.game.input.onDown.add(i.onSpaceMobile, i); - 1 === e.currCar && (e.currCar = Math.round(2 * Math.random())), g.default.instance.signalRestart.add(i.hardRestart, i), g.default.instance.signalPause.add(i.onPause, i), g.default.instance.signalToggleMusic.add(i.onToggleMusic, i), u.MaxGameCore.instance.paused = !1, u.MaxGameCore.instance.enginePitch = l.default.getInstance()
                            .play(n.Sounds.Engine1, .1, !0)
                    }), u.MaxGameCore.instance.signalLoaded.removeAll(), u.MaxGameCore.instance.signalLoaded.addOnce(function() {
                        this.transition.start(), u.MaxGameCore.instance.paused = !0
                    }, this), l.default.getInstance()
                    .playMusic(n.Sounds.GameMusic)
            }, e.prototype.create = function() {
                t.prototype.create.call(this), this.resize()
            }, e.prototype.setNewViewCar = function() {
                e.currCar++;
                var t = a.default.LevelNum;
                e.currCar >= 3 && t < 10 && (e.currCar = 0), e.currCar >= 5 && (e.currCar = 0), null !== this._armatureDisplay && this._armatureDisplay.destroy();
                var i;
                if (e.currCar < 3) {
                    var s = "bike";
                    switch (e.currCar) {
                        case 0:
                            s += "5_db";
                            break;
                        case 1:
                            s += "6_db";
                            break;
                        default:
                            s += "8_db"
                    }
                    this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay(s), this._armatureDisplay.x = 0, this._armatureDisplay.y = 150, this._armatureDisplay.animation.play("anim", 1), this._armatureDisplay.addDBEventListener(dragonBones.EventObject.COMPLETE, this.animComplete, this), this.popup.addChild(this._armatureDisplay)
                } else 3 === e.currCar ? (i = new r.default(this.game, "", null, this.onMoto2, this, o.default.Garage), i.setFrames("moto20000", "moto20000", "moto20000", "moto20000"), i.btn.anchor.set(.5), i.y = 114, this.popup.getChildAt(1)
                    .addChild(i)) : 4 === e.currCar && (i = new r.default(this.game, "", null, this.onMoto1, this, o.default.Garage), i.setFrames("moto10000", "moto10000", "moto10000", "moto10000"), i.btn.anchor.set(.5), i.y = 114, this.popup.getChildAt(1)
                    .addChild(i))
            }, e.prototype.animComplete = function(t) {
                this._armatureDisplay.animation.play("anim", 1)
            }, e.prototype.hardRestart = function() {
                g.default.instance.hideControlsHint(), 1 === d.GameData.raceId && g.default.instance.showControlsHint(), u.MaxGameCore.instance.car.review(), u.MaxGameCore.instance.restart(), u.MaxGameCore.instance.drive = !1, u.MaxGameCore.instance.finished = !1, g.default.instance.showTimer(), u.MaxGameCore.instance.timer = 0, u.MaxGameCore.instance.car.callbackDie = g.default.instance.showDeathHint, u.MaxGameCore.instance.car.callbackStunt = g.default.instance.showFlipMsg, u.MaxGameCore.instance.car.callbackContext = g.default.instance, this.closePopup()
            }, e.prototype.onSpaceMobile = function() {
                u.MaxGameCore.instance.finished || u.MaxGameCore.instance.car.dead && (u.MaxGameCore.instance.paused || (g.default.instance.hideControlsHint(), u.MaxGameCore.instance.car.safeId >= 0 ? (u.MaxGameCore.instance.car.review(), u.MaxGameCore.instance.restartFromSafePoint(u.MaxGameCore.instance.car.safeId)) : this.hardRestart()))
            }, e.prototype.onSpace = function() {
                u.MaxGameCore.instance.finished || u.MaxGameCore.instance.car.dead && (u.MaxGameCore.instance.paused || (g.default.instance.hideControlsHint(), u.MaxGameCore.instance.car.safeId >= 0 ? (u.MaxGameCore.instance.car.review(), u.MaxGameCore.instance.restartFromSafePoint(u.MaxGameCore.instance.car.safeId)) : this.hardRestart()))
            }, e.prototype.onR = function() {
                this.hardRestart()
            }, e.prototype.onPause = function() {
                u.MaxGameCore.instance.finished || this.onCallPopup(0)
            }, e.prototype.onToggleMusic = function() {
                this.toggleMusic()
            }, e.prototype.toggleMusic = function() {
                b.default.getInstance()
                    .music ? l.default.getInstance()
                    .toggleMusic() : b.default.getInstance()
                    .sfx ? l.default.getInstance()
                    .toggleSfx() : (l.default.getInstance()
                        .toggleSfx(), l.default.getInstance()
                        .toggleMusic()), g.default.instance.updateSoundButtons(), l.default.getInstance()
                    .play(n.Sounds.Click)
            }, e.prototype.setFields = function(t) {
                var e = d.RacesData.data,
                    i = new r.default(this.game, "", n.Constants.styleTime, null, this, o.default.Garage);
                i.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), t.addChild(i), i.y = 20, i.label.setMaxSize(200, 50), i.label.stroke = "#000000", i.label.strokeThickness = 2;
                var s = this.game.add.sprite(-133, -76, o.default.Garage, "star00000"),
                    a = this.game.add.sprite(0, -88, o.default.Garage, "star00000"),
                    h = this.game.add.sprite(133, -76, o.default.Garage, "star00000");
                s.anchor.set(.5), a.anchor.set(.5), h.anchor.set(.5), s.scale.set(.9), h.scale.set(.9), s.angle = -10, h.angle = 10;
                var c = this.game.add.sprite(-133, -76, o.default.Garage, "star10000");
                c.anchor.set(.5);
                var u = this.game.add.sprite(0, -88, o.default.Garage, "star10000");
                u.anchor.set(.5);
                var p = this.game.add.sprite(133, -76, o.default.Garage, "star10000");
                p.anchor.set(.5), c.angle = -10, p.angle = 10;
                var f = new r.default(this.game, "0", n.Constants.styleTime, null, null);
                f.x = -133, f.y = -6;
                var g = new r.default(this.game, "0", n.Constants.styleTime, null, null);
                g.y = -16;
                var y = new r.default(this.game, "0", n.Constants.styleTime, null, null);
                y.x = 133, y.y = -6, t.addChild(s), t.addChild(a), t.addChild(h), t.addChild(c), t.addChild(u), t.addChild(p), t.addChild(f), t.addChild(g), t.addChild(y);
                var m = d.RacesData.map.settings.prizes,
                    v = m.split(",");
                f.setText(v[2] + " sec."), g.setText(v[1] + " sec."), y.setText(v[0] + " sec.");
                var b = e.stars;
                c.visible = b > 0, u.visible = b > 1, p.visible = b > 2, c.scale.set(.9), p.scale.set(.9);
                var x, _ = 200;
                b > 0 && (c.scale.set(3), c.alpha = 0, x = this.game.add.tween(c), x.onComplete.addOnce(function() {
                    l.default.getInstance()
                        .play(n.Sounds.Explode2), d.RacesData.data.camera.shakeContainer(this.popup)
                }, this), x.to({
                    alpha: 1
                }, 400, Phaser.Easing.Linear.None, !0, _ - 150), x = this.game.add.tween(c.scale), x.to({
                    x: .9,
                    y: .9
                }, 400, Phaser.Easing.Back.Out, !0, _), _ += 400), b > 1 && (u.scale.set(3), u.alpha = 0, x = this.game.add.tween(u), x.onComplete.addOnce(function() {
                    l.default.getInstance()
                        .play(n.Sounds.Explode1), d.RacesData.data.camera.shakeContainer(this.popup)
                }, this), x.to({
                    alpha: 1
                }, 400, Phaser.Easing.Linear.None, !0, _ - 100), x = this.game.add.tween(u.scale), x.to({
                    x: 1,
                    y: 1
                }, 400, Phaser.Easing.Back.Out, !0, _), _ += 700), b > 2 && (p.scale.set(3), p.alpha = 0, x = this.game.add.tween(p), x.onComplete.addOnce(function() {
                    l.default.getInstance()
                        .play(n.Sounds.Explode2), d.RacesData.data.camera.shakeContainer(this.popup)
                }, this), x.to({
                    alpha: 1
                }, 400, Phaser.Easing.Linear.None, !0, _ - 100), x = this.game.add.tween(p.scale), x.to({
                    x: .9,
                    y: .9
                }, 400, Phaser.Easing.Back.Out, !0, _), _ += 1e3);
                var w = Math.ceil(100 * e.timer),
                    C = w / 100 >> 0;
                w -= 100 * C;
                var P = this.game.add.sprite(200, 90, o.default.Garage, "improved_bg");
                if (P.anchor.set(.5), t.addChild(P), P.visible = e.improved, P.alpha = 0, e.improved) {
                    var T = new r.default(this.game, "NEW BEST TIME", n.Constants.styleBestTime, null, null);
                    T.angle = 25, T.y = -25, P.addChild(T);
                    var S = new r.default(this.game, C.toString() + "." + w.toString() + " sec", n.Constants.styleBestTime, null, null);
                    S.angle = 25, S.x = -8, S.y = -5, P.addChild(S), T.label.setShadow(1, 1, "rgba(0,0,0,0.8)"), S.label.setShadow(1, 1, "rgba(0,0,0,0.8)");
                    var A = P.x,
                        E = P.y;
                    P.x = -500, P.alpha = 0;
                    this.game.add.tween(P)
                        .to({
                            x: A,
                            y: E,
                            alpha: 1
                        }, 250, Phaser.Easing.Back.InOut, !0)
                }
                i.setText("Your time: " + C + "." + w + " sec.")
            }, e.prototype.postRace = function(t) {
                var e = d.RacesData.data;
                e.timer = u.MaxGameCore.instance.timer;
                var i = 0,
                    s, n = d.RacesData.map.settings.prizes;
                if (0 === n.length);
                else {
                    s = n.split(",");
                    var a = void 0,
                        o = void 0;
                    for (a = 0; a < s.length; a++) o = parseFloat(s[a]), e.timer <= o && i++
                }
                if (e.stars = i, e.improved = d.Inventory.instance.setRaceResult(d.GameData.raceId, i, e.timer), e.improved) {
                    var r = 1e3 + 50 * (d.RacesData.map.id - 1);
                    if (s) {
                        var l = parseFloat(s[0]) - 5,
                            c = parseFloat(s[s.length - 1]) + 10,
                            p = c - l,
                            f = c - e.timer;
                        f < 0 ? f = 0 : f > p && (f = p), r += (3e3 + 100 * (d.RacesData.map.id - 1)) * f / p
                    }
                    var g = d.Inventory.instance.setScore(d.GameData.raceId, r);
                }
                this.setFields(t), h.default.getInstance()
                    .save()
            }, e.prototype.onCallPopup = function(t) {
                if (u.MaxGameCore.instance.paused) return void this.closePopup();
                var i = a.default.LevelNum;
                if (1 === t && !e.promoShowed && i === d.RacesData.MAP_COUNT - 1) return void this.game.time.events.add(Phaser.Timer.SECOND, this.motoX3MPopup, this);
                this.createPopup(), 1 !== t && (u.MaxGameCore.instance.paused = !0, g.default.instance.flipTexts.alpha = 0);
                var s = null,
                    h = "GAME PAUSED",
                    l = null;
                if (1 === t) {
                    var c = null;
                    try {
                        c = new Event("finish")
                    } catch (t) {
                        c = document.createEvent("Event");
                        var p = !1,
                            y = !1;
                        c.initEvent("finish", !1, !1)
                    }
                    document.getElementById("content")
                        .dispatchEvent(c), h = i + 1 < 10 ? "LEVEL 0" + (i + 1) + " COMPLETE" : "LEVEL " + (i + 1) + " COMPLETE", this.setNewViewCar(), l = new r.default(this.game, h, n.Constants.styleFinish, null, null, o.default.Garage), l.y = -220, l.label.stroke = "#000000", l.label.strokeThickness = 2;
                    var m = new f.default(this.game, 0, 2, h, n.Constants.styleFinish);
                    m.anchor.set(.5), l.label.parent.addChildAt(m, 0), m.stroke = "#FFFFFF", m.strokeThickness = 5;
                    var v = null;
                    v = new r.default(this.game, "CHANGE BIKE", n.Constants.styleFinish1, this.onGarage, this, o.default.Garage), v.y = 190, v.setFrames("orange_btn_big0000", "orange_btn_big0000", "orange_btn_big0000", "orange_btn_big0000"), v.label.setMaxSize(200, 40), v.label.y = -1, v.label.setText("CHANGE BIKE"), v.label.setShadow(1, 1, "rgba(0,0,0,0.8)", 5), this.popup.getChildAt(1)
                        .addChild(v), g.default.instance.timer.visible = !1
                } else {
                    s = this.game.add.sprite(0, 3, o.default.Garage, "bg0000"), s.anchor.set(.5), s.scale.set(1, 1.4), this.popup.getChildAt(1)
                        .addChild(s), l = new r.default(this.game, h, n.Constants.stylePause, null, this, o.default.Garage), l.y = -145, l.label.stroke = "#000000", l.label.strokeThickness = 2;
                    var b = this.game.add.group();
                    this.popup.getChildAt(1)
                        .addChild(b), this.setPauseViewCar(b)
                }
                l.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.popup.getChildAt(1)
                    .addChild(l);
                var _ = new r.default(this.game, "", n.Constants.styleCredits1, this.onChooseZone, this, o.default.Garage);
                _.x = -270, _.y = 200, _.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000"), _.scale.set(.8);
                var w = this.game.add.sprite(0, -11, o.default.Garage, "exit_btn0000");
                w.anchor.set(.5), _.label.parent.addChild(w), this.popup.getChildAt(1)
                    .addChild(_);
                var C = new r.default(this.game, "", n.Constants.stylePopBtn2, 1 === t ? this.onPlayNextLevel : this.onResume, this, o.default.Garage);
                C.x = 270, C.y = 200, C.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000"), C.scale.set(.8);
                var P = this.game.add.sprite(0, -7, o.default.Garage, "next_btn0000");
                if (P.anchor.set(.5), C.label.parent.addChild(P), this.popup.getChildAt(1)
                    .addChild(C), 1 === t) {
                    var T = this.game.add.group();
                    this.popup.getChildAt(1)
                        .addChild(T), this.postRace(T), this.popupDelay > 0 && (this.popup.visible = !1, this.game.time.events.add(this.popupDelay, this.setPopupVisible, this))
                }
                this.resizePopup(1)
            }, e.prototype.setPopupVisible = function() {
                this.popup && (this.popup.visible = !0)
            }, e.prototype.disposePopup = function() {
                this.popup && this.popup.destroy(), this.popup = null, u.MaxGameCore.instance.paused = !1, g.default.instance.showTimer()
            }, e.prototype.backgroundPopup = function() {
                this.popup = this.game.add.sprite(350, 250, o.default.Garage, "bg0000"), this.popup.anchor.set(.5);
                var t = this.game.add.sprite(0, 0, o.default.Garage, "bg0000");
                t.width = this.game.width, t.height = this.game.height, t.inputEnabled = !0, t.anchor.set(.5), this.popup.addChild(t), this.world.addChild(g.default.instance.container), g.default.instance.hideTimer()
            }, e.prototype.createPopup = function() {
                null !== this.popup && this.disposePopup(), this.backgroundPopup();
                var t = this.game.add.sprite(0, 0, o.default.Garage, "0popup_bg0000");
                t.anchor.set(.5), this.popup.addChild(t)
            }, e.prototype.resizePopup = function(t) {
                if (null !== this.popup) {
                    var e = this.popup.removeChildAt(0);
                    e.width = this.game.width, e.height = this.game.height, this.popup.x = this.world.bounds.centerX, this.popup.y = this.world.bounds.centerY, this.popup.addChildAt(e, 0)
                }
            }, e.prototype.closePopup = function() {
                this.disposePopup()
            }, e.prototype.onResume = function() {
                this.closePopup()
            }, e.prototype.onChooseZone = function() {
                h.default.getInstance()
                    .save(), this.closePopup(), new c.default(this.game, 0, a.default.Name)
            }, e.prototype.onGarage = function() {
                h.default.getInstance()
                    .save(), this.closePopup(), new c.default(this.game, 0, y.default.Name)
            }, e.prototype.parseStaticGraphic = function(t, e) {
                var i = null;
                i = this.game.add.image(t[e].x, t[e].y, d.GraphicUtil.currentAtlass, t[e].g + "0000"), i.angle = t[e].r, -1 !== e.indexOf("base") ? i.anchor.set(m.AssetsList.FRAMES_ANCHORX[0], m.AssetsList.FRAMES_ANCHORY[0]) : -1 !== e.indexOf("suspend") ? -1 !== e.indexOf("front") ? i.anchor.set(.8, -1 !== t[e].g.indexOf("1") ? .2 : .5) : i.anchor.set(0, .5) : i.anchor.set(.5), this.bike.addChild(i)
            }, e.prototype.setPauseViewCar = function(t) {
                null !== this.bike ? (this.bike.destroy(), this.bike = this.game.add.group(t)) : this.bike = this.game.add.group(t);
                var e = d.CarsData.geomObj.bike11,
                    i = "Wheel0";
                this.parseStaticGraphic(e, i), i = "Wheel1", this.parseStaticGraphic(e, i), i = "suspend_back", this.parseStaticGraphic(e, i), i = "base", this.parseStaticGraphic(e, i), i = "driver_corpse", this.parseStaticGraphic(e, i), i = "driver_hip", this.parseStaticGraphic(e, i), i = "driver_shin", this.parseStaticGraphic(e, i), i = "driver_arm", this.parseStaticGraphic(e, i), i = "driver_forearm", this.parseStaticGraphic(e, i), i = "driver_head", this.parseStaticGraphic(e, i), i = "suspend_front", this.parseStaticGraphic(e, i), this.bike.x = 0, this.bike.y = 10
            }, e.prototype.update = function() {
                if (this.isFirstUpdate) return this.isFirstUpdate = !1, this.timeAcc = 0, void(this.prevTimeMS = Date.now());
                if (!e.isAdsPause) {
                    for (t.prototype.update.call(this), this.currTimeMS = Date.now(), this.deltaTime = (this.currTimeMS - this.prevTimeMS) / 1e3, this.deltaTime > e.MAX_FRAME_TIME && (this.deltaTime = e.MAX_FRAME_TIME), this.prevTimeMS = this.currTimeMS, this.timeAcc += this.deltaTime; this.timeAcc >= e.DESIRED_FRAME_TIME;) this.updateGameController(e.DESIRED_FRAME_TIME), this.timeAcc -= e.DESIRED_FRAME_TIME;
                    u.MaxGameCore.instance.physics.updateGraphics(), g.default.instance.setTimer()
                }
            }, e.prototype.resize = function() {
                t.prototype.resize.call(this);
                var e = 1;
                this.game.width / this.game.height >= n.Constants.WIDTH / n.Constants.HEIGHT ? (e = this.game.width / n.Constants.WIDTH, e = e > 1 ? 1 : e) : (e = this.game.height / n.Constants.HEIGHT, e = e > 1 ? 1 : e), g.default.instance.resize(e), this.resizePopup(e)
            }, e.prototype.shutdown = function() {
                this.closePopup(), u.MaxGameCore.instance.release(), g.default.instance.release(), t.prototype.shutdown.call(this)
            }, e.prototype.render = function() {
                null !== this.popup && dragonBones.PhaserFactory.factory.dragonBones.advanceTime(-1), t.prototype.render.call(this)
            }, e.prototype.initData = function() {
                this.isFirstUpdate = !0
            }, e.prototype.updateGameController = function(t) {
                u.MaxGameCore.instance.update(t)
            }, e.prototype.motoX3MPopup = function() {
                null !== this.popup && this.disposePopup(), e.promoShowed = !0, this.popupDelay = 0, this.backgroundPopup();
                var t = this.game.add.sprite(0, 0, o.default.Garage, "0popup_bg0000");
                t.anchor.set(.5), this.popup.addChild(t);
                var i = null,
                    s = null;
                i = this.game.add.sprite(0, 3, o.default.Garage, "bg0000"), i.anchor.set(.5), i.scale.set(1, 1.4), this.popup.getChildAt(1)
                    .addChild(i), s = new r.default(this.game, "You win! Congratulations!  \nPlay more MotoX3M games", n.Constants.styleMoney, null, this, o.default.Garage), s.y = -130, s.label.align = "center", s.label.stroke = "#000000", s.label.strokeThickness = 2;
                var a = this.game.add.group();
                this.popup.getChildAt(1)
                    .addChild(a), s.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.popup.getChildAt(1)
                    .addChild(s);
                var l = new r.default(this.game, "OK", n.Constants.styleGarage3, this.closeMotoX3MPopup, this, o.default.Garage);
                l.label.y -= 8, l.label.setShadow(1, 1, "rgba(0,0,0,0.8)", 5), l.x = 0, l.y = 100 + .5 * h.height + 10, l.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000"), l.scale.set(.8), this.popup.getChildAt(1)
                    .addChild(l), this.resizePopup(1)
            }, e.prototype.closeMotoX3MPopup = function() {
                this.onCallPopup(1)
            }, e.promoShowed = !1, e.Name = "gameplay", e.pause = !1, e.MAX_FRAME_TIME = .1, e.DESIRED_FRAME_TIME = 1 / 30, e.isAdsPause = !1, e.loadedLevel = !1, e.currCar = 1, e
        }(Phaser.State);
    e.default = _
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.brandInstances = {}, this.motoLinks = {}, this.brandDomains = [], this.brandInstances[t.VSEIGRU] = "https://vseigru.net", t.Current = t.VSEIGRU, t.Current === t.VSEIGRU && (this.brandDomains = [], this.brandDomains.push("vseigru.net"), this.brandDomains.push("madpuffers.com"), this.brandDomains.push("localhost:3000"), this.brandDomains.push("iriysoft.ru"), this.brandDomains.push("iriysoft.com"))
        }
        return t.prototype.getMotoLink = function(t) {
            return this.motoLinks[t]
        }, t.getInstance = function() {
            return null === t.instance && (t.instance = new t), t.instance
        }, t.prototype.checkDomain = function(t) {
            for (var e = 0; e < this.brandDomains.length; e++) {
                var i = this.brandDomains[e];
                if (-1 !== t.indexOf(i)) return !0
            }
            return !1
        }, t.prototype.getUrlLock = function() {
            return null !== t.Current ? this.brandInstances[t.Current] : ""
        }, t.prototype.getUrl = function(t) {
            return this.brandInstances[t]
        }, t.instance = null, t.VSEIGRU = "vseigru", t.Current = t.VSEIGRU, t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(10),
        a = i(18),
        o = i(4),
        r = i(13),
        h = i(40),
        l = i(16),
        c = i(20),
        u = i(0),
        d = i(15),
        p = i(24),
        f = i(31),
        g = i(23),
        y = i(30),
        m = i(27),
        v = i(14),
        b = i(17),
        x = i(126),
        _ = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i.popup = null, i.popup_btn = null, i._armatureDisplay = null, i
            }
            return s(e, t), e.prototype.init = function() {
                this.game.world.removeAll(), dragonBones.PhaserFactory.init(this.game), c.default.DISPLAY_W = Phaser.Math.max(this.game.width, this.game.height), c.default.DISPLAY_H = Phaser.Math.min(this.game.width, this.game.height)
            }, e.prototype.create = function() {
                t.prototype.create.call(this), u.Inventory.instance.signalUnlock.removeAll(), u.Inventory.instance.signalUnlock.addOnce(function() {
                    new l.default(this.game, 0, p.default.Name)
                }, this), this.background2 = this.game.add.sprite(0, 0, o.Atlases.Garage, "0bg_garage0000"), this.background = this.game.add.sprite(0, 0, o.Atlases.Garage, "0bg_garage0000"), this.background3 = this.game.add.sprite(0, 0, o.Atlases.Garage, "bg0000"), this.background4 = this.game.add.sprite(0, 0, o.Atlases.Garage, "bg0000");
                var e = this.game.cache.getJSON(f.default.DBMenu),
                    i = this.game.cache.getJSON(f.default.DBMenu_Texture),
                    s = this.game.cache.getImage(y.default.DBMenu, !0)
                    .base;
                dragonBones.PhaserFactory.factory.parseDragonBonesData(e), dragonBones.PhaserFactory.factory.parseTextureAtlasData(i, s), this._armatureDisplay = dragonBones.PhaserFactory.factory.buildArmatureDisplay("MenuAnim"), this._armatureDisplay.x = 0, this._armatureDisplay.y = 0, this.bg = this.game.add.image(0, 0, o.Atlases.Menu, "BG0000"), this.background.addChild(this.bg), this.bgSky = this.game.add.tileSprite(0, -30, 720, 262, o.Atlases.Menu, "BG20000"), this.bgSky.scale.set(2, 2), this.background.addChild(this.bgSky), this.dust0 = this.game.add.sprite(226, -40, o.Atlases.Menu, "dust_anim0000"), this.dust0.animations.add("dust_anim", Phaser.Animation.generateFrameNames("dust_anim", 0, 3, "", 4)), this.dust0.animations.getAnimation("dust_anim")
                    .play(9, !0), this.dust1 = this.game.add.sprite(206, 215, o.Atlases.Menu, "dust_anim0000"), this.dust1.animations.add("dust_anim", Phaser.Animation.generateFrameNames("dust_anim", 0, 3, "", 4)), this.dust1.animations.getAnimation("dust_anim")
                    .play(9, !0), this.dust1.scale.set(.2, .4), this.dust1.angle = -38, this.water01 = this.game.add.sprite(-20, 315, o.Atlases.Menu, "water_anim10000"), this.water01.animations.add("water_anim1", Phaser.Animation.generateFrameNames("water_anim1", 0, 2, "", 4)), this.water01.animations.getAnimation("water_anim1")
                    .play(15, !0), this.water02 = this.game.add.sprite(-50, 355, o.Atlases.Menu, "water_anim00000"), this.water02.animations.add("water_anim0", Phaser.Animation.generateFrameNames("water_anim0", 0, 4, "", 4)), this.water02.animations.getAnimation("water_anim0")
                    .play(15, !0), this.water03 = this.game.add.sprite(210, 352, o.Atlases.Menu, "water_anim00000"), this.water03.animations.add("water_anim0", Phaser.Animation.generateFrameNames("water_anim0", 0, 4, "", 4)), this.water03.animations.getAnimation("water_anim0")
                    .play(15, !0), this.background.addChild(this._armatureDisplay), this._armatureDisplay.addChildAt(this.dust0, 0), this._armatureDisplay.addChild(this.dust1), this._armatureDisplay.addChild(this.water01), this._armatureDisplay.addChild(this.water02), this._armatureDisplay.addChild(this.water03), this.bgBeach = this.game.add.tileSprite(0, 400, 1008, 146, o.Atlases.Menu, "beach0000"), this.bgBeach.scale.set(1.5, 1.5), this.background.addChild(this.bgBeach);
                var n = {
                    font: "bold 20px Djvu",
                    fill: "#FFFFFF"
                };
                this.bgTop = this.game.add.image(0, 0, o.Atlases.Garage, "top_bg0000"), this.bgTop.scale.set(1.5, 1), this.playBtn = new r.default(this.game, "Play", o.Constants.stylePlay, this.startGame, this, o.Atlases.Garage), this.playBtn.setFrames("play_btn0000", "play_btn0000", "play_btn0000", "play_btn0000"), this.playBtn.x = 500, this.playBtn.y = 200, this.playBtn.btn.inputEnabled = !1, this.playBtn.label.x = 130, this.playBtn.label.stroke = "#000000", this.playBtn.label.strokeThickness = 5;
                var a = new d.default(this.game, 130, 2, "Play", o.Constants.stylePlay);
                a.anchor.set(.5), this.playBtn.label.parent.addChildAt(a, 0), this.play2 = this.game.add.image(100, 0, o.Atlases.Garage, "black0000"), this.play2.alpha = 0, this.play2.width = 250, this.play2.height = 90, this.play2.anchor.set(.5), this.play2.inputEnabled = !0, this.play2.input.useHandCursor = !0, this.play2.events.onInputDown.addOnce(this.startGame, this), this.play2.events.onInputOut.add(this.outPlay, this), this.play2.events.onInputOver.add(this.overPlay, this), this.playBtn.label.parent.addChildAt(this.play2, 0), a.stroke = "#FFFFFF", a.strokeThickness = 10, this.background4.addChild(this.playBtn), this.moregames = new r.default(this.game, "Reset", n, this.resetGame, this, o.Atlases.Garage), this.moregames.setFrames("play_btn0000", "play_btn0000", "play_btn0000", "play_btn0000"), this.moregames.x = 620, this.moregames.y = 400, this.background4.addChild(this.moregames), this.moregames.visible = !1, this.credits = new x.default(this.game, "CREDITS", o.Constants.styleCreditsBtn, this.onCredits, this, o.Atlases.Garage), this.credits.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.credits.setProp("#000000", 4, "#FFFFFF", 7), this.background4.addChild(this.credits), this.logo = this.game.add.image(125, 125, o.Atlases.Garage, "0logo0000"), this.logo.anchor.set(.5), this.garageBtn = new r.default(this.game, "", null, null, this, o.Atlases.Garage), this.garageBtn.setFrames("shop_btn0000", "shop_btn0000", "shop_btn0001", "shop_btn0000"), this.garageBtn.x = this.game.width - 140, this.garageBtn.y = 40, this.world.addChild(this.garageBtn), this.garageBtn.visible = !1, this.musicBtn = this.game.add.image(this.game.width - 28, 25, o.Atlases.Garage, "InGameMusicButton0000"), this.musicBtn.inputEnabled = !1, this.musicBtn.events.onInputUp.add(this.toggleMusic, this), this.musicBtn.events.onInputOver.add(this.onBtnOver, this), this.musicBtn.events.onInputOut.add(this.onBtnOut, this), this.musicBtn.anchor.set(.5), this.playBtn.visible = !1, this.blackRightBG = this.game.add.sprite(900, o.Constants.HEIGHT / 2, o.Atlases.Garage, "0popup_bg0000"), this.blackRightBG.anchor.set(.5), this.blackRightBG.angle = 90, this.background3.addChild(this.blackRightBG);
                var c = this.game.add.sprite(0, -o.Constants.HEIGHT, o.Atlases.Garage, "0popup_bg0000");
                c.anchor.set(.5), this.blackRightBG.addChild(c), c = this.game.add.sprite(0, -o.Constants.HEIGHT / 2, o.Atlases.Garage, "0popup_bg0000"), c.anchor.set(.5), this.blackRightBG.addChild(c), c = this.game.add.sprite(0, -330, o.Atlases.Garage, "0popup_bg0000"), c.anchor.set(.5), this.blackRightBG.addChild(c), c = this.game.add.sprite(0, -1200, o.Atlases.Garage, "0popup_bg0000"), c.anchor.set(.5), this.blackRightBG.addChild(c), this.textVersion = new d.default(this.game, 680, 470, " " + o.Constants.VERSION, o.Constants.styleVersion), this.background3.addChild(this.textVersion), this.brand_logo = new r.default(this.game, "", null, this.onMoreGames, this, o.Atlases.Garage), this.brand_logo.setFrames("branding_l20000", "branding_l20000", "branding_l20000", "branding_l20000"), this.brand_logo.scale.set(.8), this.brand_logo.btn.anchor.set(1, .5), this.background3.addChild(this.brand_logo), this._armatureDisplay.animation.play("biker_anim_menu", 0), b.default.getInstance(this.game, this.onLoadSave, this), new h.default(this.game, 0, null), this.resize()
            }, e.prototype.onLoadSave = function() {
                n.default.getInstance(this.game)
                    .playMusic(o.Sounds.MenuMusic), this.musicBtn.inputEnabled = !0, this.updateSoundButtons(), this.playBtn.visible = !0
            }, e.prototype.onMoreGames = function() {
                window.open(window.location.origin, "_blank")
            }, e.prototype.initGame = function() {
                null === u.GameData.currentCar && (u.GameData.currentCar = this.game.cache.getJSON(f.default.Car001), u.CarsData.geomObj = this.game.cache.getJSON(f.default.Objects), this.setCar(u.GameData.currentCar))
            }, e.prototype.overPlay = function() {
                this.playBtn.btn.scale.set(1.1)
            }, e.prototype.outPlay = function() {
                this.playBtn.btn.scale.set(1)
            }, e.prototype.startGame = function() {
                this.playBtn.btn.scale.set(.9), a.default.getInstance(this.game, this.onGameLoad, this)
            }, e.prototype.onGameLoad = function() {
                this.initGame(), new l.default(this.game, 0, p.default.Name)
            }, e.prototype.setCar = function(t) {
                u.CarsData.params = new u.CarParams, u.CarsData.params.setData(t), g.default.currCar = g.default.carList.indexOf(u.Inventory.instance.skin), u.CarsData.params.skinId = g.default.carList[g.default.currCar]
            }, e.prototype.resetGame = function() {
                u.Inventory.instance.reset(), a.default.getInstance()
                    .save()
            }, e.prototype.onBtnOver = function(t) {
                t.scale.set(1.1)
            }, e.prototype.onBtnOut = function(t) {
                t.scale.set(1)
            }, e.prototype.toggleMusic = function() {
                b.default.getInstance()
                    .music ? n.default.getInstance()
                    .toggleMusic() : b.default.getInstance()
                    .sfx ? n.default.getInstance()
                    .toggleSfx() : (n.default.getInstance()
                        .toggleSfx(), n.default.getInstance()
                        .toggleMusic()), this.updateSoundButtons(), n.default.getInstance()
                    .play(o.Sounds.Click)
            }, e.prototype.updateSoundButtons = function() {
                var t = b.default.getInstance()
                    .music ? 0 : 1;
                t += b.default.getInstance()
                    .sfx ? 0 : 1, this.musicBtn.loadTexture(o.Atlases.Garage, "InGameMusicButton000" + t)
            }, e.prototype.onCredits = function() {
                this.createPopup();
                for (var t = 23, e, i = [" ", " ", " ", " ", " ", "CEO: Konstantin Matrunchik", "Coding: Dmitry Borozenets", "Art: Andrey Zdyschuk", "Game Design: Vasiliy Kachor", "", "Ported by iriysoft.com"], s = 0; s < i.length; s++) e = new r.default(this.game, i[s], i.length - 2 <= s ? o.Constants.styleCredits2 : o.Constants.styleCredits1, null, this, o.Atlases.Garage), e.y = 23 * s - 75, e.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), e.btn.inputEnabled = !1, this.popup.getChildAt(1)
                    .addChild(e);
                this.popup_btn = new r.default(this.game, "OK", o.Constants.styleCreditsOK, this.disposePopup, this, o.Atlases.Garage), this.popup_btn.setFrames("orange_btn0000", "orange_btn0000", "orange_btn0000", "orange_btn0000"), this.popup_btn.y = 200, this.popup_btn.btn.alpha = 0, this.popup_btn.label.y = 0, this.popup_btn.label.stroke = "#000000", this.popup_btn.label.strokeThickness = 5;
                var n = new d.default(this.game, 0, 0, "OK", o.Constants.styleCreditsOK);
                n.anchor.set(.5), this.popup_btn.label.parent.addChildAt(n, 0), n.stroke = "#FFFFFF", n.strokeThickness = 10;
                var a = this.game.add.image(0, -130, o.Atlases.Garage, "logo_mad0000");
                a.anchor.set(.5), a.inputEnabled = !0, a.input.useHandCursor = !0, a.events.onInputDown.add(this.onLogo, this), this.popup.getChildAt(1)
                    .addChild(a);
                var h = this.game.add.image(0, 0, o.Atlases.Garage, "vk_icon0000");
                h.anchor.set(.5), h.inputEnabled = !0, h.input.useHandCursor = !0, h.events.onInputDown.add(this.onVK, this), this.popup.getChildAt(1)
                    .addChild(h);
                var l = this.game.add.image(70, 0, o.Atlases.Garage, "fb_icon0000");
                l.anchor.set(.5), l.inputEnabled = !0, l.input.useHandCursor = !0, l.events.onInputDown.add(this.onFB, this), this.popup.getChildAt(1)
                    .addChild(l);
                var c = this.game.add.image(-70, 0, o.Atlases.Garage, "tw_icon0000");
                c.anchor.set(.5), c.inputEnabled = !0, c.input.useHandCursor = !0, c.events.onInputDown.add(this.onTW, this), this.popup.getChildAt(1)
                    .addChild(c), this.resizePopup(1)
            }, e.prototype.onLogo = function() {
                window.open("http://madpuffers.com/", "_blank")
            }, e.prototype.onVK = function() {
                window.open("https://vk.com/madpuffers", "_blank")
            }, e.prototype.onFB = function() {
                window.open("https://www.facebook.com/madpuffers", "_blank")
            }, e.prototype.onTW = function() {
                window.open("https://twitter.com/MadPuffers", "_blank")
            }, e.prototype.disposePopup = function() {
                this.popup.destroy(), this.popup = null, this.popup_btn.destroy(), this.popup_btn = null
            }, e.prototype.backgroundPopup = function() {
                this.popup = this.game.add.sprite(350, 250, o.Atlases.Garage, "bg0000"), this.popup.anchor.set(.5);
                var t = this.game.add.sprite(0, 0, o.Atlases.Garage, "black0000");
                t.width = this.game.width + 500, t.height = this.game.height + 500, t.inputEnabled = !0, t.anchor.set(.5), this.popup.addChild(t)
            }, e.prototype.createPopup = function() {
                null !== this.popup && this.disposePopup(), this.backgroundPopup();
                var t = this.game.add.sprite(0, 0, o.Atlases.Garage, "0popup_bg0000");
                t.anchor.set(.5), this.popup.addChild(t)
            }, e.prototype.resizePopup = function(t) {
                if (null !== this.popup) {
                    var e = this.popup.removeChildAt(0);
                    e.width = this.game.width + 500, e.height = this.game.height + 500, this.popup.x = this.world.bounds.centerX, this.popup.y = this.world.bounds.centerY, this.popup.addChildAt(e, 0), this.popup_btn.x = this.world.bounds.centerX, this.popup_btn.y = this.world.bounds.centerY + 200
                }
            }, e.prototype.render = function() {
                dragonBones.PhaserFactory.factory.dragonBones.advanceTime(.01666666), this.bgSky.tilePosition.x -= 2, this.bgBeach.tilePosition.x -= 2.5, t.prototype.render.call(this)
            }, e.prototype.resize = function() {
                var e = 1;
                e = this.game.width / o.Constants.WIDTH, e = e > 1 ? 1 : e, this.garageBtn.x = this.game.width - 120, this.musicBtn.x = this.game.width - 28, this.bgTop.x = this.game.width - 250, this.background.scale.set(e), this.background.alignIn(this.world.bounds, Phaser.BOTTOM_CENTER), this.logo.scale.set(.9 * e), this.background2.scale.set(2.02 * Phaser.Math.max(this.game.width / o.Constants.WIDTH, this.game.height / o.Constants.HEIGHT)), this.background2.alignIn(this.world.bounds, Phaser.CENTER), this.background2.visible = !1, this._armatureDisplay.x = -this.background.x, this._armatureDisplay.y = 10 - this.background.y, this.bg.x = -this.background.x, this.bg.y = -this.background.y, this.bgSky.x = -this.background.x, this.bgSky.y = -this.background.y - 30, this.bgBeach.x = -this.background.x, this.bgBeach.y = 400 - this.background.y, this.game.width > 1280 ? this.blackRightBG.x = 1100 : this.blackRightBG.x = this.game.width - 110, this.playBtn.x = this.game.width - 250, this.playBtn.y = 170, this.credits.x = this.game.width - 125, this.credits.y = 245, this.moregames.x = this.game.width - 100, this.moregames.y = this.game.height - 180, this.playBtn.scale.set(e), this.credits.scale.set(e), this.moregames.scale.set(e), this.textVersion.x = this.game.width - 60, this.textVersion.y = this.game.height - 20, this.brand_logo.x = this.game.width - 72, this.brand_logo.y = this.game.height - 180, this.resizePopup(e), t.prototype.resize.call(this)
            }, e.prototype.shutdown = function() {
                t.prototype.shutdown.call(this), this.bg = null, this.bgBeach = null, this.bgSky = null, this.background = null, this.background2 = null, this.popup = null, this.popup_btn = null, this.playBtn = null, this.moregames = null, this.musicBtn = null, this.bgTop = null, this._armatureDisplay = null, this.brand_logo = null, this.moto2 = null, this.moto1 = null, this.moto4 = null
            }, e.Name = "menu", e
        }(Phaser.State);
    e.default = _
}, function(t, e) {
    var i;
    i = function() {
        return this
    }();
    try {
        i = i || Function("return this")() || (0, eval)("this")
    } catch (t) {
        "object" == typeof window && (i = window)
    }
    t.exports = i
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.DBBike = "bikes_data", t.DBMenu = "menu_data", t.preloadList = [], t.list = [t.DBBike, t.DBMenu], t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.Level001 = "map1", t.Level002 = "map2", t.Level003 = "map3", t.Level004 = "map4", t.Level005 = "map5", t.Level006 = "map6", t.Level007 = "map7", t.Level008 = "map8", t.Level009 = "map9", t.Level010 = "map10", t.Level011 = "map11", t.Level012 = "map12", t.Level013 = "map13", t.Level014 = "map14", t.Level015 = "map15", t.Level016 = "map16", t.Level017 = "map17", t.Level018 = "map18", t.Level019 = "map19", t.Level020 = "map20", t.Level021 = "map21", t.Level022 = "map22", t.Car001 = "1", t.Bike = "bike", t.DBBike = "bikes_sc", t.DBBike_Texture = "bikes_texture", t.DBMenu = "menu_sc", t.DBMenu_Texture = "menu_texture", t.Objects = "objects", t.preloadList = [t.Objects], t.list = [t.Car001, t.Level001, t.Level002, t.Level003, t.Level004, t.Level005, t.Level006, t.Level007, t.Level008, t.Level009, t.Level010, t.Level011, t.Level012, t.Level013, t.Level014, t.Level015, t.Level016, t.Level017, t.Level018, t.Level019, t.Level020, t.Level021, t.Level022, t.Objects, t.DBBike, t.DBBike_Texture, t.DBMenu, t.DBMenu_Texture, t.Bike], t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(4),
        a = i(16),
        o = i(28),
        r = i(2),
        h = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i.loadComplete = !0, i.bike = null, i.w0 = null, i.w1 = null, i.wait = null, i.mainParent = null, i
            }
            return s(e, t), e.prototype.preload = function() {
                var e = this;
                t.prototype.preload.call(this), this.wait = this.game.add.text(this.game.width / 2, this.game.height / 2, "LOADING...", n.Constants.styleCredits0), this.wait.anchor.set(.5), this.game.sound.muteOnPause = !0, this.game.load.onFileComplete.add(this.fileComplete, this);
                var i = "x" + n.Constants.GAME_SCALE + "/";
                n.JSONData.list.forEach(function(t) {
                    e.game.load.json(t, "assets/levels/" + t + ".json")
                }), n.Images.list.forEach(function(t) {
                    e.game.load.image(t, "assets/images/" + i + t + ".png")
                }), n.Atlases.list.forEach(function(t) {
                    e.game.load.atlas(t, "assets/atlases/" + i + t + ".png", "assets/atlases/" + i + t + ".json")
                }), n.Sounds.list.forEach(function(t) {
                    e.game.device.iOS ? e.game.load.audio(t, ["assets/sound/" + t + ".m4a"]) : e.game.load.audio(t, ["assets/sound/" + t + ".ogg", "assets/sound/" + t + ".mp3"])
                }), this.game.scale.onSizeChange.add(function() {
                    e.game.state.getCurrentState()
                        .resize()
                }, this)
            }, e.prototype.init = function() {
                t.prototype.init.call(this), this.mainParent = this.game.add.group(), this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2 - 80, this.setPauseViewCar(this.mainParent)
            }, e.prototype.setPauseViewCar = function(t) {
                null !== this.bike ? (this.bike.destroy(), this.bike = this.game.add.group(t)) : this.bike = this.game.add.group(t);
                var e = this.game.cache.getJSON(n.JSONData.Objects)
                    .bike11,
                    i = "Wheel0";
                this.w0 = this.parseStaticGraphic(e, i), i = "Wheel1", this.w1 = this.parseStaticGraphic(e, i), i = "suspend_back", this.parseStaticGraphic(e, i), i = "base", this.parseStaticGraphic(e, i), i = "driver_corpse", this.parseStaticGraphic(e, i), i = "driver_hip", this.parseStaticGraphic(e, i), i = "driver_shin", this.parseStaticGraphic(e, i), i = "driver_arm", this.parseStaticGraphic(e, i), i = "driver_forearm", this.parseStaticGraphic(e, i), i = "driver_head", this.parseStaticGraphic(e, i), i = "suspend_front", this.parseStaticGraphic(e, i), this.bike.x = 0, this.bike.y = 10
            }, e.prototype.parseStaticGraphic = function(t, e) {
                var i = null;
                return i = this.game.add.image(t[e].x, t[e].y, n.Atlases.Cars, t[e].g + "0000"), i.angle = t[e].r, -1 !== e.indexOf("base") ? i.anchor.set(r.AssetsList.FRAMES_ANCHORX[0], r.AssetsList.FRAMES_ANCHORY[0]) : -1 !== e.indexOf("suspend") ? -1 !== e.indexOf("front") ? i.anchor.set(.8, -1 !== t[e].g.indexOf("1") ? .2 : .5) : i.anchor.set(0, .5) : i.anchor.set(.5), this.bike.addChild(i), i
            }, e.prototype.create = function() {
                t.prototype.create.call(this)
            }, e.prototype.update = function() {
                t.prototype.update.call(this), this.loadComplete && (this.loadComplete = !1, e.game = this.game, new a.default(this.game, 0, o.default.Name))
            }, e.prototype.fileComplete = function(t, e, i, s, n) {
                this.wait.setText("Loading..." + t + "%"), this.w0.angle = 720 * t / 100, this.w1.angle = 720 * t / 100
            }, e.prototype.resize = function() {
                var e = 1;
                e = this.game.width / n.Constants.WIDTH, e = e > 1 ? 1 : e, this.mainParent && (this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2 - 80), this.wait && this.wait.position.set(this.game.width / 2, this.game.height / 2), t.prototype.resize.call(this)
            }, e.prototype.shutdown = function() {
                t.prototype.shutdown.call(this)
            }, e.Name = "preloader", e.game = null, e
        }(Phaser.State);
    e.default = h
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.geom.Vec2,
        n = function() {
            function t() {
                this.tweened = !1, this.pathes = []
            }
            return t.prototype.reset = function() {
                this.prevPath = null, this.tweened = !1
            }, t.prototype.addPathByPoints = function(t) {
                var e = new a(t);
                this.pathes.push(e)
            }, t.prototype.getPathPointXY = function(t, e) {
                for (var i = NaN, s = this.pathes.length, n, a = 0; a < s; a++) {
                    var o = this.pathes[a],
                        r = o.getPoint(t, e);
                    isNaN(r) || (isNaN(i) ? (i = r, n = o) : r < i && (i = r, n = o))
                }
                return null !== this.prevPath && this.prevPath !== n && (this.tweened = !0), this.prevPath = n, i
            }, t.prototype.clearPrevPath = function() {
                this.tweened = !1, this.prevPath = null
            }, t.prototype.clear = function() {
                this.clearPrevPath(), this.pathes.splice(0, this.pathes.length)
            }, Object.defineProperty(t, "instance", {
                get: function() {
                    return null === t._instance && (t._instance = new t), t._instance
                },
                enumerable: !0,
                configurable: !0
            }), t._instance = null, t
        }();
    e.CameraPathes = n;
    var a = function() {
        function t(t) {
            this.points = t, this.minX = t[0].x, this.maxX = t[t.length - 1].x
        }
        return t.prototype.getPoint = function(t, e) {
            if (t < this.minX || t > this.maxX) return NaN;
            for (var i = this.points.length, n = s.get(0, 0), a = 1; a < i; a++) {
                var o = this.points[a];
                if (o.x >= t) {
                    var r = this.points[a - 1],
                        h = t - r.x;
                    n.x = o.x - r.x, n.y = o.y - r.y;
                    var l = h * Math.tan(n.angle),
                        c = r.y + l;
                    return c < e ? NaN : c
                }
            }
            return NaN
        }, t
    }();
    e.CameraPath = a
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return Object.defineProperty(t, "map", {
            get: function() {
                return t._map
            },
            set: function(e) {
                t._map !== e && t.data.reset(), t._map = e
            },
            enumerable: !0,
            configurable: !0
        }), t.EDITED = -1, t.MAP_COUNT = 25, t._map = {}, t.prize_coin = 100, t
    }();
    e.RacesData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.raceId = 0, t.currentLevel = null, t.currentCar = null, t.raceResult = 0, t.carId = -1, t
    }();
    e.GameData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = Phaser.Keyboard,
        n = i(4),
        a = i(13),
        o = function() {
            function t() {
                this.container = null, this.btnUp = null, this.btnDown = null, this.btnLeft = null, this.btnRight = null, this._isbtnUp = !1, this._isbtnDown = !1, this._isbtnLeft = !1, this._isbtnRight = !1
            }
            return Object.defineProperty(t.prototype, "isbtnUp", {
                get: function() {
                    return this.game.device.desktop ? this.game.input.keyboard.isDown(s.UP) || this.game.input.keyboard.isDown(s.W) : this._isbtnUp
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isbtnDown", {
                get: function() {
                    return this.game.device.desktop ? this.game.input.keyboard.isDown(s.DOWN) || this.game.input.keyboard.isDown(s.S) : this._isbtnDown
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isbtnLeft", {
                get: function() {
                    return this.game.device.desktop ? this.game.input.keyboard.isDown(s.LEFT) || this.game.input.keyboard.isDown(s.A) : this._isbtnLeft
                },
                enumerable: !0,
                configurable: !0
            }), Object.defineProperty(t.prototype, "isbtnRight", {
                get: function() {
                    return this.game.device.desktop ? this.game.input.keyboard.isDown(s.RIGHT) || this.game.input.keyboard.isDown(s.D) : this._isbtnRight
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function(t, e) {
                this.container = t, this.game = e, this.container.inputEnableChildren = !0, this.game.device.desktop ? (this.game.input.keyboard.addKeyCapture(s.RIGHT), this.game.input.keyboard.addKeyCapture(s.LEFT), this.game.input.keyboard.addKeyCapture(s.DOWN), this.game.input.keyboard.addKeyCapture(s.UP)) : this.createButtons()
            }, t.prototype.createButtons = function() {
                var t = this.game.add.image(0, 0, n.Atlases.Garage, "arrow_key0000");
                t.anchor.set(.5), this.btnUp = new a.default(this.game, "", {}, function() {}, null, n.Atlases.Garage), this.btnUp.setFrames("btn_body0000", "btn_body0000", "btn_body0001", "btn_body0000"), this.btnUp.x = this.game.width - 70, this.btnUp.y = this.game.height - 70, this.btnUp.scale.set(1.3), this.btnUp.btn.events.onInputDown.add(this.upTap, this), this.btnUp.btn.events.onInputUp.add(this.upUnTap, this), this.container.addChild(this.btnUp), this.btnUp.label.parent.addChild(t), t = this.game.add.image(0, 0, n.Atlases.Garage, "arrow_key0000"), t.anchor.set(.5), t.rotation = 180 * Math.PI / 180, this.btnDown = new a.default(this.game, "", {}, function() {}, null, n.Atlases.Garage), this.btnDown.setFrames("btn_body0000", "btn_body0000", "btn_body0001", "btn_body0000"), this.btnDown.x = this.game.width - 220, this.btnDown.y = this.game.height - 70, this.btnDown.scale.set(1.3), this.btnDown.btn.events.onInputDown.add(this.downTap, this), this.btnDown.btn.events.onInputUp.add(this.downUnTap, this), this.container.addChild(this.btnDown), this.btnDown.label.parent.addChild(t), t = this.game.add.image(0, 0, n.Atlases.Garage, "arrow_key20000"), t.anchor.set(.5), t.scale.set(-1, 1), this.btnLeft = new a.default(this.game, "", {}, function() {}, null, n.Atlases.Garage), this.btnLeft.setFrames("btn_body0000", "btn_body0000", "btn_body0001", "btn_body0000"), this.btnLeft.x = 70, this.btnLeft.y = this.game.height - 70, this.btnLeft.scale.set(1.3), this.btnLeft.btn.events.onInputDown.add(this.leftTap, this), this.btnLeft.btn.events.onInputUp.add(this.leftUnTap, this), this.container.addChild(this.btnLeft), this.btnLeft.label.parent.addChild(t), t = this.game.add.image(0, 0, n.Atlases.Garage, "arrow_key20000"), t.anchor.set(.5), this.btnRight = new a.default(this.game, "", {}, function() {}, null, n.Atlases.Garage), this.btnRight.setFrames("btn_body0000", "btn_body0000", "btn_body0001", "btn_body0000"), this.btnRight.x = 220, this.btnRight.y = this.game.height - 70, this.btnRight.scale.set(1.3), this.btnRight.btn.events.onInputDown.add(this.rightTap, this), this.btnRight.btn.events.onInputUp.add(this.rightUnTap, this), this.container.addChild(this.btnRight), this.btnRight.label.parent.addChild(t)
            }, t.prototype.upTap = function() {
                this._isbtnUp = !0
            }, t.prototype.downTap = function() {
                this._isbtnDown = !0
            }, t.prototype.leftTap = function() {
                this._isbtnLeft = !0
            }, t.prototype.rightTap = function() {
                this._isbtnRight = !0
            }, t.prototype.upUnTap = function() {
                this._isbtnUp = !1
            }, t.prototype.downUnTap = function() {
                this._isbtnDown = !1
            }, t.prototype.leftUnTap = function() {
                this._isbtnLeft = !1
            }, t.prototype.rightUnTap = function() {
                this._isbtnRight = !1
            }, t.prototype.resize = function(t) {
                this.container && (this.container.scale.set(t), this.btnUp.x = this.game.width / t - 70, this.btnUp.y = this.game.height / t - 70, this.btnDown.x = this.game.width / t - 220, this.btnDown.y = this.game.height / t - 70, this.btnLeft.x = 70, this.btnLeft.y = this.game.height / t - 70, this.btnRight.x = 220, this.btnRight.y = this.game.height / t - 70)
            }, Object.defineProperty(t, "instance", {
                get: function() {
                    return t._instance || (t._instance = new t), t._instance
                },
                enumerable: !0,
                configurable: !0
            }), t
        }();
    e.default = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(4),
        n = i(13),
        a = i(24),
        o = i(36),
        r = i(26),
        h = i(3),
        l = i(15),
        c = i(10),
        u = i(17),
        d = i(18),
        p = i(14),
        f = function() {
            function t() {
                this.stars = null, this.signalRestart = null, this.signalPause = null, this.signalToggleMusic = null, this.game = null, this.scl = 1, this.container = null, this.bgBtnRight = null, this.timer = null, this.helperText = null, this.continueText = null, this.bgBtnLeft = null, this.time = 0, this.helperShow = !1, this.continueShow = !1, this.wasDead = !1, this.lFront = null, this.lBack = null, this.flipTexts = null, this.flipBG = null, this.MSG_DELAY = 40
            }
            return t.prototype.onBtnOver = function(t) {
                t.scale.set(1.1)
            }, t.prototype.onBtnOut = function(t) {
                t.scale.set(1)
            }, t.prototype.setTimer = function() {
                var t = Math.ceil(100 * h.MaxGameCore.instance.timer),
                    e = t / 100 >> 0;
                t -= 100 * e;
                var i = (e < 10 ? "0" + e : e) + "." + t;
                i.length < 5 && (i += "0"), this.timer.setText(i)
            }, t.prototype.showFlipMsg = function(t, e) {
                var i = "FLIP",
                    n = "";
                n = n + "-" + .5 * t + " sec", this.flipTexts.setText(n), this.flipBG.setText(n), t > 1 && (i = i + " " + t + "X"), this.lFront.setText(i), this.lBack.setText(i), h.MaxGameCore.instance.timer -= .5 * t, this.startTextAnim(this.flipTexts, this.hideFlipTxtAnim, this), c.default.getInstance()
                    .play(s.Sounds.FlipSound())
            }, t.prototype.startTextAnim = function(t, e, i) {
                t.scale.set(.1), this.flipBG.stroke = "#000000", this.flipBG.strokeThickness = 2, t.label.stroke = "#FFFFFF", t.label.strokeThickness = 5;
                var s = this.game.add.tween(t.scale);
                t.alpha = 1, s.to({
                    x: 1,
                    y: 1
                }, 350, Phaser.Easing.Back.Out, !0), s.onComplete.addOnce(e, i)
            }, t.prototype.hideFlipTxtAnim = function() {
                this.game.add.tween(this.flipTexts)
                    .to({
                        alpha: 0
                    }, 250, Phaser.Easing.Linear.None, !0, 500)
            }, t.prototype.release = function() {
                this.flipTexts = null, this.flipBG = null, this.bgBtnRight = null, this.bgBtnLeft = null, this.helperText = null, this.continueText = null, this.continueShow = !1, this.wasDead = !1, this.helperShow = !1, this.game = null, this.timer = null, this.pauseBtn = null, this.restartBtn = null, this.musicBtn = null, this.stars = null, this.signalToggleMusic.removeAll(), this.signalRestart.removeAll(), this.signalPause.removeAll(), this.signalToggleMusic = null, this.signalRestart = null, this.signalPause = null, this.container.destroy(), this.container = null
            }, t.prototype.showControlsHint = function() {
                this.helperText.visible = !0, this.continueText.visible = !1, this.helperShow = !0, this.continueShow = !1
            }, t.prototype.showDeathHint = function() {
                h.MaxGameCore.instance.finished || (this.continueText.visible = !0), this.helperText.visible = !1, this.helperShow = !1, this.continueShow = !0, this.wasDead = !0, c.default.getInstance()
                    .play(s.Sounds.DieSound())
            }, t.prototype.hideControlsHint = function() {
                this.helperShow = !1, this.continueShow = !1, this.helperText.visible = !1, this.continueText.visible = !1
            }, t.prototype.showTimer = function() {
                this.timer.visible || h.MaxGameCore.instance.finished || (this.timer.visible = !0, this.helperShow && (this.helperText.visible = !0), this.continueShow && (this.continueText.visible = !0), o.default.instance.container.visible = !0)
            }, t.prototype.hideTimer = function() {
                this.timer.visible && (this.timer.visible = !1, this.helperText.visible = !1, this.continueText.visible = !1, o.default.instance.container.visible = !1)
            }, t.prototype.init = function(e, i) {
                this.container = e, this.game = i, this.game.device.desktop || (t.MSG_CONTINUE = "Tap to continue", t.MSG_HELP = "Use arrows to move"), this.scl = Math.max(this.game.width, this.game.height) / s.Constants.WIDTH, this.scl = this.scl > 1 ? 1 : this.scl, this.signalRestart = new Phaser.Signal, this.signalPause = new Phaser.Signal, this.signalToggleMusic = new Phaser.Signal, this.timer = new n.default(this.game, "00.00", s.Constants.styleTimer, null, null, s.Atlases.Garage), this.timer.setFrames("timer_bg0000", "timer_bg0000", "timer_bg0000", "timer_bg0000"), this.timer.x = this.game.width / 2, this.timer.y = 25, this.timer.label.x = -2, this.timer.label.anchor.set(0, .6), this.timer.inputEnableChildren = !1, this.helperText = new n.default(this.game, t.MSG_HELP, s.Constants.styleHelp, null, null, s.Atlases.Garage), this.helperText.setFrames("0popup_bg0000", "0popup_bg0000", "0popup_bg0000", "0popup_bg0000"), this.helperText.x = this.game.width / 2, this.helperText.y = this.game.height + this.helperText.height / 2 - 90 * s.Constants.GAME_SCALE, this.helperText.label.anchor.set(.5, 5.5), this.helperText.visible = !1, this.continueText = new n.default(this.game, t.MSG_CONTINUE, s.Constants.styleHelp, null, null, s.Atlases.Garage), this.continueText.setFrames("0popup_bg0000", "0popup_bg0000", "0popup_bg0000", "0popup_bg0000"), this.continueText.x = this.game.width / 2, this.continueText.y = this.game.height + this.helperText.height / 2 - 90 * s.Constants.GAME_SCALE, this.continueText.label.anchor.set(.5, 5.5), this.continueText.visible = !1, this.bgBtnRight = this.game.add.image(this.game.width, 0, s.Atlases.Garage, "pause_bg0000"), this.bgBtnRight.scale.set(-1.4, 1), this.bgBtnLeft = this.game.add.image(0, 0, s.Atlases.Garage, "pause_bg0000"), this.bgBtnLeft.scale.set(1.4, 1), this.restartBtn = this.game.add.image(25, 30, s.Atlases.Garage, "restart_btn0000"), this.pauseBtn = this.game.add.image(this.game.width - 90, 25, s.Atlases.Garage, "InGamePauseButton0000"), this.musicBtn = this.game.add.image(this.game.width - 58, 22, s.Atlases.Garage, "InGameMusicButton0000"), this.stars = this.game.add.text(45, 6, "#" + (a.default.LevelNum + 1), s.Constants.styleMoney), this.restartBtn.anchor.set(.5), this.musicBtn.anchor.set(.5), this.pauseBtn.anchor.set(.5), this.flipTexts = new n.default(i, "", s.Constants.styleTrick, null, null, s.Atlases.Garage), this.flipTexts.setFrames("bg0000", "bg0000", "bg0000", "bg0000"), this.flipTexts.label.setMaxSize(200, 45), this.flipTexts.label.y = 20, this.flipTexts.alpha = 0, this.lBack = new l.default(this.game, 0, -20, "FLIP", s.Constants.styleTrick), this.lBack.anchor.set(.5), this.flipTexts.label.parent.addChildAt(this.lBack, 0), this.lBack.stroke = "#FFFFFF", this.lBack.strokeThickness = 5, this.lFront = new l.default(this.game, 0, -20, "FLIP", s.Constants.styleTrick), this.lFront.anchor.set(.5), this.flipTexts.label.parent.addChild(this.lFront), this.lFront.stroke = "#000000", this.lFront.strokeThickness = 2, this.flipBG = new l.default(this.game, 0, 20, "", s.Constants.styleTrick), this.flipBG.anchor.set(.5), this.flipTexts.label.parent.addChild(this.flipBG), this.restartBtn.inputEnabled = !0, this.restartBtn.events.onInputDown.add(this.onRestart, this), this.restartBtn.events.onInputOut.add(this.onBtnOut, this), this.restartBtn.events.onInputOver.add(this.onBtnOver, this), this.pauseBtn.inputEnabled = !0, this.pauseBtn.events.onInputDown.add(this.onPause, this), this.pauseBtn.events.onInputOut.add(this.onBtnOut, this), this.pauseBtn.events.onInputOver.add(this.onBtnOver, this), this.musicBtn.inputEnabled = !0, this.musicBtn.events.onInputDown.add(this.toggleMusic, this), this.musicBtn.events.onInputOut.add(this.onBtnOut, this), this.musicBtn.events.onInputOver.add(this.onBtnOver, this), this.updateSoundButtons(), this.container.addChild(this.bgBtnRight), this.container.addChild(this.bgBtnLeft), this.container.addChild(this.pauseBtn), this.container.addChild(this.restartBtn), this.container.addChild(this.musicBtn), this.container.addChild(this.flipTexts), this.container.addChild(this.stars), this.container.addChild(this.timer), this.container.addChild(this.helperText), this.container.addChild(this.continueText), this.game.device.desktop || o.default.instance.container.parent.addChild(o.default.instance.container), this.flipTexts.x = .5 * this.game.width / this.scl, this.flipTexts.y = .2 * s.Constants.HEIGHT
            }, t.prototype.toggleMusic = function() {
                this.signalToggleMusic.dispatch()
            }, t.prototype.updateSoundButtons = function() {
                var t = u.default.getInstance()
                    .music ? 0 : 1;
                t += u.default.getInstance()
                    .sfx ? 0 : 1, this.musicBtn.loadTexture(s.Atlases.Garage, "InGameMusicButton000" + t)
            }, t.prototype.resize = function(t) {
                this.container.scale.set(t), this.bgBtnRight.x = this.game.width / t, this.musicBtn.x = this.game.width / t - 28, this.pauseBtn.x = this.game.width / t - 75, this.bgBtnRight.y = 0, this.bgBtnLeft.y = 0, this.game.state.current === r.default.Name && this.resizeGameplay(t), this.game.device.desktop || o.default.instance.resize(t)
            }, t.prototype.resizeGameplay = function(t) {
                this.flipTexts.x = .5 * this.game.width, this.continueText.x = .5 * this.game.width, this.helperText.x = .5 * this.game.width, this.timer.x = .5 * this.game.width, this.helperText.y = this.game.height + this.helperText.height / 2 - 90 * s.Constants.GAME_SCALE, this.continueText.y = this.game.height + this.helperText.height / 2 - 90 * s.Constants.GAME_SCALE
            }, t.prototype.onPause = function() {
                this.signalPause.dispatch()
            }, t.prototype.onRestart = function() {
                this.signalRestart.dispatch()
            }, Object.defineProperty(t, "instance", {
                get: function() {
                    return t._instance || (t._instance = new t), t._instance
                },
                enumerable: !0,
                configurable: !0
            }), t.MSG_CONTINUE = "Press SPACE to continue", t.MSG_HELP = "Use arrows to move", t
        }();
    e.default = f
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(47),
        n = function() {
            function t() {}
            return t.prototype.init = function(t, e) {
                this.prevX = t, this.prevY = e, this.prevDist = 0
            }, t.prototype.emit = function(e, i) {
                var n = Math.sqrt((e - this.prevX) * (e - this.prevX) + (i - this.prevY) * (i - this.prevY));
                if (n < t.MIN_DIST) s.TrailPartObject.get()
                    .put(e, i), this.prevX = e, this.prevY = i, this.prevDist = n;
                else
                    for (var a = Math.atan2(i - this.prevY, e - this.prevX), o = Math.cos(a), r = Math.sin(a); n > t.MIN_DIST;) this.prevX += t.MIN_DIST * o, this.prevY += t.MIN_DIST * r, s.TrailPartObject.get()
                        .put(this.prevX, this.prevY), n -= t.MIN_DIST
            }, t.MIN_DIST = 16, t
        }();
    e.TrailParticlesSystem = n
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(3),
        r = i(6),
        h = i(2),
        l = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.create(), e
            }
            return s(e, t), e.get = function() {
                return new e
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = a.ObjectTypes.EFFECT, this.graphic = r.GraphicUtil.createMovieClip(null, h.AssetsStorage.instance.getByKey("car_exp_anim"), 30, !1);
                var e = h.AssetsStorage.instance.getByKey("car_exp_anim");
                this.graphic.animations.getAnimation(e)
                    .onComplete.add(this.animComplete, this), this.graphic.completeCallback = this.animComplete, this.graphic.scale.set(2), this.graphic.visible = !1, o.MaxGameCore.instance.add(this)
            }, e.prototype.animComplete = function(t) {
                this.active = !1, this.graphic.visible = !1, null !== this.completeCallback && (this.completeCallback(), this.completeCallback = null)
            }, e.prototype.activate = function(t, e, i, s, n) {
                void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = null), this.active = !0, this.graphic.x = t, this.graphic.y = e, this.graphic.visible = !0, this.maxSizeCallback = i, this.completeCallback = s, this.completeCallbackContext = n;
                var a = h.AssetsStorage.instance.getByKey("car_exp_anim");
                this.graphic.animations.getAnimation(a)
                    .play(30)
            }, e.prototype.restart = function() {
                this.active && (this.graphic.visible = !1, this.active = !1, this.maxSizeCallback = null, this.completeCallback = null, this.completeCallbackContext = null)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.active && null !== this.maxSizeCallback && (this.maxSizeCallback(this.completeCallbackContext), this.maxSizeCallback = null, this.completeCallbackContext = null)
            }, e.prototype.release = function() {
                this.maxSizeCallback = null, this.completeCallback = null, this.completeCallbackContext = null, t.prototype.release.call(this)
            }, e
        }(n.GameObject);
    e.CarExplodeObject = l
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(4),
        a = function(t) {
            function e(e, i, s) {
                void 0 === s && (s = null);
                var a = t.call(this, e) || this;
                a.beginFill(i, 1), a.drawRect(0, 0, a.game.width, a.game.height), a.endFill(), e.add.group(a, "white", !0)
                    .add(a);
                var o = a.game.add.text(a.game.width / 2, a.game.height / 2, "LOADING...", n.Constants.styleCredits0);
                o.anchor.set(.5), a.addChild(o);
                var r = a.game.add.tween(a);
                return r.to({
                    alpha: 0
                }, 100), r.onComplete.add(function() {
                    null !== s && s()
                }), r.start(), a
            }
            return s(e, t), e
        }(Phaser.Graphics);
    e.default = a
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(8),
        n = i(0),
        a = function() {
            function t() {}
            return t.setTransform = function(t, e, i, s, n, a, o, r) {
                void 0 === n && (n = null), void 0 === a && (a = null), void 0 === o && (o = null), void 0 === r && (r = null), t.x = e, t.y = i, t.rotation = s, n && (t.pivot.x = n), a && (t.pivot.y = a), o && (t.scale.x = o), r && (t.scale.y = r)
            }, t.release = function() {
                for (var e in t.mapTexture)
                    if (t.mapTexture.hasOwnProperty(e)) {
                        var i = t.mapTexture[e];
                        i.destroy(!0)
                    } t.mapTexture = {}
            }, t.drawBitmapPath = function(e, i, s) {
                var n = s.length,
                    a = [],
                    o = 0,
                    r = null;
                for (o = 0; o < n; o++) a.push(new Phaser.Point(s[o].x, s[o].y));
                r = t.choosePic(e, a.slice()), i.addChild(r)
            }, t.drawBitmapPath2 = function(e, i, s) {
                var a = new Phaser.Image(n.GraphicUtil.game, -200, -200, n.GraphicUtil.currentAtlass, e + "0000"),
                    o = [];
                t.addPoints(s, a.width, o), t.drawOld(e, i, o)
            }, t.addPoints = function(t, e, i) {
                var n, a, o = t.length,
                    r = 0,
                    h = 0,
                    l = 0,
                    c = 0,
                    u = 0,
                    d = 0,
                    p = new s.Point;
                for (r = 0; r < o - 1; r++) n = t[r], a = t[r + 1], h += Phaser.Point.distance(n, a);
                for (l = h, i.push(new s.Point(t[0].x, t[0].y)); h > .15;) n = i[i.length - 1], a = t[d + 1], c = Phaser.Point.distance(n, a), c > e ? (u = e / c, c *= u, Phaser.Point.interpolate(n, a, u, p), i.push(new s.Point(p.x, p.y))) : (d++, i.push(new s.Point(t[d].x, t[d].y))), h -= c;
                return l
            }, t.choosePic = function(e, i) {
                if (void 0 === t.mapTexture[e]) {
                    var s = new Phaser.Image(n.GraphicUtil.game, 0, 0, n.GraphicUtil.currentAtlass, e + "0000"),
                        a = s.generateTexture();
                    s.visible = !1, t.mapTexture[e] = a
                }
                return n.GraphicUtil.game.add.rope(0, 0, t.mapTexture[e], null, i)
            }, t.drawOld = function(t, e, i) {
                var s, a, o = 0,
                    r = i.length,
                    h = 0,
                    l = null;
                for (h = 0; h < r && h !== r - 1; h++) {
                    s = i[h], a = i[h + 1];
                    var c = a.x - s.x,
                        u = a.y - s.y,
                        d = Math.atan(u / c);
                    c < 0 && (d += Math.PI), l = n.GraphicUtil.game.add.image(s.x, s.y, n.GraphicUtil.currentAtlass, t + "0000"), 0 === h && (o = d), l.anchor.set(0, .5), o = d, l.rotation = d, l.width = Math.sqrt(c * c + u * u), e.addChild(l)
                }
            }, t.mapTexture = {}, t
        }();
    e.Drawing = a
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.prototype.add = function(t) {}, t.prototype.release = function() {}, t.prototype.update = function(t) {}, t.prototype.updateGraphics = function() {}, t.prototype.start = function() {}, t
    }();
    e.GamePhysics = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.space.Space,
        a = i(42),
        o = i(19),
        r = function(t) {
            function e() {
                var i = t.call(this) || this;
                return e.space = new n, i
            }
            return s(e, t), e.prototype.start = function() {}, e.prototype.update = function(t) {
                e.space.step(.5 * t), e.space.step(.5 * t)
            }, e.prototype.updateGraphics = function() {
                for (var t = e.space.liveBodies.iterator(), i; t.hasNext();) {
                    var s = t.next(),
                        n = s.userData;
                    n.graphic ? (i = n.graphic, i.x = s.position.x, i.y = s.position.y, i.rotation = s.rotation % (2 * Math.PI)) : n.graphicEx && (i = n.graphicEx, i.x = s.position.x, i.y = s.position.y, i.rotation = s.rotation % (2 * Math.PI))
                }
            }, e.prototype.add = function(t) {
                null !== t.body.compound ? t.body.compound.space = e.space : t.body.space = e.space
            }, e.prototype.release = function() {
                for (t.prototype.release.call(this); !e.space.bodies.empty();) o.NapeUtil.disposeBody(e.space.bodies.at(0))
            }, e
        }(a.GamePhysics);
    e.NapePhysics = r
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(0),
        n = i(33),
        a = function() {
            function t() {
                this.object = null, this.car = null, this.tweening = !1
            }
            return t.prototype.setup = function(t, e, i, s) {
                this.maxScale = .45, this.tweening = !1, this.viewportW = e, this.viewportH = i, this.viewportHalfH = .5 * i, this.viewportHalfW = .5 * e, this.object = t, this.prevX = t.position.x, this.prevY = t.position.y, this.car = s, this.prevScale = t.scale.x, this.prevFrameH = i, n.CameraPathes.instance.tweened = !1, this.shakeX = 0, this.shakeY = 0
            }, t.prototype.hardFocusOnCar = function(e, i, s) {
                this.update(e + t.CAR_DX / s, i - 100, s, !1)
            }, t.prototype.shake = function() {
                var t = s.GraphicUtil.game.add.tween(this);
                t.to({
                    shakeX: 15,
                    shakeY: 15
                }, 100, Phaser.Easing.Bounce.InOut, !1, 0, 3, !0), t.start()
            }, t.prototype.shakeContainer = function(t) {
                void 0 === t && (t = null);
                var e = s.GraphicUtil.game.add.tween(t),
                    i = t.x,
                    n = t.y;
                e.to({
                    x: t.x - 10,
                    y: t.y - 10
                }, 15, Phaser.Easing.Bounce.InOut, !1, 0, 3, !0), e.onComplete.addOnce(function() {
                    t.x = i, t.y = n
                }, this), e.start()
            }, t.prototype.update = function(e, i, s, n) {
                void 0 === n && (n = !1);
                var a, o, r = 1;
                if (n) {
                    var h = .4;
                    this.prevX += .4 * (e - this.prevX), this.prevY += .4 * (i - this.prevY), r = this.prevScale + (s - this.prevScale), a = -this.prevX * r + this.viewportHalfW, o = -this.prevY * r + this.viewportHalfH
                } else r = s, a = -e * r + this.viewportHalfW, o = -i * r + this.viewportHalfH, this.prevX = e, this.prevY = i;
                this.prevScale = r, t.x = -a / r, t.y = -o / r, this.car.finished || this.updateObject(a + this.shakeX, o + this.shakeY, r), t.w = this.viewportW / r, t.h = this.viewportH / r
            }, t.prototype.updateObject = function(t, e, i) {
                this.object.scale.set(i), this.object.position.set(t, e)
            }, t.prototype.focusOnCar = function(e, i, s) {
                var a = n.CameraPathes.instance.getPathPointXY(e, i),
                    o = !1,
                    r = 1,
                    h = this.getFrameHBySpeed(s),
                    l, c;
                if (isNaN(a)) r = t.SCALE_MULT * this.viewportH / h, r < this.maxScale && (r = this.maxScale), l = e + t.CAR_DX / r, c = i - 100;
                else {
                    var u = 200,
                        d = a - i + 200;
                    d > h && (h = d), r = t.SCALE_MULT * this.viewportH / h, r < this.maxScale && (h = h * r / this.maxScale, r = this.maxScale, a = i - 200 + h), c = a - .5 * h, l = e + t.CAR_DX / r, o = n.CameraPathes.instance.tweened
                }
                o && (this.tweening = !0), this.update(l, c, r, this.tweening)
            }, t.prototype.focusOnCameraZone = function(t, e) {
                var i = s.CameraZone.current,
                    n = i.x,
                    a = i.y;
                i.move === s.CameraZone.HOR ? n = t < i.minMove ? i.minMove : t > i.maxMove ? i.maxMove : t : i.move === s.CameraZone.VER && (a = e < i.minMove ? i.minMove : e > i.maxMove ? i.maxMove : e), this.tweening = !0, this.update(n, a, i.scale, !0)
            }, t.prototype.focusOnPoint = function(t, e) {
                this.tweening = !0, this.update(t, e, 1, !0)
            }, t.prototype.getFrameHBySpeed = function(t) {
                var e = this.viewportH,
                    i = 500,
                    s = 3e3;
                if (t > 500) {
                    var n = this.viewportH;
                    t = t > 3e3 ? 3e3 : t;
                    e += (t - 500) / 2500 * n
                }
                var a = e - this.prevFrameH,
                    o = 2;
                return a < -2 ? e = this.prevFrameH - 2 : a > 8 && (e = this.prevFrameH + 8), this.prevFrameH = e, e
            }, t.prototype.release = function() {
                this.object = null, this.car = null
            }, t.inCamera = function(e, i, s) {
                return e > t.x - s && e < t.x + t.w + s && i > t.y - s && i < t.y + t.h + s
            }, t.CAR_DX = 150, t.SCALE_MULT = 1, t
        }();
    e.RaceCamera = a
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(34),
        n = i(18),
        a = i(14),
        o = function() {
            function t() {
                this.save = null, this.firstEnter = !1, this.inited = !1
            }
            return Object.defineProperty(t, "instance", {
                get: function() {
                    return null == t._instance && (t._instance = new t, t._instance.signalUnlock = new Phaser.Signal), t._instance
                },
                enumerable: !0,
                configurable: !0
            }), t.prototype.init = function() {
                if (!this.inited) {
                    this.inited = !0, this.save = {}, this.save.skin = 1;
                    var e = this.save[t.LAST_ENTER];
                    this.save[t.LAST_ENTER] = Date.now(), e || (this.firstEnter = !0), this.save[t.RACE_PREFIX + 1 + t.RACE_RESULT] = 0
                }
            }, t.prototype.reset = function() {
                this.inited = !1, this.init()
            }, t.prototype.setRaceResult = function(e, i, s) {
                var o = this.save[t.RACE_PREFIX + e.toString() + t.RACE_RESULT];
                if (!o) return 25 !== e && (this.save[t.RACE_PREFIX + (e + 1)
                    .toString() + t.RACE_RESULT] = 0), this.save[t.RACE_PREFIX + e.toString() + t.RACE_RESULT] = i, this.save[t.RACE_PREFIX + e.toString() + t.RACE_TIME] = s, !0;
                i > Number(o) && (this.save[t.RACE_PREFIX + e.toString() + t.RACE_RESULT] = i);
                var h = this.save[t.RACE_PREFIX + e.toString() + t.RACE_TIME];
                return s < parseFloat(h || 100500) && (this.save[t.RACE_PREFIX + e.toString() + t.RACE_TIME] = s, !0)
            }, t.prototype.setScore = function(e, i) {
                return this.save[t.RACE_PREFIX + e.toString() + t.RACE_SCORE] = i, this.getTotalScore()
            }, t.prototype.getTotalScore = function() {
                for (var e = 0, i = 0; i < s.RacesData.MAP_COUNT; i++) {
                    var n = t.RACE_PREFIX + (i + 1)
                        .toString() + t.RACE_SCORE;
                    void 0 !== this.save[n] && (e += this.save[n])
                }
                return e
            }, t.prototype.getTotalStars = function() {
                for (var e = 0, i = 0; i < s.RacesData.MAP_COUNT; i++) void 0 !== t.instance.save[t.RACE_PREFIX + (i + 1)
                    .toString() + t.RACE_RESULT] && (e += this.save[t.RACE_PREFIX + (i + 1)
                    .toString() + t.RACE_RESULT]);
                return e
            }, t.prototype.unlockAll = function() {
                for (var e = 1; e < 25; e++) this.save[t.RACE_PREFIX + e.toString() + t.RACE_RESULT] = 2;
                this.save[t.LAST_ENTER] = Date.now(), this.signalUnlock.dispatch()
            }, Object.defineProperty(t.prototype, "skin", {
                get: function() {
                    return this.save.skin
                },
                set: function(t) {
                    this.save.skin = t
                },
                enumerable: !0,
                configurable: !0
            }), t.LAST_ENTER = "l_e", t.RACE_PREFIX = "r_", t.RACE_RESULT = "_r", t.RACE_SCORE = "_s", t.RACE_TIME = "_t", t
        }();
    e.Inventory = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(0),
        n = function() {
            function t() {}
            return t.release = function() {
                t.paramsList.splice(0, t.paramsList.length);
                for (var e in t.geom) t.geom[e] && (t.geom[e] = null)
            }, t.EDITED = -1, t.paramsList = [], t.geom = {}, t.geomObj = {}, t.cars = new s.RaceCars, t.BASE_PHASE = 3, t.MAX_PARTS = 3, t.INVURNABLE_TIME = 2.5, t.DEAD_TIME = .5, t.FLIP = .5, t.WHEELIE_PART = .1, t.ITEM_MIN_DELAY = 0, t.ITEM_DELTA_DELAY = 0, t.BOMB_ITEM_DAMAGE = 2500, t.BOMB_ITEM_RADIUS = 32, t.RC_ITEM_DAMAGE = 2500, t.RC_ITEM_RADIUS = 32, t.prize_kill = 100, t.BOSSES = [3, 5, 7, 9], t.MAX_TORQUE_MULT = 3, t
        }();
    e.CarsData = n
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(3),
        o = i(1),
        r = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.create(), e
            }
            return s(e, t), e.get = function() {
                return e.pool.length > 0 ? e.pool.pop() : new e
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = o.ObjectTypes.LANDSCAPE, this.graphic = new n.TrailPart, this.active = !1, a.MaxGameCore.instance.add(this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.active && (this.graphic.update(t), this.graphic.isPlaying || this.remove())
            }, e.prototype.put = function(t, e) {
                this.graphic.x = t, this.graphic.y = e, this.graphic.visible = !0, this.active = !0, this.graphic.gotoAndPlay(0)
            }, e.prototype.remove = function() {
                this.active && (e.pool[e.pool.length] = this), this.active = !1, this.graphic.visible = !1
            }, e.prototype.restart = function() {
                this.remove()
            }, e.pool = [], e
        }(n.GameObject);
    e.TrailPartObject = r
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(6),
        a = i(2),
        o = function(t) {
            function e() {
                var e = t.call(this, n.GraphicUtil.game) || this;
                e.anim = null;
                var i = a.AssetsStorage.instance.getByKey("smoke_part"),
                    s = e.game.add.sprite(0, 0, n.GraphicUtil.currentAtlass, i + "0000");
                return s.animations.add(i, Phaser.Animation.generateFrameNames(i, 0, 28, "", 4)), s.anchor.set(.5), e.anim = s.animations.getAnimation(i), e.anim.play(30), e.anim.stop(), e.anim.onComplete.add(e.animationComplete, e), e.addChild(s), e.visible = !1, e
            }
            return s(e, t), e.prototype.update2 = function(t) {
                void 0 === t && (t = 0), this.anim.isPlaying && (this.x += this.velX * t, this.y += this.velY * t, this.velY += e.GRAVITY_Y * t)
            }, e.prototype.animationComplete = function() {
                this.visible = !1
            }, e.prototype.emit = function(t, i, s) {
                this.visible = !0, this.x = t, this.y = i, this.velX = e.BASE_VEL * Math.cos(s), this.velY = e.BASE_VEL * Math.sin(s), this.anim.play(30)
            }, e.GRAVITY_Y = -500, e.BASE_VEL = -50, e
        }(Phaser.Group);
    e.SmokePartClip = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(2),
        o = function(t) {
            function e() {
                var e = t.call(this, n.GraphicUtil.game) || this;
                e.anim = null;
                var i = a.AssetsStorage.instance.getByKey("ground_part"),
                    s = e.game.add.sprite(0, 0, n.GraphicUtil.currentAtlass, i + "0000");
                return s.animations.add(i, Phaser.Animation.generateFrameNames(i, 0, 28, "", 4)), s.anchor.set(.5), e.anim = s.animations.getAnimation(i), e.anim.play(30), e.anim.stop(), e.anim.onComplete.add(e.animationComplete, e), e.addChild(s), e.visible = !1, e
            }
            return s(e, t), e.prototype.update2 = function(t) {
                void 0 === t && (t = 0), this.anim.isPlaying && (this.x += this.velX * t, this.y += this.velY * t, this.velY += e.GRAVITY_Y * t)
            }, e.prototype.animationComplete = function() {
                this.visible = !1
            }, e.prototype.emit = function(t, e, i, s) {
                this.visible = !0, this.x = t, this.y = e, this.velX = i, this.velY = s, this.anim.play(30)
            }, e.GRAVITY_Y = 500, e
        }(Phaser.Group);
    e.GroundPartClip = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Ray,
        a = nape.geom.Vec2,
        o = nape.phys.Compound,
        r = i(0),
        h = i(3),
        l = i(10),
        c = i(4),
        u = i(26),
        d = i(45),
        p = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.LONG_FLY_TIME = .1, e.dampingDelta = .99, e._drive = !0, e.deadCounter = 0, e.ray = new n(a.weak(), a.weak(0, 1)), e.itemId = -1, e.accell = !1, e.smokeTimer = 0, e.wheelieTimer = 0, e.tilt = 0, e.deadCounter = 0, e.compound = new o, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.space = h.MaxGameCore.instance.getSpace(), this.setParams(t), this.finished = !1, this.boost = new r.BoostEffector(this.frame.body), this.boost.anim = this.frame.graphic.boostAnim, this.restart()
            }, e.prototype.setParams = function(t) {
                this.skinId = d.Inventory.instance.skin;
                var e;
                0 === t.wd ? (this.wdWheels = [this.backWheel.body], e = this.backWheel.body.shapes.at(0)
                    .radius) : 1 === t.wd ? (e = this.frontWheel.body.shapes.at(0)
                    .radius, this.wdWheels = [this.frontWheel.body]) : (this.wdWheels = [this.backWheel.body, this.frontWheel.body], e = Math.max(this.backWheel.body.shapes.at(0)
                    .radius, this.frontWheel.body.shapes.at(0)
                    .radius)), this.wheelRadius = e;
                var i = 2 * Math.PI * e,
                    s = t.maxSpeed / i;
                this.maxAngularVel = 2 * s * Math.PI, this.accelTorque = t.torque, t.maxTorque > t.torque ? this.deltaTorque = t.maxTorque - t.torque : this.deltaTorque = 0, this.tiltTorque = t.flipTorque, this.frame.maxFlipVel = this.maxTiltSpeed = t.maxFlipSpeed
            }, e.prototype.restart = function() {
                this.wheelieTimer = 0, this.accell = !1, this.safeId = -1, this.finished = !1, this.maxFlyAngle = this.minFlyAngle = this.startFlyAngle = this.rotation = this.frame.body.rotation, this.fallTime = this.flyTime = 0, this.frame.body.userData.handler = this, this.backWheel.body.userData.handler = this, this.frontWheel.body.userData.handler = this, this.frame.body.userData.graphic = this.frame.graphic, this.backWheel.body.userData.graphicEx = this.backWheel.graphic, this.frontWheel.body.userData.graphicEx = this.frontWheel.graphic, this._drive = !0, this._deadDelay = 0, this.dead = !1, this.itemId = -1, this.setVisible(!0), this.setAlpha(1), this.review(), this.compound.space = this.space
            }, e.prototype.release = function() {
                this.space = null, this.compound.space = null, this.compound = null, this.frame = null, this.backWheel = null, this.frontWheel = null, this.callbackFinish = null, this.callbackDie = null, this.callbackStunt = null, this.callbackFight = null, this.suspendBack = null, this.suspendBackLocal && this.suspendBackLocal.dispose(), this.suspendBackLocal = null, this.suspendFront = null, this.boost.dispose(), this.boost = null, t.prototype.release.call(this)
            }, Object.defineProperty(e.prototype, "drive", {
                get: function() {
                    return this._drive
                },
                set: function(t) {
                    t && !this._drive && (this.frontWheel.startSpin(), this.backWheel.startSpin()), this._drive = t
                },
                enumerable: !0,
                configurable: !0
            }), e.prototype.addBoost = function(t, e) {
                this.boost.add(t, e)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.dead && this.driver ? (this.x = this.driver.parts[0].body.position.x, this.y = this.driver.parts[0].body.position.y) : (this.x = this.frame.body.position.x, this.y = this.frame.body.position.y), this.rotation = this.frame.body.rotation;
                var i = this.speed;
                this.speed = this.frame.body.velocity.length, this.speedV = this.frame.body.velocity.y, this.hasGround = this.frame.hasGround || this.backWheel.hasGround || this.frontWheel.hasGround, this.hasGround ? (this.flyTime > this.LONG_FLY_TIME && (this.processLand(), i > 500 && l.default.getInstance()
                    .play(c.Sounds.Landing)), this.flyTime = 0, this.fallTime = 0) : (0 === this.flyTime && (this.maxFlyAngle = this.minFlyAngle = this.startFlyAngle = this.rotation), this.rotation > this.maxFlyAngle ? this.maxFlyAngle = this.rotation : this.rotation < this.minFlyAngle && (this.minFlyAngle = this.rotation), this.flyTime += t, this.speedV > 0 ? this.fallTime += t : this.fallTime = 0);
                var s;
                if (this._drive) {
                    var n = this.controller.getDrive();
                    if (this.applyDrive(t, !1, n), this.finished) this.applyTilt(t, 0);
                    else {
                        var a = this.controller.getTilt();
                        this.applyTilt(t, a)
                    }
                    if (5 !== this.skinId && (this.controller.accell ? this.smokeTimer -= 2 * t : this.smokeTimer -= t, this.smokeTimer <= 0)) {
                        this.smokeTimer += e.SMOKE_TIME, s = this.frame.graphic;
                        var o = this.frame.body.localPointToWorld(this.frame.localSmokePos),
                            h = .1 * Math.PI;
                        this.controller.accell ? (s.emitSmoke(o.x, o.y, this.rotation - .5 * h + Math.random() * h), s.emitSmoke(o.x, o.y, this.rotation - .1 * Math.PI + .5 * h + Math.random() * h), s.emitSmoke(o.x, o.y, this.rotation + .1 * Math.PI + .5 * h + Math.random() * h), o.dispose()) : (s.emitSmoke(o.x, o.y, this.rotation - .5 * h + Math.random() * h), o.dispose())
                    }
                    this.updateWheelie(t)
                } else this._deadDelay > 0 && (this._deadDelay -= t, this._deadDelay <= 0 && 9 !== this.skinId && (this._drive = !0, this._deadDelay = 0, this.dead = !1, this.setVisible(!0), this.compound.space = this.space)), this.finished && (this.frontWheel.body.angularVel *= .8, this.backWheel.body.angularVel *= .8);
                if (this.suspendBack) {
                    var u = this.frame.body.localPointToWorld(this.suspendBackLocal),
                        d = this.backWheel.body.position.sub(u);
                    r.Drawing.setTransform(this.suspendBack.graphic, u.x, u.y, d.angle, NaN, NaN, d.length / this.suspendBackW, 1), d.dispose(), u.dispose()
                }
                this.suspendFront && (this.suspendFront.graphic.x = this.frontWheel.body.position.x, this.suspendFront.graphic.y = this.frontWheel.body.position.y, this.suspendFront.graphic.rotation = (this.suspendFrontAngle + this.frame.body.rotation) % (2 * Math.PI)), this.driver.head && (this.driver.head.trail && this.driver.head.trail.emit(this.driver.head.body.position.x, this.driver.head.body.position.y), this.driver.head.update(t))
            }, e.prototype.updateWheelie = function(t) {
                h.MaxGameCore.instance.finished || (this.hasGround ? this.frame.hasGround ? this.wheelieTimer > 0 && this.wheelieComplete() : this.backWheel.hasGround && !this.frontWheel.hasGround || !this.backWheel.hasGround && this.frontWheel.hasGround ? (this.wheelieTimer += t, this.wheelieTimer > 1 && this.callbackWheelie && this.callbackWheelie(this.wheelieTimer, !1)) : this.wheelieTimer > 0 && this.wheelieComplete() : this.wheelieTimer > 0 && this.wheelieComplete())
            }, e.prototype.wheelieComplete = function() {
                this.wheelieTimer > 1 && this.callbackWheelie && this.callbackWheelie(this.wheelieTimer, !0), this.wheelieTimer = 0
            }, e.prototype.setAlpha = function(t) {
                this.frame.graphic.alpha = this.backWheel.graphic.alpha = this.frontWheel.graphic.alpha = t
            }, e.prototype.processLand = function() {
                if (!h.MaxGameCore.instance.finished) {
                    if (!this.dead && (this.backWheel.hasGround || this.frontWheel.hasGround)) {
                        var t = void 0,
                            e = Math.PI;
                        t = this.startFlyAngle - this.minFlyAngle;
                        var i = t / (2 * Math.PI) >> 0;
                        t -= 2 * i * Math.PI, t >= e && i++;
                        var s = i;
                        t = this.maxFlyAngle - this.startFlyAngle, i = t / (2 * Math.PI) >> 0, t -= 2 * i * Math.PI, t >= e && i++;
                        var n = i;
                        s > 0 && this.callbackStunt && this.callbackStunt.call(this.callbackContext, s, !0), n > 0 && this.callbackStunt && this.callbackStunt.call(this.callbackContext, n, !1)
                    }
                    this.startFlyAngle = this.maxFlyAngle = this.minFlyAngle = this.rotation
                }
            }, e.prototype.applyDrive = function(t, e, i) {
                var s = !1,
                    n = !1;
                this.finished || (1 === i ? s = !0 : -1 === i && (n = !0));
                var a = this.accelTorque,
                    o = this.maxAngularVel;
                if (this.deltaTorque > 0 && (s || n)) {
                    var r = this.speed / this.wheelRadius;
                    if (r < o) {
                        var h = void 0,
                            l = .5,
                            c = 2.5,
                            u = 1 / 9,
                            d = 4,
                            p = .5 + 2.5 * r / o;
                        h = (1 / (p * p) - 1 / 9) / (4 - 1 / 9), a = this.accelTorque + h * this.deltaTorque
                    }
                }
                this.frontWheel.brake(n), this.backWheel.brake(n);
                for (var f = this.wdWheels.length, g = o, y = 0; y < f; y++) {
                    var m = this.wdWheels[y];
                    this.finished ? m.angularVel *= .8 : (s ? (m.angularVel < 0 && (m.angularVel *= .5), m.angularVel < o && m.applyAngularImpulse(t * a / f)) : n ? (m.angularVel > 0 && (m.angularVel *= .5), m.angularVel > -o && m.applyAngularImpulse(-t * a / f)) : e || (m.angularVel *= this.dampingDelta), Math.abs(m.angularVel) < g && (g = Math.abs(m.angularVel)))
                }
            }, e.prototype.applyTilt = function(t, e) {
                this.tilt = e;
                var i = this.frame.body;
                i.torque = e * this.tiltTorque;
                var s = i.angularVel;
                if (s < 0 && s < -this.maxTiltSpeed ? i.angularVel = -this.maxTiltSpeed : s > 0 && s > this.maxTiltSpeed && (i.angularVel = this.maxTiltSpeed), this.driver) {
                    var n = e;
                    if (0 === n)
                        if (this.hasGround) this.controller.accell && (n = -1);
                        else {
                            var a = this.frame.body.velocity.y;
                            a < -20 ? n = 1 : a > 20 && (n = -1)
                        } this.driver.move(e, n)
                }
            }, e.prototype.setReviewPos = function(t, e, i) {
                this.safeId = i, this.frame.body.userData.reviewX = t, this.frame.body.userData.reviewY = e
            }, e.prototype.review = function() {
                h.MaxGameCore.instance.stopAllSounds(), u.default.loadedLevel && (h.MaxGameCore.instance.engineStart = l.default.getInstance()
                    .play(c.Sounds.Start)), this.wheelieTimer = 0, this.backWheel.connect(!1), this.frontWheel.connect(!1), this.driver.connectDriver(!1), this.driver.connect(!1), r.NapeUtil.stopBody(this.frame.body), r.NapeUtil.stopBody(this.backWheel.body), r.NapeUtil.stopBody(this.frontWheel.body), this.driver.stop(), this.frame.review(), this.startFlyAngle = this.maxFlyAngle = this.minFlyAngle = this.rotation = this.frame.body.rotation;
                var t = a.get(-this.frame.wheelBackDx, this.frame.wheelDy),
                    e = this.frame.body.localPointToWorld(t);
                this.backWheel.body.position.set(e), e.dispose(), t.setxy(this.frame.wheelFrontDx, this.frame.wheelDy), e = this.frame.body.localPointToWorld(t), this.frontWheel.body.position.set(e), e.dispose(), t.dispose(), this.driver.review(this.frame.body.position), this.backWheel.connect(!0), this.frontWheel.connect(!0), this.driver.connectDriver(!0), this.driver.connect(!0), this.driver.activateMirrorParts(!1), this.dead = !1, this._drive = !0, this.boost.restart()
            }, e.prototype.setVisible = function(t) {
                this.frame.graphic.visible = this.backWheel.graphic.visible = this.frontWheel.graphic.visible = t
            }, e.prototype.processFinish = function(t) {
                this.wheelieComplete(), this._drive = !1, this.finished = !0, this.applyTilt(0, 0), h.MaxGameCore.instance.processFinish()
            }, e.SMOKE_TIME = .2, e
        }(r.GameObject);
    e.CarObject = p
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(5),
        r = i(2),
        h = function(t) {
            function e(e) {
                var i = t.call(this) || this;
                return i.type = e ? a.ObjectTypes.LANDSCAPE : a.ObjectTypes.FRONT, i
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = t.className;
                0 !== n.RacesData.map.settings.theme && 2 !== n.RacesData.map.settings.theme || (this.type = a.ObjectTypes.LANDSCAPE_BACK, 0 === e.indexOf("Dec") && (2 === n.RacesData.map.settings.theme || Number(e.slice(3, e.length)) <= 7 && (this.type = a.ObjectTypes.FRONT)));
                var i = e.indexOf("_dup");
                i >= 0 && (e = e.substring(0, i));
                var s = r.AssetsStorage.instance.getByKey(e);
                if (s) {
                    var h = s + "0000";
                    this.graphic = n.GraphicUtil.game.add.sprite(0, 0, n.GraphicUtil.currentAtlass, h), n.Drawing.setTransform(this.graphic, t.params.x, t.params.y, o.default.TO_RAD * t.params.rotation, 0, 0, t.params.scaleX, t.params.scaleY), this.graphic.anchor.set(.5), 0 === h.indexOf("Sign") && "SignPillar0000" !== h && (this.type = a.ObjectTypes.LANDSCAPE)
                }
            }, e
        }(n.GameObject);
    e.DecorObject = h
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(6),
        r = i(3),
        h = i(2),
        l = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.create(), e
            }
            return s(e, t), e.get = function() {
                return e.pool.length > 0 ? e.pool.pop() : new e
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = a.ObjectTypes.EFFECT, this.graphic = o.GraphicUtil.createMovieClip(null, h.AssetsStorage.instance.getByKey("glass_exp_anim"), 30, !1), this.graphic.completeCallback = this.animComplete, this.graphic.scaleX = this.graphic.scaleY = 2, this.graphic.visible = !1, r.MaxGameCore.instance.add(this)
            }, e.prototype.animComplete = function(t) {
                this.active = !1, this.graphic.visible = !1, null != this.completeCallback && (this.completeCallback(), this.completeCallback = null), e.pool[e.pool.length] = this
            }, e.prototype.activate = function(t, e, i) {
                void 0 === i && (i = null), this.active = !0, this.graphic.x = t, this.graphic.y = e, this.graphic.visible = !0, this.completeCallback = i
            }, e.prototype.restart = function() {
                this.active && (this.graphic.visible = !1, this.active = !1, this.completeCallback = null, e.pool[e.pool.length] = this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.active && this.graphic.update(t)
            }, e.prototype.release = function() {
                this.completeCallback = null, t.prototype.release.call(this)
            }, e.pool = [], e
        }(n.GameObject);
    e.GlassExplodeObject = l
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(6),
        h = i(7),
        l = i(2),
        c = function(t) {
            function e(e, i) {
                var s = t.call(this) || this;
                return s.id = e, s.parentKey = i, s
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = o.ObjectTypes.LANDSCAPE;
                var e = l.AssetsStorage.instance,
                    i = this.parentKey + this.id.toString();
                this.graphic = r.GraphicUtil.createImage(0, 0, 0, e.getByKey(i)), this.body = a.NapeUtil.createCircleBody(n.DYNAMIC, h.Filters.NOTHING, !1, 4), this.body.userData.graphicEx = this.graphic
            }, e.prototype.restart = function() {
                this.killTweenLite(), this.body.space = null, this.graphic.visible = !1
            }, e.prototype.release = function() {
                this.killTweenLite(), t.prototype.release.call(this)
            }, e.prototype.activate = function(t, e, i) {
                this.killTweenLite(), a.NapeUtil.stopBody(this.body);
                var s = r.GraphicUtil.game.add.group();
                this.tweenLite = r.GraphicUtil.game.add.tween(s), this.tweenLite.to({
                    x: 100
                }, 5e3), this.tweenLite.start(), this.tweenLite.onComplete.addOnce(this.deactivate), this.body.position = t, this.body.rotation = e, this.body.space = a.NapePhysics.space, this.graphic.scaleX = i, this.graphic.visible = !0
            }, e.prototype.killTweenLite = function() {
                this.tweenLite && (this.tweenLite.onComplete.removeAll(), this.tweenLite = null)
            }, e.prototype.deactivate = function() {
                this.restart()
            }, e
        }(a.GameObject);
    e.GlassBlockPart = c
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.geom.GeomPoly,
        n = nape.geom.GeomPolyList,
        a = nape.geom.Vec2,
        o = nape.phys.Body,
        r = nape.phys.BodyType,
        h = nape.shape.Polygon,
        l = i(5),
        c = i(0),
        u = function() {
            function t() {}
            return t.createGroundBody = function(e) {
                var i = e.params.x,
                    s = e.params.y,
                    n = e.params.vertices,
                    h = n.length,
                    u = NaN,
                    d = NaN,
                    p = null != e.params.thick ? e.params.thick : 128,
                    f = e.params.direction * l.default.TO_RAD,
                    g = e.params.directed,
                    y = c.Materials.GROUND,
                    m = new o(r.STATIC, a.weak(i, s));
                m.cbTypes.add(c.CbTypes.GROUND);
                var v, b = n[0];
                v = [b];
                for (var x, _ = 1; _ < h; _++) {
                    b = n[_];
                    var w = v[v.length - 1],
                        C = v.length;
                    if (1 === C) v[C] = b, x = a.weak(b.x - w.x, b.y - w.y)
                        .angle, isNaN(u) && (u = x + .5 * Math.PI);
                    else {
                        var P = a.weak(b.x - w.x, b.y - w.y)
                            .angle;
                        if (l.default.normalizeAngle(P - x) < 0) {
                            if (!g) {
                                var T = a.fromPolar(1, x),
                                    S = a.fromPolar(1, P);
                                d = T.sub(S, !0)
                                    .angle, T.dispose(), S.dispose()
                            }
                            t.addGroundShape(m, v, f, g, u, d, y, p), u = d, v = [w, b]
                        } else v[v.length] = b;
                        x = P
                    }
                }
                return t.addGroundShape(m, v, f, g, u, x + .5 * Math.PI, y, p), 0 === m.shapes.length ? null : (m.align(), m)
            }, t.addGroundShape = function(e, i, n, o, r, l, u, d) {
                var p = [],
                    f = i.length,
                    g;
                for (g = 0; g < f; g++) {
                    var y = i[g];
                    if (null === y) return;
                    var m = a.get(y.x, y.y);
                    0 === g && (p[p.length] = o ? a.get(m.x + Math.cos(n) * d, m.y + Math.sin(n) * d) : a.get(m.x + Math.cos(r) * d, m.y + Math.sin(r) * d)), p[p.length] = m, g === f - 1 && (p[p.length] = o ? a.get(m.x + Math.cos(n) * d, m.y + Math.sin(n) * d) : a.get(m.x + Math.cos(l) * d, m.y + Math.sin(l) * d))
                }
                var v = s.get(p),
                    b;
                if (v.isConvex()) b = new h(p, u, c.Filters.GROUND), e.shapes.add(b);
                else
                    for (v.convexDecomposition(!1, t.geomPolyList); !t.geomPolyList.empty();) v = t.geomPolyList.pop(), v.isConvex() && (b = new h(v, u, c.Filters.GROUND), e.shapes.add(b));
                for (v.dispose(), f = p.length, g = 0; g < f; g++) p[g].dispose();
                e.userData.isGround = !0
            }, t.geomPolyList = new n, t
        }();
    e.PhysicUtil = u
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(7),
        h = i(5),
        l = i(6),
        c = i(11),
        u = i(9),
        d = i(3),
        p = i(2),
        f = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.activeOnStart = !0, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = o.ObjectTypes.OBJECT, null !== t.params.id && (this.id = t.params.id), this.safeId = t.params.safeId;
                var i = p.AssetsStorage.instance,
                    s = t.className,
                    d = i.getByKey(s + "_data"),
                    f = t.params,
                    g = f.x,
                    y = f.y,
                    m = t.params.rotation * h.default.TO_RAD,
                    v = r.Filters.GROUND;
                "reg" === d.shape ? this.body = a.NapeUtil.createRegularBody(n.DYNAMIC, v, !1, d.w, d.h, 8, g, y, m, null, u.Materials.DEFAULT) : "rect" === d.shape ? this.body = a.NapeUtil.createRectBodyWH(n.DYNAMIC, v, !1, d.w, d.h, g, y, m, null, u.Materials.DEFAULT) : "circ" === d.shape && (this.body = a.NapeUtil.createCircleBody(n.DYNAMIC, v, !1, .5 * d.w, g, y, m, null, u.Materials.DEFAULT));
                var b = s.indexOf("Candy") > 0 || s.indexOf("Bone") > 0;
                this.graphic = b ? l.GraphicUtil.createImageWithObj(f, i.getByKey(e.CANDIES[e.CANDIES_COUNT * Math.random() >> 0])) : l.GraphicUtil.createImageWithObj(f, i.getByKey(s)), a.NapeUtil.setupStartPos(this.body), this.body.userData.graphicEx = this.graphic, s.indexOf("Barrel") >= 0 && this.body.cbTypes.add(c.CbTypes.BARREL), 0 === s.indexOf("Removed") && this.body.cbTypes.add(c.CbTypes.WOOD), (b || 0 === s.indexOf("Plank")) && (this.body.userData.isGround = !0, b && (this.body.userData.isPT = !0)), !1 === t.params.active ? this.activeOnStart = !1 : this.activeOnStart = !0
            }, e.prototype.restart = function() {
                a.NapeUtil.stopBody(this.body), a.NapeUtil.resetStartPos(this.body), this.activeOnStart || (this.graphic.x = this.body.position.x, this.graphic.y = this.body.position.y, this.graphic.rotation = this.body.rotation, this.activate(!1))
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0);
                var e, i;
                if (t)
                    for (this.body.space = d.MaxGameCore.instance.getSpace(), e = this.body.constraints.iterator(); e.hasNext();) i = e.next(), i.active = !0;
                else {
                    for (e = this.body.constraints.iterator(); e.hasNext();) i = e.next(), i.active = !1, i.userData.skipActive = !0;
                    this.body.space = null
                }
            }, e.prototype.isActive = function() {
                return this.activeOnStart
            }, e.CANDIES = ["PlankBone", "PlankCandy", "PlankCandy0", "PlankCandy1"], e.CANDIES_COUNT = 4, e
        }(a.GameObject);
    e.DynamicBodyObject = f
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t(t) {
            this.accell = !1, this.brake = !1, this.car = t
        }
        return t.prototype.getBoost = function() {
            return !1
        }, t.prototype.getDrive = function() {
            return 0
        }, t.prototype.getTilt = function() {
            return 0
        }, t.prototype.getUseItem = function() {
            return !1
        }, t.prototype.dispose = function() {
            this.car = null
        }, t
    }();
    e.CarController = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(58), i(12), i(8);
    var n = i(63),
        a = i(64),
        o = i(32),
        r = i(127),
        h = i(37),
        l = i(14),
        c;
    ! function(t) {
        var e = function(t) {
            function e() {
                var e = t.call(this, {
                    enableDebug: !1,
                    width: 720,
                    height: 480,
                    renderer: Phaser.WEBGL,
                    parent: "content",
                    transparent: !0,
                    antialias: !0,
                    preserveDrawingBuffer: !1,
                    physicsConfig: null,
                    seed: "",
                    state: null,
                    forceSetTimeOut: !1
                }) || this;
                return e.state.add("game", {
                    create: e.stateCreator.bind(e),
                    preload: e.statePreloader.bind(e)
                }, !0), e
            }
            return s(e, t), e.prototype.statePreloader = function() {
                var t = this;
                ["../../cdn.jsdelivr.net-npm-@orange-games-phaser-cachebuster@2.0-build-phaser-cachebuster.min.js", "../../cdn.jsdelivr.net-npm-@orange-games-phaser-super-storage@1.0-build-phaser-super-storage.min.js", "assets/box2dweb/dragonBones.min.js"].forEach(function(e) {
                    t.load.script(e, e)
                })
            }, e.prototype.stateCreator = function() {
                var t = this;
                this.plugins.add(PhaserSuperStorage.StoragePlugin), this.plugins.add(PhaserCachebuster.CacheBuster), this.storage.forcePromises = !0, this.state.add(a.Boot.Name, a.Boot, !1), this.state.add(o.default.Name, o.default, !1), this.state.add(r.default.Name, r.default, !1), this.state.add(a.Menu.Name, a.Menu, !1), this.state.add(a.Garage.Name, a.Garage, !1), this.state.add(a.ChooseZone.Name, a.ChooseZone, !1), this.state.add(a.Gameplay.Name, a.Gameplay, !1);
                var e = function() {
                    t.recursiveUpdateText(t.stage)
                };
                n.load({
                    custom: {
                        families: ["Aller Display", "CfCrackBold", "Impact"],
                        urls: ["assets/css/AllerDisplay.css", "assets/css/CfCrackBold.css", "assets/css/impact.css"]
                    },
                    active: e,
                    inactive: e
                }), this.state.start(a.Boot.Name), this.state.remove("game")
            }, e.prototype.recursiveUpdateText = function(t) {
                var e = this;
                t instanceof Phaser.Text && (t.dirty = !0), t.children && t.children.length > 0 && t.children.forEach(function(t) {
                    e.recursiveUpdateText(t)
                })
            }, e.prototype.adsResume = function() {
                this.sound.mute = !1, a.Gameplay.isAdsPause = !1
            }, e.prototype.adsPause = function() {
                this.sound.mute = !0, a.Gameplay.isAdsPause = !0, h.default.instance.signalPause && h.default.instance.signalPause.dispatch()
            }, e
        }(Phaser.Game);
        t.Game = e
    }(c || (c = {})), new c.Game
}, function(t, e, i) {
    (function(e) {
        t.exports = e.p2 = i(59)
    })
    .call(e, i(29))
}, function(t, e, i) {
    var s, s;
    ! function(e) {
        var i;
        t.exports = e()
    }(function() {
        var t, e, i;
        return function t(e, i, n) {
            function a(r, h) {
                if (!i[r]) {
                    if (!e[r]) {
                        var l = "function" == typeof s && s;
                        if (!h && l) return s(r, !0);
                        if (o) return o(r, !0);
                        throw new Error("Cannot find module '" + r + "'")
                    }
                    var c = i[r] = {
                        exports: {}
                    };
                    e[r][0].call(c.exports, function(t) {
                        var i = e[r][1][t];
                        return a(i || t)
                    }, c, c.exports, t, e, i, n)
                }
                return i[r].exports
            }
            for (var o = "function" == typeof s && s, r = 0; r < n.length; r++) a(n[r]);
            return a
        }({
            1: [function(t, e, i) {
                function s() {}
                var n = t("./Scalar");
                e.exports = s, s.lineInt = function(t, e, i) {
                    i = i || 0;
                    var s = [0, 0],
                        a, o, r, h, l, c, u;
                    return a = t[1][1] - t[0][1], o = t[0][0] - t[1][0], r = a * t[0][0] + o * t[0][1], h = e[1][1] - e[0][1], l = e[0][0] - e[1][0], c = h * e[0][0] + l * e[0][1], u = a * l - h * o, n.eq(u, 0, i) || (s[0] = (l * r - o * c) / u, s[1] = (a * c - h * r) / u), s
                }, s.segmentsIntersect = function(t, e, i, s) {
                    var n = e[0] - t[0],
                        a = e[1] - t[1],
                        o = s[0] - i[0],
                        r = s[1] - i[1];
                    if (o * a - r * n == 0) return !1;
                    var h = (n * (i[1] - t[1]) + a * (t[0] - i[0])) / (o * a - r * n),
                        l = (o * (t[1] - i[1]) + r * (i[0] - t[0])) / (r * n - o * a);
                    return h >= 0 && h <= 1 && l >= 0 && l <= 1
                }
            }, {
                "./Scalar": 4
            }],
            2: [function(t, e, i) {
                function s() {}
                e.exports = s, s.area = function(t, e, i) {
                    return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1])
                }, s.left = function(t, e, i) {
                    return s.area(t, e, i) > 0
                }, s.leftOn = function(t, e, i) {
                    return s.area(t, e, i) >= 0
                }, s.right = function(t, e, i) {
                    return s.area(t, e, i) < 0
                }, s.rightOn = function(t, e, i) {
                    return s.area(t, e, i) <= 0
                };
                var n = [],
                    a = [];
                s.collinear = function(t, e, i, o) {
                    if (o) {
                        var r = n,
                            h = a;
                        r[0] = e[0] - t[0], r[1] = e[1] - t[1], h[0] = i[0] - e[0], h[1] = i[1] - e[1];
                        var l = r[0] * h[0] + r[1] * h[1],
                            c = Math.sqrt(r[0] * r[0] + r[1] * r[1]),
                            u = Math.sqrt(h[0] * h[0] + h[1] * h[1]);
                        return Math.acos(l / (c * u)) < o
                    }
                    return 0 == s.area(t, e, i)
                }, s.sqdist = function(t, e) {
                    var i = e[0] - t[0],
                        s = e[1] - t[1];
                    return i * i + s * s
                }
            }, {}],
            3: [function(t, e, i) {
                function s() {
                    this.vertices = []
                }

                function n(t, e, i, s, n) {
                    n = n || 0;
                    var a = e[1] - t[1],
                        o = t[0] - e[0],
                        h = a * t[0] + o * t[1],
                        l = s[1] - i[1],
                        c = i[0] - s[0],
                        u = l * i[0] + c * i[1],
                        d = a * c - l * o;
                    return r.eq(d, 0, n) ? [0, 0] : [(c * h - o * u) / d, (a * u - l * h) / d]
                }
                var a = t("./Line"),
                    o = t("./Point"),
                    r = t("./Scalar");
                e.exports = s, s.prototype.at = function(t) {
                    var e = this.vertices,
                        i = e.length;
                    return e[t < 0 ? t % i + i : t % i]
                }, s.prototype.first = function() {
                    return this.vertices[0]
                }, s.prototype.last = function() {
                    return this.vertices[this.vertices.length - 1]
                }, s.prototype.clear = function() {
                    this.vertices.length = 0
                }, s.prototype.append = function(t, e, i) {
                    if (void 0 === e) throw new Error("From is not given!");
                    if (void 0 === i) throw new Error("To is not given!");
                    if (i - 1 < e) throw new Error("lol1");
                    if (i > t.vertices.length) throw new Error("lol2");
                    if (e < 0) throw new Error("lol3");
                    for (var s = e; s < i; s++) this.vertices.push(t.vertices[s])
                }, s.prototype.makeCCW = function() {
                    for (var t = 0, e = this.vertices, i = 1; i < this.vertices.length; ++i)(e[i][1] < e[t][1] || e[i][1] == e[t][1] && e[i][0] > e[t][0]) && (t = i);
                    o.left(this.at(t - 1), this.at(t), this.at(t + 1)) || this.reverse()
                }, s.prototype.reverse = function() {
                    for (var t = [], e = 0, i = this.vertices.length; e !== i; e++) t.push(this.vertices.pop());
                    this.vertices = t
                }, s.prototype.isReflex = function(t) {
                    return o.right(this.at(t - 1), this.at(t), this.at(t + 1))
                };
                var h = [],
                    l = [];
                s.prototype.canSee = function(t, e) {
                    var i, s, n = h,
                        r = l;
                    if (o.leftOn(this.at(t + 1), this.at(t), this.at(e)) && o.rightOn(this.at(t - 1), this.at(t), this.at(e))) return !1;
                    s = o.sqdist(this.at(t), this.at(e));
                    for (var c = 0; c !== this.vertices.length; ++c)
                        if ((c + 1) % this.vertices.length !== t && c !== t && o.leftOn(this.at(t), this.at(e), this.at(c + 1)) && o.rightOn(this.at(t), this.at(e), this.at(c)) && (n[0] = this.at(t), n[1] = this.at(e), r[0] = this.at(c), r[1] = this.at(c + 1), i = a.lineInt(n, r), o.sqdist(this.at(t), i) < s)) return !1;
                    return !0
                }, s.prototype.copy = function(t, e, i) {
                    var n = i || new s;
                    if (n.clear(), t < e)
                        for (var a = t; a <= e; a++) n.vertices.push(this.vertices[a]);
                    else {
                        for (var a = 0; a <= e; a++) n.vertices.push(this.vertices[a]);
                        for (var a = t; a < this.vertices.length; a++) n.vertices.push(this.vertices[a])
                    }
                    return n
                }, s.prototype.getCutEdges = function() {
                    for (var t = [], e = [], i = [], n = new s, a = Number.MAX_VALUE, o = 0; o < this.vertices.length; ++o)
                        if (this.isReflex(o))
                            for (var r = 0; r < this.vertices.length; ++r)
                                if (this.canSee(o, r)) {
                                    e = this.copy(o, r, n)
                                        .getCutEdges(), i = this.copy(r, o, n)
                                        .getCutEdges();
                                    for (var h = 0; h < i.length; h++) e.push(i[h]);
                                    e.length < a && (t = e, a = e.length, t.push([this.at(o), this.at(r)]))
                                } return t
                }, s.prototype.decomp = function() {
                    var t = this.getCutEdges();
                    return t.length > 0 ? this.slice(t) : [this]
                }, s.prototype.slice = function(t) {
                    if (0 == t.length) return [this];
                    if (t instanceof Array && t.length && t[0] instanceof Array && 2 == t[0].length && t[0][0] instanceof Array) {
                        for (var e = [this], i = 0; i < t.length; i++)
                            for (var s = t[i], n = 0; n < e.length; n++) {
                                var a = e[n],
                                    o = a.slice(s);
                                if (o) {
                                    e.splice(n, 1), e.push(o[0], o[1]);
                                    break
                                }
                            }
                        return e
                    }
                    var s = t,
                        i = this.vertices.indexOf(s[0]),
                        n = this.vertices.indexOf(s[1]);
                    return -1 != i && -1 != n && [this.copy(i, n), this.copy(n, i)]
                }, s.prototype.isSimple = function() {
                    for (var t = this.vertices, e = 0; e < t.length - 1; e++)
                        for (var i = 0; i < e - 1; i++)
                            if (a.segmentsIntersect(t[e], t[e + 1], t[i], t[i + 1])) return !1;
                    for (var e = 1; e < t.length - 2; e++)
                        if (a.segmentsIntersect(t[0], t[t.length - 1], t[e], t[e + 1])) return !1;
                    return !0
                }, s.prototype.quickDecomp = function(t, e, i, a, r, h) {
                    r = r || 100, h = h || 0, a = a || 25, t = void 0 !== t ? t : [], e = e || [], i = i || [];
                    var l = [0, 0],
                        c = [0, 0],
                        u = [0, 0],
                        d = 0,
                        p = 0,
                        f = 0,
                        g = 0,
                        y = 0,
                        m = 0,
                        v = 0,
                        b = new s,
                        x = new s,
                        _ = this,
                        w = this.vertices;
                    if (w.length < 3) return t;
                    if (++h > r) return t;
                    for (var C = 0; C < this.vertices.length; ++C)
                        if (_.isReflex(C)) {
                            e.push(_.vertices[C]), d = p = Number.MAX_VALUE;
                            for (var P = 0; P < this.vertices.length; ++P) o.left(_.at(C - 1), _.at(C), _.at(P)) && o.rightOn(_.at(C - 1), _.at(C), _.at(P - 1)) && (u = n(_.at(C - 1), _.at(C), _.at(P), _.at(P - 1)), o.right(_.at(C + 1), _.at(C), u) && (f = o.sqdist(_.vertices[C], u)) < p && (p = f, c = u, m = P)), o.left(_.at(C + 1), _.at(C), _.at(P + 1)) && o.rightOn(_.at(C + 1), _.at(C), _.at(P)) && (u = n(_.at(C + 1), _.at(C), _.at(P), _.at(P + 1)), o.left(_.at(C - 1), _.at(C), u) && (f = o.sqdist(_.vertices[C], u)) < d && (d = f, l = u, y = P));
                            if (m == (y + 1) % this.vertices.length) u[0] = (c[0] + l[0]) / 2, u[1] = (c[1] + l[1]) / 2, i.push(u), C < y ? (b.append(_, C, y + 1), b.vertices.push(u), x.vertices.push(u), 0 != m && x.append(_, m, _.vertices.length), x.append(_, 0, C + 1)) : (0 != C && b.append(_, C, _.vertices.length), b.append(_, 0, y + 1), b.vertices.push(u), x.vertices.push(u), x.append(_, m, C + 1));
                            else {
                                if (m > y && (y += this.vertices.length), g = Number.MAX_VALUE, y < m) return t;
                                for (var P = m; P <= y; ++P) o.leftOn(_.at(C - 1), _.at(C), _.at(P)) && o.rightOn(_.at(C + 1), _.at(C), _.at(P)) && (f = o.sqdist(_.at(C), _.at(P))) < g && (g = f, v = P % this.vertices.length);
                                C < v ? (b.append(_, C, v + 1), 0 != v && x.append(_, v, w.length), x.append(_, 0, C + 1)) : (0 != C && b.append(_, C, w.length), b.append(_, 0, v + 1), x.append(_, v, C + 1))
                            }
                            return b.vertices.length < x.vertices.length ? (b.quickDecomp(t, e, i, a, r, h), x.quickDecomp(t, e, i, a, r, h)) : (x.quickDecomp(t, e, i, a, r, h), b.quickDecomp(t, e, i, a, r, h)), t
                        } return t.push(this), t
                }, s.prototype.removeCollinearPoints = function(t) {
                    for (var e = 0, i = this.vertices.length - 1; this.vertices.length > 3 && i >= 0; --i) o.collinear(this.at(i - 1), this.at(i), this.at(i + 1), t) && (this.vertices.splice(i % this.vertices.length, 1), i--, e++);
                    return e
                }
            }, {
                "./Line": 1,
                "./Point": 2,
                "./Scalar": 4
            }],
            4: [function(t, e, i) {
                function s() {}
                e.exports = s, s.eq = function(t, e, i) {
                    return i = i || 0, Math.abs(t - e) < i
                }
            }, {}],
            5: [function(t, e, i) {
                e.exports = {
                    Polygon: t("./Polygon"),
                    Point: t("./Point")
                }
            }, {
                "./Point": 2,
                "./Polygon": 3
            }],
            6: [function(t, e, i) {
                e.exports = {
                    name: "p2",
                    version: "0.7.0",
                    description: "A JavaScript 2D physics engine.",
                    author: "Stefan Hedman <schteppe@gmail.com> (http://steffe.se)",
                    keywords: ["p2.js", "p2", "physics", "engine", "2d"],
                    main: "./src/p2.js",
                    engines: {
                        node: "*"
                    },
                    repository: {
                        type: "git",
                        url: "https://github.com/schteppe/p2.js.git"
                    },
                    bugs: {
                        url: "https://github.com/schteppe/p2.js/issues"
                    },
                    licenses: [{
                        type: "MIT"
                    }],
                    devDependencies: {
                        grunt: "^0.4.5",
                        "grunt-contrib-jshint": "^0.11.2",
                        "grunt-contrib-nodeunit": "^0.4.1",
                        "grunt-contrib-uglify": "~0.4.0",
                        "grunt-contrib-watch": "~0.5.0",
                        "grunt-browserify": "~2.0.1",
                        "grunt-contrib-concat": "^0.4.0"
                    },
                    dependencies: {
                        "poly-decomp": "0.1.0"
                    }
                }
            }, {}],
            7: [function(t, e, i) {
                function s(t) {
                    this.lowerBound = n.create(), t && t.lowerBound && n.copy(this.lowerBound, t.lowerBound), this.upperBound = n.create(), t && t.upperBound && n.copy(this.upperBound, t.upperBound)
                }
                var n = t("../math/vec2"),
                    a = t("../utils/Utils");
                e.exports = s;
                var o = n.create();
                s.prototype.setFromPoints = function(t, e, i, s) {
                    var a = this.lowerBound,
                        r = this.upperBound;
                    "number" != typeof i && (i = 0), 0 !== i ? n.rotate(a, t[0], i) : n.copy(a, t[0]), n.copy(r, a);
                    for (var h = Math.cos(i), l = Math.sin(i), c = 1; c < t.length; c++) {
                        var u = t[c];
                        if (0 !== i) {
                            var d = u[0],
                                p = u[1];
                            o[0] = h * d - l * p, o[1] = l * d + h * p, u = o
                        }
                        for (var f = 0; f < 2; f++) u[f] > r[f] && (r[f] = u[f]), u[f] < a[f] && (a[f] = u[f])
                    }
                    e && (n.add(this.lowerBound, this.lowerBound, e), n.add(this.upperBound, this.upperBound, e)), s && (this.lowerBound[0] -= s, this.lowerBound[1] -= s, this.upperBound[0] += s, this.upperBound[1] += s)
                }, s.prototype.copy = function(t) {
                    n.copy(this.lowerBound, t.lowerBound), n.copy(this.upperBound, t.upperBound)
                }, s.prototype.extend = function(t) {
                    for (var e = 2; e--;) {
                        var i = t.lowerBound[e];
                        this.lowerBound[e] > i && (this.lowerBound[e] = i);
                        var s = t.upperBound[e];
                        this.upperBound[e] < s && (this.upperBound[e] = s)
                    }
                }, s.prototype.overlaps = function(t) {
                    var e = this.lowerBound,
                        i = this.upperBound,
                        s = t.lowerBound,
                        n = t.upperBound;
                    return (s[0] <= i[0] && i[0] <= n[0] || e[0] <= n[0] && n[0] <= i[0]) && (s[1] <= i[1] && i[1] <= n[1] || e[1] <= n[1] && n[1] <= i[1])
                }, s.prototype.containsPoint = function(t) {
                    var e = this.lowerBound,
                        i = this.upperBound;
                    return e[0] <= t[0] && t[0] <= i[0] && e[1] <= t[1] && t[1] <= i[1]
                }, s.prototype.overlapsRay = function(t) {
                    var e = 0,
                        i = 1 / t.direction[0],
                        s = 1 / t.direction[1],
                        n = (this.lowerBound[0] - t.from[0]) * i,
                        a = (this.upperBound[0] - t.from[0]) * i,
                        o = (this.lowerBound[1] - t.from[1]) * s,
                        r = (this.upperBound[1] - t.from[1]) * s,
                        h = Math.max(Math.max(Math.min(n, a), Math.min(o, r))),
                        l = Math.min(Math.min(Math.max(n, a), Math.max(o, r)));
                    return l < 0 ? -1 : h > l ? -1 : h
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            8: [function(t, e, i) {
                function s(t) {
                    this.type = t, this.result = [], this.world = null, this.boundingVolumeType = s.AABB
                }
                var n = t("../math/vec2"),
                    a = t("../objects/Body");
                e.exports = s, s.AABB = 1, s.BOUNDING_CIRCLE = 2, s.prototype.setWorld = function(t) {
                    this.world = t
                }, s.prototype.getCollisionPairs = function(t) {};
                var o = n.create();
                s.boundingRadiusCheck = function(t, e) {
                    n.sub(o, t.position, e.position);
                    var i = n.squaredLength(o),
                        s = t.boundingRadius + e.boundingRadius;
                    return i <= s * s
                }, s.aabbCheck = function(t, e) {
                    return t.getAABB()
                        .overlaps(e.getAABB())
                }, s.prototype.boundingVolumeCheck = function(t, e) {
                    var i;
                    switch (this.boundingVolumeType) {
                        case s.BOUNDING_CIRCLE:
                            i = s.boundingRadiusCheck(t, e);
                            break;
                        case s.AABB:
                            i = s.aabbCheck(t, e);
                            break;
                        default:
                            throw new Error("Bounding volume type not recognized: " + this.boundingVolumeType)
                    }
                    return i
                }, s.canCollide = function(t, e) {
                    var i = a.KINEMATIC,
                        s = a.STATIC;
                    return (t.type !== s || e.type !== s) && (!(t.type === i && e.type === s || t.type === s && e.type === i) && ((t.type !== i || e.type !== i) && ((t.sleepState !== a.SLEEPING || e.sleepState !== a.SLEEPING) && !(t.sleepState === a.SLEEPING && e.type === s || e.sleepState === a.SLEEPING && t.type === s))))
                }, s.NAIVE = 1, s.SAP = 2
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31
            }],
            9: [function(t, e, i) {
                function s() {
                    h.call(this, h.NAIVE)
                }
                var n = t("../shapes/Circle"),
                    a = t("../shapes/Plane"),
                    o = t("../shapes/Shape"),
                    r = t("../shapes/Particle"),
                    h = t("../collision/Broadphase"),
                    l = t("../math/vec2");
                e.exports = s, s.prototype = new h, s.prototype.constructor = s, s.prototype.getCollisionPairs = function(t) {
                    var e = t.bodies,
                        i = this.result;
                    i.length = 0;
                    for (var s = 0, n = e.length; s !== n; s++)
                        for (var a = e[s], o = 0; o < s; o++) {
                            var r = e[o];
                            h.canCollide(a, r) && this.boundingVolumeCheck(a, r) && i.push(a, r)
                        }
                    return i
                }, s.prototype.aabbQuery = function(t, e, i) {
                    i = i || [];
                    for (var s = t.bodies, n = 0; n < s.length; n++) {
                        var a = s[n];
                        a.aabbNeedsUpdate && a.updateAABB(), a.aabb.overlaps(e) && i.push(a)
                    }
                    return i
                }
            }, {
                "../collision/Broadphase": 8,
                "../math/vec2": 30,
                "../shapes/Circle": 39,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45
            }],
            10: [function(t, e, i) {
                function s() {
                    this.contactEquations = [], this.frictionEquations = [], this.enableFriction = !0, this.enabledEquations = !0, this.slipForce = 10, this.frictionCoefficient = .3, this.surfaceVelocity = 0, this.contactEquationPool = new u({
                        size: 32
                    }), this.frictionEquationPool = new d({
                        size: 64
                    }), this.restitution = 0, this.stiffness = f.DEFAULT_STIFFNESS, this.relaxation = f.DEFAULT_RELAXATION, this.frictionStiffness = f.DEFAULT_STIFFNESS, this.frictionRelaxation = f.DEFAULT_RELAXATION, this.enableFrictionReduction = !0, this.collidingBodiesLastStep = new p, this.contactSkinSize = .01
                }

                function n(t, e) {
                    o.set(t.vertices[0], .5 * -e.length, -e.radius), o.set(t.vertices[1], .5 * e.length, -e.radius), o.set(t.vertices[2], .5 * e.length, e.radius), o.set(t.vertices[3], .5 * -e.length, e.radius)
                }

                function a(t, e, i, s) {
                    for (var n = K, a = J, l = Z, c = Q, u = t, d = e.vertices, p = null, f = 0; f !== d.length + 1; f++) {
                        var g = d[f % d.length],
                            y = d[(f + 1) % d.length];
                        o.rotate(n, g, s), o.rotate(a, y, s), h(n, n, i), h(a, a, i), r(l, n, u), r(c, a, u);
                        var m = o.crossLength(l, c);
                        if (null === p && (p = m), m * p <= 0) return !1;
                        p = m
                    }
                    return !0
                }
                var o = t("../math/vec2"),
                    r = o.sub,
                    h = o.add,
                    l = o.dot,
                    c = t("../utils/Utils"),
                    u = t("../utils/ContactEquationPool"),
                    d = t("../utils/FrictionEquationPool"),
                    p = t("../utils/TupleDictionary"),
                    f = t("../equations/Equation"),
                    g = t("../equations/ContactEquation"),
                    y = t("../equations/FrictionEquation"),
                    m = t("../shapes/Circle"),
                    v = t("../shapes/Convex"),
                    b = t("../shapes/Shape"),
                    x = t("../objects/Body"),
                    _ = t("../shapes/Box");
                e.exports = s;
                var w = o.fromValues(0, 1),
                    C = o.fromValues(0, 0),
                    P = o.fromValues(0, 0),
                    T = o.fromValues(0, 0),
                    S = o.fromValues(0, 0),
                    A = o.fromValues(0, 0),
                    E = o.fromValues(0, 0),
                    I = o.fromValues(0, 0),
                    M = o.fromValues(0, 0),
                    O = o.fromValues(0, 0),
                    B = o.fromValues(0, 0),
                    R = o.fromValues(0, 0),
                    k = o.fromValues(0, 0),
                    D = o.fromValues(0, 0),
                    L = o.fromValues(0, 0),
                    F = o.fromValues(0, 0),
                    G = o.fromValues(0, 0),
                    U = o.fromValues(0, 0),
                    N = o.fromValues(0, 0),
                    j = [],
                    W = o.create(),
                    X = o.create();
                s.prototype.bodiesOverlap = function(t, e) {
                    for (var i = W, s = X, n = 0, a = t.shapes.length; n !== a; n++) {
                        var o = t.shapes[n];
                        t.toWorldFrame(i, o.position);
                        for (var r = 0, h = e.shapes.length; r !== h; r++) {
                            var l = e.shapes[r];
                            if (e.toWorldFrame(s, l.position), this[o.type | l.type](t, o, i, o.angle + t.angle, e, l, s, l.angle + e.angle, !0)) return !0
                        }
                    }
                    return !1
                }, s.prototype.collidedLastStep = function(t, e) {
                    var i = 0 | t.id,
                        s = 0 | e.id;
                    return !!this.collidingBodiesLastStep.get(i, s)
                }, s.prototype.reset = function() {
                    this.collidingBodiesLastStep.reset();
                    for (var t = this.contactEquations, e = t.length; e--;) {
                        var i = t[e],
                            s = i.bodyA.id,
                            n = i.bodyB.id;
                        this.collidingBodiesLastStep.set(s, n, !0)
                    }
                    for (var a = this.contactEquations, o = this.frictionEquations, r = 0; r < a.length; r++) this.contactEquationPool.release(a[r]);
                    for (var r = 0; r < o.length; r++) this.frictionEquationPool.release(o[r]);
                    this.contactEquations.length = this.frictionEquations.length = 0
                }, s.prototype.createContactEquation = function(t, e, i, s) {
                    var n = this.contactEquationPool.get();
                    return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.restitution = this.restitution, n.firstImpact = !this.collidedLastStep(t, e), n.stiffness = this.stiffness, n.relaxation = this.relaxation, n.needsUpdate = !0, n.enabled = this.enabledEquations, n.offset = this.contactSkinSize, n
                }, s.prototype.createFrictionEquation = function(t, e, i, s) {
                    var n = this.frictionEquationPool.get();
                    return n.bodyA = t, n.bodyB = e, n.shapeA = i, n.shapeB = s, n.setSlipForce(this.slipForce), n.frictionCoefficient = this.frictionCoefficient, n.relativeVelocity = this.surfaceVelocity, n.enabled = this.enabledEquations, n.needsUpdate = !0, n.stiffness = this.frictionStiffness, n.relaxation = this.frictionRelaxation, n.contactEquations.length = 0, n
                }, s.prototype.createFrictionFromContact = function(t) {
                    var e = this.createFrictionEquation(t.bodyA, t.bodyB, t.shapeA, t.shapeB);
                    return o.copy(e.contactPointA, t.contactPointA), o.copy(e.contactPointB, t.contactPointB), o.rotate90cw(e.t, t.normalA), e.contactEquations.push(t), e
                }, s.prototype.createFrictionFromAverage = function(t) {
                    var e = this.contactEquations[this.contactEquations.length - 1],
                        i = this.createFrictionEquation(e.bodyA, e.bodyB, e.shapeA, e.shapeB),
                        s = e.bodyA,
                        n = e.bodyB;
                    o.set(i.contactPointA, 0, 0), o.set(i.contactPointB, 0, 0), o.set(i.t, 0, 0);
                    for (var a = 0; a !== t; a++) e = this.contactEquations[this.contactEquations.length - 1 - a], e.bodyA === s ? (o.add(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointA), o.add(i.contactPointB, i.contactPointB, e.contactPointB)) : (o.sub(i.t, i.t, e.normalA), o.add(i.contactPointA, i.contactPointA, e.contactPointB), o.add(i.contactPointB, i.contactPointB, e.contactPointA)), i.contactEquations.push(e);
                    var r = 1 / t;
                    return o.scale(i.contactPointA, i.contactPointA, r), o.scale(i.contactPointB, i.contactPointB, r), o.normalize(i.t, i.t), o.rotate90cw(i.t, i.t), i
                }, s.prototype[b.LINE | b.CONVEX] = s.prototype.convexLine = function(t, e, i, s, n, a, o, r, h) {
                    return !h && 0
                }, s.prototype[b.LINE | b.BOX] = s.prototype.lineBox = function(t, e, i, s, n, a, o, r, h) {
                    return !h && 0
                };
                var H = new _({
                        width: 1,
                        height: 1
                    }),
                    V = o.create();
                s.prototype[b.CAPSULE | b.CONVEX] = s.prototype[b.CAPSULE | b.BOX] = s.prototype.convexCapsule = function(t, e, i, s, a, r, h, l, c) {
                    var u = V;
                    o.set(u, r.length / 2, 0), o.rotate(u, u, l), o.add(u, u, h);
                    var d = this.circleConvex(a, r, u, l, t, e, i, s, c, r.radius);
                    o.set(u, -r.length / 2, 0), o.rotate(u, u, l), o.add(u, u, h);
                    var p = this.circleConvex(a, r, u, l, t, e, i, s, c, r.radius);
                    if (c && (d || p)) return !0;
                    var f = H;
                    return n(f, r), this.convexConvex(t, e, i, s, a, f, h, l, c) + d + p
                }, s.prototype[b.CAPSULE | b.LINE] = s.prototype.lineCapsule = function(t, e, i, s, n, a, o, r, h) {
                    return !h && 0
                };
                var Y = o.create(),
                    q = o.create(),
                    z = new _({
                        width: 1,
                        height: 1
                    });
                s.prototype[b.CAPSULE | b.CAPSULE] = s.prototype.capsuleCapsule = function(t, e, i, s, a, r, h, l, c) {
                    for (var u, d = Y, p = q, f = 0, g = 0; g < 2; g++) {
                        o.set(d, (0 === g ? -1 : 1) * e.length / 2, 0), o.rotate(d, d, s), o.add(d, d, i);
                        for (var y = 0; y < 2; y++) {
                            o.set(p, (0 === y ? -1 : 1) * r.length / 2, 0), o.rotate(p, p, l), o.add(p, p, h), this.enableFrictionReduction && (u = this.enableFriction, this.enableFriction = !1);
                            var m = this.circleCircle(t, e, d, s, a, r, p, l, c, e.radius, r.radius);
                            if (this.enableFrictionReduction && (this.enableFriction = u), c && m) return !0;
                            f += m
                        }
                    }
                    this.enableFrictionReduction && (u = this.enableFriction, this.enableFriction = !1);
                    var v = z;
                    n(v, e);
                    var b = this.convexCapsule(t, v, i, s, a, r, h, l, c);
                    if (this.enableFrictionReduction && (this.enableFriction = u), c && b) return !0;
                    if (f += b, this.enableFrictionReduction) {
                        var u = this.enableFriction;
                        this.enableFriction = !1
                    }
                    n(v, r);
                    var x = this.convexCapsule(a, v, h, l, t, e, i, s, c);
                    return this.enableFrictionReduction && (this.enableFriction = u), !(!c || !x) || (f += x, this.enableFrictionReduction && f && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(f)), f)
                }, s.prototype[b.LINE | b.LINE] = s.prototype.lineLine = function(t, e, i, s, n, a, o, r, h) {
                    return !h && 0
                }, s.prototype[b.PLANE | b.LINE] = s.prototype.planeLine = function(t, e, i, s, n, a, c, u, d) {
                    var p = C,
                        f = P,
                        g = T,
                        y = S,
                        m = A,
                        v = E,
                        b = I,
                        x = M,
                        _ = O,
                        B = j,
                        R = 0;
                    o.set(p, -a.length / 2, 0), o.set(f, a.length / 2, 0), o.rotate(g, p, u), o.rotate(y, f, u), h(g, g, c), h(y, y, c), o.copy(p, g), o.copy(f, y), r(m, f, p), o.normalize(v, m), o.rotate90cw(_, v), o.rotate(x, w, s), B[0] = p, B[1] = f;
                    for (var k = 0; k < B.length; k++) {
                        var D = B[k];
                        r(b, D, i);
                        var L = l(b, x);
                        if (L < 0) {
                            if (d) return !0;
                            var F = this.createContactEquation(t, n, e, a);
                            R++, o.copy(F.normalA, x), o.normalize(F.normalA, F.normalA), o.scale(b, x, L), r(F.contactPointA, D, b), r(F.contactPointA, F.contactPointA, t.position), r(F.contactPointB, D, c), h(F.contactPointB, F.contactPointB, c), r(F.contactPointB, F.contactPointB, n.position), this.contactEquations.push(F), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(F))
                        }
                    }
                    return !d && (this.enableFrictionReduction || R && this.enableFriction && this.frictionEquations.push(this.createFrictionFromAverage(R)), R)
                }, s.prototype[b.PARTICLE | b.CAPSULE] = s.prototype.particleCapsule = function(t, e, i, s, n, a, o, r, h) {
                    return this.circleLine(t, e, i, s, n, a, o, r, h, a.radius, 0)
                }, s.prototype[b.CIRCLE | b.LINE] = s.prototype.circleLine = function(t, e, i, s, n, a, c, u, d, p, f) {
                    var p = p || 0,
                        f = void 0 !== f ? f : e.radius,
                        g = C,
                        y = P,
                        m = T,
                        v = S,
                        b = A,
                        x = E,
                        _ = I,
                        w = M,
                        F = O,
                        G = B,
                        U = R,
                        N = k,
                        W = D,
                        X = L,
                        H = j;
                    o.set(w, -a.length / 2, 0), o.set(F, a.length / 2, 0), o.rotate(G, w, u), o.rotate(U, F, u), h(G, G, c), h(U, U, c), o.copy(w, G), o.copy(F, U), r(x, F, w), o.normalize(_, x), o.rotate90cw(b, _), r(N, i, w);
                    var V = l(N, b);
                    r(v, w, c), r(W, i, c);
                    var Y = f + p;
                    if (Math.abs(V) < Y) {
                        o.scale(g, b, V), r(m, i, g), o.scale(y, b, l(b, W)), o.normalize(y, y), o.scale(y, y, p), h(m, m, y);
                        var q = l(_, m),
                            z = l(_, w),
                            K = l(_, F);
                        if (q > z && q < K) {
                            if (d) return !0;
                            var J = this.createContactEquation(t, n, e, a);
                            return o.scale(J.normalA, g, -1), o.normalize(J.normalA, J.normalA), o.scale(J.contactPointA, J.normalA, f), h(J.contactPointA, J.contactPointA, i), r(J.contactPointA, J.contactPointA, t.position), r(J.contactPointB, m, c), h(J.contactPointB, J.contactPointB, c), r(J.contactPointB, J.contactPointB, n.position), this.contactEquations.push(J), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(J)), 1
                        }
                    }
                    H[0] = w, H[1] = F;
                    for (var Z = 0; Z < H.length; Z++) {
                        var Q = H[Z];
                        if (r(N, Q, i), o.squaredLength(N) < Math.pow(Y, 2)) {
                            if (d) return !0;
                            var J = this.createContactEquation(t, n, e, a);
                            return o.copy(J.normalA, N), o.normalize(J.normalA, J.normalA), o.scale(J.contactPointA, J.normalA, f), h(J.contactPointA, J.contactPointA, i), r(J.contactPointA, J.contactPointA, t.position), r(J.contactPointB, Q, c), o.scale(X, J.normalA, -p), h(J.contactPointB, J.contactPointB, X), h(J.contactPointB, J.contactPointB, c), r(J.contactPointB, J.contactPointB, n.position), this.contactEquations.push(J), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(J)), 1
                        }
                    }
                    return 0
                }, s.prototype[b.CIRCLE | b.CAPSULE] = s.prototype.circleCapsule = function(t, e, i, s, n, a, o, r, h) {
                    return this.circleLine(t, e, i, s, n, a, o, r, h, a.radius)
                }, s.prototype[b.CIRCLE | b.CONVEX] = s.prototype[b.CIRCLE | b.BOX] = s.prototype.circleConvex = function(t, e, i, s, n, l, c, u, d, p) {
                    for (var p = "number" == typeof p ? p : e.radius, f = C, g = P, y = T, m = S, v = A, b = E, x = I, _ = M, w = O, U = B, N = R, j = -1, W = null, X = k, H = D, V = L, Y = F, q = G, z = !1, K = Number.MAX_VALUE, J = 0, Z = l.vertices, Q = 0; Q !== Z.length + 1; Q++) {
                        var $ = Z[Q % Z.length],
                            tt = Z[(Q + 1) % Z.length];
                        if (o.rotate(f, $, u), o.rotate(g, tt, u), h(f, f, c), h(g, g, c), r(y, g, f), o.normalize(m, y), o.rotate90cw(v, m), o.scale(V, v, -e.radius), h(V, V, i), a(V, l, c, u)) {
                            o.sub(Y, f, V);
                            var et = Math.abs(o.dot(Y, v));
                            et < K && (o.copy(q, V), K = et, o.scale(H, v, et), o.add(H, H, V), z = !0)
                        }
                    }
                    if (z) {
                        if (d) return !0;
                        var it = this.createContactEquation(t, n, e, l);
                        return o.sub(it.normalA, q, i), o.normalize(it.normalA, it.normalA), o.scale(it.contactPointA, it.normalA, p), h(it.contactPointA, it.contactPointA, i), r(it.contactPointA, it.contactPointA, t.position), r(it.contactPointB, H, c), h(it.contactPointB, it.contactPointB, c), r(it.contactPointB, it.contactPointB, n.position), this.contactEquations.push(it), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(it)), 1
                    }
                    if (p > 0)
                        for (var Q = 0; Q < Z.length; Q++) {
                            var st = Z[Q];
                            if (o.rotate(N, st, u), h(N, N, c), r(U, N, i), o.squaredLength(U) < Math.pow(p, 2)) {
                                if (d) return !0;
                                var it = this.createContactEquation(t, n, e, l);
                                return o.copy(it.normalA, U), o.normalize(it.normalA, it.normalA), o.scale(it.contactPointA, it.normalA, p), h(it.contactPointA, it.contactPointA, i), r(it.contactPointA, it.contactPointA, t.position), r(it.contactPointB, N, c), h(it.contactPointB, it.contactPointB, c), r(it.contactPointB, it.contactPointB, n.position), this.contactEquations.push(it), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(it)), 1
                            }
                        }
                    return 0
                };
                var K = o.create(),
                    J = o.create(),
                    Z = o.create(),
                    Q = o.create();
                s.prototype[b.PARTICLE | b.CONVEX] = s.prototype[b.PARTICLE | b.BOX] = s.prototype.particleConvex = function(t, e, i, s, n, c, u, d, p) {
                    var f = C,
                        g = P,
                        y = T,
                        m = S,
                        v = A,
                        b = E,
                        x = I,
                        _ = M,
                        w = O,
                        j = B,
                        W = R,
                        X = -1,
                        H = null,
                        V = k,
                        Y = D,
                        q = L,
                        z = F,
                        K = G,
                        J = U,
                        Z = N,
                        Q = Number.MAX_VALUE,
                        $ = 0,
                        tt = !1,
                        et = c.vertices;
                    if (!a(i, c, u, d)) return 0;
                    if (p) return !0;
                    for (var it = null, st = 0; st !== et.length + 1; st++) {
                        var nt = et[st % et.length],
                            at = et[(st + 1) % et.length];
                        o.rotate(f, nt, d), o.rotate(g, at, d), h(f, f, u), h(g, g, u), r(y, g, f), o.normalize(m, y), o.rotate90cw(v, m), r(j, i, f);
                        var ot = l(j, v);
                        r(b, f, u), r(x, i, u), o.sub(J, f, i);
                        var rt = Math.abs(o.dot(J, v));
                        rt < Q && (Q = rt, o.scale(Y, v, rt), o.add(Y, Y, i), o.copy(Z, v), tt = !0)
                    }
                    if (tt) {
                        var ht = this.createContactEquation(t, n, e, c);
                        return o.scale(ht.normalA, Z, -1), o.normalize(ht.normalA, ht.normalA), o.set(ht.contactPointA, 0, 0), h(ht.contactPointA, ht.contactPointA, i), r(ht.contactPointA, ht.contactPointA, t.position), r(ht.contactPointB, Y, u), h(ht.contactPointB, ht.contactPointB, u), r(ht.contactPointB, ht.contactPointB, n.position), this.contactEquations.push(ht), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(ht)), 1
                    }
                    return 0
                }, s.prototype[b.CIRCLE] = s.prototype.circleCircle = function(t, e, i, s, n, a, l, c, u, d, p) {
                    var f = C,
                        d = d || e.radius,
                        p = p || a.radius;
                    r(f, i, l);
                    var g = d + p;
                    if (o.squaredLength(f) > Math.pow(g, 2)) return 0;
                    if (u) return !0;
                    var y = this.createContactEquation(t, n, e, a);
                    return r(y.normalA, l, i), o.normalize(y.normalA, y.normalA), o.scale(y.contactPointA, y.normalA, d), o.scale(y.contactPointB, y.normalA, -p), h(y.contactPointA, y.contactPointA, i), r(y.contactPointA, y.contactPointA, t.position), h(y.contactPointB, y.contactPointB, l), r(y.contactPointB, y.contactPointB, n.position), this.contactEquations.push(y), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(y)), 1
                }, s.prototype[b.PLANE | b.CONVEX] = s.prototype[b.PLANE | b.BOX] = s.prototype.planeConvex = function(t, e, i, s, n, a, c, u, d) {
                    var p = C,
                        f = P,
                        g = T,
                        y = 0;
                    o.rotate(f, w, s);
                    for (var m = 0; m !== a.vertices.length; m++) {
                        var v = a.vertices[m];
                        if (o.rotate(p, v, u), h(p, p, c), r(g, p, i), l(g, f) <= 0) {
                            if (d) return !0;
                            y++;
                            var b = this.createContactEquation(t, n, e, a);
                            r(g, p, i), o.copy(b.normalA, f);
                            var x = l(g, b.normalA);
                            o.scale(g, b.normalA, x), r(b.contactPointB, p, n.position), r(b.contactPointA, p, g), r(b.contactPointA, b.contactPointA, t.position), this.contactEquations.push(b), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(b))
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && y && this.frictionEquations.push(this.createFrictionFromAverage(y)), y
                }, s.prototype[b.PARTICLE | b.PLANE] = s.prototype.particlePlane = function(t, e, i, s, n, a, h, c, u) {
                    var d = C,
                        p = P;
                    c = c || 0, r(d, i, h), o.rotate(p, w, c);
                    var f = l(d, p);
                    if (f > 0) return 0;
                    if (u) return !0;
                    var g = this.createContactEquation(n, t, a, e);
                    return o.copy(g.normalA, p), o.scale(d, g.normalA, f), r(g.contactPointA, i, d), r(g.contactPointA, g.contactPointA, n.position), r(g.contactPointB, i, t.position), this.contactEquations.push(g), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(g)), 1
                }, s.prototype[b.CIRCLE | b.PARTICLE] = s.prototype.circleParticle = function(t, e, i, s, n, a, l, c, u) {
                    var d = C;
                    if (r(d, l, i), o.squaredLength(d) > Math.pow(e.radius, 2)) return 0;
                    if (u) return !0;
                    var p = this.createContactEquation(t, n, e, a);
                    return o.copy(p.normalA, d), o.normalize(p.normalA, p.normalA), o.scale(p.contactPointA, p.normalA, e.radius), h(p.contactPointA, p.contactPointA, i), r(p.contactPointA, p.contactPointA, t.position), r(p.contactPointB, l, n.position), this.contactEquations.push(p), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(p)), 1
                };
                var $ = new m({
                        radius: 1
                    }),
                    tt = o.create(),
                    et = o.create(),
                    it = o.create();
                s.prototype[b.PLANE | b.CAPSULE] = s.prototype.planeCapsule = function(t, e, i, s, n, a, r, l, c) {
                    var u = tt,
                        d = et,
                        p = $,
                        f = it;
                    o.set(u, -a.length / 2, 0), o.rotate(u, u, l), h(u, u, r), o.set(d, a.length / 2, 0), o.rotate(d, d, l), h(d, d, r), p.radius = a.radius;
                    var g;
                    this.enableFrictionReduction && (g = this.enableFriction, this.enableFriction = !1);
                    var y = this.circlePlane(n, p, u, 0, t, e, i, s, c),
                        m = this.circlePlane(n, p, d, 0, t, e, i, s, c);
                    if (this.enableFrictionReduction && (this.enableFriction = g), c) return y || m;
                    var v = y + m;
                    return this.enableFrictionReduction && v && this.frictionEquations.push(this.createFrictionFromAverage(v)), v
                }, s.prototype[b.CIRCLE | b.PLANE] = s.prototype.circlePlane = function(t, e, i, s, n, a, c, u, d) {
                    var p = t,
                        f = e,
                        g = i,
                        y = n,
                        m = a,
                        v = c,
                        b = u;
                    b = b || 0;
                    var x = C,
                        _ = P,
                        S = T;
                    r(x, g, v), o.rotate(_, w, b);
                    var A = l(_, x);
                    if (A > f.radius) return 0;
                    if (d) return !0;
                    var E = this.createContactEquation(y, p, a, e);
                    return o.copy(E.normalA, _), o.scale(E.contactPointB, E.normalA, -f.radius), h(E.contactPointB, E.contactPointB, g), r(E.contactPointB, E.contactPointB, p.position), o.scale(S, E.normalA, A), r(E.contactPointA, x, S), h(E.contactPointA, E.contactPointA, v), r(E.contactPointA, E.contactPointA, y.position), this.contactEquations.push(E), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(E)), 1
                }, s.prototype[b.CONVEX] = s.prototype[b.CONVEX | b.BOX] = s.prototype[b.BOX] = s.prototype.convexConvex = function(t, e, i, n, a, c, u, d, p, f) {
                    var g = C,
                        y = P,
                        m = T,
                        v = S,
                        b = A,
                        x = E,
                        _ = I,
                        w = M,
                        B = O,
                        R = 0,
                        f = "number" == typeof f ? f : 0;
                    if (!s.findSeparatingAxis(e, i, n, c, u, d, g)) return 0;
                    r(w, u, i), l(g, w) > 0 && o.scale(g, g, -1);
                    var k = s.getClosestEdge(e, n, g, !0),
                        D = s.getClosestEdge(c, d, g);
                    if (-1 === k || -1 === D) return 0;
                    for (var L = 0; L < 2; L++) {
                        var F = k,
                            G = D,
                            U = e,
                            N = c,
                            j = i,
                            W = u,
                            X = n,
                            H = d,
                            V = t,
                            Y = a;
                        if (0 === L) {
                            var q;
                            q = F, F = G, G = q, q = U, U = N, N = q, q = j, j = W, W = q, q = X, X = H, H = q, q = V, V = Y, Y = q
                        }
                        for (var z = G; z < G + 2; z++) {
                            var K = N.vertices[(z + N.vertices.length) % N.vertices.length];
                            o.rotate(y, K, H), h(y, y, W);
                            for (var J = 0, Z = F - 1; Z < F + 2; Z++) {
                                var Q = U.vertices[(Z + U.vertices.length) % U.vertices.length],
                                    $ = U.vertices[(Z + 1 + U.vertices.length) % U.vertices.length];
                                o.rotate(m, Q, X), o.rotate(v, $, X), h(m, m, j), h(v, v, j), r(b, v, m), o.rotate90cw(B, b), o.normalize(B, B), r(w, y, m);
                                var tt = l(B, w);
                                (Z === F && tt <= f || Z !== F && tt <= 0) && J++
                            }
                            if (J >= 3) {
                                if (p) return !0;
                                var et = this.createContactEquation(V, Y, U, N);
                                R++;
                                var Q = U.vertices[F % U.vertices.length],
                                    $ = U.vertices[(F + 1) % U.vertices.length];
                                o.rotate(m, Q, X), o.rotate(v, $, X), h(m, m, j), h(v, v, j), r(b, v, m), o.rotate90cw(et.normalA, b), o.normalize(et.normalA, et.normalA), r(w, y, m);
                                var tt = l(et.normalA, w);
                                o.scale(_, et.normalA, tt), r(et.contactPointA, y, j), r(et.contactPointA, et.contactPointA, _), h(et.contactPointA, et.contactPointA, j), r(et.contactPointA, et.contactPointA, V.position), r(et.contactPointB, y, W), h(et.contactPointB, et.contactPointB, W), r(et.contactPointB, et.contactPointB, Y.position), this.contactEquations.push(et), this.enableFrictionReduction || this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(et))
                            }
                        }
                    }
                    return this.enableFrictionReduction && this.enableFriction && R && this.frictionEquations.push(this.createFrictionFromAverage(R)), R
                };
                var st = o.fromValues(0, 0);
                s.projectConvexOntoAxis = function(t, e, i, s, n) {
                    var a = null,
                        r = null,
                        h, c, u = st;
                    o.rotate(u, s, -i);
                    for (var d = 0; d < t.vertices.length; d++) h = t.vertices[d], c = l(h, u), (null === a || c > a) && (a = c), (null === r || c < r) && (r = c);
                    if (r > a) {
                        var p = r;
                        r = a, a = p
                    }
                    var f = l(e, s);
                    o.set(n, r + f, a + f)
                };
                var nt = o.fromValues(0, 0),
                    at = o.fromValues(0, 0),
                    ot = o.fromValues(0, 0),
                    rt = o.fromValues(0, 0),
                    ht = o.fromValues(0, 0),
                    lt = o.fromValues(0, 0);
                s.findSeparatingAxis = function(t, e, i, n, a, h, l) {
                    var c = null,
                        u = !1,
                        d = !1,
                        p = nt,
                        f = at,
                        g = ot,
                        y = rt,
                        m = ht,
                        v = lt;
                    if (t instanceof _ && n instanceof _)
                        for (var b = 0; 2 !== b; b++) {
                            var x = t,
                                w = i;
                            1 === b && (x = n, w = h);
                            for (var C = 0; 2 !== C; C++) {
                                0 === C ? o.set(y, 0, 1) : 1 === C && o.set(y, 1, 0), 0 !== w && o.rotate(y, y, w), s.projectConvexOntoAxis(t, e, i, y, m), s.projectConvexOntoAxis(n, a, h, y, v);
                                var P = m,
                                    T = v,
                                    S = !1;
                                m[0] > v[0] && (T = m, P = v, S = !0);
                                var A = T[0] - P[1];
                                u = A <= 0, (null === c || A > c) && (o.copy(l, y), c = A, d = u)
                            }
                        } else
                            for (var b = 0; 2 !== b; b++) {
                                var x = t,
                                    w = i;
                                1 === b && (x = n, w = h);
                                for (var C = 0; C !== x.vertices.length; C++) {
                                    o.rotate(f, x.vertices[C], w), o.rotate(g, x.vertices[(C + 1) % x.vertices.length], w), r(p, g, f), o.rotate90cw(y, p), o.normalize(y, y), s.projectConvexOntoAxis(t, e, i, y, m), s.projectConvexOntoAxis(n, a, h, y, v);
                                    var P = m,
                                        T = v,
                                        S = !1;
                                    m[0] > v[0] && (T = m, P = v, S = !0);
                                    var A = T[0] - P[1];
                                    u = A <= 0, (null === c || A > c) && (o.copy(l, y), c = A, d = u)
                                }
                            }
                    return d
                };
                var ct = o.fromValues(0, 0),
                    ut = o.fromValues(0, 0),
                    dt = o.fromValues(0, 0);
                s.getClosestEdge = function(t, e, i, s) {
                    var n = ct,
                        a = ut,
                        h = dt;
                    o.rotate(n, i, -e), s && o.scale(n, n, -1);
                    for (var c = -1, u = t.vertices.length, d = -1, p = 0; p !== u; p++) {
                        r(a, t.vertices[(p + 1) % u], t.vertices[p % u]), o.rotate90cw(h, a), o.normalize(h, h);
                        var f = l(h, n);
                        (-1 === c || f > d) && (c = p % u, d = f)
                    }
                    return c
                };
                var pt = o.create(),
                    ft = o.create(),
                    gt = o.create(),
                    yt = o.create(),
                    mt = o.create(),
                    vt = o.create(),
                    bt = o.create();
                s.prototype[b.CIRCLE | b.HEIGHTFIELD] = s.prototype.circleHeightfield = function(t, e, i, s, n, a, l, c, u, d) {
                    var p = a.heights,
                        d = d || e.radius,
                        f = a.elementWidth,
                        g = ft,
                        y = pt,
                        m = mt,
                        v = bt,
                        b = vt,
                        x = gt,
                        _ = yt,
                        w = Math.floor((i[0] - d - l[0]) / f),
                        C = Math.ceil((i[0] + d - l[0]) / f);
                    w < 0 && (w = 0), C >= p.length && (C = p.length - 1);
                    for (var P = p[w], T = p[C], S = w; S < C; S++) p[S] < T && (T = p[S]), p[S] > P && (P = p[S]);
                    if (i[1] - d > P) return !u && 0;
                    for (var A = !1, S = w; S < C; S++) {
                        o.set(x, S * f, p[S]), o.set(_, (S + 1) * f, p[S + 1]), o.add(x, x, l), o.add(_, _, l), o.sub(b, _, x), o.rotate(b, b, Math.PI / 2), o.normalize(b, b), o.scale(y, b, -d), o.add(y, y, i), o.sub(g, y, x);
                        var E = o.dot(g, b);
                        if (y[0] >= x[0] && y[0] < _[0] && E <= 0) {
                            if (u) return !0;
                            A = !0, o.scale(g, b, -E), o.add(m, y, g), o.copy(v, b);
                            var I = this.createContactEquation(n, t, a, e);
                            o.copy(I.normalA, v), o.scale(I.contactPointB, I.normalA, -d), h(I.contactPointB, I.contactPointB, i), r(I.contactPointB, I.contactPointB, t.position), o.copy(I.contactPointA, m), o.sub(I.contactPointA, I.contactPointA, n.position), this.contactEquations.push(I), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(I))
                        }
                    }
                    if (A = !1, d > 0)
                        for (var S = w; S <= C; S++)
                            if (o.set(x, S * f, p[S]), o.add(x, x, l), o.sub(g, i, x), o.squaredLength(g) < Math.pow(d, 2)) {
                                if (u) return !0;
                                A = !0;
                                var I = this.createContactEquation(n, t, a, e);
                                o.copy(I.normalA, g), o.normalize(I.normalA, I.normalA), o.scale(I.contactPointB, I.normalA, -d), h(I.contactPointB, I.contactPointB, i), r(I.contactPointB, I.contactPointB, t.position), r(I.contactPointA, x, l), h(I.contactPointA, I.contactPointA, l), r(I.contactPointA, I.contactPointA, n.position), this.contactEquations.push(I), this.enableFriction && this.frictionEquations.push(this.createFrictionFromContact(I))
                            } return A ? 1 : 0
                };
                var xt = o.create(),
                    _t = o.create(),
                    wt = o.create(),
                    Ct = new v({
                        vertices: [o.create(), o.create(), o.create(), o.create()]
                    });
                s.prototype[b.BOX | b.HEIGHTFIELD] = s.prototype[b.CONVEX | b.HEIGHTFIELD] = s.prototype.convexHeightfield = function(t, e, i, s, n, a, r, h, l) {
                    var c = a.heights,
                        u = a.elementWidth,
                        d = xt,
                        p = _t,
                        f = wt,
                        g = Ct,
                        y = Math.floor((t.aabb.lowerBound[0] - r[0]) / u),
                        m = Math.ceil((t.aabb.upperBound[0] - r[0]) / u);
                    y < 0 && (y = 0), m >= c.length && (m = c.length - 1);
                    for (var v = c[y], b = c[m], x = y; x < m; x++) c[x] < b && (b = c[x]), c[x] > v && (v = c[x]);
                    if (t.aabb.lowerBound[1] > v) return !l && 0;
                    for (var _ = !1, w = 0, x = y; x < m; x++) {
                        o.set(d, x * u, c[x]), o.set(p, (x + 1) * u, c[x + 1]), o.add(d, d, r), o.add(p, p, r);
                        var C = 100;
                        o.set(f, .5 * (p[0] + d[0]), .5 * (p[1] + d[1] - 100)), o.sub(g.vertices[0], p, f), o.sub(g.vertices[1], d, f), o.copy(g.vertices[2], g.vertices[1]), o.copy(g.vertices[3], g.vertices[0]), g.vertices[2][1] -= 100, g.vertices[3][1] -= 100, w += this.convexConvex(t, e, i, s, n, g, f, 0, l)
                    }
                    return w
                }
            }, {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../shapes/Box": 37,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Shape": 45,
                "../utils/ContactEquationPool": 48,
                "../utils/FrictionEquationPool": 49,
                "../utils/TupleDictionary": 56,
                "../utils/Utils": 57
            }],
            11: [function(t, e, i) {
                function s(t) {
                    t = t || {}, this.from = t.from ? a.fromValues(t.from[0], t.from[1]) : a.create(), this.to = t.to ? a.fromValues(t.to[0], t.to[1]) : a.create(), this.checkCollisionResponse = void 0 === t.checkCollisionResponse || t.checkCollisionResponse, this.skipBackfaces = !!t.skipBackfaces, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : -1, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : -1, this.mode = void 0 !== t.mode ? t.mode : s.ANY, this.callback = t.callback || function(t) {}, this.direction = a.create(), this.length = 1, this.update()
                }

                function n(t, e, i) {
                    a.sub(u, i, t);
                    var s = a.dot(u, e);
                    return a.scale(d, e, s), a.add(d, d, t), a.squaredDistance(i, d)
                }
                e.exports = s;
                var a = t("../math/vec2"),
                    o = t("../collision/RaycastResult"),
                    r = t("../shapes/Shape"),
                    h = t("../collision/AABB");
                s.prototype.constructor = s, s.CLOSEST = 1, s.ANY = 2, s.ALL = 4, s.prototype.update = function() {
                    var t = this.direction;
                    a.sub(t, this.to, this.from), this.length = a.length(t), a.normalize(t, t)
                }, s.prototype.intersectBodies = function(t, e) {
                    for (var i = 0, s = e.length; !t.shouldStop(this) && i < s; i++) {
                        var n = e[i],
                            a = n.getAABB();
                        (a.overlapsRay(this) >= 0 || a.containsPoint(this.from)) && this.intersectBody(t, n)
                    }
                };
                var l = a.create();
                s.prototype.intersectBody = function(t, e) {
                    var i = this.checkCollisionResponse;
                    if (!i || e.collisionResponse)
                        for (var s = l, n = 0, o = e.shapes.length; n < o; n++) {
                            var r = e.shapes[n];
                            if ((!i || r.collisionResponse) && (0 != (this.collisionGroup & r.collisionMask) && 0 != (r.collisionGroup & this.collisionMask))) {
                                a.rotate(s, r.position, e.angle), a.add(s, s, e.position);
                                var h = r.angle + e.angle;
                                if (this.intersectShape(t, r, h, s, e), t.shouldStop(this)) break
                            }
                        }
                }, s.prototype.intersectShape = function(t, e, i, s, a) {
                    n(this.from, this.direction, s) > e.boundingRadius * e.boundingRadius || (this._currentBody = a, this._currentShape = e, e.raycast(t, this, s, i), this._currentBody = this._currentShape = null)
                }, s.prototype.getAABB = function(t) {
                    var e = this.to,
                        i = this.from;
                    a.set(t.lowerBound, Math.min(e[0], i[0]), Math.min(e[1], i[1])), a.set(t.upperBound, Math.max(e[0], i[0]), Math.max(e[1], i[1]))
                };
                var c = a.create();
                s.prototype.reportIntersection = function(t, e, i, n) {
                    var o = this.from,
                        r = this.to,
                        h = this._currentShape,
                        l = this._currentBody;
                    if (!(this.skipBackfaces && a.dot(i, this.direction) > 0)) switch (this.mode) {
                        case s.ALL:
                            t.set(i, h, l, e, n), this.callback(t);
                            break;
                        case s.CLOSEST:
                            (e < t.fraction || !t.hasHit()) && t.set(i, h, l, e, n);
                            break;
                        case s.ANY:
                            t.set(i, h, l, e, n)
                    }
                };
                var u = a.create(),
                    d = a.create()
            }, {
                "../collision/AABB": 7,
                "../collision/RaycastResult": 12,
                "../math/vec2": 30,
                "../shapes/Shape": 45
            }],
            12: [function(t, e, i) {
                function s() {
                    this.normal = n.create(), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
                }
                var n = t("../math/vec2"),
                    a = t("../collision/Ray");
                e.exports = s, s.prototype.reset = function() {
                    n.set(this.normal, 0, 0), this.shape = null, this.body = null, this.faceIndex = -1, this.fraction = -1, this.isStopped = !1
                }, s.prototype.getHitDistance = function(t) {
                    return n.distance(t.from, t.to) * this.fraction
                }, s.prototype.hasHit = function() {
                    return -1 !== this.fraction
                }, s.prototype.getHitPoint = function(t, e) {
                    n.lerp(t, e.from, e.to, this.fraction)
                }, s.prototype.stop = function() {
                    this.isStopped = !0
                }, s.prototype.shouldStop = function(t) {
                    return this.isStopped || -1 !== this.fraction && t.mode === a.ANY
                }, s.prototype.set = function(t, e, i, s, a) {
                    n.copy(this.normal, t), this.shape = e, this.body = i, this.fraction = s, this.faceIndex = a
                }
            }, {
                "../collision/Ray": 11,
                "../math/vec2": 30
            }],
            13: [function(t, e, i) {
                function s() {
                    a.call(this, a.SAP), this.axisList = [], this.axisIndex = 0;
                    var t = this;
                    this._addBodyHandler = function(e) {
                        t.axisList.push(e.body)
                    }, this._removeBodyHandler = function(e) {
                        var i = t.axisList.indexOf(e.body); - 1 !== i && t.axisList.splice(i, 1)
                    }
                }
                var n = t("../utils/Utils"),
                    a = t("../collision/Broadphase");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.setWorld = function(t) {
                    this.axisList.length = 0, n.appendArray(this.axisList, t.bodies), t.off("addBody", this._addBodyHandler)
                        .off("removeBody", this._removeBodyHandler), t.on("addBody", this._addBodyHandler)
                        .on("removeBody", this._removeBodyHandler), this.world = t
                }, s.sortAxisList = function(t, e) {
                    e |= 0;
                    for (var i = 1, s = t.length; i < s; i++) {
                        for (var n = t[i], a = i - 1; a >= 0 && !(t[a].aabb.lowerBound[e] <= n.aabb.lowerBound[e]); a--) t[a + 1] = t[a];
                        t[a + 1] = n
                    }
                    return t
                }, s.prototype.sortList = function() {
                    var t = this.axisList,
                        e = this.axisIndex;
                    s.sortAxisList(t, e)
                }, s.prototype.getCollisionPairs = function(t) {
                    var e = this.axisList,
                        i = this.result,
                        s = this.axisIndex;
                    i.length = 0;
                    for (var n = e.length; n--;) {
                        var o = e[n];
                        o.aabbNeedsUpdate && o.updateAABB()
                    }
                    this.sortList();
                    for (var r = 0, h = 0 | e.length; r !== h; r++)
                        for (var l = e[r], c = r + 1; c < h; c++) {
                            var u = e[c],
                                d = u.aabb.lowerBound[s] <= l.aabb.upperBound[s];
                            if (!d) break;
                            a.canCollide(l, u) && this.boundingVolumeCheck(l, u) && i.push(l, u)
                        }
                    return i
                }, s.prototype.aabbQuery = function(t, e, i) {
                    i = i || [], this.sortList();
                    var s = this.axisIndex,
                        n = "x";
                    1 === s && (n = "y"), 2 === s && (n = "z");
                    for (var a = this.axisList, o = e.lowerBound[n], r = e.upperBound[n], h = 0; h < a.length; h++) {
                        var l = a[h];
                        l.aabbNeedsUpdate && l.updateAABB(), l.aabb.overlaps(e) && i.push(l)
                    }
                    return i
                }
            }, {
                "../collision/Broadphase": 8,
                "../utils/Utils": 57
            }],
            14: [function(t, e, i) {
                function s(t, e, i, s) {
                    this.type = i, s = n.defaults(s, {
                        collideConnected: !0,
                        wakeUpBodies: !0
                    }), this.equations = [], this.bodyA = t, this.bodyB = e, this.collideConnected = s.collideConnected, s.wakeUpBodies && (t && t.wakeUp(), e && e.wakeUp())
                }
                e.exports = s;
                var n = t("../utils/Utils");
                s.prototype.update = function() {
                    throw new Error("method update() not implmemented in this Constraint subclass!")
                }, s.DISTANCE = 1, s.GEAR = 2, s.LOCK = 3, s.PRISMATIC = 4, s.REVOLUTE = 5, s.prototype.setStiffness = function(t) {
                    for (var e = this.equations, i = 0; i !== e.length; i++) {
                        var s = e[i];
                        s.stiffness = t, s.needsUpdate = !0
                    }
                }, s.prototype.setRelaxation = function(t) {
                    for (var e = this.equations, i = 0; i !== e.length; i++) {
                        var s = e[i];
                        s.relaxation = t, s.needsUpdate = !0
                    }
                }
            }, {
                "../utils/Utils": 57
            }],
            15: [function(t, e, i) {
                function s(t, e, i) {
                    i = r.defaults(i, {
                        localAnchorA: [0, 0],
                        localAnchorB: [0, 0]
                    }), n.call(this, t, e, n.DISTANCE, i), this.localAnchorA = o.fromValues(i.localAnchorA[0], i.localAnchorA[1]), this.localAnchorB = o.fromValues(i.localAnchorB[0], i.localAnchorB[1]);
                    var s = this.localAnchorA,
                        h = this.localAnchorB;
                    if (this.distance = 0, "number" == typeof i.distance) this.distance = i.distance;
                    else {
                        var l = o.create(),
                            c = o.create(),
                            u = o.create();
                        o.rotate(l, s, t.angle), o.rotate(c, h, e.angle), o.add(u, e.position, c), o.sub(u, u, l), o.sub(u, u, t.position), this.distance = o.length(u)
                    }
                    var d;
                    d = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce;
                    var p = new a(t, e, -d, d);
                    this.equations = [p], this.maxForce = d;
                    var u = o.create(),
                        f = o.create(),
                        g = o.create(),
                        y = this;
                    p.computeGq = function() {
                        var t = this.bodyA,
                            e = this.bodyB,
                            i = t.position,
                            n = e.position;
                        return o.rotate(f, s, t.angle), o.rotate(g, h, e.angle), o.add(u, n, g), o.sub(u, u, f), o.sub(u, u, i), o.length(u) - y.distance
                    }, this.setMaxForce(d), this.upperLimitEnabled = !1, this.upperLimit = 1, this.lowerLimitEnabled = !1, this.lowerLimit = 0, this.position = 0
                }
                var n = t("./Constraint"),
                    a = t("../equations/Equation"),
                    o = t("../math/vec2"),
                    r = t("../utils/Utils");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s;
                var h = o.create(),
                    l = o.create(),
                    c = o.create();
                s.prototype.update = function() {
                    var t = this.equations[0],
                        e = this.bodyA,
                        i = this.bodyB,
                        s = this.distance,
                        n = e.position,
                        a = i.position,
                        r = this.equations[0],
                        u = t.G;
                    o.rotate(l, this.localAnchorA, e.angle), o.rotate(c, this.localAnchorB, i.angle), o.add(h, a, c), o.sub(h, h, l), o.sub(h, h, n), this.position = o.length(h);
                    var d = !1;
                    if (this.upperLimitEnabled && this.position > this.upperLimit && (r.maxForce = 0, r.minForce = -this.maxForce, this.distance = this.upperLimit, d = !0), this.lowerLimitEnabled && this.position < this.lowerLimit && (r.maxForce = this.maxForce, r.minForce = 0, this.distance = this.lowerLimit, d = !0), (this.lowerLimitEnabled || this.upperLimitEnabled) && !d) return void(r.enabled = !1);
                    r.enabled = !0, o.normalize(h, h);
                    var p = o.crossLength(l, h),
                        f = o.crossLength(c, h);
                    u[0] = -h[0], u[1] = -h[1], u[2] = -p, u[3] = h[0], u[4] = h[1], u[5] = f
                }, s.prototype.setMaxForce = function(t) {
                    var e = this.equations[0];
                    e.minForce = -t, e.maxForce = t
                }, s.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                }
            }, {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Constraint": 14
            }],
            16: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, n.GEAR, i), this.ratio = void 0 !== i.ratio ? i.ratio : 1, this.angle = void 0 !== i.angle ? i.angle : e.angle - this.ratio * t.angle, i.angle = this.angle, i.ratio = this.ratio, this.equations = [new o(t, e, i)], void 0 !== i.maxTorque && this.setMaxTorque(i.maxTorque)
                }
                var n = t("./Constraint"),
                    a = t("../equations/Equation"),
                    o = t("../equations/AngleLockEquation"),
                    r = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.update = function() {
                    var t = this.equations[0];
                    t.ratio !== this.ratio && t.setRatio(this.ratio), t.angle = this.angle
                }, s.prototype.setMaxTorque = function(t) {
                    this.equations[0].setMaxTorque(t)
                }, s.prototype.getMaxTorque = function(t) {
                    return this.equations[0].maxForce
                }
            }, {
                "../equations/AngleLockEquation": 20,
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            17: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, n.LOCK, i);
                    var s = void 0 === i.maxForce ? Number.MAX_VALUE : i.maxForce,
                        r = i.localAngleB || 0,
                        h = new o(t, e, -s, s),
                        l = new o(t, e, -s, s),
                        c = new o(t, e, -s, s),
                        u = a.create(),
                        d = a.create(),
                        p = this;
                    h.computeGq = function() {
                        return a.rotate(u, p.localOffsetB, t.angle), a.sub(d, e.position, t.position), a.sub(d, d, u), d[0]
                    }, l.computeGq = function() {
                        return a.rotate(u, p.localOffsetB, t.angle), a.sub(d, e.position, t.position), a.sub(d, d, u), d[1]
                    };
                    var f = a.create(),
                        g = a.create();
                    c.computeGq = function() {
                        return a.rotate(f, p.localOffsetB, e.angle - p.localAngleB), a.scale(f, f, -1), a.sub(d, t.position, e.position), a.add(d, d, f), a.rotate(g, f, -Math.PI / 2), a.normalize(g, g), a.dot(d, g)
                    }, this.localOffsetB = a.create(), i.localOffsetB ? a.copy(this.localOffsetB, i.localOffsetB) : (a.sub(this.localOffsetB, e.position, t.position), a.rotate(this.localOffsetB, this.localOffsetB, -t.angle)), this.localAngleB = 0, "number" == typeof i.localAngleB ? this.localAngleB = i.localAngleB : this.localAngleB = e.angle - t.angle, this.equations.push(h, l, c), this.setMaxForce(s)
                }
                var n = t("./Constraint"),
                    a = t("../math/vec2"),
                    o = t("../equations/Equation");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.setMaxForce = function(t) {
                    for (var e = this.equations, i = 0; i < this.equations.length; i++) e[i].maxForce = t, e[i].minForce = -t
                }, s.prototype.getMaxForce = function() {
                    return this.equations[0].maxForce
                };
                var r = a.create(),
                    h = a.create(),
                    l = a.create(),
                    c = a.fromValues(1, 0),
                    u = a.fromValues(0, 1);
                s.prototype.update = function() {
                    var t = this.equations[0],
                        e = this.equations[1],
                        i = this.equations[2],
                        s = this.bodyA,
                        n = this.bodyB;
                    a.rotate(r, this.localOffsetB, s.angle), a.rotate(h, this.localOffsetB, n.angle - this.localAngleB), a.scale(h, h, -1), a.rotate(l, h, Math.PI / 2), a.normalize(l, l), t.G[0] = -1, t.G[1] = 0, t.G[2] = -a.crossLength(r, c), t.G[3] = 1, e.G[0] = 0, e.G[1] = -1, e.G[2] = -a.crossLength(r, u), e.G[4] = 1, i.G[0] = -l[0], i.G[1] = -l[1], i.G[3] = l[0], i.G[4] = l[1], i.G[5] = a.crossLength(h, l)
                }
            }, {
                "../equations/Equation": 22,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            18: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, n.PRISMATIC, i);
                    var s = r.fromValues(0, 0),
                        l = r.fromValues(1, 0),
                        c = r.fromValues(0, 0);
                    i.localAnchorA && r.copy(s, i.localAnchorA), i.localAxisA && r.copy(l, i.localAxisA), i.localAnchorB && r.copy(c, i.localAnchorB), this.localAnchorA = s, this.localAnchorB = c, this.localAxisA = l;
                    var u = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE,
                        d = new o(t, e, -u, u),
                        p = new r.create,
                        f = new r.create,
                        g = new r.create,
                        y = new r.create;
                    if (d.computeGq = function() {
                            return r.dot(g, y)
                        }, d.updateJacobian = function() {
                            var i = this.G,
                                n = t.position,
                                a = e.position;
                            r.rotate(p, s, t.angle), r.rotate(f, c, e.angle), r.add(g, a, f), r.sub(g, g, n), r.sub(g, g, p), r.rotate(y, l, t.angle + Math.PI / 2), i[0] = -y[0], i[1] = -y[1], i[2] = -r.crossLength(p, y) + r.crossLength(y, g), i[3] = y[0], i[4] = y[1], i[5] = r.crossLength(f, y)
                        }, this.equations.push(d), !i.disableRotationalLock) {
                        var m = new h(t, e, -u, u);
                        this.equations.push(m)
                    }
                    this.position = 0, this.velocity = 0, this.lowerLimitEnabled = void 0 !== i.lowerLimit, this.upperLimitEnabled = void 0 !== i.upperLimit, this.lowerLimit = void 0 !== i.lowerLimit ? i.lowerLimit : 0, this.upperLimit = void 0 !== i.upperLimit ? i.upperLimit : 1, this.upperLimitEquation = new a(t, e), this.lowerLimitEquation = new a(t, e), this.upperLimitEquation.minForce = this.lowerLimitEquation.minForce = 0, this.upperLimitEquation.maxForce = this.lowerLimitEquation.maxForce = u, this.motorEquation = new o(t, e), this.motorEnabled = !1, this.motorSpeed = 0;
                    var v = this,
                        b = this.motorEquation,
                        x = b.computeGW;
                    b.computeGq = function() {
                        return 0
                    }, b.computeGW = function() {
                        var t = this.G,
                            e = this.bodyA,
                            i = this.bodyB,
                            s = e.velocity,
                            n = i.velocity,
                            a = e.angularVelocity,
                            o = i.angularVelocity;
                        return this.gmult(t, s, a, n, o) + v.motorSpeed
                    }
                }
                var n = t("./Constraint"),
                    a = t("../equations/ContactEquation"),
                    o = t("../equations/Equation"),
                    r = t("../math/vec2"),
                    h = t("../equations/RotationalLockEquation");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s;
                var l = r.create(),
                    c = r.create(),
                    u = r.create(),
                    d = r.create(),
                    p = r.create(),
                    f = r.create();
                s.prototype.update = function() {
                    var t = this.equations,
                        e = t[0],
                        i = this.upperLimit,
                        s = this.lowerLimit,
                        n = this.upperLimitEquation,
                        a = this.lowerLimitEquation,
                        o = this.bodyA,
                        h = this.bodyB,
                        g = this.localAxisA,
                        y = this.localAnchorA,
                        m = this.localAnchorB;
                    e.updateJacobian(), r.rotate(l, g, o.angle), r.rotate(d, y, o.angle), r.add(c, d, o.position), r.rotate(p, m, h.angle), r.add(u, p, h.position);
                    var v = this.position = r.dot(u, l) - r.dot(c, l);
                    if (this.motorEnabled) {
                        var b = this.motorEquation.G;
                        b[0] = l[0], b[1] = l[1], b[2] = r.crossLength(l, p), b[3] = -l[0], b[4] = -l[1], b[5] = -r.crossLength(l, d)
                    }
                    if (this.upperLimitEnabled && v > i) r.scale(n.normalA, l, -1), r.sub(n.contactPointA, c, o.position), r.sub(n.contactPointB, u, h.position), r.scale(f, l, i), r.add(n.contactPointA, n.contactPointA, f), -1 === t.indexOf(n) && t.push(n);
                    else {
                        var x = t.indexOf(n); - 1 !== x && t.splice(x, 1)
                    }
                    if (this.lowerLimitEnabled && v < s) r.scale(a.normalA, l, 1), r.sub(a.contactPointA, c, o.position), r.sub(a.contactPointB, u, h.position), r.scale(f, l, s), r.sub(a.contactPointB, a.contactPointB, f), -1 === t.indexOf(a) && t.push(a);
                    else {
                        var x = t.indexOf(a); - 1 !== x && t.splice(x, 1)
                    }
                }, s.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                }, s.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1), this.motorEnabled = !1
                    }
                }, s.prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
                }
            }, {
                "../equations/ContactEquation": 21,
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            19: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, n.REVOLUTE, i);
                    var s = this.maxForce = void 0 !== i.maxForce ? i.maxForce : Number.MAX_VALUE;
                    this.pivotA = h.create(), this.pivotB = h.create(), i.worldPivot ? (h.sub(this.pivotA, i.worldPivot, t.position), h.sub(this.pivotB, i.worldPivot, e.position), h.rotate(this.pivotA, this.pivotA, -t.angle), h.rotate(this.pivotB, this.pivotB, -e.angle)) : (h.copy(this.pivotA, i.localPivotA), h.copy(this.pivotB, i.localPivotB));
                    var f = this.equations = [new a(t, e, -s, s), new a(t, e, -s, s)],
                        g = f[0],
                        y = f[1],
                        m = this;
                    g.computeGq = function() {
                        return h.rotate(l, m.pivotA, t.angle), h.rotate(c, m.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, u)
                    }, y.computeGq = function() {
                        return h.rotate(l, m.pivotA, t.angle), h.rotate(c, m.pivotB, e.angle), h.add(p, e.position, c), h.sub(p, p, t.position), h.sub(p, p, l), h.dot(p, d)
                    }, y.minForce = g.minForce = -s, y.maxForce = g.maxForce = s, this.motorEquation = new o(t, e), this.motorEnabled = !1, this.angle = 0, this.lowerLimitEnabled = !1, this.upperLimitEnabled = !1, this.lowerLimit = 0, this.upperLimit = 0, this.upperLimitEquation = new r(t, e), this.lowerLimitEquation = new r(t, e), this.upperLimitEquation.minForce = 0, this.lowerLimitEquation.maxForce = 0
                }
                var n = t("./Constraint"),
                    a = t("../equations/Equation"),
                    o = t("../equations/RotationalVelocityEquation"),
                    r = t("../equations/RotationalLockEquation"),
                    h = t("../math/vec2");
                e.exports = s;
                var l = h.create(),
                    c = h.create(),
                    u = h.fromValues(1, 0),
                    d = h.fromValues(0, 1),
                    p = h.create();
                s.prototype = new n, s.prototype.constructor = s, s.prototype.setLimits = function(t, e) {
                    "number" == typeof t ? (this.lowerLimit = t, this.lowerLimitEnabled = !0) : (this.lowerLimit = t, this.lowerLimitEnabled = !1), "number" == typeof e ? (this.upperLimit = e, this.upperLimitEnabled = !0) : (this.upperLimit = e, this.upperLimitEnabled = !1)
                }, s.prototype.update = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = this.pivotA,
                        s = this.pivotB,
                        n = this.equations,
                        a = n[0],
                        o = n[1],
                        r = n[0],
                        p = n[1],
                        f = this.upperLimit,
                        g = this.lowerLimit,
                        y = this.upperLimitEquation,
                        m = this.lowerLimitEquation,
                        v = this.angle = e.angle - t.angle;
                    if (this.upperLimitEnabled && v > f) y.angle = f, -1 === n.indexOf(y) && n.push(y);
                    else {
                        var b = n.indexOf(y); - 1 !== b && n.splice(b, 1)
                    }
                    if (this.lowerLimitEnabled && v < g) m.angle = g, -1 === n.indexOf(m) && n.push(m);
                    else {
                        var b = n.indexOf(m); - 1 !== b && n.splice(b, 1)
                    }
                    h.rotate(l, i, t.angle), h.rotate(c, s, e.angle), r.G[0] = -1, r.G[1] = 0, r.G[2] = -h.crossLength(l, u), r.G[3] = 1, r.G[4] = 0, r.G[5] = h.crossLength(c, u), p.G[0] = 0, p.G[1] = -1, p.G[2] = -h.crossLength(l, d), p.G[3] = 0, p.G[4] = 1, p.G[5] = h.crossLength(c, d)
                }, s.prototype.enableMotor = function() {
                    this.motorEnabled || (this.equations.push(this.motorEquation), this.motorEnabled = !0)
                }, s.prototype.disableMotor = function() {
                    if (this.motorEnabled) {
                        var t = this.equations.indexOf(this.motorEquation);
                        this.equations.splice(t, 1), this.motorEnabled = !1
                    }
                }, s.prototype.motorIsEnabled = function() {
                    return !!this.motorEnabled
                }, s.prototype.setMotorSpeed = function(t) {
                    if (this.motorEnabled) {
                        var e = this.equations.indexOf(this.motorEquation);
                        this.equations[e].relativeVelocity = t
                    }
                }, s.prototype.getMotorSpeed = function() {
                    return !!this.motorEnabled && this.motorEquation.relativeVelocity
                }
            }, {
                "../equations/Equation": 22,
                "../equations/RotationalLockEquation": 24,
                "../equations/RotationalVelocityEquation": 25,
                "../math/vec2": 30,
                "./Constraint": 14
            }],
            20: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0, this.ratio = "number" == typeof i.ratio ? i.ratio : 1, this.setRatio(this.ratio)
                }
                var n = t("./Equation"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeGq = function() {
                    return this.ratio * this.bodyA.angle - this.bodyB.angle + this.angle
                }, s.prototype.setRatio = function(t) {
                    var e = this.G;
                    e[2] = t, e[5] = -1, this.ratio = t
                }, s.prototype.setMaxTorque = function(t) {
                    this.maxForce = t, this.minForce = -t
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            21: [function(t, e, i) {
                function s(t, e) {
                    n.call(this, t, e, 0, Number.MAX_VALUE), this.contactPointA = a.create(), this.penetrationVec = a.create(), this.contactPointB = a.create(), this.normalA = a.create(), this.restitution = 0, this.firstImpact = !1, this.shapeA = null, this.shapeB = null
                }
                var n = t("./Equation"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeB = function(t, e, i) {
                    var s = this.bodyA,
                        n = this.bodyB,
                        o = this.contactPointA,
                        r = this.contactPointB,
                        h = s.position,
                        l = n.position,
                        c = this.penetrationVec,
                        u = this.normalA,
                        d = this.G,
                        p = a.crossLength(o, u),
                        f = a.crossLength(r, u);
                    d[0] = -u[0], d[1] = -u[1], d[2] = -p, d[3] = u[0], d[4] = u[1], d[5] = f, a.add(c, l, r), a.sub(c, c, h), a.sub(c, c, o);
                    var g, y;
                    return this.firstImpact && 0 !== this.restitution ? (y = 0, g = 1 / e * (1 + this.restitution) * this.computeGW()) : (y = a.dot(u, c) + this.offset, g = this.computeGW()), -y * t - g * e - i * this.computeGiMf()
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            22: [function(t, e, i) {
                function s(t, e, i, n) {
                    this.minForce = void 0 === i ? -Number.MAX_VALUE : i, this.maxForce = void 0 === n ? Number.MAX_VALUE : n, this.bodyA = t, this.bodyB = e, this.stiffness = s.DEFAULT_STIFFNESS, this.relaxation = s.DEFAULT_RELAXATION, this.G = new a.ARRAY_TYPE(6);
                    for (var o = 0; o < 6; o++) this.G[o] = 0;
                    this.offset = 0, this.a = 0, this.b = 0, this.epsilon = 0, this.timeStep = 1 / 60, this.needsUpdate = !0, this.multiplier = 0, this.relativeVelocity = 0, this.enabled = !0
                }
                e.exports = s;
                var n = t("../math/vec2"),
                    a = t("../utils/Utils"),
                    o = t("../objects/Body");
                s.prototype.constructor = s, s.DEFAULT_STIFFNESS = 1e6, s.DEFAULT_RELAXATION = 4, s.prototype.update = function() {
                    var t = this.stiffness,
                        e = this.relaxation,
                        i = this.timeStep;
                    this.a = 4 / (i * (1 + 4 * e)), this.b = 4 * e / (1 + 4 * e), this.epsilon = 4 / (i * i * t * (1 + 4 * e)), this.needsUpdate = !1
                }, s.prototype.gmult = function(t, e, i, s, n) {
                    return t[0] * e[0] + t[1] * e[1] + t[2] * i + t[3] * s[0] + t[4] * s[1] + t[5] * n
                }, s.prototype.computeB = function(t, e, i) {
                    var s = this.computeGW();
                    return -this.computeGq() * t - s * e - this.computeGiMf() * i
                };
                var r = n.create(),
                    h = n.create();
                s.prototype.computeGq = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.position,
                        n = i.position,
                        a = e.angle,
                        o = i.angle;
                    return this.gmult(t, r, a, h, o) + this.offset
                }, s.prototype.computeGW = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.velocity,
                        n = i.velocity,
                        a = e.angularVelocity,
                        o = i.angularVelocity;
                    return this.gmult(t, s, a, n, o) + this.relativeVelocity
                }, s.prototype.computeGWlambda = function() {
                    var t = this.G,
                        e = this.bodyA,
                        i = this.bodyB,
                        s = e.vlambda,
                        n = i.vlambda,
                        a = e.wlambda,
                        o = i.wlambda;
                    return this.gmult(t, s, a, n, o)
                };
                var l = n.create(),
                    c = n.create();
                s.prototype.computeGiMf = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.force,
                        s = t.angularForce,
                        a = e.force,
                        o = e.angularForce,
                        r = t.invMassSolve,
                        h = e.invMassSolve,
                        u = t.invInertiaSolve,
                        d = e.invInertiaSolve,
                        p = this.G;
                    return n.scale(l, i, r), n.multiply(l, t.massMultiplier, l), n.scale(c, a, h), n.multiply(c, e.massMultiplier, c), this.gmult(p, l, s * u, c, o * d)
                }, s.prototype.computeGiMGt = function() {
                    var t = this.bodyA,
                        e = this.bodyB,
                        i = t.invMassSolve,
                        s = e.invMassSolve,
                        n = t.invInertiaSolve,
                        a = e.invInertiaSolve,
                        o = this.G;
                    return o[0] * o[0] * i * t.massMultiplier[0] + o[1] * o[1] * i * t.massMultiplier[1] + o[2] * o[2] * n + o[3] * o[3] * s * e.massMultiplier[0] + o[4] * o[4] * s * e.massMultiplier[1] + o[5] * o[5] * a
                };
                var u = n.create(),
                    d = n.create(),
                    p = n.create(),
                    f = n.create(),
                    g = n.create(),
                    y = n.create();
                s.prototype.addToWlambda = function(t) {
                    var e = this.bodyA,
                        i = this.bodyB,
                        s = u,
                        a = d,
                        o = p,
                        r = f,
                        h = g,
                        l = e.invMassSolve,
                        c = i.invMassSolve,
                        m = e.invInertiaSolve,
                        v = i.invInertiaSolve,
                        b = y,
                        x = this.G;
                    a[0] = x[0], a[1] = x[1], o[0] = x[3], o[1] = x[4], n.scale(s, a, l * t), n.multiply(s, s, e.massMultiplier), n.add(e.vlambda, e.vlambda, s), e.wlambda += m * x[2] * t, n.scale(s, o, c * t), n.multiply(s, s, i.massMultiplier), n.add(i.vlambda, i.vlambda, s), i.wlambda += v * x[5] * t
                }, s.prototype.computeInvC = function(t) {
                    return 1 / (this.computeGiMGt() + t)
                }
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            23: [function(t, e, i) {
                function s(t, e, i) {
                    a.call(this, t, e, -i, i), this.contactPointA = n.create(), this.contactPointB = n.create(), this.t = n.create(), this.contactEquations = [], this.shapeA = null, this.shapeB = null, this.frictionCoefficient = .3
                }
                var n = t("../math/vec2"),
                    a = t("./Equation"),
                    o = t("../utils/Utils");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.setSlipForce = function(t) {
                    this.maxForce = t, this.minForce = -t
                }, s.prototype.getSlipForce = function() {
                    return this.maxForce
                }, s.prototype.computeB = function(t, e, i) {
                    var s = this.bodyA,
                        a = this.bodyB,
                        o = this.contactPointA,
                        r = this.contactPointB,
                        h = this.t,
                        l = this.G;
                    return l[0] = -h[0], l[1] = -h[1], l[2] = -n.crossLength(o, h), l[3] = h[0], l[4] = h[1], l[5] = n.crossLength(r, h), -this.computeGW() * e - i * this.computeGiMf()
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Equation": 22
            }],
            24: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.angle = i.angle || 0;
                    var s = this.G;
                    s[2] = 1, s[5] = -1
                }
                var n = t("./Equation"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s;
                var o = a.create(),
                    r = a.create(),
                    h = a.fromValues(1, 0),
                    l = a.fromValues(0, 1);
                s.prototype.computeGq = function() {
                    return a.rotate(o, h, this.bodyA.angle + this.angle), a.rotate(r, l, this.bodyB.angle), a.dot(o, r)
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            25: [function(t, e, i) {
                function s(t, e) {
                    n.call(this, t, e, -Number.MAX_VALUE, Number.MAX_VALUE), this.relativeVelocity = 1, this.ratio = 1
                }
                var n = t("./Equation"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeB = function(t, e, i) {
                    var s = this.G;
                    s[2] = -1, s[5] = this.ratio;
                    var n = this.computeGiMf();
                    return -this.computeGW() * e - i * n
                }
            }, {
                "../math/vec2": 30,
                "./Equation": 22
            }],
            26: [function(t, e, i) {
                var s = function() {};
                e.exports = s, s.prototype = {
                    constructor: s,
                    on: function(t, e, i) {
                        e.context = i || this, void 0 === this._listeners && (this._listeners = {});
                        var s = this._listeners;
                        return void 0 === s[t] && (s[t] = []), -1 === s[t].indexOf(e) && s[t].push(e), this
                    },
                    has: function(t, e) {
                        if (void 0 === this._listeners) return !1;
                        var i = this._listeners;
                        if (e) {
                            if (void 0 !== i[t] && -1 !== i[t].indexOf(e)) return !0
                        } else if (void 0 !== i[t]) return !0;
                        return !1
                    },
                    off: function(t, e) {
                        if (void 0 === this._listeners) return this;
                        var i = this._listeners,
                            s = i[t].indexOf(e);
                        return -1 !== s && i[t].splice(s, 1), this
                    },
                    emit: function(t) {
                        if (void 0 === this._listeners) return this;
                        var e = this._listeners,
                            i = e[t.type];
                        if (void 0 !== i) {
                            t.target = this;
                            for (var s = 0, n = i.length; s < n; s++) {
                                var a = i[s];
                                a.call(a.context, t)
                            }
                        }
                        return this
                    }
                }
            }, {}],
            27: [function(t, e, i) {
                function s(t, e, i) {
                    if (i = i || {}, !(t instanceof n && e instanceof n)) throw new Error("First two arguments must be Material instances.");
                    this.id = s.idCounter++, this.materialA = t, this.materialB = e, this.friction = void 0 !== i.friction ? Number(i.friction) : .3, this.restitution = void 0 !== i.restitution ? Number(i.restitution) : 0, this.stiffness = void 0 !== i.stiffness ? Number(i.stiffness) : a.DEFAULT_STIFFNESS, this.relaxation = void 0 !== i.relaxation ? Number(i.relaxation) : a.DEFAULT_RELAXATION, this.frictionStiffness = void 0 !== i.frictionStiffness ? Number(i.frictionStiffness) : a.DEFAULT_STIFFNESS, this.frictionRelaxation = void 0 !== i.frictionRelaxation ? Number(i.frictionRelaxation) : a.DEFAULT_RELAXATION, this.surfaceVelocity = void 0 !== i.surfaceVelocity ? Number(i.surfaceVelocity) : 0, this.contactSkinSize = .005
                }
                var n = t("./Material"),
                    a = t("../equations/Equation");
                e.exports = s, s.idCounter = 0
            }, {
                "../equations/Equation": 22,
                "./Material": 28
            }],
            28: [function(t, e, i) {
                function s(t) {
                    this.id = t || s.idCounter++
                }
                e.exports = s, s.idCounter = 0
            }, {}],
            29: [function(t, e, i) {
                var s = {};
                s.GetArea = function(t) {
                    if (t.length < 6) return 0;
                    for (var e = t.length - 2, i = 0, s = 0; s < e; s += 2) i += (t[s + 2] - t[s]) * (t[s + 1] + t[s + 3]);
                    return .5 * -(i += (t[0] - t[e]) * (t[e + 1] + t[1]))
                }, s.Triangulate = function(t) {
                    var e = t.length >> 1;
                    if (e < 3) return [];
                    for (var i = [], n = [], a = 0; a < e; a++) n.push(a);
                    for (var a = 0, o = e; o > 3;) {
                        var r = n[(a + 0) % o],
                            h = n[(a + 1) % o],
                            l = n[(a + 2) % o],
                            c = t[2 * r],
                            u = t[2 * r + 1],
                            d = t[2 * h],
                            p = t[2 * h + 1],
                            f = t[2 * l],
                            g = t[2 * l + 1],
                            y = !1;
                        if (s._convex(c, u, d, p, f, g)) {
                            y = !0;
                            for (var m = 0; m < o; m++) {
                                var v = n[m];
                                if (v != r && v != h && v != l && s._PointInTriangle(t[2 * v], t[2 * v + 1], c, u, d, p, f, g)) {
                                    y = !1;
                                    break
                                }
                            }
                        }
                        if (y) i.push(r, h, l), n.splice((a + 1) % o, 1), o--, a = 0;
                        else if (a++ > 3 * o) break
                    }
                    return i.push(n[0], n[1], n[2]), i
                }, s._PointInTriangle = function(t, e, i, s, n, a, o, r) {
                    var h = o - i,
                        l = r - s,
                        c = n - i,
                        u = a - s,
                        d = t - i,
                        p = e - s,
                        f = h * h + l * l,
                        g = h * c + l * u,
                        y = h * d + l * p,
                        m = c * c + u * u,
                        v = c * d + u * p,
                        b = 1 / (f * m - g * g),
                        x = (m * y - g * v) * b,
                        _ = (f * v - g * y) * b;
                    return x >= 0 && _ >= 0 && x + _ < 1
                }, s._convex = function(t, e, i, s, n, a) {
                    return (e - s) * (n - i) + (i - t) * (a - s) >= 0
                }, e.exports = s
            }, {}],
            30: [function(t, e, i) {
                var s = e.exports = {},
                    n = t("../utils/Utils");
                s.crossLength = function(t, e) {
                    return t[0] * e[1] - t[1] * e[0]
                }, s.crossVZ = function(t, e, i) {
                    return s.rotate(t, e, -Math.PI / 2), s.scale(t, t, i), t
                }, s.crossZV = function(t, e, i) {
                    return s.rotate(t, i, Math.PI / 2), s.scale(t, t, e), t
                }, s.rotate = function(t, e, i) {
                    if (0 !== i) {
                        var s = Math.cos(i),
                            n = Math.sin(i),
                            a = e[0],
                            o = e[1];
                        t[0] = s * a - n * o, t[1] = n * a + s * o
                    } else t[0] = e[0], t[1] = e[1]
                }, s.rotate90cw = function(t, e) {
                    var i = e[0],
                        s = e[1];
                    t[0] = s, t[1] = -i
                }, s.toLocalFrame = function(t, e, i, n) {
                    s.copy(t, e), s.sub(t, t, i), s.rotate(t, t, -n)
                }, s.toGlobalFrame = function(t, e, i, n) {
                    s.copy(t, e), s.rotate(t, t, n), s.add(t, t, i)
                }, s.vectorToLocalFrame = function(t, e, i) {
                    s.rotate(t, e, -i)
                }, s.vectorToGlobalFrame = function(t, e, i) {
                    s.rotate(t, e, i)
                }, s.centroid = function(t, e, i, n) {
                    return s.add(t, e, i), s.add(t, t, n), s.scale(t, t, 1 / 3), t
                }, s.create = function() {
                    var t = new n.ARRAY_TYPE(2);
                    return t[0] = 0, t[1] = 0, t
                }, s.clone = function(t) {
                    var e = new n.ARRAY_TYPE(2);
                    return e[0] = t[0], e[1] = t[1], e
                }, s.fromValues = function(t, e) {
                    var i = new n.ARRAY_TYPE(2);
                    return i[0] = t, i[1] = e, i
                }, s.copy = function(t, e) {
                    return t[0] = e[0], t[1] = e[1], t
                }, s.set = function(t, e, i) {
                    return t[0] = e, t[1] = i, t
                }, s.add = function(t, e, i) {
                    return t[0] = e[0] + i[0], t[1] = e[1] + i[1], t
                }, s.subtract = function(t, e, i) {
                    return t[0] = e[0] - i[0], t[1] = e[1] - i[1], t
                }, s.sub = s.subtract, s.multiply = function(t, e, i) {
                    return t[0] = e[0] * i[0], t[1] = e[1] * i[1], t
                }, s.mul = s.multiply, s.divide = function(t, e, i) {
                    return t[0] = e[0] / i[0], t[1] = e[1] / i[1], t
                }, s.div = s.divide, s.scale = function(t, e, i) {
                    return t[0] = e[0] * i, t[1] = e[1] * i, t
                }, s.distance = function(t, e) {
                    var i = e[0] - t[0],
                        s = e[1] - t[1];
                    return Math.sqrt(i * i + s * s)
                }, s.dist = s.distance, s.squaredDistance = function(t, e) {
                    var i = e[0] - t[0],
                        s = e[1] - t[1];
                    return i * i + s * s
                }, s.sqrDist = s.squaredDistance, s.length = function(t) {
                    var e = t[0],
                        i = t[1];
                    return Math.sqrt(e * e + i * i)
                }, s.len = s.length, s.squaredLength = function(t) {
                    var e = t[0],
                        i = t[1];
                    return e * e + i * i
                }, s.sqrLen = s.squaredLength, s.negate = function(t, e) {
                    return t[0] = -e[0], t[1] = -e[1], t
                }, s.normalize = function(t, e) {
                    var i = e[0],
                        s = e[1],
                        n = i * i + s * s;
                    return n > 0 && (n = 1 / Math.sqrt(n), t[0] = e[0] * n, t[1] = e[1] * n), t
                }, s.dot = function(t, e) {
                    return t[0] * e[0] + t[1] * e[1]
                }, s.str = function(t) {
                    return "vec2(" + t[0] + ", " + t[1] + ")"
                }, s.lerp = function(t, e, i, s) {
                    var n = e[0],
                        a = e[1];
                    return t[0] = n + s * (i[0] - n), t[1] = a + s * (i[1] - a), t
                }, s.reflect = function(t, e, i) {
                    var s = e[0] * i[0] + e[1] * i[1];
                    t[0] = e[0] - 2 * i[0] * s, t[1] = e[1] - 2 * i[1] * s
                }, s.getLineSegmentsIntersection = function(t, e, i, n, a) {
                    var o = s.getLineSegmentsIntersectionFraction(e, i, n, a);
                    return !(o < 0) && (t[0] = e[0] + o * (i[0] - e[0]), t[1] = e[1] + o * (i[1] - e[1]), !0)
                }, s.getLineSegmentsIntersectionFraction = function(t, e, i, s) {
                    var n = e[0] - t[0],
                        a = e[1] - t[1],
                        o = s[0] - i[0],
                        r = s[1] - i[1],
                        h, l;
                    return h = (-a * (t[0] - i[0]) + n * (t[1] - i[1])) / (-o * a + n * r), l = (o * (t[1] - i[1]) - r * (t[0] - i[0])) / (-o * a + n * r), h >= 0 && h <= 1 && l >= 0 && l <= 1 ? l : -1
                }
            }, {
                "../utils/Utils": 57
            }],
            31: [function(t, e, i) {
                function s(t) {
                    t = t || {}, c.call(this), this.id = t.id || ++s._idCounter, this.world = null, this.shapes = [], this.mass = t.mass || 0, this.invMass = 0, this.inertia = 0, this.invInertia = 0, this.invMassSolve = 0, this.invInertiaSolve = 0, this.fixedRotation = !!t.fixedRotation, this.fixedX = !!t.fixedX, this.fixedY = !!t.fixedY, this.massMultiplier = n.create(), this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.interpolatedPosition = n.fromValues(0, 0), this.interpolatedAngle = 0, this.previousPosition = n.fromValues(0, 0), this.previousAngle = 0, this.velocity = n.fromValues(0, 0), t.velocity && n.copy(this.velocity, t.velocity), this.vlambda = n.fromValues(0, 0), this.wlambda = 0, this.angle = t.angle || 0, this.angularVelocity = t.angularVelocity || 0, this.force = n.create(), t.force && n.copy(this.force, t.force), this.angularForce = t.angularForce || 0, this.damping = "number" == typeof t.damping ? t.damping : .1, this.angularDamping = "number" == typeof t.angularDamping ? t.angularDamping : .1, this.type = s.STATIC, void 0 !== t.type ? this.type = t.type : t.mass ? this.type = s.DYNAMIC : this.type = s.STATIC, this.boundingRadius = 0, this.aabb = new l, this.aabbNeedsUpdate = !0, this.allowSleep = void 0 === t.allowSleep || t.allowSleep, this.wantsToSleep = !1, this.sleepState = s.AWAKE, this.sleepSpeedLimit = void 0 !== t.sleepSpeedLimit ? t.sleepSpeedLimit : .2, this.sleepTimeLimit = void 0 !== t.sleepTimeLimit ? t.sleepTimeLimit : 1, this.gravityScale = void 0 !== t.gravityScale ? t.gravityScale : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.idleTime = 0, this.timeLastSleepy = 0, this.ccdSpeedThreshold = void 0 !== t.ccdSpeedThreshold ? t.ccdSpeedThreshold : -1, this.ccdIterations = void 0 !== t.ccdIterations ? t.ccdIterations : 10, this.concavePath = null, this._wakeUpAfterNarrowphase = !1, this.updateMassProperties()
                }
                var n = t("../math/vec2"),
                    a = t("poly-decomp"),
                    o = t("../shapes/Convex"),
                    r = t("../collision/RaycastResult"),
                    h = t("../collision/Ray"),
                    l = t("../collision/AABB"),
                    c = t("../events/EventEmitter");
                e.exports = s, s.prototype = new c, s.prototype.constructor = s, s._idCounter = 0, s.prototype.updateSolveMassProperties = function() {
                    this.sleepState === s.SLEEPING || this.type === s.KINEMATIC ? (this.invMassSolve = 0, this.invInertiaSolve = 0) : (this.invMassSolve = this.invMass, this.invInertiaSolve = this.invInertia)
                }, s.prototype.setDensity = function(t) {
                    var e = this.getArea();
                    this.mass = e * t, this.updateMassProperties()
                }, s.prototype.getArea = function() {
                    for (var t = 0, e = 0; e < this.shapes.length; e++) t += this.shapes[e].area;
                    return t
                }, s.prototype.getAABB = function() {
                    return this.aabbNeedsUpdate && this.updateAABB(), this.aabb
                };
                var u = new l,
                    d = n.create();
                s.prototype.updateAABB = function() {
                    for (var t = this.shapes, e = t.length, i = d, s = this.angle, a = 0; a !== e; a++) {
                        var o = t[a],
                            r = o.angle + s;
                        n.rotate(i, o.position, s), n.add(i, i, this.position), o.computeAABB(u, i, r), 0 === a ? this.aabb.copy(u) : this.aabb.extend(u)
                    }
                    this.aabbNeedsUpdate = !1
                }, s.prototype.updateBoundingRadius = function() {
                    for (var t = this.shapes, e = t.length, i = 0, s = 0; s !== e; s++) {
                        var a = t[s],
                            o = n.length(a.position),
                            r = a.boundingRadius;
                        o + r > i && (i = o + r)
                    }
                    this.boundingRadius = i
                }, s.prototype.addShape = function(t, e, i) {
                    if (t.body) throw new Error("A shape can only be added to one body.");
                    t.body = this, e ? n.copy(t.position, e) : n.set(t.position, 0, 0), t.angle = i || 0, this.shapes.push(t), this.updateMassProperties(), this.updateBoundingRadius(), this.aabbNeedsUpdate = !0
                }, s.prototype.removeShape = function(t) {
                    var e = this.shapes.indexOf(t);
                    return -1 !== e && (this.shapes.splice(e, 1), this.aabbNeedsUpdate = !0, t.body = null, !0)
                }, s.prototype.updateMassProperties = function() {
                    if (this.type === s.STATIC || this.type === s.KINEMATIC) this.mass = Number.MAX_VALUE, this.invMass = 0, this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                    else {
                        var t = this.shapes,
                            e = t.length,
                            i = this.mass / e,
                            a = 0;
                        if (this.fixedRotation) this.inertia = Number.MAX_VALUE, this.invInertia = 0;
                        else {
                            for (var o = 0; o < e; o++) {
                                var r = t[o],
                                    h = n.squaredLength(r.position);
                                a += r.computeMomentOfInertia(i) + i * h
                            }
                            this.inertia = a, this.invInertia = a > 0 ? 1 / a : 0
                        }
                        this.invMass = 1 / this.mass, n.set(this.massMultiplier, this.fixedX ? 0 : 1, this.fixedY ? 0 : 1)
                    }
                };
                var p = n.create();
                s.prototype.applyForce = function(t, e) {
                    if (n.add(this.force, this.force, t), e) {
                        var i = n.crossLength(e, t);
                        this.angularForce += i
                    }
                };
                var f = n.create(),
                    g = n.create(),
                    y = n.create();
                s.prototype.applyForceLocal = function(t, e) {
                    e = e || y;
                    var i = f,
                        s = g;
                    this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyForce(i, s)
                };
                var m = n.create();
                s.prototype.applyImpulse = function(t, e) {
                    if (this.type === s.DYNAMIC) {
                        var i = m;
                        if (n.scale(i, t, this.invMass), n.multiply(i, this.massMultiplier, i), n.add(this.velocity, i, this.velocity), e) {
                            var a = n.crossLength(e, t);
                            a *= this.invInertia, this.angularVelocity += a
                        }
                    }
                };
                var v = n.create(),
                    b = n.create(),
                    x = n.create();
                s.prototype.applyImpulseLocal = function(t, e) {
                    e = e || x;
                    var i = v,
                        s = b;
                    this.vectorToWorldFrame(i, t), this.vectorToWorldFrame(s, e), this.applyImpulse(i, s)
                }, s.prototype.toLocalFrame = function(t, e) {
                    n.toLocalFrame(t, e, this.position, this.angle)
                }, s.prototype.toWorldFrame = function(t, e) {
                    n.toGlobalFrame(t, e, this.position, this.angle)
                }, s.prototype.vectorToLocalFrame = function(t, e) {
                    n.vectorToLocalFrame(t, e, this.angle)
                }, s.prototype.vectorToWorldFrame = function(t, e) {
                    n.vectorToGlobalFrame(t, e, this.angle)
                }, s.prototype.fromPolygon = function(t, e) {
                    e = e || {};
                    for (var i = this.shapes.length; i >= 0; --i) this.removeShape(this.shapes[i]);
                    var s = new a.Polygon;
                    if (s.vertices = t, s.makeCCW(), "number" == typeof e.removeCollinearPoints && s.removeCollinearPoints(e.removeCollinearPoints), void 0 === e.skipSimpleCheck && !s.isSimple()) return !1;
                    this.concavePath = s.vertices.slice(0);
                    for (var i = 0; i < this.concavePath.length; i++) {
                        var r = [0, 0];
                        n.copy(r, this.concavePath[i]), this.concavePath[i] = r
                    }
                    var h;
                    h = e.optimalDecomp ? s.decomp() : s.quickDecomp();
                    for (var l = n.create(), i = 0; i !== h.length; i++) {
                        for (var c = new o({
                                vertices: h[i].vertices
                            }), u = 0; u !== c.vertices.length; u++) {
                            var r = c.vertices[u];
                            n.sub(r, r, c.centerOfMass)
                        }
                        n.scale(l, c.centerOfMass, 1), c.updateTriangles(), c.updateCenterOfMass(), c.updateBoundingRadius(), this.addShape(c, l)
                    }
                    return this.adjustCenterOfMass(), this.aabbNeedsUpdate = !0, !0
                };
                var _ = n.fromValues(0, 0),
                    w = n.fromValues(0, 0),
                    C = n.fromValues(0, 0),
                    P = n.fromValues(0, 0);
                s.prototype.adjustCenterOfMass = function() {
                    var t = w,
                        e = C,
                        i = P,
                        s = 0;
                    n.set(e, 0, 0);
                    for (var a = 0; a !== this.shapes.length; a++) {
                        var o = this.shapes[a];
                        n.scale(t, o.position, o.area), n.add(e, e, t), s += o.area
                    }
                    n.scale(i, e, 1 / s);
                    for (var a = 0; a !== this.shapes.length; a++) {
                        var o = this.shapes[a];
                        n.sub(o.position, o.position, i)
                    }
                    n.add(this.position, this.position, i);
                    for (var a = 0; this.concavePath && a < this.concavePath.length; a++) n.sub(this.concavePath[a], this.concavePath[a], i);
                    this.updateMassProperties(), this.updateBoundingRadius()
                }, s.prototype.setZeroForce = function() {
                    n.set(this.force, 0, 0), this.angularForce = 0
                }, s.prototype.resetConstraintVelocity = function() {
                    var t = this,
                        e = t.vlambda;
                    n.set(e, 0, 0), t.wlambda = 0
                }, s.prototype.addConstraintVelocity = function() {
                    var t = this,
                        e = t.velocity;
                    n.add(e, e, t.vlambda), t.angularVelocity += t.wlambda
                }, s.prototype.applyDamping = function(t) {
                    if (this.type === s.DYNAMIC) {
                        var e = this.velocity;
                        n.scale(e, e, Math.pow(1 - this.damping, t)), this.angularVelocity *= Math.pow(1 - this.angularDamping, t)
                    }
                }, s.prototype.wakeUp = function() {
                    var t = this.sleepState;
                    this.sleepState = s.AWAKE, this.idleTime = 0, t !== s.AWAKE && this.emit(s.wakeUpEvent)
                }, s.prototype.sleep = function() {
                    this.sleepState = s.SLEEPING, this.angularVelocity = 0, this.angularForce = 0, n.set(this.velocity, 0, 0), n.set(this.force, 0, 0), this.emit(s.sleepEvent)
                }, s.prototype.sleepTick = function(t, e, i) {
                    if (this.allowSleep && this.type !== s.SLEEPING) {
                        this.wantsToSleep = !1;
                        var a = this.sleepState;
                        n.squaredLength(this.velocity) + Math.pow(this.angularVelocity, 2) >= Math.pow(this.sleepSpeedLimit, 2) ? (this.idleTime = 0, this.sleepState = s.AWAKE) : (this.idleTime += i, this.sleepState = s.SLEEPY), this.idleTime > this.sleepTimeLimit && (e ? this.wantsToSleep = !0 : this.sleep())
                    }
                }, s.prototype.overlaps = function(t) {
                    return this.world.overlapKeeper.bodiesAreOverlapping(this, t)
                };
                var T = n.create(),
                    S = n.create();
                s.prototype.integrate = function(t) {
                    var e = this.invMass,
                        i = this.force,
                        s = this.position,
                        a = this.velocity;
                    n.copy(this.previousPosition, this.position), this.previousAngle = this.angle, this.fixedRotation || (this.angularVelocity += this.angularForce * this.invInertia * t), n.scale(T, i, t * e), n.multiply(T, this.massMultiplier, T), n.add(a, T, a), this.integrateToTimeOfImpact(t) || (n.scale(S, a, t), n.add(s, s, S), this.fixedRotation || (this.angle += this.angularVelocity * t)), this.aabbNeedsUpdate = !0
                };
                var A = new r,
                    E = new h({
                        mode: h.ALL
                    }),
                    I = n.create(),
                    M = n.create(),
                    O = n.create(),
                    B = n.create();
                s.prototype.integrateToTimeOfImpact = function(t) {
                    if (this.ccdSpeedThreshold < 0 || n.squaredLength(this.velocity) < Math.pow(this.ccdSpeedThreshold, 2)) return !1;
                    n.normalize(I, this.velocity), n.scale(M, this.velocity, t), n.add(M, M, this.position), n.sub(O, M, this.position);
                    var e = this.angularVelocity * t,
                        i = n.length(O),
                        s = 1,
                        a, o = this;
                    if (A.reset(), E.callback = function(t) {
                            t.body !== o && (a = t.body, t.getHitPoint(M, E), n.sub(O, M, o.position), s = n.length(O) / i, t.stop())
                        }, n.copy(E.from, this.position), n.copy(E.to, M), E.update(), this.world.raycast(A, E), !a) return !1;
                    var r = this.angle;
                    n.copy(B, this.position);
                    for (var h = 0, l = 0, c = 0, u = s; u >= l && h < this.ccdIterations;) {
                        h++, c = (u - l) / 2, n.scale(S, O, s), n.add(this.position, B, S), this.angle = r + e * s, this.updateAABB();
                        this.aabb.overlaps(a.aabb) && this.world.narrowphase.bodiesOverlap(this, a) ? l = c : u = c
                    }
                    return s = c, n.copy(this.position, B), this.angle = r, n.scale(S, O, s), n.add(this.position, this.position, S), this.fixedRotation || (this.angle += e * s), !0
                }, s.prototype.getVelocityAtPoint = function(t, e) {
                    return n.crossVZ(t, e, this.angularVelocity), n.subtract(t, this.velocity, t), t
                }, s.sleepyEvent = {
                    type: "sleepy"
                }, s.sleepEvent = {
                    type: "sleep"
                }, s.wakeUpEvent = {
                    type: "wakeup"
                }, s.DYNAMIC = 1, s.STATIC = 2, s.KINEMATIC = 4, s.AWAKE = 0, s.SLEEPY = 1, s.SLEEPING = 2
            }, {
                "../collision/AABB": 7,
                "../collision/Ray": 11,
                "../collision/RaycastResult": 12,
                "../events/EventEmitter": 26,
                "../math/vec2": 30,
                "../shapes/Convex": 40,
                "poly-decomp": 5
            }],
            32: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, a.call(this, t, e, i), this.localAnchorA = n.fromValues(0, 0), this.localAnchorB = n.fromValues(0, 0), i.localAnchorA && n.copy(this.localAnchorA, i.localAnchorA), i.localAnchorB && n.copy(this.localAnchorB, i.localAnchorB), i.worldAnchorA && this.setWorldAnchorA(i.worldAnchorA), i.worldAnchorB && this.setWorldAnchorB(i.worldAnchorB);
                    var s = n.create(),
                        o = n.create();
                    this.getWorldAnchorA(s), this.getWorldAnchorB(o);
                    var r = n.distance(s, o);
                    this.restLength = "number" == typeof i.restLength ? i.restLength : r
                }
                var n = t("../math/vec2"),
                    a = t("./Spring"),
                    o = t("../utils/Utils");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.setWorldAnchorA = function(t) {
                    this.bodyA.toLocalFrame(this.localAnchorA, t)
                }, s.prototype.setWorldAnchorB = function(t) {
                    this.bodyB.toLocalFrame(this.localAnchorB, t)
                }, s.prototype.getWorldAnchorA = function(t) {
                    this.bodyA.toWorldFrame(t, this.localAnchorA)
                }, s.prototype.getWorldAnchorB = function(t) {
                    this.bodyB.toWorldFrame(t, this.localAnchorB)
                };
                var r = n.create(),
                    h = n.create(),
                    l = n.create(),
                    c = n.create(),
                    u = n.create(),
                    d = n.create(),
                    p = n.create(),
                    f = n.create(),
                    g = n.create();
                s.prototype.applyForce = function() {
                    var t = this.stiffness,
                        e = this.damping,
                        i = this.restLength,
                        s = this.bodyA,
                        a = this.bodyB,
                        o = r,
                        y = h,
                        m = l,
                        v = c,
                        b = g,
                        x = u,
                        _ = d,
                        w = p,
                        C = f;
                    this.getWorldAnchorA(x), this.getWorldAnchorB(_), n.sub(w, x, s.position), n.sub(C, _, a.position), n.sub(o, _, x);
                    var P = n.len(o);
                    n.normalize(y, o), n.sub(m, a.velocity, s.velocity), n.crossZV(b, a.angularVelocity, C), n.add(m, m, b), n.crossZV(b, s.angularVelocity, w), n.sub(m, m, b), n.scale(v, y, -t * (P - i) - e * n.dot(m, y)), n.sub(s.force, s.force, v), n.add(a.force, a.force, v);
                    var T = n.crossLength(w, v),
                        S = n.crossLength(C, v);
                    s.angularForce -= T, a.angularForce += S
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Spring": 34
            }],
            33: [function(t, e, i) {
                function s(t, e, i) {
                    i = i || {}, a.call(this, t, e, i), this.restAngle = "number" == typeof i.restAngle ? i.restAngle : e.angle - t.angle
                }
                var n = t("../math/vec2"),
                    a = t("./Spring");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.applyForce = function() {
                    var t = this.stiffness,
                        e = this.damping,
                        i = this.restAngle,
                        s = this.bodyA,
                        n = this.bodyB,
                        a = n.angle - s.angle,
                        o = n.angularVelocity - s.angularVelocity,
                        r = -t * (a - i) - e * o * 0;
                    s.angularForce -= r, n.angularForce += r
                }
            }, {
                "../math/vec2": 30,
                "./Spring": 34
            }],
            34: [function(t, e, i) {
                function s(t, e, i) {
                    i = a.defaults(i, {
                        stiffness: 100,
                        damping: 1
                    }), this.stiffness = i.stiffness, this.damping = i.damping, this.bodyA = t, this.bodyB = e
                }
                var n = t("../math/vec2"),
                    a = t("../utils/Utils");
                e.exports = s, s.prototype.applyForce = function() {}
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57
            }],
            35: [function(t, e, i) {
                function s(t, e) {
                    e = e || {}, this.chassisBody = t, this.wheels = [], this.groundBody = new l({
                        mass: 0
                    }), this.world = null;
                    var i = this;
                    this.preStepCallback = function() {
                        i.update()
                    }
                }

                function n(t, e) {
                    e = e || {}, this.vehicle = t, this.forwardEquation = new h(t.chassisBody, t.groundBody), this.sideEquation = new h(t.chassisBody, t.groundBody), this.steerValue = 0, this.engineForce = 0, this.setSideFriction(void 0 !== e.sideFriction ? e.sideFriction : 5), this.localForwardVector = a.fromValues(0, 1), e.localForwardVector && a.copy(this.localForwardVector, e.localForwardVector), this.localPosition = a.fromValues(0, 0), e.localPosition && a.copy(this.localPosition, e.localPosition), r.apply(this, t.chassisBody, t.groundBody), this.equations.push(this.forwardEquation, this.sideEquation), this.setBrakeForce(0)
                }
                var a = t("../math/vec2"),
                    o = t("../utils/Utils"),
                    r = t("../constraints/Constraint"),
                    h = t("../equations/FrictionEquation"),
                    l = t("../objects/Body");
                e.exports = s, s.prototype.addToWorld = function(t) {
                    this.world = t, t.addBody(this.groundBody), t.on("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var i = this.wheels[e];
                        t.addConstraint(i)
                    }
                }, s.prototype.removeFromWorld = function() {
                    var t = this.world;
                    t.removeBody(this.groundBody), t.off("preStep", this.preStepCallback);
                    for (var e = 0; e < this.wheels.length; e++) {
                        var i = this.wheels[e];
                        t.removeConstraint(i)
                    }
                    this.world = null
                }, s.prototype.addWheel = function(t) {
                    var e = new n(this, t);
                    return this.wheels.push(e), e
                }, s.prototype.update = function() {
                    for (var t = 0; t < this.wheels.length; t++) this.wheels[t].update()
                }, n.prototype = new r, n.prototype.setBrakeForce = function(t) {
                    this.forwardEquation.setSlipForce(t)
                }, n.prototype.setSideFriction = function(t) {
                    this.sideEquation.setSlipForce(t)
                };
                var c = a.create(),
                    u = a.create();
                n.prototype.getSpeed = function() {
                    return this.vehicle.chassisBody.vectorToWorldFrame(u, this.localForwardVector), this.vehicle.chassisBody.getVelocityAtPoint(c, u), a.dot(c, u)
                };
                var d = a.create();
                n.prototype.update = function() {
                    this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.t, this.localForwardVector), a.rotate(this.sideEquation.t, this.localForwardVector, Math.PI / 2), this.vehicle.chassisBody.vectorToWorldFrame(this.sideEquation.t, this.sideEquation.t), a.rotate(this.forwardEquation.t, this.forwardEquation.t, this.steerValue), a.rotate(this.sideEquation.t, this.sideEquation.t, this.steerValue), this.vehicle.chassisBody.toWorldFrame(this.forwardEquation.contactPointB, this.localPosition), a.copy(this.sideEquation.contactPointB, this.forwardEquation.contactPointB), this.vehicle.chassisBody.vectorToWorldFrame(this.forwardEquation.contactPointA, this.localPosition), a.copy(this.sideEquation.contactPointA, this.forwardEquation.contactPointA), a.normalize(d, this.forwardEquation.t), a.scale(d, d, this.engineForce), this.vehicle.chassisBody.applyForce(d, this.forwardEquation.contactPointA)
                }
            }, {
                "../constraints/Constraint": 14,
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../utils/Utils": 57
            }],
            36: [function(t, e, i) {
                var s = e.exports = {
                    AABB: t("./collision/AABB"),
                    AngleLockEquation: t("./equations/AngleLockEquation"),
                    Body: t("./objects/Body"),
                    Broadphase: t("./collision/Broadphase"),
                    Capsule: t("./shapes/Capsule"),
                    Circle: t("./shapes/Circle"),
                    Constraint: t("./constraints/Constraint"),
                    ContactEquation: t("./equations/ContactEquation"),
                    ContactEquationPool: t("./utils/ContactEquationPool"),
                    ContactMaterial: t("./material/ContactMaterial"),
                    Convex: t("./shapes/Convex"),
                    DistanceConstraint: t("./constraints/DistanceConstraint"),
                    Equation: t("./equations/Equation"),
                    EventEmitter: t("./events/EventEmitter"),
                    FrictionEquation: t("./equations/FrictionEquation"),
                    FrictionEquationPool: t("./utils/FrictionEquationPool"),
                    GearConstraint: t("./constraints/GearConstraint"),
                    GSSolver: t("./solver/GSSolver"),
                    Heightfield: t("./shapes/Heightfield"),
                    Line: t("./shapes/Line"),
                    LockConstraint: t("./constraints/LockConstraint"),
                    Material: t("./material/Material"),
                    Narrowphase: t("./collision/Narrowphase"),
                    NaiveBroadphase: t("./collision/NaiveBroadphase"),
                    Particle: t("./shapes/Particle"),
                    Plane: t("./shapes/Plane"),
                    Pool: t("./utils/Pool"),
                    RevoluteConstraint: t("./constraints/RevoluteConstraint"),
                    PrismaticConstraint: t("./constraints/PrismaticConstraint"),
                    Ray: t("./collision/Ray"),
                    RaycastResult: t("./collision/RaycastResult"),
                    Box: t("./shapes/Box"),
                    RotationalVelocityEquation: t("./equations/RotationalVelocityEquation"),
                    SAPBroadphase: t("./collision/SAPBroadphase"),
                    Shape: t("./shapes/Shape"),
                    Solver: t("./solver/Solver"),
                    Spring: t("./objects/Spring"),
                    TopDownVehicle: t("./objects/TopDownVehicle"),
                    LinearSpring: t("./objects/LinearSpring"),
                    RotationalSpring: t("./objects/RotationalSpring"),
                    Utils: t("./utils/Utils"),
                    World: t("./world/World"),
                    vec2: t("./math/vec2"),
                    version: t("../package.json")
                        .version
                };
                Object.defineProperty(s, "Rectangle", {
                    get: function() {
                        return this.Box
                    }
                })
            }, {
                "../package.json": 6,
                "./collision/AABB": 7,
                "./collision/Broadphase": 8,
                "./collision/NaiveBroadphase": 9,
                "./collision/Narrowphase": 10,
                "./collision/Ray": 11,
                "./collision/RaycastResult": 12,
                "./collision/SAPBroadphase": 13,
                "./constraints/Constraint": 14,
                "./constraints/DistanceConstraint": 15,
                "./constraints/GearConstraint": 16,
                "./constraints/LockConstraint": 17,
                "./constraints/PrismaticConstraint": 18,
                "./constraints/RevoluteConstraint": 19,
                "./equations/AngleLockEquation": 20,
                "./equations/ContactEquation": 21,
                "./equations/Equation": 22,
                "./equations/FrictionEquation": 23,
                "./equations/RotationalVelocityEquation": 25,
                "./events/EventEmitter": 26,
                "./material/ContactMaterial": 27,
                "./material/Material": 28,
                "./math/vec2": 30,
                "./objects/Body": 31,
                "./objects/LinearSpring": 32,
                "./objects/RotationalSpring": 33,
                "./objects/Spring": 34,
                "./objects/TopDownVehicle": 35,
                "./shapes/Box": 37,
                "./shapes/Capsule": 38,
                "./shapes/Circle": 39,
                "./shapes/Convex": 40,
                "./shapes/Heightfield": 41,
                "./shapes/Line": 42,
                "./shapes/Particle": 43,
                "./shapes/Plane": 44,
                "./shapes/Shape": 45,
                "./solver/GSSolver": 46,
                "./solver/Solver": 47,
                "./utils/ContactEquationPool": 48,
                "./utils/FrictionEquationPool": 49,
                "./utils/Pool": 55,
                "./utils/Utils": 57,
                "./world/World": 61
            }],
            37: [function(t, e, i) {
                function s(t) {
                    "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                        width: arguments[0],
                        height: arguments[1]
                    }), t = t || {};
                    var e = this.width = t.width || 1,
                        i = this.height = t.height || 1,
                        s = [n.fromValues(-e / 2, -i / 2), n.fromValues(e / 2, -i / 2), n.fromValues(e / 2, i / 2), n.fromValues(-e / 2, i / 2)],
                        r = [n.fromValues(1, 0), n.fromValues(0, 1)];
                    t.vertices = s, t.axes = r, t.type = a.BOX, o.call(this, t)
                }
                var n = t("../math/vec2"),
                    a = t("./Shape"),
                    o = t("./Convex");
                e.exports = s, s.prototype = new o, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    var e = this.width,
                        i = this.height;
                    return t * (i * i + e * e) / 12
                }, s.prototype.updateBoundingRadius = function() {
                    var t = this.width,
                        e = this.height;
                    this.boundingRadius = Math.sqrt(t * t + e * e) / 2
                };
                var r = n.create(),
                    h = n.create(),
                    l = n.create(),
                    c = n.create();
                s.prototype.computeAABB = function(t, e, i) {
                    t.setFromPoints(this.vertices, e, i, 0)
                }, s.prototype.updateArea = function() {
                    this.area = this.width * this.height
                }
            }, {
                "../math/vec2": 30,
                "./Convex": 40,
                "./Shape": 45
            }],
            38: [function(t, e, i) {
                function s(t) {
                    "number" == typeof arguments[0] && "number" == typeof arguments[1] && (t = {
                        length: arguments[0],
                        radius: arguments[1]
                    }), t = t || {}, this.length = t.length || 1, this.radius = t.radius || 1, t.type = n.CAPSULE, n.call(this, t)
                }
                var n = t("./Shape"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius,
                        i = this.length + e,
                        s = 2 * e;
                    return t * (s * s + i * i) / 12
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius + this.length / 2
                }, s.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius + 2 * this.radius * this.length
                };
                var o = a.create();
                s.prototype.computeAABB = function(t, e, i) {
                    var s = this.radius;
                    a.set(o, this.length / 2, 0), 0 !== i && a.rotate(o, o, i), a.set(t.upperBound, Math.max(o[0] + s, -o[0] + s), Math.max(o[1] + s, -o[1] + s)), a.set(t.lowerBound, Math.min(o[0] - s, -o[0] - s), Math.min(o[1] - s, -o[1] - s)), a.add(t.lowerBound, t.lowerBound, e), a.add(t.upperBound, t.upperBound, e)
                };
                var r = a.create(),
                    h = a.create(),
                    l = a.create(),
                    c = a.create(),
                    u = a.fromValues(0, 1);
                s.prototype.raycast = function(t, e, i, s) {
                    for (var n = e.from, o = e.to, d = e.direction, p = r, f = h, g = l, y = c, m = this.length / 2, v = 0; v < 2; v++) {
                        var b = this.radius * (2 * v - 1);
                        a.set(g, -m, b), a.set(y, m, b), a.toGlobalFrame(g, g, i, s), a.toGlobalFrame(y, y, i, s);
                        var x = a.getLineSegmentsIntersectionFraction(n, o, g, y);
                        if (x >= 0 && (a.rotate(f, u, s), a.scale(f, f, 2 * v - 1), e.reportIntersection(t, x, f, -1), t.shouldStop(e))) return
                    }
                    for (var _ = Math.pow(this.radius, 2) + Math.pow(m, 2), v = 0; v < 2; v++) {
                        a.set(g, m * (2 * v - 1), 0), a.toGlobalFrame(g, g, i, s);
                        var w = Math.pow(o[0] - n[0], 2) + Math.pow(o[1] - n[1], 2),
                            C = 2 * ((o[0] - n[0]) * (n[0] - g[0]) + (o[1] - n[1]) * (n[1] - g[1])),
                            P = Math.pow(n[0] - g[0], 2) + Math.pow(n[1] - g[1], 2) - Math.pow(this.radius, 2),
                            x = Math.pow(C, 2) - 4 * w * P;
                        if (!(x < 0))
                            if (0 === x) {
                                if (a.lerp(p, n, o, x), a.squaredDistance(p, i) > _ && (a.sub(f, p, g), a.normalize(f, f), e.reportIntersection(t, x, f, -1), t.shouldStop(e))) return
                            } else {
                                var T = Math.sqrt(x),
                                    S = 1 / (2 * w),
                                    A = (-C - T) * S,
                                    E = (-C + T) * S;
                                if (A >= 0 && A <= 1 && (a.lerp(p, n, o, A), a.squaredDistance(p, i) > _ && (a.sub(f, p, g), a.normalize(f, f), e.reportIntersection(t, A, f, -1), t.shouldStop(e)))) return;
                                if (E >= 0 && E <= 1 && (a.lerp(p, n, o, E), a.squaredDistance(p, i) > _ && (a.sub(f, p, g), a.normalize(f, f), e.reportIntersection(t, E, f, -1), t.shouldStop(e)))) return
                            }
                    }
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            39: [function(t, e, i) {
                function s(t) {
                    "number" == typeof arguments[0] && (t = {
                        radius: arguments[0]
                    }), t = t || {}, this.radius = t.radius || 1, t.type = n.CIRCLE, n.call(this, t)
                }
                var n = t("./Shape"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    var e = this.radius;
                    return t * e * e / 2
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.radius
                }, s.prototype.updateArea = function() {
                    this.area = Math.PI * this.radius * this.radius
                }, s.prototype.computeAABB = function(t, e, i) {
                    var s = this.radius;
                    a.set(t.upperBound, s, s), a.set(t.lowerBound, -s, -s), e && (a.add(t.lowerBound, t.lowerBound, e), a.add(t.upperBound, t.upperBound, e))
                };
                var o = a.create(),
                    r = a.create();
                s.prototype.raycast = function(t, e, i, s) {
                    var n = e.from,
                        h = e.to,
                        l = this.radius,
                        c = Math.pow(h[0] - n[0], 2) + Math.pow(h[1] - n[1], 2),
                        u = 2 * ((h[0] - n[0]) * (n[0] - i[0]) + (h[1] - n[1]) * (n[1] - i[1])),
                        d = Math.pow(n[0] - i[0], 2) + Math.pow(n[1] - i[1], 2) - Math.pow(l, 2),
                        p = Math.pow(u, 2) - 4 * c * d,
                        f = o,
                        g = r;
                    if (!(p < 0))
                        if (0 === p) a.lerp(f, n, h, p), a.sub(g, f, i), a.normalize(g, g), e.reportIntersection(t, p, g, -1);
                        else {
                            var y = Math.sqrt(p),
                                m = 1 / (2 * c),
                                v = (-u - y) * m,
                                b = (-u + y) * m;
                            if (v >= 0 && v <= 1 && (a.lerp(f, n, h, v), a.sub(g, f, i), a.normalize(g, g), e.reportIntersection(t, v, g, -1), t.shouldStop(e))) return;
                            b >= 0 && b <= 1 && (a.lerp(f, n, h, b), a.sub(g, f, i), a.normalize(g, g), e.reportIntersection(t, b, g, -1))
                        }
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            40: [function(t, e, i) {
                function s(t) {
                    Array.isArray(arguments[0]) && (t = {
                        vertices: arguments[0],
                        axes: arguments[1]
                    }), t = t || {}, this.vertices = [];
                    for (var e = void 0 !== t.vertices ? t.vertices : [], i = 0; i < e.length; i++) {
                        var s = a.create();
                        a.copy(s, e[i]), this.vertices.push(s)
                    }
                    if (this.axes = [], t.axes)
                        for (var i = 0; i < t.axes.length; i++) {
                            var o = a.create();
                            a.copy(o, t.axes[i]), this.axes.push(o)
                        } else
                            for (var i = 0; i < this.vertices.length; i++) {
                                var r = this.vertices[i],
                                    h = this.vertices[(i + 1) % this.vertices.length],
                                    l = a.create();
                                a.sub(l, h, r), a.rotate90cw(l, l), a.normalize(l, l), this.axes.push(l)
                            }
                    if (this.centerOfMass = a.fromValues(0, 0), this.triangles = [], this.vertices.length && (this.updateTriangles(), this.updateCenterOfMass()), this.boundingRadius = 0, t.type = n.CONVEX, n.call(this, t), this.updateBoundingRadius(), this.updateArea(), this.area < 0) throw new Error("Convex vertices must be given in conter-clockwise winding.")
                }
                var n = t("./Shape"),
                    a = t("../math/vec2"),
                    o = t("../math/polyk"),
                    r = t("poly-decomp");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s;
                var h = a.create(),
                    l = a.create();
                s.prototype.projectOntoLocalAxis = function(t, e) {
                    for (var i = null, s = null, n, o, t = h, r = 0; r < this.vertices.length; r++) n = this.vertices[r], o = a.dot(n, t), (null === i || o > i) && (i = o), (null === s || o < s) && (s = o);
                    if (s > i) {
                        var l = s;
                        s = i, i = l
                    }
                    a.set(e, s, i)
                }, s.prototype.projectOntoWorldAxis = function(t, e, i, s) {
                    var n = l;
                    this.projectOntoLocalAxis(t, s), 0 !== i ? a.rotate(n, t, i) : n = t;
                    var o = a.dot(e, n);
                    a.set(s, s[0] + o, s[1] + o)
                }, s.prototype.updateTriangles = function() {
                    this.triangles.length = 0;
                    for (var t = [], e = 0; e < this.vertices.length; e++) {
                        var i = this.vertices[e];
                        t.push(i[0], i[1])
                    }
                    for (var s = o.Triangulate(t), e = 0; e < s.length; e += 3) {
                        var n = s[e],
                            a = s[e + 1],
                            r = s[e + 2];
                        this.triangles.push([n, a, r])
                    }
                };
                var c = a.create(),
                    u = a.create(),
                    d = a.create(),
                    p = a.create(),
                    f = a.create(),
                    g = a.create(),
                    y = a.create(),
                    m = a.create(),
                    v = a.create();
                s.prototype.updateCenterOfMass = function() {
                    var t = this.triangles,
                        e = this.vertices,
                        i = this.centerOfMass,
                        n = c,
                        o = v,
                        r = d,
                        h = p,
                        l = f,
                        b = g,
                        x = y,
                        _ = m,
                        w = u;
                    a.set(i, 0, 0);
                    for (var C = 0, P = 0; P !== t.length; P++) {
                        var T = t[P],
                            r = e[T[0]],
                            h = e[T[1]],
                            l = e[T[2]];
                        a.centroid(n, r, h, l);
                        var S = s.triangleArea(r, h, l);
                        C += S, a.scale(w, n, S), a.add(i, i, w)
                    }
                    a.scale(i, i, 1 / C)
                }, s.prototype.computeMomentOfInertia = function(t) {
                    for (var e = 0, i = 0, s = this.vertices.length, n = s - 1, o = 0; o < s; n = o, o++) {
                        var r = this.vertices[n],
                            h = this.vertices[o],
                            l = Math.abs(a.crossLength(r, h));
                        e += l * (a.dot(h, h) + a.dot(h, r) + a.dot(r, r)), i += l
                    }
                    return t / 6 * (e / i)
                }, s.prototype.updateBoundingRadius = function() {
                    for (var t = this.vertices, e = 0, i = 0; i !== t.length; i++) {
                        var s = a.squaredLength(t[i]);
                        s > e && (e = s)
                    }
                    this.boundingRadius = Math.sqrt(e)
                }, s.triangleArea = function(t, e, i) {
                    return .5 * ((e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]))
                }, s.prototype.updateArea = function() {
                    this.updateTriangles(), this.area = 0;
                    for (var t = this.triangles, e = this.vertices, i = 0; i !== t.length; i++) {
                        var n = t[i],
                            a = e[n[0]],
                            o = e[n[1]],
                            r = e[n[2]],
                            h = s.triangleArea(a, o, r);
                        this.area += h
                    }
                }, s.prototype.computeAABB = function(t, e, i) {
                    t.setFromPoints(this.vertices, e, i, 0)
                };
                var b = a.create(),
                    x = a.create(),
                    _ = a.create();
                s.prototype.raycast = function(t, e, i, s) {
                    var n = b,
                        o = x,
                        r = _,
                        h = this.vertices;
                    a.toLocalFrame(n, e.from, i, s), a.toLocalFrame(o, e.to, i, s);
                    for (var l = h.length, c = 0; c < l && !t.shouldStop(e); c++) {
                        var u = h[c],
                            d = h[(c + 1) % l],
                            p = a.getLineSegmentsIntersectionFraction(n, o, u, d);
                        p >= 0 && (a.sub(r, d, u), a.rotate(r, r, -Math.PI / 2 + s), a.normalize(r, r), e.reportIntersection(t, p, r, c))
                    }
                }
            }, {
                "../math/polyk": 29,
                "../math/vec2": 30,
                "./Shape": 45,
                "poly-decomp": 5
            }],
            41: [function(t, e, i) {
                function s(t) {
                    if (Array.isArray(arguments[0]) && (t = {
                            heights: arguments[0]
                        }, "object" == typeof arguments[1]))
                        for (var e in arguments[1]) t[e] = arguments[1][e];
                    t = t || {}, this.heights = t.heights ? t.heights.slice(0) : [], this.maxValue = t.maxValue || null, this.minValue = t.minValue || null, this.elementWidth = t.elementWidth || .1, void 0 !== t.maxValue && void 0 !== t.minValue || this.updateMaxMinValues(), t.type = a.HEIGHTFIELD, a.call(this, t)
                }

                function n(t, e, i, s, n) {
                    var a, o, r, h;
                    a = i[0] - e[0], o = i[1] - e[1], r = n[0] - s[0], h = n[1] - s[1];
                    var l, c;
                    if (l = (-o * (e[0] - s[0]) + a * (e[1] - s[1])) / (-r * o + a * h), c = (r * (e[1] - s[1]) - h * (e[0] - s[0])) / (-r * o + a * h), l >= 0 && l <= 1 && c >= 0 && c <= 1) {
                        var u = e[0] + c * a,
                            d = e[1] + c * o;
                        return t[0] = u, t[1] = d, c
                    }
                    return -1
                }
                var a = t("./Shape"),
                    o = t("../math/vec2"),
                    r = t("../utils/Utils");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.updateMaxMinValues = function() {
                    for (var t = this.heights, e = t[0], i = t[0], s = 0; s !== t.length; s++) {
                        var n = t[s];
                        n > e && (e = n), n < i && (i = n)
                    }
                    this.maxValue = e, this.minValue = i
                }, s.prototype.computeMomentOfInertia = function(t) {
                    return Number.MAX_VALUE
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }, s.prototype.updateArea = function() {
                    for (var t = this.heights, e = 0, i = 0; i < t.length - 1; i++) e += (t[i] + t[i + 1]) / 2 * this.elementWidth;
                    this.area = e
                };
                var h = [o.create(), o.create(), o.create(), o.create()];
                s.prototype.computeAABB = function(t, e, i) {
                    o.set(h[0], 0, this.maxValue), o.set(h[1], this.elementWidth * this.heights.length, this.maxValue), o.set(h[2], this.elementWidth * this.heights.length, this.minValue), o.set(h[3], 0, this.minValue), t.setFromPoints(h, e, i)
                }, s.prototype.getLineSegment = function(t, e, i) {
                    var s = this.heights,
                        n = this.elementWidth;
                    o.set(t, i * n, s[i]), o.set(e, (i + 1) * n, s[i + 1])
                }, s.prototype.getSegmentIndex = function(t) {
                    return Math.floor(t[0] / this.elementWidth)
                }, s.prototype.getClampedSegmentIndex = function(t) {
                    var e = this.getSegmentIndex(t);
                    return e = Math.min(this.heights.length, Math.max(e, 0))
                };
                var l = o.create(),
                    c = o.create(),
                    u = o.create(),
                    d = o.create(),
                    p = o.create(),
                    f = o.create(),
                    g = o.fromValues(0, 1);
                s.prototype.raycast = function(t, e, i, s) {
                    var n = e.from,
                        a = e.to,
                        r = e.direction,
                        h = l,
                        g = c,
                        y = u,
                        m = d,
                        v = p,
                        b = f;
                    o.toLocalFrame(v, n, i, s), o.toLocalFrame(b, a, i, s);
                    var x = this.getClampedSegmentIndex(v),
                        _ = this.getClampedSegmentIndex(b);
                    if (x > _) {
                        var w = x;
                        x = _, _ = w
                    }
                    for (var C = 0; C < this.heights.length - 1; C++) {
                        this.getLineSegment(y, m, C);
                        var P = o.getLineSegmentsIntersectionFraction(v, b, y, m);
                        if (P >= 0 && (o.sub(g, m, y), o.rotate(g, g, s + Math.PI / 2), o.normalize(g, g), e.reportIntersection(t, P, g, -1), t.shouldStop(e))) return
                    }
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            42: [function(t, e, i) {
                function s(t) {
                    "number" == typeof arguments[0] && (t = {
                        length: arguments[0]
                    }), t = t || {}, this.length = t.length || 1, t.type = n.LINE, n.call(this, t)
                }
                var n = t("./Shape"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    return t * Math.pow(this.length, 2) / 12
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = this.length / 2
                };
                var o = [a.create(), a.create()];
                s.prototype.computeAABB = function(t, e, i) {
                    var s = this.length / 2;
                    a.set(o[0], -s, 0), a.set(o[1], s, 0), t.setFromPoints(o, e, i, 0)
                };
                var r = a.create(),
                    h = a.create(),
                    l = a.create(),
                    c = a.create(),
                    u = a.fromValues(0, 1);
                s.prototype.raycast = function(t, e, i, s) {
                    var n = e.from,
                        o = e.to,
                        r = l,
                        d = c,
                        p = this.length / 2;
                    a.set(r, -p, 0), a.set(d, p, 0), a.toGlobalFrame(r, r, i, s), a.toGlobalFrame(d, d, i, s);
                    var f = a.getLineSegmentsIntersectionFraction(r, d, n, o);
                    if (f >= 0) {
                        var g = h;
                        a.rotate(g, u, s), e.reportIntersection(t, f, g, -1)
                    }
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            43: [function(t, e, i) {
                function s(t) {
                    t = t || {}, t.type = n.PARTICLE, n.call(this, t)
                }
                var n = t("./Shape"),
                    a = t("../math/vec2");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    return 0
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = 0
                }, s.prototype.computeAABB = function(t, e, i) {
                    a.copy(t.lowerBound, e), a.copy(t.upperBound, e)
                }
            }, {
                "../math/vec2": 30,
                "./Shape": 45
            }],
            44: [function(t, e, i) {
                function s(t) {
                    t = t || {}, t.type = n.PLANE, n.call(this, t)
                }
                var n = t("./Shape"),
                    a = t("../math/vec2"),
                    o = t("../utils/Utils");
                e.exports = s, s.prototype = new n, s.prototype.constructor = s, s.prototype.computeMomentOfInertia = function(t) {
                    return 0
                }, s.prototype.updateBoundingRadius = function() {
                    this.boundingRadius = Number.MAX_VALUE
                }, s.prototype.computeAABB = function(t, e, i) {
                    var s = i % (2 * Math.PI),
                        n = a.set,
                        o = Number.MAX_VALUE,
                        r = t.lowerBound,
                        h = t.upperBound;
                    0 === s ? (n(r, -o, -o), n(h, o, 0)) : s === Math.PI / 2 ? (n(r, 0, -o), n(h, o, o)) : s === Math.PI ? (n(r, -o, 0), n(h, o, o)) : s === 3 * Math.PI / 2 ? (n(r, -o, -o), n(h, 0, o)) : (n(r, -o, -o), n(h, o, o)), a.add(r, r, e), a.add(h, h, e)
                }, s.prototype.updateArea = function() {
                    this.area = Number.MAX_VALUE
                };
                var r = a.create(),
                    h = a.create(),
                    l = a.create(),
                    c = a.create(),
                    u = a.create();
                s.prototype.raycast = function(t, e, i, s) {
                    var n = e.from,
                        o = e.to,
                        d = e.direction,
                        p = r,
                        f = h,
                        g = l,
                        y = c,
                        m = u;
                    a.set(y, 0, 1), a.rotate(y, y, s), a.sub(m, n, i);
                    var v = a.dot(m, y);
                    if (a.sub(m, o, i), !(v * a.dot(m, y) > 0 || a.squaredDistance(n, o) < v * v)) {
                        var b = a.dot(y, d);
                        a.sub(p, n, i);
                        var x = -a.dot(y, p) / b / e.length;
                        e.reportIntersection(t, x, y, -1)
                    }
                }
            }, {
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Shape": 45
            }],
            45: [function(t, e, i) {
                function s(t) {
                    t = t || {}, this.body = null, this.position = n.fromValues(0, 0), t.position && n.copy(this.position, t.position), this.angle = t.angle || 0, this.type = t.type || 0, this.id = s.idCounter++, this.boundingRadius = 0, this.collisionGroup = void 0 !== t.collisionGroup ? t.collisionGroup : 1, this.collisionResponse = void 0 === t.collisionResponse || t.collisionResponse, this.collisionMask = void 0 !== t.collisionMask ? t.collisionMask : 1, this.material = t.material || null, this.area = 0, this.sensor = void 0 !== t.sensor && t.sensor, this.type && this.updateBoundingRadius(), this.updateArea()
                }
                e.exports = s;
                var n = t("../math/vec2");
                s.idCounter = 0, s.CIRCLE = 1, s.PARTICLE = 2, s.PLANE = 4, s.CONVEX = 8, s.LINE = 16, s.BOX = 32, Object.defineProperty(s, "RECTANGLE", {
                    get: function() {
                        return s.BOX
                    }
                }), s.CAPSULE = 64, s.HEIGHTFIELD = 128, s.prototype.computeMomentOfInertia = function(t) {}, s.prototype.updateBoundingRadius = function() {}, s.prototype.updateArea = function() {}, s.prototype.computeAABB = function(t, e, i) {}, s.prototype.raycast = function(t, e, i, s) {}
            }, {
                "../math/vec2": 30
            }],
            46: [function(t, e, i) {
                function s(t) {
                    o.call(this, t, o.GS), t = t || {}, this.iterations = t.iterations || 10, this.tolerance = t.tolerance || 1e-7, this.arrayStep = 30, this.lambda = new r.ARRAY_TYPE(this.arrayStep), this.Bs = new r.ARRAY_TYPE(this.arrayStep), this.invCs = new r.ARRAY_TYPE(this.arrayStep), this.useZeroRHS = !1, this.frictionIterations = 0, this.usedIterations = 0
                }

                function n(t) {
                    for (var e = t.length; e--;) t[e] = 0
                }
                var a = t("../math/vec2"),
                    o = t("./Solver"),
                    r = t("../utils/Utils"),
                    h = t("../equations/FrictionEquation");
                e.exports = s, s.prototype = new o, s.prototype.constructor = s, s.prototype.solve = function(t, e) {
                    this.sortEquations();
                    var i = 0,
                        o = this.iterations,
                        l = this.frictionIterations,
                        c = this.equations,
                        u = c.length,
                        d = Math.pow(this.tolerance * u, 2),
                        p = e.bodies,
                        f = e.bodies.length,
                        g = a.add,
                        y = a.set,
                        m = this.useZeroRHS,
                        v = this.lambda;
                    if (this.usedIterations = 0, u)
                        for (var b = 0; b !== f; b++) {
                            var x = p[b];
                            x.updateSolveMassProperties()
                        }
                    v.length < u && (v = this.lambda = new r.ARRAY_TYPE(u + this.arrayStep), this.Bs = new r.ARRAY_TYPE(u + this.arrayStep), this.invCs = new r.ARRAY_TYPE(u + this.arrayStep)), n(v);
                    for (var _ = this.invCs, w = this.Bs, v = this.lambda, b = 0; b !== c.length; b++) {
                        var C = c[b];
                        (C.timeStep !== t || C.needsUpdate) && (C.timeStep = t, C.update()), w[b] = C.computeB(C.a, C.b, t), _[b] = C.computeInvC(C.epsilon)
                    }
                    var P, T, C, S, b, A;
                    if (0 !== u) {
                        for (b = 0; b !== f; b++) {
                            var x = p[b];
                            x.resetConstraintVelocity()
                        }
                        if (l) {
                            for (i = 0; i !== l; i++) {
                                for (S = 0, A = 0; A !== u; A++) {
                                    C = c[A];
                                    var E = s.iterateEquation(A, C, C.epsilon, w, _, v, m, t, i);
                                    S += Math.abs(E)
                                }
                                if (this.usedIterations++, S * S <= d) break
                            }
                            for (s.updateMultipliers(c, v, 1 / t), A = 0; A !== u; A++) {
                                var I = c[A];
                                if (I instanceof h) {
                                    for (var M = 0, O = 0; O !== I.contactEquations.length; O++) M += I.contactEquations[O].multiplier;
                                    M *= I.frictionCoefficient / I.contactEquations.length, I.maxForce = M, I.minForce = -M
                                }
                            }
                        }
                        for (i = 0; i !== o; i++) {
                            for (S = 0, A = 0; A !== u; A++) {
                                C = c[A];
                                var E = s.iterateEquation(A, C, C.epsilon, w, _, v, m, t, i);
                                S += Math.abs(E)
                            }
                            if (this.usedIterations++, S * S <= d) break
                        }
                        for (b = 0; b !== f; b++) p[b].addConstraintVelocity();
                        s.updateMultipliers(c, v, 1 / t)
                    }
                }, s.updateMultipliers = function(t, e, i) {
                    for (var s = t.length; s--;) t[s].multiplier = e[s] * i
                }, s.iterateEquation = function(t, e, i, s, n, a, o, r, h) {
                    var l = s[t],
                        c = n[t],
                        u = a[t],
                        d = e.computeGWlambda(),
                        p = e.maxForce,
                        f = e.minForce;
                    o && (l = 0);
                    var g = c * (l - d - i * u),
                        y = u + g;
                    return y < f * r ? g = f * r - u : y > p * r && (g = p * r - u), a[t] += g, e.addToWlambda(g), g
                }
            }, {
                "../equations/FrictionEquation": 23,
                "../math/vec2": 30,
                "../utils/Utils": 57,
                "./Solver": 47
            }],
            47: [function(t, e, i) {
                function s(t, e) {
                    t = t || {}, a.call(this), this.type = e, this.equations = [], this.equationSortFunction = t.equationSortFunction || !1
                }
                var n = t("../utils/Utils"),
                    a = t("../events/EventEmitter");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.solve = function(t, e) {
                    throw new Error("Solver.solve should be implemented by subclasses!")
                };
                var o = {
                    bodies: []
                };
                s.prototype.solveIsland = function(t, e) {
                    this.removeAllEquations(), e.equations.length && (this.addEquations(e.equations), o.bodies.length = 0, e.getBodies(o.bodies), o.bodies.length && this.solve(t, o))
                }, s.prototype.sortEquations = function() {
                    this.equationSortFunction && this.equations.sort(this.equationSortFunction)
                }, s.prototype.addEquation = function(t) {
                    t.enabled && this.equations.push(t)
                }, s.prototype.addEquations = function(t) {
                    for (var e = 0, i = t.length; e !== i; e++) {
                        var s = t[e];
                        s.enabled && this.equations.push(s)
                    }
                }, s.prototype.removeEquation = function(t) {
                    var e = this.equations.indexOf(t); - 1 !== e && this.equations.splice(e, 1)
                }, s.prototype.removeAllEquations = function() {
                    this.equations.length = 0
                }, s.GS = 1, s.ISLAND = 2
            }, {
                "../events/EventEmitter": 26,
                "../utils/Utils": 57
            }],
            48: [function(t, e, i) {
                function s() {
                    a.apply(this, arguments)
                }
                var n = t("../equations/ContactEquation"),
                    a = t("./Pool");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.create = function() {
                    return new n
                }, s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null, this
                }
            }, {
                "../equations/ContactEquation": 21,
                "./Pool": 55
            }],
            49: [function(t, e, i) {
                function s() {
                    a.apply(this, arguments)
                }
                var n = t("../equations/FrictionEquation"),
                    a = t("./Pool");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.create = function() {
                    return new n
                }, s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = null, this
                }
            }, {
                "../equations/FrictionEquation": 23,
                "./Pool": 55
            }],
            50: [function(t, e, i) {
                function s() {
                    a.apply(this, arguments)
                }
                var n = t("../world/IslandNode"),
                    a = t("./Pool");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.create = function() {
                    return new n
                }, s.prototype.destroy = function(t) {
                    return t.reset(), this
                }
            }, {
                "../world/IslandNode": 60,
                "./Pool": 55
            }],
            51: [function(t, e, i) {
                function s() {
                    a.apply(this, arguments)
                }
                var n = t("../world/Island"),
                    a = t("./Pool");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.create = function() {
                    return new n
                }, s.prototype.destroy = function(t) {
                    return t.reset(), this
                }
            }, {
                "../world/Island": 58,
                "./Pool": 55
            }],
            52: [function(t, e, i) {
                function s() {
                    this.overlappingShapesLastState = new n, this.overlappingShapesCurrentState = new n, this.recordPool = new o({
                        size: 16
                    }), this.tmpDict = new n, this.tmpArray1 = []
                }
                var n = t("./TupleDictionary"),
                    a = t("./OverlapKeeperRecord"),
                    o = t("./OverlapKeeperRecordPool"),
                    r = t("./Utils");
                e.exports = s, s.prototype.tick = function() {
                    for (var t = this.overlappingShapesLastState, e = this.overlappingShapesCurrentState, i = t.keys.length; i--;) {
                        var s = t.keys[i],
                            n = t.getByKey(s),
                            a = e.getByKey(s);
                        n && this.recordPool.release(n)
                    }
                    t.reset(), t.copy(e), e.reset()
                }, s.prototype.setOverlapping = function(t, e, i, s) {
                    var n = this.overlappingShapesLastState,
                        a = this.overlappingShapesCurrentState;
                    if (!a.get(e.id, s.id)) {
                        var o = this.recordPool.get();
                        o.set(t, e, i, s), a.set(e.id, s.id, o)
                    }
                }, s.prototype.getNewOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesLastState, this.overlappingShapesCurrentState, t)
                }, s.prototype.getEndOverlaps = function(t) {
                    return this.getDiff(this.overlappingShapesCurrentState, this.overlappingShapesLastState, t)
                }, s.prototype.bodiesAreOverlapping = function(t, e) {
                    for (var i = this.overlappingShapesCurrentState, s = i.keys.length; s--;) {
                        var n = i.keys[s],
                            a = i.data[n];
                        if (a.bodyA === t && a.bodyB === e || a.bodyA === e && a.bodyB === t) return !0
                    }
                    return !1
                }, s.prototype.getDiff = function(t, e, i) {
                    var i = i || [],
                        s = t,
                        n = e;
                    i.length = 0;
                    for (var a = n.keys.length; a--;) {
                        var o = n.keys[a],
                            r = n.data[o];
                        if (!r) throw new Error("Key " + o + " had no data!");
                        s.data[o] || i.push(r)
                    }
                    return i
                }, s.prototype.isNewOverlap = function(t, e) {
                    var i = 0 | t.id,
                        s = 0 | e.id,
                        n = this.overlappingShapesLastState,
                        a = this.overlappingShapesCurrentState;
                    return !n.get(i, s) && !!a.get(i, s)
                }, s.prototype.getNewBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getNewOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }, s.prototype.getEndBodyOverlaps = function(t) {
                    this.tmpArray1.length = 0;
                    var e = this.getEndOverlaps(this.tmpArray1);
                    return this.getBodyDiff(e, t)
                }, s.prototype.getBodyDiff = function(t, e) {
                    e = e || [];
                    for (var i = this.tmpDict, s = t.length; s--;) {
                        var n = t[s];
                        i.set(0 | n.bodyA.id, 0 | n.bodyB.id, n)
                    }
                    for (s = i.keys.length; s--;) {
                        var n = i.getByKey(i.keys[s]);
                        n && e.push(n.bodyA, n.bodyB)
                    }
                    return i.reset(), e
                }
            }, {
                "./OverlapKeeperRecord": 53,
                "./OverlapKeeperRecordPool": 54,
                "./TupleDictionary": 56,
                "./Utils": 57
            }],
            53: [function(t, e, i) {
                function s(t, e, i, s) {
                    this.shapeA = e, this.shapeB = s, this.bodyA = t, this.bodyB = i
                }
                e.exports = s, s.prototype.set = function(t, e, i, n) {
                    s.call(this, t, e, i, n)
                }
            }, {}],
            54: [function(t, e, i) {
                function s() {
                    a.apply(this, arguments)
                }
                var n = t("./OverlapKeeperRecord"),
                    a = t("./Pool");
                e.exports = s, s.prototype = new a, s.prototype.constructor = s, s.prototype.create = function() {
                    return new n
                }, s.prototype.destroy = function(t) {
                    return t.bodyA = t.bodyB = t.shapeA = t.shapeB = null, this
                }
            }, {
                "./OverlapKeeperRecord": 53,
                "./Pool": 55
            }],
            55: [function(t, e, i) {
                function s(t) {
                    t = t || {}, this.objects = [], void 0 !== t.size && this.resize(t.size)
                }
                e.exports = s, s.prototype.resize = function(t) {
                    for (var e = this.objects; e.length > t;) e.pop();
                    for (; e.length < t;) e.push(this.create());
                    return this
                }, s.prototype.get = function() {
                    var t = this.objects;
                    return t.length ? t.pop() : this.create()
                }, s.prototype.release = function(t) {
                    return this.destroy(t), this.objects.push(t), this
                }
            }, {}],
            56: [function(t, e, i) {
                function s() {
                    this.data = {}, this.keys = []
                }
                var n = t("./Utils");
                e.exports = s, s.prototype.getKey = function(t, e) {
                    return t |= 0, e |= 0, (0 | t) == (0 | e) ? -1 : 0 | ((0 | t) > (0 | e) ? t << 16 | 65535 & e : e << 16 | 65535 & t)
                }, s.prototype.getByKey = function(t) {
                    return t |= 0, this.data[t]
                }, s.prototype.get = function(t, e) {
                    return this.data[this.getKey(t, e)]
                }, s.prototype.set = function(t, e, i) {
                    if (!i) throw new Error("No data!");
                    var s = this.getKey(t, e);
                    return this.data[s] || this.keys.push(s), this.data[s] = i, s
                }, s.prototype.reset = function() {
                    for (var t = this.data, e = this.keys, i = e.length; i--;) delete t[e[i]];
                    e.length = 0
                }, s.prototype.copy = function(t) {
                    this.reset(), n.appendArray(this.keys, t.keys);
                    for (var e = t.keys.length; e--;) {
                        var i = t.keys[e];
                        this.data[i] = t.data[i]
                    }
                }
            }, {
                "./Utils": 57
            }],
            57: [function(t, e, i) {
                function s() {}
                e.exports = s, s.appendArray = function(t, e) {
                    if (e.length < 15e4) t.push.apply(t, e);
                    else
                        for (var i = 0, s = e.length; i !== s; ++i) t.push(e[i])
                }, s.splice = function(t, e, i) {
                    i = i || 1;
                    for (var s = e, n = t.length - i; s < n; s++) t[s] = t[s + i];
                    t.length = n
                }, "undefined" != typeof P2_ARRAY_TYPE ? s.ARRAY_TYPE = P2_ARRAY_TYPE : "undefined" != typeof Float32Array ? s.ARRAY_TYPE = Float32Array : s.ARRAY_TYPE = Array, s.extend = function(t, e) {
                    for (var i in e) t[i] = e[i]
                }, s.defaults = function(t, e) {
                    t = t || {};
                    for (var i in e) i in t || (t[i] = e[i]);
                    return t
                }
            }, {}],
            58: [function(t, e, i) {
                function s() {
                    this.equations = [], this.bodies = []
                }
                var n = t("../objects/Body");
                e.exports = s, s.prototype.reset = function() {
                    this.equations.length = this.bodies.length = 0
                };
                var a = [];
                s.prototype.getBodies = function(t) {
                    var e = t || [],
                        i = this.equations;
                    a.length = 0;
                    for (var s = 0; s !== i.length; s++) {
                        var n = i[s]; - 1 === a.indexOf(n.bodyA.id) && (e.push(n.bodyA), a.push(n.bodyA.id)), -1 === a.indexOf(n.bodyB.id) && (e.push(n.bodyB), a.push(n.bodyB.id))
                    }
                    return e
                }, s.prototype.wantsToSleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        var e = this.bodies[t];
                        if (e.type === n.DYNAMIC && !e.wantsToSleep) return !1
                    }
                    return !0
                }, s.prototype.sleep = function() {
                    for (var t = 0; t < this.bodies.length; t++) {
                        this.bodies[t].sleep()
                    }
                    return !0
                }
            }, {
                "../objects/Body": 31
            }],
            59: [function(t, e, i) {
                function s(t) {
                    this.nodePool = new r({
                        size: 16
                    }), this.islandPool = new h({
                        size: 8
                    }), this.equations = [], this.islands = [], this.nodes = [], this.queue = []
                }
                var n = t("../math/vec2"),
                    a = t("./Island"),
                    o = t("./IslandNode"),
                    r = t("./../utils/IslandNodePool"),
                    h = t("./../utils/IslandPool"),
                    l = t("../objects/Body");
                e.exports = s, s.getUnvisitedNode = function(t) {
                    for (var e = t.length, i = 0; i !== e; i++) {
                        var s = t[i];
                        if (!s.visited && s.body.type === l.DYNAMIC) return s
                    }
                    return !1
                }, s.prototype.visit = function(t, e, i) {
                    e.push(t.body);
                    for (var s = t.equations.length, n = 0; n !== s; n++) {
                        var a = t.equations[n]; - 1 === i.indexOf(a) && i.push(a)
                    }
                }, s.prototype.bfs = function(t, e, i) {
                    var n = this.queue;
                    for (n.length = 0, n.push(t), t.visited = !0, this.visit(t, e, i); n.length;)
                        for (var a = n.pop(), o; o = s.getUnvisitedNode(a.neighbors);) o.visited = !0, this.visit(o, e, i), o.body.type === l.DYNAMIC && n.push(o)
                }, s.prototype.split = function(t) {
                    for (var e = t.bodies, i = this.nodes, n = this.equations; i.length;) this.nodePool.release(i.pop());
                    for (var a = 0; a !== e.length; a++) {
                        var o = this.nodePool.get();
                        o.body = e[a], i.push(o)
                    }
                    for (var r = 0; r !== n.length; r++) {
                        var h = n[r],
                            a = e.indexOf(h.bodyA),
                            l = e.indexOf(h.bodyB),
                            c = i[a],
                            u = i[l];
                        c.neighbors.push(u), u.neighbors.push(c), c.equations.push(h), u.equations.push(h)
                    }
                    for (var d = this.islands, a = 0; a < d.length; a++) this.islandPool.release(d[a]);
                    d.length = 0;
                    for (var p; p = s.getUnvisitedNode(i);) {
                        var f = this.islandPool.get();
                        this.bfs(p, f.bodies, f.equations), d.push(f)
                    }
                    return d
                }
            }, {
                "../math/vec2": 30,
                "../objects/Body": 31,
                "./../utils/IslandNodePool": 50,
                "./../utils/IslandPool": 51,
                "./Island": 58,
                "./IslandNode": 60
            }],
            60: [function(t, e, i) {
                function s(t) {
                    this.body = t, this.neighbors = [], this.equations = [], this.visited = !1
                }
                e.exports = s, s.prototype.reset = function() {
                    this.equations.length = 0, this.neighbors.length = 0, this.visited = !1, this.body = null
                }
            }, {}],
            61: [function(t, e, i) {
                function s(t) {
                    f.apply(this), t = t || {}, this.springs = [], this.bodies = [], this.disabledBodyCollisionPairs = [], this.solver = t.solver || new n, this.narrowphase = new M(this), this.islandManager = new R, this.gravity = r.fromValues(0, -9.78), t.gravity && r.copy(this.gravity, t.gravity), this.frictionGravity = r.length(this.gravity) || 10, this.useWorldGravityAsFrictionGravity = !0, this.useFrictionGravityOnZeroGravity = !0, this.broadphase = t.broadphase || new I, this.broadphase.setWorld(this), this.constraints = [], this.defaultMaterial = new v, this.defaultContactMaterial = new b(this.defaultMaterial, this.defaultMaterial), this.lastTimeStep = 1 / 60, this.applySpringForces = !0, this.applyDamping = !0, this.applyGravity = !0, this.solveConstraints = !0, this.contactMaterials = [], this.time = 0, this.accumulator = 0, this.stepping = !1, this.bodiesToBeRemoved = [], this.islandSplit = void 0 === t.islandSplit || !!t.islandSplit, this.emitImpactEvent = !0, this._constraintIdCounter = 0, this._bodyIdCounter = 0, this.postStepEvent = {
                        type: "postStep"
                    }, this.addBodyEvent = {
                        type: "addBody",
                        body: null
                    }, this.removeBodyEvent = {
                        type: "removeBody",
                        body: null
                    }, this.addSpringEvent = {
                        type: "addSpring",
                        spring: null
                    }, this.impactEvent = {
                        type: "impact",
                        bodyA: null,
                        bodyB: null,
                        shapeA: null,
                        shapeB: null,
                        contactEquation: null
                    }, this.postBroadphaseEvent = {
                        type: "postBroadphase",
                        pairs: null
                    }, this.sleepMode = s.NO_SLEEPING, this.beginContactEvent = {
                        type: "beginContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null,
                        contactEquations: []
                    }, this.endContactEvent = {
                        type: "endContact",
                        shapeA: null,
                        shapeB: null,
                        bodyA: null,
                        bodyB: null
                    }, this.preSolveEvent = {
                        type: "preSolve",
                        contactEquations: null,
                        frictionEquations: null
                    }, this.overlappingShapesLastState = {
                        keys: []
                    }, this.overlappingShapesCurrentState = {
                        keys: []
                    }, this.overlapKeeper = new B
                }
                var n = t("../solver/GSSolver"),
                    a = t("../solver/Solver"),
                    o = t("../collision/Ray"),
                    r = t("../math/vec2"),
                    h = t("../shapes/Circle"),
                    l = t("../shapes/Convex"),
                    c = t("../shapes/Line"),
                    u = t("../shapes/Plane"),
                    d = t("../shapes/Capsule"),
                    p = t("../shapes/Particle"),
                    f = t("../events/EventEmitter"),
                    g = t("../objects/Body"),
                    y = t("../shapes/Shape"),
                    m = t("../objects/LinearSpring"),
                    v = t("../material/Material"),
                    b = t("../material/ContactMaterial"),
                    x = t("../constraints/DistanceConstraint"),
                    _ = t("../constraints/Constraint"),
                    w = t("../constraints/LockConstraint"),
                    C = t("../constraints/RevoluteConstraint"),
                    P = t("../constraints/PrismaticConstraint"),
                    T = t("../constraints/GearConstraint"),
                    S = t("../../package.json"),
                    A = t("../collision/Broadphase"),
                    E = t("../collision/AABB"),
                    I = t("../collision/SAPBroadphase"),
                    M = t("../collision/Narrowphase"),
                    O = t("../utils/Utils"),
                    B = t("../utils/OverlapKeeper"),
                    R = t("./IslandManager"),
                    k = t("../objects/RotationalSpring");
                e.exports = s, s.prototype = new Object(f.prototype), s.prototype.constructor = s, s.NO_SLEEPING = 1, s.BODY_SLEEPING = 2, s.ISLAND_SLEEPING = 4, s.prototype.addConstraint = function(t) {
                    this.constraints.push(t)
                }, s.prototype.addContactMaterial = function(t) {
                    this.contactMaterials.push(t)
                }, s.prototype.removeContactMaterial = function(t) {
                    var e = this.contactMaterials.indexOf(t); - 1 !== e && O.splice(this.contactMaterials, e, 1)
                }, s.prototype.getContactMaterial = function(t, e) {
                    for (var i = this.contactMaterials, s = 0, n = i.length; s !== n; s++) {
                        var a = i[s];
                        if (a.materialA.id === t.id && a.materialB.id === e.id || a.materialA.id === e.id && a.materialB.id === t.id) return a
                    }
                    return !1
                }, s.prototype.removeConstraint = function(t) {
                    var e = this.constraints.indexOf(t); - 1 !== e && O.splice(this.constraints, e, 1)
                };
                var D = r.create(),
                    L = r.create(),
                    F = r.create(),
                    G = r.create(),
                    U = r.create(),
                    N = r.create(),
                    j = r.create(),
                    W = r.fromValues(0, 0),
                    X = r.fromValues(0, 0),
                    H = r.fromValues(0, 0),
                    V = r.fromValues(0, 0);
                s.prototype.step = function(t, e, i) {
                    if (i = i || 10, 0 === (e = e || 0)) this.internalStep(t), this.time += t;
                    else {
                        this.accumulator += e;
                        for (var s = 0; this.accumulator >= t && s < i;) this.internalStep(t), this.time += t, this.accumulator -= t, s++;
                        for (var n = this.accumulator % t / t, a = 0; a !== this.bodies.length; a++) {
                            var o = this.bodies[a];
                            r.lerp(o.interpolatedPosition, o.previousPosition, o.position, n), o.interpolatedAngle = o.previousAngle + n * (o.angle - o.previousAngle)
                        }
                    }
                };
                var Y = [];
                s.prototype.internalStep = function(t) {
                    this.stepping = !0;
                    var e = this,
                        i = this.springs.length,
                        n = this.springs,
                        a = this.bodies,
                        o = this.gravity,
                        h = this.solver,
                        l = this.bodies.length,
                        c = this.broadphase,
                        u = this.narrowphase,
                        d = this.constraints,
                        p, f, y = U,
                        m = N,
                        v = j,
                        b = r.scale,
                        x = r.add,
                        _ = r.rotate,
                        w = this.islandManager;
                    if (this.overlapKeeper.tick(), this.lastTimeStep = t, this.useWorldGravityAsFrictionGravity) {
                        var C = r.length(this.gravity);
                        0 === C && this.useFrictionGravityOnZeroGravity || (this.frictionGravity = C)
                    }
                    if (this.applyGravity)
                        for (var P = 0; P !== l; P++) {
                            var T = a[P],
                                S = T.force;
                            T.type === g.DYNAMIC && T.sleepState !== g.SLEEPING && (r.scale(v, o, T.mass * T.gravityScale), x(S, S, v))
                        }
                    if (this.applySpringForces)
                        for (var P = 0; P !== i; P++) {
                            var A = n[P];
                            A.applyForce()
                        }
                    if (this.applyDamping)
                        for (var P = 0; P !== l; P++) {
                            var T = a[P];
                            T.type === g.DYNAMIC && T.applyDamping(t)
                        }
                    for (var E = c.getCollisionPairs(this), I = this.disabledBodyCollisionPairs, P = I.length - 2; P >= 0; P -= 2)
                        for (var M = E.length - 2; M >= 0; M -= 2)(I[P] === E[M] && I[P + 1] === E[M + 1] || I[P + 1] === E[M] && I[P] === E[M + 1]) && E.splice(M, 2);
                    var B = d.length;
                    for (P = 0; P !== B; P++) {
                        var R = d[P];
                        if (!R.collideConnected)
                            for (var M = E.length - 2; M >= 0; M -= 2)(R.bodyA === E[M] && R.bodyB === E[M + 1] || R.bodyB === E[M] && R.bodyA === E[M + 1]) && E.splice(M, 2)
                    }
                    this.postBroadphaseEvent.pairs = E, this.emit(this.postBroadphaseEvent), this.postBroadphaseEvent.pairs = null, u.reset(this);
                    for (var P = 0, k = E.length; P !== k; P += 2)
                        for (var D = E[P], L = E[P + 1], F = 0, G = D.shapes.length; F !== G; F++)
                            for (var W = D.shapes[F], X = W.position, H = W.angle, V = 0, q = L.shapes.length; V !== q; V++) {
                                var z = L.shapes[V],
                                    K = z.position,
                                    J = z.angle,
                                    Z = this.defaultContactMaterial;
                                if (W.material && z.material) {
                                    var Q = this.getContactMaterial(W.material, z.material);
                                    Q && (Z = Q)
                                }
                                this.runNarrowphase(u, D, W, X, H, L, z, K, J, Z, this.frictionGravity)
                            }
                    for (var P = 0; P !== l; P++) {
                        var $ = a[P];
                        $._wakeUpAfterNarrowphase && ($.wakeUp(), $._wakeUpAfterNarrowphase = !1)
                    }
                    if (this.has("endContact")) {
                        this.overlapKeeper.getEndOverlaps(Y);
                        for (var tt = this.endContactEvent, V = Y.length; V--;) {
                            var et = Y[V];
                            tt.shapeA = et.shapeA, tt.shapeB = et.shapeB, tt.bodyA = et.bodyA, tt.bodyB = et.bodyB, this.emit(tt)
                        }
                        Y.length = 0
                    }
                    var it = this.preSolveEvent;
                    it.contactEquations = u.contactEquations, it.frictionEquations = u.frictionEquations, this.emit(it), it.contactEquations = it.frictionEquations = null;
                    var B = d.length;
                    for (P = 0; P !== B; P++) d[P].update();
                    if (u.contactEquations.length || u.frictionEquations.length || B)
                        if (this.islandSplit) {
                            for (w.equations.length = 0, O.appendArray(w.equations, u.contactEquations), O.appendArray(w.equations, u.frictionEquations), P = 0; P !== B; P++) O.appendArray(w.equations, d[P].equations);
                            w.split(this);
                            for (var P = 0; P !== w.islands.length; P++) {
                                var st = w.islands[P];
                                st.equations.length && h.solveIsland(t, st)
                            }
                        } else {
                            for (h.addEquations(u.contactEquations), h.addEquations(u.frictionEquations), P = 0; P !== B; P++) h.addEquations(d[P].equations);
                            this.solveConstraints && h.solve(t, this), h.removeAllEquations()
                        } for (var P = 0; P !== l; P++) {
                        var $ = a[P];
                        $.integrate(t)
                    }
                    for (var P = 0; P !== l; P++) a[P].setZeroForce();
                    if (this.emitImpactEvent && this.has("impact"))
                        for (var nt = this.impactEvent, P = 0; P !== u.contactEquations.length; P++) {
                            var at = u.contactEquations[P];
                            at.firstImpact && (nt.bodyA = at.bodyA, nt.bodyB = at.bodyB, nt.shapeA = at.shapeA, nt.shapeB = at.shapeB, nt.contactEquation = at, this.emit(nt))
                        }
                    if (this.sleepMode === s.BODY_SLEEPING)
                        for (P = 0; P !== l; P++) a[P].sleepTick(this.time, !1, t);
                    else if (this.sleepMode === s.ISLAND_SLEEPING && this.islandSplit) {
                        for (P = 0; P !== l; P++) a[P].sleepTick(this.time, !0, t);
                        for (var P = 0; P < this.islandManager.islands.length; P++) {
                            var st = this.islandManager.islands[P];
                            st.wantsToSleep() && st.sleep()
                        }
                    }
                    this.stepping = !1;
                    for (var ot = this.bodiesToBeRemoved, P = 0; P !== ot.length; P++) this.removeBody(ot[P]);
                    ot.length = 0, this.emit(this.postStepEvent)
                }, s.prototype.runNarrowphase = function(t, e, i, s, n, a, o, h, l, c, u) {
                    if (0 != (i.collisionGroup & o.collisionMask) && 0 != (o.collisionGroup & i.collisionMask)) {
                        r.rotate(W, s, e.angle), r.rotate(X, h, a.angle), r.add(W, W, e.position), r.add(X, X, a.position);
                        var d = n + e.angle,
                            p = l + a.angle;
                        t.enableFriction = c.friction > 0, t.frictionCoefficient = c.friction;
                        var f;
                        f = e.type === g.STATIC || e.type === g.KINEMATIC ? a.mass : a.type === g.STATIC || a.type === g.KINEMATIC ? e.mass : e.mass * a.mass / (e.mass + a.mass), t.slipForce = c.friction * u * f, t.restitution = c.restitution, t.surfaceVelocity = c.surfaceVelocity, t.frictionStiffness = c.frictionStiffness, t.frictionRelaxation = c.frictionRelaxation, t.stiffness = c.stiffness, t.relaxation = c.relaxation, t.contactSkinSize = c.contactSkinSize, t.enabledEquations = e.collisionResponse && a.collisionResponse && i.collisionResponse && o.collisionResponse;
                        var y = t[i.type | o.type],
                            m = 0;
                        if (y) {
                            var v = i.sensor || o.sensor,
                                b = t.frictionEquations.length;
                            m = i.type < o.type ? y.call(t, e, i, W, d, a, o, X, p, v) : y.call(t, a, o, X, p, e, i, W, d, v);
                            var x = t.frictionEquations.length - b;
                            if (m) {
                                if (e.allowSleep && e.type === g.DYNAMIC && e.sleepState === g.SLEEPING && a.sleepState === g.AWAKE && a.type !== g.STATIC) {
                                    r.squaredLength(a.velocity) + Math.pow(a.angularVelocity, 2) >= 2 * Math.pow(a.sleepSpeedLimit, 2) && (e._wakeUpAfterNarrowphase = !0)
                                }
                                if (a.allowSleep && a.type === g.DYNAMIC && a.sleepState === g.SLEEPING && e.sleepState === g.AWAKE && e.type !== g.STATIC) {
                                    r.squaredLength(e.velocity) + Math.pow(e.angularVelocity, 2) >= 2 * Math.pow(e.sleepSpeedLimit, 2) && (a._wakeUpAfterNarrowphase = !0)
                                }
                                if (this.overlapKeeper.setOverlapping(e, i, a, o), this.has("beginContact") && this.overlapKeeper.isNewOverlap(i, o)) {
                                    var _ = this.beginContactEvent;
                                    if (_.shapeA = i, _.shapeB = o, _.bodyA = e, _.bodyB = a, _.contactEquations.length = 0, "number" == typeof m)
                                        for (var w = t.contactEquations.length - m; w < t.contactEquations.length; w++) _.contactEquations.push(t.contactEquations[w]);
                                    this.emit(_)
                                }
                                if ("number" == typeof m && x > 1)
                                    for (var w = t.frictionEquations.length - x; w < t.frictionEquations.length; w++) {
                                        var C = t.frictionEquations[w];
                                        C.setSlipForce(C.getSlipForce() / x)
                                    }
                            }
                        }
                    }
                }, s.prototype.addSpring = function(t) {
                    this.springs.push(t);
                    var e = this.addSpringEvent;
                    e.spring = t, this.emit(e), e.spring = null
                }, s.prototype.removeSpring = function(t) {
                    var e = this.springs.indexOf(t); - 1 !== e && O.splice(this.springs, e, 1)
                }, s.prototype.addBody = function(t) {
                    if (-1 === this.bodies.indexOf(t)) {
                        this.bodies.push(t), t.world = this;
                        var e = this.addBodyEvent;
                        e.body = t, this.emit(e), e.body = null
                    }
                }, s.prototype.removeBody = function(t) {
                    if (this.stepping) this.bodiesToBeRemoved.push(t);
                    else {
                        t.world = null;
                        var e = this.bodies.indexOf(t); - 1 !== e && (O.splice(this.bodies, e, 1), this.removeBodyEvent.body = t, t.resetConstraintVelocity(), this.emit(this.removeBodyEvent), this.removeBodyEvent.body = null)
                    }
                }, s.prototype.getBodyById = function(t) {
                    for (var e = this.bodies, i = 0; i < e.length; i++) {
                        var s = e[i];
                        if (s.id === t) return s
                    }
                    return !1
                }, s.prototype.disableBodyCollision = function(t, e) {
                    this.disabledBodyCollisionPairs.push(t, e)
                }, s.prototype.enableBodyCollision = function(t, e) {
                    for (var i = this.disabledBodyCollisionPairs, s = 0; s < i.length; s += 2)
                        if (i[s] === t && i[s + 1] === e || i[s + 1] === t && i[s] === e) return void i.splice(s, 2)
                }, s.prototype.clear = function() {
                    this.time = 0, this.solver && this.solver.equations.length && this.solver.removeAllEquations();
                    for (var t = this.constraints, e = t.length - 1; e >= 0; e--) this.removeConstraint(t[e]);
                    for (var i = this.bodies, e = i.length - 1; e >= 0; e--) this.removeBody(i[e]);
                    for (var n = this.springs, e = n.length - 1; e >= 0; e--) this.removeSpring(n[e]);
                    for (var a = this.contactMaterials, e = a.length - 1; e >= 0; e--) this.removeContactMaterial(a[e]);
                    s.apply(this)
                };
                var q = r.create(),
                    z = r.fromValues(0, 0),
                    K = r.fromValues(0, 0);
                s.prototype.hitTest = function(t, e, i) {
                    i = i || 0;
                    var s = new g({
                            position: t
                        }),
                        n = new p,
                        a = t,
                        o = 0,
                        c = q,
                        f = z,
                        y = K;
                    s.addShape(n);
                    for (var m = this.narrowphase, v = [], b = 0, x = e.length; b !== x; b++)
                        for (var _ = e[b], w = 0, C = _.shapes.length; w !== C; w++) {
                            var P = _.shapes[w];
                            r.rotate(c, P.position, _.angle), r.add(c, c, _.position);
                            var T = P.angle + _.angle;
                            (P instanceof h && m.circleParticle(_, P, c, T, s, n, a, 0, !0) || P instanceof l && m.particleConvex(s, n, a, 0, _, P, c, T, !0) || P instanceof u && m.particlePlane(s, n, a, 0, _, P, c, T, !0) || P instanceof d && m.particleCapsule(s, n, a, 0, _, P, c, T, !0) || P instanceof p && r.squaredLength(r.sub(y, c, t)) < i * i) && v.push(_)
                        }
                    return v
                }, s.prototype.setGlobalStiffness = function(t) {
                    for (var e = this.constraints, i = 0; i !== e.length; i++)
                        for (var s = e[i], n = 0; n !== s.equations.length; n++) {
                            var a = s.equations[n];
                            a.stiffness = t, a.needsUpdate = !0
                        }
                    for (var o = this.contactMaterials, i = 0; i !== o.length; i++) {
                        var s = o[i];
                        s.stiffness = s.frictionStiffness = t
                    }
                    var s = this.defaultContactMaterial;
                    s.stiffness = s.frictionStiffness = t
                }, s.prototype.setGlobalRelaxation = function(t) {
                    for (var e = 0; e !== this.constraints.length; e++)
                        for (var i = this.constraints[e], s = 0; s !== i.equations.length; s++) {
                            var n = i.equations[s];
                            n.relaxation = t, n.needsUpdate = !0
                        }
                    for (var e = 0; e !== this.contactMaterials.length; e++) {
                        var i = this.contactMaterials[e];
                        i.relaxation = i.frictionRelaxation = t
                    }
                    var i = this.defaultContactMaterial;
                    i.relaxation = i.frictionRelaxation = t
                };
                var J = new E,
                    Z = [];
                s.prototype.raycast = function(t, e) {
                    return e.getAABB(J), this.broadphase.aabbQuery(this, J, Z), e.intersectBodies(t, Z), Z.length = 0, t.hasHit()
                }
            }, {
                "../../package.json": 6,
                "../collision/AABB": 7,
                "../collision/Broadphase": 8,
                "../collision/Narrowphase": 10,
                "../collision/Ray": 11,
                "../collision/SAPBroadphase": 13,
                "../constraints/Constraint": 14,
                "../constraints/DistanceConstraint": 15,
                "../constraints/GearConstraint": 16,
                "../constraints/LockConstraint": 17,
                "../constraints/PrismaticConstraint": 18,
                "../constraints/RevoluteConstraint": 19,
                "../events/EventEmitter": 26,
                "../material/ContactMaterial": 27,
                "../material/Material": 28,
                "../math/vec2": 30,
                "../objects/Body": 31,
                "../objects/LinearSpring": 32,
                "../objects/RotationalSpring": 33,
                "../shapes/Capsule": 38,
                "../shapes/Circle": 39,
                "../shapes/Convex": 40,
                "../shapes/Line": 42,
                "../shapes/Particle": 43,
                "../shapes/Plane": 44,
                "../shapes/Shape": 45,
                "../solver/GSSolver": 46,
                "../solver/Solver": 47,
                "../utils/OverlapKeeper": 52,
                "../utils/Utils": 57,
                "./IslandManager": 59
            }]
        }, {}, [36])(36)
    })
}, function(t, e, i) {
    /**
     * @author       Richard Davey <rich@photonstorm.com>
     * @copyright    2016 Photon Storm Ltd.
     * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
     *
     * @overview
     *
     * Phaser - http://phaser.io
     *
     * v2.6.4 "Kore Springs" - Built: Thu Nov 16 2017 13:53:48
     *
     * By Richard Davey http://www.photonstorm.com @photonstorm
     *
     * Phaser is a fun, free and fast 2D game framework for making HTML5 games
     * for desktop and mobile web browsers, supporting Canvas and WebGL rendering.
     *
     * Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23
     * Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe
     * Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com
     *
     * Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.
     *
     * Follow development at http://phaser.io and on our forum
     *
     * "If you want your children to be intelligent,  read them fairy tales."
     * "If you want them to be more intelligent, read them more fairy tales."
     *                                                     -- Albert Einstein
     */
    (function() {
        var i = this,
            s = s || {};
        /**
         * @author       Mat Groves http://matgroves.com @Doormat23
         * @author       Richard Davey <rich@photonstorm.com>
         * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
         */
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2016 Photon Storm Ltd.
         * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
         */
        return s.game = null, s.WEBGL_RENDERER = 0, s.CANVAS_RENDERER = 1, s.VERSION = "v2.2.9", s._UID = 0, "undefined" != typeof Float32Array ? (s.Float32Array = Float32Array, s.Uint16Array = Uint16Array, s.Uint32Array = Uint32Array, s.ArrayBuffer = ArrayBuffer) : (s.Float32Array = Array, s.Uint16Array = Array), s.PI_2 = 2 * Math.PI, s.RAD_TO_DEG = 180 / Math.PI, s.DEG_TO_RAD = Math.PI / 180, s.RETINA_PREFIX = "@2x", s.DisplayObject = function() {
            this.position = new s.Point(0, 0), this.scale = new s.Point(1, 1), this.pivot = new s.Point(0, 0), this.rotation = 0, this.alpha = 1, this.visible = !0, this.hitArea = null, this.renderable = !1, this.parent = null, this.worldAlpha = 1, this.worldTransform = new s.Matrix, this.worldPosition = new s.Point(0, 0), this.worldScale = new s.Point(1, 1), this.worldRotation = 0, this.filterArea = null, this._sr = 0, this._cr = 1, this._bounds = new s.Rectangle(0, 0, 0, 0), this._currentBounds = null, this._mask = null, this._cacheAsBitmap = !1, this._cacheIsDirty = !1
        }, s.DisplayObject.prototype.constructor = s.DisplayObject, s.DisplayObject.prototype = {
            destroy: function() {
                if (this.children) {
                    for (var t = this.children.length; t--;) this.children[t].destroy();
                    this.children = []
                }
                this.hitArea = null, this.parent = null, this.worldTransform = null, this.filterArea = null, this.renderable = !1, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite()
            },
            updateTransform: function(t) {
                if (!t && !this.parent && !this.game) return this;
                var e = this.parent;
                t ? e = t : this.parent || (e = this.game.world);
                var i = e.worldTransform,
                    n = this.worldTransform,
                    a, o, r, h, l, c;
                return this.rotation % s.PI_2 ? (this.rotation !== this.rotationCache && (this.rotationCache = this.rotation, this._sr = Math.sin(this.rotation), this._cr = Math.cos(this.rotation)), a = this._cr * this.scale.x, o = this._sr * this.scale.x, r = -this._sr * this.scale.y, h = this._cr * this.scale.y, l = this.position.x, c = this.position.y, (this.pivot.x || this.pivot.y) && (l -= this.pivot.x * a + this.pivot.y * r, c -= this.pivot.x * o + this.pivot.y * h), n.a = a * i.a + o * i.c, n.b = a * i.b + o * i.d, n.c = r * i.a + h * i.c, n.d = r * i.b + h * i.d, n.tx = l * i.a + c * i.c + i.tx, n.ty = l * i.b + c * i.d + i.ty) : (a = this.scale.x, h = this.scale.y, l = this.position.x - this.pivot.x * a, c = this.position.y - this.pivot.y * h, n.a = a * i.a, n.b = a * i.b, n.c = h * i.c, n.d = h * i.d, n.tx = l * i.a + c * i.c + i.tx, n.ty = l * i.b + c * i.d + i.ty), this.worldAlpha = this.alpha * e.worldAlpha, this.worldPosition.set(n.tx, n.ty), this.worldScale.set(this.scale.x * Math.sqrt(n.a * n.a + n.c * n.c), this.scale.y * Math.sqrt(n.b * n.b + n.d * n.d)), this.worldRotation = Math.atan2(-n.c, n.d), this._currentBounds = null, this.transformCallback && this.transformCallback.call(this.transformCallbackContext, n, i), this
            },
            preUpdate: function() {},
            generateTexture: function(t, e, i) {
                var n = this.getLocalBounds(),
                    a = new s.RenderTexture(0 | n.width, 0 | n.height, i, e, t);
                return s.DisplayObject._tempMatrix.tx = -n.x, s.DisplayObject._tempMatrix.ty = -n.y, a.render(this, s.DisplayObject._tempMatrix), a
            },
            updateCache: function() {
                return this._generateCachedSprite(), this
            },
            toGlobal: function(t) {
                return this.updateTransform(), this.worldTransform.apply(t)
            },
            toLocal: function(t, e) {
                return e && (t = e.toGlobal(t)), this.updateTransform(), this.worldTransform.applyInverse(t)
            },
            _renderCachedSprite: function(t) {
                this._cachedSprite.worldAlpha = this.worldAlpha, t.gl ? s.Sprite.prototype._renderWebGL.call(this._cachedSprite, t) : s.Sprite.prototype._renderCanvas.call(this._cachedSprite, t)
            },
            _generateCachedSprite: function() {
                this._cacheAsBitmap = !1;
                var t = this.getLocalBounds();
                if (t.width = Math.max(1, Math.ceil(t.width)), t.height = Math.max(1, Math.ceil(t.height)), this.updateTransform(), this._cachedSprite) this._cachedSprite.texture.resize(t.width, t.height);
                else {
                    var e = new s.RenderTexture(t.width, t.height);
                    this._cachedSprite = new s.Sprite(e), this._cachedSprite.worldTransform = this.worldTransform
                }
                var i = this._filters;
                this._filters = null, this._cachedSprite.filters = i, s.DisplayObject._tempMatrix.tx = -t.x, s.DisplayObject._tempMatrix.ty = -t.y, this._cachedSprite.texture.render(this, s.DisplayObject._tempMatrix, !0), this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._filters = i, this._cacheAsBitmap = !0
            },
            _destroyCachedSprite: function() {
                this._cachedSprite && (this._cachedSprite.texture.destroy(!0), this._cachedSprite = null)
            }
        }, s.DisplayObject.prototype.displayObjectUpdateTransform = s.DisplayObject.prototype.updateTransform, Object.defineProperties(s.DisplayObject.prototype, {
            x: {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            },
            y: {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            },
            worldVisible: {
                get: function() {
                    if (this.visible) {
                        var t = this.parent;
                        if (!t) return this.visible;
                        do {
                            if (!t.visible) return !1;
                            t = t.parent
                        } while (t);
                        return !0
                    }
                    return !1
                }
            },
            mask: {
                get: function() {
                    return this._mask
                },
                set: function(t) {
                    this._mask && (this._mask.isMask = !1), this._mask = t, t && (this._mask.isMask = !0)
                }
            },
            filters: {
                get: function() {
                    return this._filters
                },
                set: function(t) {
                    if (Array.isArray(t)) {
                        for (var e = [], i = 0; i < t.length; i++)
                            for (var n = t[i].passes, a = 0; a < n.length; a++) e.push(n[a]);
                        this._filterBlock = {
                            target: this,
                            filterPasses: e
                        }
                    }
                    this._filters = t, this.blendMode && this.blendMode === s.blendModes.MULTIPLY && (this.blendMode = s.blendModes.NORMAL)
                }
            },
            cacheAsBitmap: {
                get: function() {
                    return this._cacheAsBitmap
                },
                set: function(t) {
                    this._cacheAsBitmap !== t && (t ? this._generateCachedSprite() : this._destroyCachedSprite(), this._cacheAsBitmap = t)
                }
            }
        }), s.DisplayObjectContainer = function() {
            s.DisplayObject.call(this), this.children = [], this.ignoreChildInput = !1
        }, s.DisplayObjectContainer.prototype = Object.create(s.DisplayObject.prototype), s.DisplayObjectContainer.prototype.constructor = s.DisplayObjectContainer, s.DisplayObjectContainer.prototype.addChild = function(t) {
            return this.addChildAt(t, this.children.length)
        }, s.DisplayObjectContainer.prototype.addChildAt = function(t, e) {
            if (e >= 0 && e <= this.children.length) return t.parent && t.parent.removeChild(t), t.parent = this, this.children.splice(e, 0, t), t;
            throw new Error(t + "addChildAt: The index " + e + " supplied is out of bounds " + this.children.length)
        }, s.DisplayObjectContainer.prototype.swapChildren = function(t, e) {
            if (t !== e) {
                var i = this.getChildIndex(t),
                    s = this.getChildIndex(e);
                if (i < 0 || s < 0) throw new Error("swapChildren: Both the supplied DisplayObjects must be a child of the caller.");
                this.children[i] = e, this.children[s] = t
            }
        }, s.DisplayObjectContainer.prototype.getChildIndex = function(t) {
            var e = this.children.indexOf(t);
            if (-1 === e) throw new Error("The supplied DisplayObject must be a child of the caller");
            return e
        }, s.DisplayObjectContainer.prototype.setChildIndex = function(t, e) {
            if (e < 0 || e >= this.children.length) throw new Error("The supplied index is out of bounds");
            var i = this.getChildIndex(t);
            this.children.splice(i, 1), this.children.splice(e, 0, t)
        }, s.DisplayObjectContainer.prototype.getChildAt = function(t) {
            if (t < 0 || t >= this.children.length) throw new Error("getChildAt: Supplied index " + t + " does not exist in the child list, or the supplied DisplayObject must be a child of the caller");
            return this.children[t]
        }, s.DisplayObjectContainer.prototype.removeChild = function(t) {
            var e = this.children.indexOf(t);
            if (-1 !== e) return this.removeChildAt(e)
        }, s.DisplayObjectContainer.prototype.removeChildAt = function(t) {
            var e = this.getChildAt(t);
            return e && (e.parent = void 0, this.children.splice(t, 1)), e
        }, s.DisplayObjectContainer.prototype.removeChildren = function(t, e) {
            void 0 === t && (t = 0), void 0 === e && (e = this.children.length);
            var i = e - t;
            if (i > 0 && i <= e) {
                for (var s = this.children.splice(begin, i), n = 0; n < s.length; n++) {
                    s[n].parent = void 0
                }
                return s
            }
            if (0 === i && 0 === this.children.length) return [];
            throw new Error("removeChildren: Range Error, numeric values are outside the acceptable range")
        }, s.DisplayObjectContainer.prototype.updateTransform = function() {
            if (this.visible && (this.displayObjectUpdateTransform(), !this._cacheAsBitmap))
                for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
        }, s.DisplayObjectContainer.prototype.displayObjectContainerUpdateTransform = s.DisplayObjectContainer.prototype.updateTransform, s.DisplayObjectContainer.prototype.getBounds = function(t) {
            var e = t && t instanceof s.DisplayObject,
                i = !0;
            e ? i = t instanceof s.DisplayObjectContainer && t.contains(this) : t = this;
            var n;
            if (e) {
                var a = t.worldTransform;
                for (t.worldTransform = s.identityMatrix, n = 0; n < t.children.length; n++) t.children[n].updateTransform()
            }
            var o = 1 / 0,
                r = 1 / 0,
                h = -1 / 0,
                l = -1 / 0,
                c, u, d, p = !1;
            for (n = 0; n < this.children.length; n++) {
                this.children[n].visible && (p = !0, c = this.children[n].getBounds(), o = o < c.x ? o : c.x, r = r < c.y ? r : c.y, u = c.width + c.x, d = c.height + c.y, h = h > u ? h : u, l = l > d ? l : d)
            }
            var f = this._bounds;
            if (!p) {
                f = new s.Rectangle;
                var g = f.x,
                    y = f.width + f.x,
                    m = f.y,
                    v = f.height + f.y,
                    b = this.worldTransform,
                    x = b.a,
                    _ = b.b,
                    w = b.c,
                    C = b.d,
                    P = b.tx,
                    T = b.ty,
                    S = x * y + w * v + P,
                    A = C * v + _ * y + T,
                    E = x * g + w * v + P,
                    I = C * v + _ * g + T,
                    M = x * g + w * m + P,
                    O = C * m + _ * g + T,
                    B = x * y + w * m + P,
                    R = C * m + _ * y + T;
                h = S, l = A, o = S, r = A, o = E < o ? E : o, o = M < o ? M : o, o = B < o ? B : o, r = I < r ? I : r, r = O < r ? O : r, r = R < r ? R : r, h = E > h ? E : h, h = M > h ? M : h, h = B > h ? B : h, l = I > l ? I : l, l = O > l ? O : l, l = R > l ? R : l
            }
            if (f.x = o, f.y = r, f.width = h - o, f.height = l - r, e)
                for (t.worldTransform = a, n = 0; n < t.children.length; n++) t.children[n].updateTransform();
            if (!i) {
                var k = t.getBounds();
                f.x -= k.x, f.y -= k.y
            }
            return f
        }, s.DisplayObjectContainer.prototype.getLocalBounds = function() {
            return this.getBounds(this)
        }, s.DisplayObjectContainer.prototype.contains = function(t) {
            return !!t && (t === this || this.contains(t.parent))
        }, s.DisplayObjectContainer.prototype._renderWebGL = function(t) {
            if (this.visible && !(this.alpha <= 0)) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                var e;
                if (this._mask || this._filters) {
                    for (this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                    t.spriteBatch.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), t.spriteBatch.start()
                } else
                    for (e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t)
            }
        }, s.DisplayObjectContainer.prototype._renderCanvas = function(t) {
            if (!1 !== this.visible && 0 !== this.alpha) {
                if (this._cacheAsBitmap) return void this._renderCachedSprite(t);
                this._mask && t.maskManager.pushMask(this._mask, t);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, Object.defineProperty(s.DisplayObjectContainer.prototype, "width", {
            get: function() {
                return this.getLocalBounds()
                    .width * this.scale.x
            },
            set: function(t) {
                var e = this.getLocalBounds()
                    .width;
                this.scale.x = 0 !== e ? t / e : 1, this._width = t
            }
        }), Object.defineProperty(s.DisplayObjectContainer.prototype, "height", {
            get: function() {
                return this.getLocalBounds()
                    .height * this.scale.y
            },
            set: function(t) {
                var e = this.getLocalBounds()
                    .height;
                this.scale.y = 0 !== e ? t / e : 1, this._height = t
            }
        }), s.Sprite = function(t) {
            s.DisplayObjectContainer.call(this), this.anchor = new s.Point, this.texture = t || s.Texture.emptyTexture, this._width = 0, this._height = 0, this.tint = 16777215, this.cachedTint = -1, this.tintedTexture = null, this.blendMode = s.blendModes.NORMAL, this.shader = null, this.exists = !0, this.texture.baseTexture.hasLoaded && this.onTextureUpdate(), this.renderable = !0
        }, s.Sprite.prototype = Object.create(s.DisplayObjectContainer.prototype), s.Sprite.prototype.constructor = s.Sprite, Object.defineProperty(s.Sprite.prototype, "width", {
            get: function() {
                return this.scale.x * this.texture.frame.width
            },
            set: function(t) {
                this.scale.x = t / this.texture.frame.width, this._width = t
            }
        }), Object.defineProperty(s.Sprite.prototype, "height", {
            get: function() {
                return this.scale.y * this.texture.frame.height
            },
            set: function(t) {
                this.scale.y = t / this.texture.frame.height, this._height = t
            }
        }), s.Sprite.prototype.setTexture = function(t, e) {
            void 0 !== e && this.texture.baseTexture.destroy(), this.texture.baseTexture.skipRender = !1, this.texture = t, this.texture.valid = !0, this.cachedTint = -1
        }, s.Sprite.prototype.onTextureUpdate = function() {
            this._width && (this.scale.x = this._width / this.texture.frame.width), this._height && (this.scale.y = this._height / this.texture.frame.height)
        }, s.Sprite.prototype.getBounds = function(t) {
            var e = this.texture.frame.width,
                i = this.texture.frame.height,
                s = e * (1 - this.anchor.x),
                n = e * -this.anchor.x,
                a = i * (1 - this.anchor.y),
                o = i * -this.anchor.y,
                r = t || this.worldTransform,
                h = r.a,
                l = r.b,
                c = r.c,
                u = r.d,
                d = r.tx,
                p = r.ty,
                f = -1 / 0,
                g = -1 / 0,
                y = 1 / 0,
                m = 1 / 0;
            if (0 === l && 0 === c) {
                if (h < 0) {
                    h *= -1;
                    var v = s;
                    s = -n, n = -v
                }
                if (u < 0) {
                    u *= -1;
                    var v = a;
                    a = -o, o = -v
                }
                y = h * n + d, f = h * s + d, m = u * o + p, g = u * a + p
            } else {
                var b = h * n + c * o + d,
                    x = u * o + l * n + p,
                    _ = h * s + c * o + d,
                    w = u * o + l * s + p,
                    C = h * s + c * a + d,
                    P = u * a + l * s + p,
                    T = h * n + c * a + d,
                    S = u * a + l * n + p;
                y = b < y ? b : y, y = _ < y ? _ : y, y = C < y ? C : y, y = T < y ? T : y, m = x < m ? x : m, m = w < m ? w : m, m = P < m ? P : m, m = S < m ? S : m, f = b > f ? b : f, f = _ > f ? _ : f, f = C > f ? C : f, f = T > f ? T : f, g = x > g ? x : g, g = w > g ? w : g, g = P > g ? P : g, g = S > g ? S : g
            }
            var A = this._bounds;
            return A.x = y, A.width = f - y, A.y = m, A.height = g - m, this._currentBounds = A, A
        }, s.Sprite.prototype.getLocalBounds = function() {
            var t = this.worldTransform;
            this.worldTransform = s.identityMatrix;
            for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            var i = this.getBounds();
            for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
            return i
        }, s.Sprite.prototype._renderWebGL = function(t, e) {
            if (this.visible && !(this.alpha <= 0) && this.renderable) {
                var i = this.worldTransform;
                if (e && (i = e), this._mask || this._filters) {
                    var s = t.spriteBatch;
                    this._filters && (s.flush(), t.filterManager.pushFilter(this._filterBlock)), this._mask && (s.stop(), t.maskManager.pushMask(this.mask, t), s.start()), s.render(this);
                    for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t);
                    s.stop(), this._mask && t.maskManager.popMask(this._mask, t), this._filters && t.filterManager.popFilter(), s.start()
                } else {
                    t.spriteBatch.render(this);
                    for (var n = 0; n < this.children.length; n++) this.children[n]._renderWebGL(t, i)
                }
            }
        }, s.Sprite.prototype._renderCanvas = function(t, e) {
            if (!(!this.visible || 0 === this.alpha || !this.renderable || this.texture.crop.width <= 0 || this.texture.crop.height <= 0)) {
                var i = this.worldTransform;
                if (e && (i = e), this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, t.context.globalCompositeOperation = s.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t), this.texture.valid) {
                    var n = this.texture.baseTexture.resolution / t.resolution;
                    t.context.globalAlpha = this.worldAlpha, t.smoothProperty && t.scaleMode !== this.texture.baseTexture.scaleMode && (t.scaleMode = this.texture.baseTexture.scaleMode, t.context[t.smoothProperty] = t.scaleMode === s.scaleModes.LINEAR);
                    var a = this.texture.trim ? this.texture.trim.x - this.anchor.x * this.texture.trim.width : this.anchor.x * -this.texture.frame.width,
                        o = this.texture.trim ? this.texture.trim.y - this.anchor.y * this.texture.trim.height : this.anchor.y * -this.texture.frame.height,
                        r = i.tx * t.resolution + t.shakeX,
                        h = i.ty * t.resolution + t.shakeY;
                    t.roundPixels ? (t.context.setTransform(i.a, i.b, i.c, i.d, 0 | r, 0 | h), a |= 0, o |= 0) : t.context.setTransform(i.a, i.b, i.c, i.d, r, h);
                    var l = this.texture.crop.width,
                        c = this.texture.crop.height;
                    if (a /= n, o /= n, 16777215 !== this.tint)(this.texture.requiresReTint || this.cachedTint !== this.tint) && (this.tintedTexture = s.CanvasTinter.getTintedTexture(this, this.tint), this.cachedTint = this.tint, this.texture.requiresReTint = !1), t.context.drawImage(this.tintedTexture, 0, 0, l, c, a, o, l / n, c / n);
                    else {
                        var u = this.texture.crop.x,
                            d = this.texture.crop.y;
                        t.context.drawImage(this.texture.baseTexture.source, u, d, l, c, a, o, l / n, c / n)
                    }
                }
                for (var p = 0; p < this.children.length; p++) this.children[p]._renderCanvas(t);
                this._mask && t.maskManager.popMask(t)
            }
        }, s.SpriteBatch = function(t) {
            s.DisplayObjectContainer.call(this), this.textureThing = t, this.ready = !1
        }, s.SpriteBatch.prototype = Object.create(s.DisplayObjectContainer.prototype), s.SpriteBatch.prototype.constructor = s.SpriteBatch, s.SpriteBatch.prototype.initWebGL = function(t) {
            this.fastSpriteBatch = new s.WebGLFastSpriteBatch(t), this.ready = !0
        }, s.SpriteBatch.prototype.updateTransform = function() {
            this.displayObjectUpdateTransform()
        }, s.SpriteBatch.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || !this.children.length || (this.ready || this.initWebGL(t.gl), this.fastSpriteBatch.gl !== t.gl && this.fastSpriteBatch.setContext(t.gl), t.spriteBatch.stop(), t.shaderManager.setShader(t.shaderManager.fastShader), this.fastSpriteBatch.begin(this, t), this.fastSpriteBatch.render(this), t.spriteBatch.start())
        }, s.SpriteBatch.prototype._renderCanvas = function(t) {
            if (this.visible && !(this.alpha <= 0) && this.children.length) {
                var e = t.context;
                e.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
                for (var i = this.worldTransform, s = !0, n = 0; n < this.children.length; n++) {
                    var a = this.children[n];
                    if (a.visible) {
                        var o = a.texture,
                            r = o.frame;
                        if (e.globalAlpha = this.worldAlpha * a.alpha, a.rotation % (2 * Math.PI) == 0) s && (e.setTransform(i.a, i.b, i.c, i.d, i.tx, i.ty), s = !1), e.drawImage(o.baseTexture.source, r.x, r.y, r.width, r.height, a.anchor.x * (-r.width * a.scale.x) + a.position.x + .5 + t.shakeX | 0, a.anchor.y * (-r.height * a.scale.y) + a.position.y + .5 + t.shakeY | 0, r.width * a.scale.x, r.height * a.scale.y);
                        else {
                            s || (s = !0), a.displayObjectUpdateTransform();
                            var h = a.worldTransform,
                                l = h.tx * t.resolution + t.shakeX,
                                c = h.ty * t.resolution + t.shakeY;
                            t.roundPixels ? e.setTransform(h.a, h.b, h.c, h.d, 0 | l, 0 | c) : e.setTransform(h.a, h.b, h.c, h.d, l, c), e.drawImage(o.baseTexture.source, r.x, r.y, r.width, r.height, a.anchor.x * -r.width + .5 | 0, a.anchor.y * -r.height + .5 | 0, r.width, r.height)
                        }
                    }
                }
            }
        }, s.hex2rgb = function(t) {
            return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (255 & t) / 255]
        }, s.rgb2hex = function(t) {
            return (255 * t[0] << 16) + (255 * t[1] << 8) + 255 * t[2]
        }, s.canUseNewCanvasBlendModes = function() {
            if (void 0 === document) return !1;
            var t = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/",
                e = "AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==",
                i = new Image;
            i.src = t + "AP804Oa6" + e;
            var n = new Image;
            n.src = t + "/wCKxvRF" + e;
            var a = s.CanvasPool.create(this, 6, 1),
                o = a.getContext("2d");
            if (o.globalCompositeOperation = "multiply", o.drawImage(i, 0, 0), o.drawImage(n, 2, 0), !o.getImageData(2, 0, 1, 1)) return !1;
            var r = o.getImageData(2, 0, 1, 1)
                .data;
            return s.CanvasPool.remove(this), 255 === r[0] && 0 === r[1] && 0 === r[2]
        }, s.getNextPowerOfTwo = function(t) {
            if (t > 0 && 0 == (t & t - 1)) return t;
            for (var e = 1; e < t;) e <<= 1;
            return e
        }, s.isPowerOfTwo = function(t, e) {
            return t > 0 && 0 == (t & t - 1) && e > 0 && 0 == (e & e - 1)
        }, s.CanvasPool = {
            create: function(t, e, i) {
                var n = s.CanvasPool.getFirst(),
                    a;
                if (-1 === n) {
                    var o = {
                        parent: t,
                        canvas: document.createElement("canvas")
                    };
                    s.CanvasPool.pool.push(o), a = o.canvas
                } else s.CanvasPool.pool[n].parent = t, a = s.CanvasPool.pool[n].canvas;
                return void 0 !== e && (a.width = e, a.height = i), a
            },
            getFirst: function() {
                for (var t = s.CanvasPool.pool, e = 0; e < t.length; e++)
                    if (!t[e].parent) return e;
                return -1
            },
            remove: function(t) {
                for (var e = s.CanvasPool.pool, i = 0; i < e.length; i++) e[i].parent === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
            },
            removeByCanvas: function(t) {
                for (var e = s.CanvasPool.pool, i = 0; i < e.length; i++) e[i].canvas === t && (e[i].parent = null, e[i].canvas.width = 1, e[i].canvas.height = 1)
            },
            getTotal: function() {
                for (var t = s.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent && e++;
                return e
            },
            getFree: function() {
                for (var t = s.CanvasPool.pool, e = 0, i = 0; i < t.length; i++) t[i].parent || e++;
                return e
            }
        }, s.CanvasPool.pool = [], s.initDefaultShaders = function() {}, s.CompileVertexShader = function(t, e) {
            return s._CompileShader(t, e, t.VERTEX_SHADER)
        }, s.CompileFragmentShader = function(t, e) {
            return s._CompileShader(t, e, t.FRAGMENT_SHADER)
        }, s._CompileShader = function(t, e, i) {
            var s = e;
            Array.isArray(e) && (s = e.join("\n"));
            var n = t.createShader(i);
            return t.shaderSource(n, s), t.compileShader(n), t.getShaderParameter(n, t.COMPILE_STATUS) ? n : (window.console.log(t.getShaderInfoLog(n)), null)
        }, s.compileProgram = function(t, e, i) {
            var n = s.CompileFragmentShader(t, i),
                a = s.CompileVertexShader(t, e),
                o = t.createProgram();
            return t.attachShader(o, a), t.attachShader(o, n), t.linkProgram(o), t.getProgramParameter(o, t.LINK_STATUS) || (window.console.log(t.getProgramInfoLog(o)), window.console.log("Could not initialise shaders")), o
        }, s.PixiShader = function(t) {
            this._UID = s._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.textureCount = 0, this.firstRun = !0, this.dirty = !0, this.attributes = [], this.init()
        }, s.PixiShader.prototype.constructor = s.PixiShader, s.PixiShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc || s.PixiShader.defaultVertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aTextureCoord, this.colorAttribute];
            for (var i in this.uniforms) this.uniforms[i].uniformLocation = t.getUniformLocation(e, i);
            this.initUniforms(), this.program = e
        }, s.PixiShader.prototype.initUniforms = function() {
            this.textureCount = 1;
            var t = this.gl,
                e;
            for (var i in this.uniforms) {
                e = this.uniforms[i];
                var s = e.type;
                "sampler2D" === s ? (e._init = !1, null !== e.value && this.initSampler2D(e)) : "mat2" === s || "mat3" === s || "mat4" === s ? (e.glMatrix = !0, e.glValueLength = 1, "mat2" === s ? e.glFunc = t.uniformMatrix2fv : "mat3" === s ? e.glFunc = t.uniformMatrix3fv : "mat4" === s && (e.glFunc = t.uniformMatrix4fv)) : (e.glFunc = t["uniform" + s], e.glValueLength = "2f" === s || "2i" === s ? 2 : "3f" === s || "3i" === s ? 3 : "4f" === s || "4i" === s ? 4 : 1)
            }
        }, s.PixiShader.prototype.initSampler2D = function(t) {
            if (t.value && t.value.baseTexture && t.value.baseTexture.hasLoaded) {
                var e = this.gl;
                if (e.activeTexture(e["TEXTURE" + this.textureCount]), e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), t.textureData) {
                    var i = t.textureData,
                        s = i.magFilter ? i.magFilter : e.LINEAR,
                        n = i.minFilter ? i.minFilter : e.LINEAR,
                        a = i.wrapS ? i.wrapS : e.CLAMP_TO_EDGE,
                        o = i.wrapT ? i.wrapT : e.CLAMP_TO_EDGE,
                        r = i.luminance ? e.LUMINANCE : e.RGBA;
                    if (i.repeat && (a = e.REPEAT, o = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) {
                        var h = i.width ? i.width : 512,
                            l = i.height ? i.height : 2,
                            c = i.border ? i.border : 0;
                        e.texImage2D(e.TEXTURE_2D, 0, r, h, l, c, r, e.UNSIGNED_BYTE, null)
                    } else e.texImage2D(e.TEXTURE_2D, 0, r, e.RGBA, e.UNSIGNED_BYTE, t.value.baseTexture.source);
                    e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, a), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, o)
                }
                e.uniform1i(t.uniformLocation, this.textureCount), t._init = !0, this.textureCount++
            }
        }, s.PixiShader.prototype.syncUniforms = function() {
            this.textureCount = 1;
            var t, e = this.gl;
            for (var i in this.uniforms) t = this.uniforms[i], 1 === t.glValueLength ? !0 === t.glMatrix ? t.glFunc.call(e, t.uniformLocation, t.transpose, t.value) : t.glFunc.call(e, t.uniformLocation, t.value) : 2 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y) : 3 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z) : 4 === t.glValueLength ? t.glFunc.call(e, t.uniformLocation, t.value.x, t.value.y, t.value.z, t.value.w) : "sampler2D" === t.type && (t._init ? (e.activeTexture(e["TEXTURE" + this.textureCount]), t.value.baseTexture._dirty[e.id] ? s.instances[e.id].updateTexture(t.value.baseTexture) : e.bindTexture(e.TEXTURE_2D, t.value.baseTexture._glTextures[e.id]), e.uniform1i(t.uniformLocation, this.textureCount), this.textureCount++) : this.initSampler2D(t))
        }, s.PixiShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.PixiShader.defaultVertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "attribute vec4 aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   gl_Position = vec4( ((aVertexPosition + offsetVector) / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = vec4(aColor.rgb * aColor.a, aColor.a);", "}"], s.PixiFastShader = function(t) {
            this._UID = s._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision lowp float;", "varying vec2 vTextureCoord;", "varying float vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aPositionCoord;", "attribute vec2 aScale;", "attribute float aRotation;", "attribute vec2 aTextureCoord;", "attribute float aColor;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform mat3 uMatrix;", "varying vec2 vTextureCoord;", "varying float vColor;", "const vec2 center = vec2(-1.0, 1.0);", "void main(void) {", "   vec2 v;", "   vec2 sv = aVertexPosition * aScale;", "   v.x = (sv.x) * cos(aRotation) - (sv.y) * sin(aRotation);", "   v.y = (sv.x) * sin(aRotation) + (sv.y) * cos(aRotation);", "   v = ( uMatrix * vec3(v + aPositionCoord , 1.0) ).xy ;", "   gl_Position = vec4( ( v / projectionVector) + center , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "   vColor = aColor;", "}"], this.textureCount = 0, this.init()
        }, s.PixiFastShader.prototype.constructor = s.PixiFastShader, s.PixiFastShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.dimensions = t.getUniformLocation(e, "dimensions"), this.uMatrix = t.getUniformLocation(e, "uMatrix"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aPositionCoord = t.getAttribLocation(e, "aPositionCoord"), this.aScale = t.getAttribLocation(e, "aScale"), this.aRotation = t.getAttribLocation(e, "aRotation"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.colorAttribute = t.getAttribLocation(e, "aColor"), -1 === this.colorAttribute && (this.colorAttribute = 2), this.attributes = [this.aVertexPosition, this.aPositionCoord, this.aScale, this.aRotation, this.aTextureCoord, this.colorAttribute], this.program = e
        }, s.PixiFastShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.StripShader = function(t) {
            this._UID = s._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec2 vTextureCoord;", "uniform float alpha;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.x, vTextureCoord.y)) * alpha;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec2 aTextureCoord;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "varying vec2 vTextureCoord;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, v.y / -projectionVector.y + 1.0 , 0.0, 1.0);", "   vTextureCoord = aTextureCoord;", "}"], this.init()
        }, s.StripShader.prototype.constructor = s.StripShader, s.StripShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.uSampler = t.getUniformLocation(e, "uSampler"), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.aTextureCoord = t.getAttribLocation(e, "aTextureCoord"), this.attributes = [this.aVertexPosition, this.aTextureCoord], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.StripShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, s.PrimitiveShader = function(t) {
            this._UID = s._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "attribute vec4 aColor;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform float alpha;", "uniform float flipY;", "uniform vec3 tint;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = aColor * vec4(tint * alpha, alpha);", "}"], this.init()
        }, s.PrimitiveShader.prototype.constructor = s.PrimitiveShader, s.PrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.colorAttribute = t.getAttribLocation(e, "aColor"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.PrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attributes = null
        }, s.ComplexPrimitiveShader = function(t) {
            this._UID = s._UID++, this.gl = t, this.program = null, this.fragmentSrc = ["precision mediump float;", "varying vec4 vColor;", "void main(void) {", "   gl_FragColor = vColor;", "}"], this.vertexSrc = ["attribute vec2 aVertexPosition;", "uniform mat3 translationMatrix;", "uniform vec2 projectionVector;", "uniform vec2 offsetVector;", "uniform vec3 tint;", "uniform float alpha;", "uniform vec3 color;", "uniform float flipY;", "varying vec4 vColor;", "void main(void) {", "   vec3 v = translationMatrix * vec3(aVertexPosition , 1.0);", "   v -= offsetVector.xyx;", "   gl_Position = vec4( v.x / projectionVector.x -1.0, (v.y / projectionVector.y * -flipY) + flipY , 0.0, 1.0);", "   vColor = vec4(color * alpha * tint, alpha);", "}"], this.init()
        }, s.ComplexPrimitiveShader.prototype.constructor = s.ComplexPrimitiveShader, s.ComplexPrimitiveShader.prototype.init = function() {
            var t = this.gl,
                e = s.compileProgram(t, this.vertexSrc, this.fragmentSrc);
            t.useProgram(e), this.projectionVector = t.getUniformLocation(e, "projectionVector"), this.offsetVector = t.getUniformLocation(e, "offsetVector"), this.tintColor = t.getUniformLocation(e, "tint"), this.color = t.getUniformLocation(e, "color"), this.flipY = t.getUniformLocation(e, "flipY"), this.aVertexPosition = t.getAttribLocation(e, "aVertexPosition"), this.attributes = [this.aVertexPosition, this.colorAttribute], this.translationMatrix = t.getUniformLocation(e, "translationMatrix"), this.alpha = t.getUniformLocation(e, "alpha"), this.program = e
        }, s.ComplexPrimitiveShader.prototype.destroy = function() {
            this.gl.deleteProgram(this.program), this.uniforms = null, this.gl = null, this.attribute = null
        }, s.glContexts = [], s.instances = [], s.WebGLRenderer = function(t) {
            this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.type = s.WEBGL_RENDERER, this.resolution = t.resolution, this.transparent = t.transparent, this.autoResize = !1, this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.clearBeforeRender = t.clearBeforeRender, this.width = t.width, this.height = t.height, this.view = t.canvas, this._contextOptions = {
                alpha: this.transparent,
                antialias: t.antialias,
                premultipliedAlpha: this.transparent && "notMultiplied" !== this.transparent,
                stencil: !0,
                preserveDrawingBuffer: this.preserveDrawingBuffer
            }, this.projection = new s.Point, this.offset = new s.Point, this.shaderManager = new s.WebGLShaderManager, this.spriteBatch = new s.WebGLSpriteBatch, this.maskManager = new s.WebGLMaskManager, this.filterManager = new s.WebGLFilterManager, this.stencilManager = new s.WebGLStencilManager, this.blendModeManager = new s.WebGLBlendModeManager, this.renderSession = {}, this.renderSession.game = this.game, this.renderSession.gl = this.gl, this.renderSession.drawCount = 0, this.renderSession.shaderManager = this.shaderManager, this.renderSession.maskManager = this.maskManager, this.renderSession.filterManager = this.filterManager, this.renderSession.blendModeManager = this.blendModeManager, this.renderSession.spriteBatch = this.spriteBatch, this.renderSession.stencilManager = this.stencilManager, this.renderSession.renderer = this, this.renderSession.resolution = this.resolution, this.initContext(), this.mapBlendModes()
        }, s.WebGLRenderer.prototype.constructor = s.WebGLRenderer, s.WebGLRenderer.prototype.initContext = function() {
            var t = this.view.getContext("webgl", this._contextOptions) || this.view.getContext("experimental-webgl", this._contextOptions);
            if (this.gl = t, !t) throw new Error("This browser does not support webGL. Try using the canvas renderer");
            this.glContextId = t.id = s.WebGLRenderer.glContextId++, s.glContexts[this.glContextId] = t, s.instances[this.glContextId] = this, t.disable(t.DEPTH_TEST), t.disable(t.CULL_FACE), t.enable(t.BLEND), this.shaderManager.setContext(t), this.spriteBatch.setContext(t), this.maskManager.setContext(t), this.filterManager.setContext(t), this.blendModeManager.setContext(t), this.stencilManager.setContext(t), this.renderSession.gl = this.gl, this.resize(this.width, this.height)
        }, s.WebGLRenderer.prototype.render = function(t) {
            if (!this.contextLost) {
                var e = this.gl;
                e.viewport(0, 0, this.width, this.height), e.bindFramebuffer(e.FRAMEBUFFER, null), this.game.clearBeforeRender && (e.clearColor(t._bgColor.r, t._bgColor.g, t._bgColor.b, t._bgColor.a), e.clear(e.COLOR_BUFFER_BIT)), this.offset.x = this.game.camera._shake.x, this.offset.y = this.game.camera._shake.y, this.renderDisplayObject(t, this.projection)
            }
        }, s.WebGLRenderer.prototype.renderDisplayObject = function(t, e, i, n) {
            this.renderSession.blendModeManager.setBlendMode(s.blendModes.NORMAL), this.renderSession.drawCount = 0, this.renderSession.flipY = i ? -1 : 1, this.renderSession.projection = e, this.renderSession.offset = this.offset, this.spriteBatch.begin(this.renderSession), this.filterManager.begin(this.renderSession, i), t._renderWebGL(this.renderSession, n), this.spriteBatch.end()
        }, s.WebGLRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.gl.viewport(0, 0, this.width, this.height), this.projection.x = this.width / 2 / this.resolution, this.projection.y = -this.height / 2 / this.resolution
        }, s.WebGLRenderer.prototype.updateTexture = function(t) {
            if (!t.hasLoaded) return !1;
            var e = this.gl;
            return t._glTextures[e.id] || (t._glTextures[e.id] = e.createTexture()), e.bindTexture(e.TEXTURE_2D, t._glTextures[e.id]), e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t.premultipliedAlpha), e.texImage2D(e.TEXTURE_2D, 0, e.RGBA, e.RGBA, e.UNSIGNED_BYTE, t.source), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t.mipmap && s.isPowerOfTwo(t.width, t.height) ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR_MIPMAP_LINEAR : e.NEAREST_MIPMAP_NEAREST), e.generateMipmap(e.TEXTURE_2D)) : e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, t.scaleMode === s.scaleModes.LINEAR ? e.LINEAR : e.NEAREST), t._powerOf2 ? (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.REPEAT), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.REPEAT)) : (e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE)), t._dirty[e.id] = !1, !0
        }, s.WebGLRenderer.prototype.destroy = function() {
            s.glContexts[this.glContextId] = null, this.projection = null, this.offset = null, this.shaderManager.destroy(), this.spriteBatch.destroy(), this.maskManager.destroy(), this.filterManager.destroy(), this.shaderManager = null, this.spriteBatch = null, this.maskManager = null, this.filterManager = null, this.gl = null, this.renderSession = null, s.CanvasPool.remove(this), s.instances[this.glContextId] = null, s.WebGLRenderer.glContextId--
        }, s.WebGLRenderer.prototype.mapBlendModes = function() {
            var t = this.gl;
            if (!s.blendModesWebGL) {
                var e = [],
                    i = s.blendModes;
                e[i.NORMAL] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.ADD] = [t.SRC_ALPHA, t.DST_ALPHA], e[i.MULTIPLY] = [t.DST_COLOR, t.ONE_MINUS_SRC_ALPHA], e[i.SCREEN] = [t.SRC_ALPHA, t.ONE], e[i.OVERLAY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DARKEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LIGHTEN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_DODGE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR_BURN] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HARD_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SOFT_LIGHT] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.DIFFERENCE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.EXCLUSION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.HUE] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.SATURATION] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.COLOR] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], e[i.LUMINOSITY] = [t.ONE, t.ONE_MINUS_SRC_ALPHA], s.blendModesWebGL = e
            }
        }, s.WebGLRenderer.glContextId = 0, s.WebGLBlendModeManager = function() {
            this.currentBlendMode = 99999
        }, s.WebGLBlendModeManager.prototype.constructor = s.WebGLBlendModeManager, s.WebGLBlendModeManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLBlendModeManager.prototype.setBlendMode = function(t) {
            if (this.currentBlendMode === t) return !1;
            this.currentBlendMode = t;
            var e = s.blendModesWebGL[this.currentBlendMode];
            return e && this.gl.blendFunc(e[0], e[1]), !0
        }, s.WebGLBlendModeManager.prototype.destroy = function() {
            this.gl = null
        }, s.WebGLMaskManager = function() {}, s.WebGLMaskManager.prototype.constructor = s.WebGLMaskManager, s.WebGLMaskManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLMaskManager.prototype.pushMask = function(t, e) {
            var i = e.gl;
            t.dirty && s.WebGLGraphics.updateGraphics(t, i), void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.pushStencil(t, t._webGL[i.id].data[0], e)
        }, s.WebGLMaskManager.prototype.popMask = function(t, e) {
            var i = this.gl;
            void 0 !== t._webGL[i.id] && void 0 !== t._webGL[i.id].data && 0 !== t._webGL[i.id].data.length && e.stencilManager.popStencil(t, t._webGL[i.id].data[0], e)
        }, s.WebGLMaskManager.prototype.destroy = function() {
            this.gl = null
        }, s.WebGLStencilManager = function() {
            this.stencilStack = [], this.reverse = !0, this.count = 0
        }, s.WebGLStencilManager.prototype.setContext = function(t) {
            this.gl = t
        }, s.WebGLStencilManager.prototype.pushStencil = function(t, e, i) {
            var s = this.gl;
            this.bindGraphics(t, e, i), 0 === this.stencilStack.length && (s.enable(s.STENCIL_TEST), s.clear(s.STENCIL_BUFFER_BIT), this.reverse = !0, this.count = 0), this.stencilStack.push(e);
            var n = this.count;
            s.colorMask(!1, !1, !1, !1), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), 1 === e.mode ? (s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), this.reverse ? s.stencilFunc(s.EQUAL, 255 - (n + 1), 255) : s.stencilFunc(s.EQUAL, n + 1, 255), this.reverse = !this.reverse) : (this.reverse ? (s.stencilFunc(s.EQUAL, n, 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, 255 - n, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n + 1, 255) : s.stencilFunc(s.EQUAL, 255 - (n + 1), 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP), this.count++
        }, s.WebGLStencilManager.prototype.bindGraphics = function(t, e, i) {
            this._currentGraphics = t;
            var n = this.gl,
                a = i.projection,
                o = i.offset,
                r;
            1 === e.mode ? (r = i.shaderManager.complexPrimitiveShader, i.shaderManager.setShader(r), n.uniform1f(r.flipY, i.flipY), n.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform2f(r.projectionVector, a.x, -a.y), n.uniform2f(r.offsetVector, -o.x, -o.y), n.uniform3fv(r.tintColor, s.hex2rgb(t.tint)), n.uniform3fv(r.color, e.color), n.uniform1f(r.alpha, t.worldAlpha * e.alpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(r.aVertexPosition, 2, n.FLOAT, !1, 8, 0), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer)) : (r = i.shaderManager.primitiveShader, i.shaderManager.setShader(r), n.uniformMatrix3fv(r.translationMatrix, !1, t.worldTransform.toArray(!0)), n.uniform1f(r.flipY, i.flipY), n.uniform2f(r.projectionVector, a.x, -a.y), n.uniform2f(r.offsetVector, -o.x, -o.y), n.uniform3fv(r.tintColor, s.hex2rgb(t.tint)), n.uniform1f(r.alpha, t.worldAlpha), n.bindBuffer(n.ARRAY_BUFFER, e.buffer), n.vertexAttribPointer(r.aVertexPosition, 2, n.FLOAT, !1, 24, 0), n.vertexAttribPointer(r.colorAttribute, 4, n.FLOAT, !1, 24, 8), n.bindBuffer(n.ELEMENT_ARRAY_BUFFER, e.indexBuffer))
        }, s.WebGLStencilManager.prototype.popStencil = function(t, e, i) {
            var s = this.gl;
            if (this.stencilStack.pop(), this.count--, 0 === this.stencilStack.length) s.disable(s.STENCIL_TEST);
            else {
                var n = this.count;
                this.bindGraphics(t, e, i), s.colorMask(!1, !1, !1, !1), 1 === e.mode ? (this.reverse = !this.reverse, this.reverse ? (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)) : (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)), s.drawElements(s.TRIANGLE_FAN, 4, s.UNSIGNED_SHORT, 2 * (e.indices.length - 4)), s.stencilFunc(s.ALWAYS, 0, 255), s.stencilOp(s.KEEP, s.KEEP, s.INVERT), s.drawElements(s.TRIANGLE_FAN, e.indices.length - 4, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)) : (this.reverse ? (s.stencilFunc(s.EQUAL, n + 1, 255), s.stencilOp(s.KEEP, s.KEEP, s.DECR)) : (s.stencilFunc(s.EQUAL, 255 - (n + 1), 255), s.stencilOp(s.KEEP, s.KEEP, s.INCR)), s.drawElements(s.TRIANGLE_STRIP, e.indices.length, s.UNSIGNED_SHORT, 0), this.reverse ? s.stencilFunc(s.EQUAL, n, 255) : s.stencilFunc(s.EQUAL, 255 - n, 255)), s.colorMask(!0, !0, !0, !0), s.stencilOp(s.KEEP, s.KEEP, s.KEEP)
            }
        }, s.WebGLStencilManager.prototype.destroy = function() {
            this.stencilStack = null, this.gl = null
        }, s.WebGLShaderManager = function() {
            this.maxAttibs = 10, this.attribState = [], this.tempAttribState = [];
            for (var t = 0; t < this.maxAttibs; t++) this.attribState[t] = !1;
            this.stack = []
        }, s.WebGLShaderManager.prototype.constructor = s.WebGLShaderManager, s.WebGLShaderManager.prototype.setContext = function(t) {
            this.gl = t, this.primitiveShader = new s.PrimitiveShader(t), this.complexPrimitiveShader = new s.ComplexPrimitiveShader(t), this.defaultShader = new s.PixiShader(t), this.fastShader = new s.PixiFastShader(t), this.stripShader = new s.StripShader(t), this.setShader(this.defaultShader)
        }, s.WebGLShaderManager.prototype.setAttribs = function(t) {
            var e;
            for (e = 0; e < this.tempAttribState.length; e++) this.tempAttribState[e] = !1;
            for (e = 0; e < t.length; e++) {
                var i = t[e];
                this.tempAttribState[i] = !0
            }
            var s = this.gl;
            for (e = 0; e < this.attribState.length; e++) this.attribState[e] !== this.tempAttribState[e] && (this.attribState[e] = this.tempAttribState[e], this.tempAttribState[e] ? s.enableVertexAttribArray(e) : s.disableVertexAttribArray(e))
        }, s.WebGLShaderManager.prototype.setShader = function(t) {
            return this._currentId !== t._UID && (this._currentId = t._UID, this.currentShader = t, this.gl.useProgram(t.program), this.setAttribs(t.attributes), !0)
        }, s.WebGLShaderManager.prototype.destroy = function() {
            this.attribState = null, this.tempAttribState = null, this.primitiveShader.destroy(), this.complexPrimitiveShader.destroy(), this.defaultShader.destroy(), this.fastShader.destroy(), this.stripShader.destroy(), this.gl = null
        }, s.WebGLSpriteBatch = function() {
            this.vertSize = 5, this.size = 2e3;
            var t = 4 * this.size * 4 * this.vertSize,
                e = 6 * this.size;
            this.vertices = new s.ArrayBuffer(t), this.positions = new s.Float32Array(this.vertices), this.colors = new s.Uint32Array(this.vertices), this.indices = new s.Uint16Array(e), this.lastIndexCount = 0;
            for (var i = 0, n = 0; i < e; i += 6, n += 4) this.indices[i + 0] = n + 0, this.indices[i + 1] = n + 1, this.indices[i + 2] = n + 2, this.indices[i + 3] = n + 0, this.indices[i + 4] = n + 2, this.indices[i + 5] = n + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.dirty = !0, this.textures = [], this.blendModes = [], this.shaders = [], this.sprites = [], this.defaultShader = new s.AbstractFilter(["precision lowp float;", "varying vec2 vTextureCoord;", "varying vec4 vColor;", "uniform sampler2D uSampler;", "void main(void) {", "   gl_FragColor = texture2D(uSampler, vTextureCoord) * vColor ;", "}"])
        }, s.WebGLSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW), this.currentBlendMode = 99999;
            var e = new s.PixiShader(t);
            e.fragmentSrc = this.defaultShader.fragmentSrc, e.uniforms = {}, e.init(), this.defaultShader.shaders[t.id] = e
        }, s.WebGLSpriteBatch.prototype.begin = function(t) {
            this.renderSession = t, this.shader = this.renderSession.shaderManager.defaultShader, this.start()
        }, s.WebGLSpriteBatch.prototype.end = function() {
            this.flush()
        }, s.WebGLSpriteBatch.prototype.render = function(t, e) {
            var i = t.texture,
                s = t.worldTransform;
            e && (s = e), this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = i.baseTexture);
            var n = i._uvs;
            if (n) {
                var a = t.anchor.x,
                    o = t.anchor.y,
                    r, h, l, c;
                if (i.trim) {
                    var u = i.trim;
                    h = u.x - a * u.width, r = h + i.crop.width, c = u.y - o * u.height, l = c + i.crop.height
                } else r = i.frame.width * (1 - a), h = i.frame.width * -a, l = i.frame.height * (1 - o), c = i.frame.height * -o;
                var d = 4 * this.currentBatchSize * this.vertSize,
                    p = i.baseTexture.resolution,
                    f = s.a / p,
                    g = s.b / p,
                    y = s.c / p,
                    m = s.d / p,
                    v = s.tx,
                    b = s.ty,
                    x = this.colors,
                    _ = this.positions;
                this.renderSession.roundPixels ? (_[d] = f * h + y * c + v | 0, _[d + 1] = m * c + g * h + b | 0, _[d + 5] = f * r + y * c + v | 0, _[d + 6] = m * c + g * r + b | 0, _[d + 10] = f * r + y * l + v | 0, _[d + 11] = m * l + g * r + b | 0, _[d + 15] = f * h + y * l + v | 0, _[d + 16] = m * l + g * h + b | 0) : (_[d] = f * h + y * c + v, _[d + 1] = m * c + g * h + b, _[d + 5] = f * r + y * c + v, _[d + 6] = m * c + g * r + b, _[d + 10] = f * r + y * l + v, _[d + 11] = m * l + g * r + b, _[d + 15] = f * h + y * l + v, _[d + 16] = m * l + g * h + b), _[d + 2] = n.x0, _[d + 3] = n.y0, _[d + 7] = n.x1, _[d + 8] = n.y1, _[d + 12] = n.x2, _[d + 13] = n.y2, _[d + 17] = n.x3, _[d + 18] = n.y3;
                var w = t.tint;
                x[d + 4] = x[d + 9] = x[d + 14] = x[d + 19] = (w >> 16) + (65280 & w) + ((255 & w) << 16) + (255 * t.worldAlpha << 24), this.sprites[this.currentBatchSize++] = t
            }
        }, s.WebGLSpriteBatch.prototype.renderTilingSprite = function(t) {
            var e = t.tilingTexture;
            this.currentBatchSize >= this.size && (this.flush(), this.currentBaseTexture = e.baseTexture), t._uvs || (t._uvs = new s.TextureUvs);
            var i = t._uvs,
                n = e.baseTexture.width,
                a = e.baseTexture.height;
            t.tilePosition.x %= n * t.tileScaleOffset.x, t.tilePosition.y %= a * t.tileScaleOffset.y;
            var o = t.tilePosition.x / (n * t.tileScaleOffset.x),
                r = t.tilePosition.y / (a * t.tileScaleOffset.y),
                h = t.width / n / (t.tileScale.x * t.tileScaleOffset.x),
                l = t.height / a / (t.tileScale.y * t.tileScaleOffset.y);
            i.x0 = 0 - o, i.y0 = 0 - r, i.x1 = 1 * h - o, i.y1 = 0 - r, i.x2 = 1 * h - o, i.y2 = 1 * l - r, i.x3 = 0 - o, i.y3 = 1 * l - r;
            var c = t.tint,
                u = (c >> 16) + (65280 & c) + ((255 & c) << 16) + (255 * t.worldAlpha << 24),
                d = this.positions,
                p = this.colors,
                f = t.width,
                g = t.height,
                y = t.anchor.x,
                m = t.anchor.y,
                v = f * (1 - y),
                b = f * -y,
                x = g * (1 - m),
                _ = g * -m,
                w = 4 * this.currentBatchSize * this.vertSize,
                C = e.baseTexture.resolution,
                P = t.worldTransform,
                T = P.a / C,
                S = P.b / C,
                A = P.c / C,
                E = P.d / C,
                I = P.tx,
                M = P.ty;
            d[w++] = T * b + A * _ + I, d[w++] = E * _ + S * b + M, d[w++] = i.x0, d[w++] = i.y0, p[w++] = u, d[w++] = T * v + A * _ + I, d[w++] = E * _ + S * v + M, d[w++] = i.x1, d[w++] = i.y1, p[w++] = u, d[w++] = T * v + A * x + I, d[w++] = E * x + S * v + M, d[w++] = i.x2, d[w++] = i.y2, p[w++] = u, d[w++] = T * b + A * x + I, d[w++] = E * x + S * b + M, d[w++] = i.x3, d[w++] = i.y3, p[w++] = u, this.sprites[this.currentBatchSize++] = t
        }, s.WebGLSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl,
                    e;
                if (this.dirty) {
                    this.dirty = !1, t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), e = this.defaultShader.shaders[t.id];
                    var i = 4 * this.vertSize;
                    t.vertexAttribPointer(e.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(e.aTextureCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(e.colorAttribute, 4, t.UNSIGNED_BYTE, !0, i, 16)
                }
                if (this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var n = this.positions.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, n)
                }
                for (var a, o, r, h = 0, l = 0, c = null, u = this.renderSession.blendModeManager.currentBlendMode, d = null, p = !1, f = !1, g, y = 0, m = this.currentBatchSize; y < m; y++) {
                    g = this.sprites[y], a = g.tilingTexture ? g.tilingTexture.baseTexture : g.texture.baseTexture, o = g.blendMode, r = g.shader || this.defaultShader, p = u !== o, f = d !== r;
                    var v = a.skipRender;
                    if (v && g.children.length > 0 && (v = !1), (c !== a && !v || p || f) && (this.renderBatch(c, h, l), l = y, h = 0, c = a, p && (u = o, this.renderSession.blendModeManager.setBlendMode(u)), f)) {
                        d = r, e = d.shaders[t.id], e || (e = new s.PixiShader(t), e.fragmentSrc = d.fragmentSrc, e.uniforms = d.uniforms, e.init(), d.shaders[t.id] = e), this.renderSession.shaderManager.setShader(e), e.dirty && e.syncUniforms();
                        var b = this.renderSession.projection;
                        t.uniform2f(e.projectionVector, b.x, b.y);
                        var x = this.renderSession.offset;
                        t.uniform2f(e.offsetVector, x.x, x.y)
                    }
                    h++
                }
                this.renderBatch(c, h, l), this.currentBatchSize = 0
            }
        }, s.WebGLSpriteBatch.prototype.renderBatch = function(t, e, i) {
            if (0 !== e) {
                var s = this.gl;
                if (t._dirty[s.id]) {
                    if (!this.renderSession.renderer.updateTexture(t)) return
                } else s.bindTexture(s.TEXTURE_2D, t._glTextures[s.id]);
                s.drawElements(s.TRIANGLES, 6 * e, s.UNSIGNED_SHORT, 6 * i * 2), this.renderSession.drawCount++
            }
        }, s.WebGLSpriteBatch.prototype.stop = function() {
            this.flush(), this.dirty = !0
        }, s.WebGLSpriteBatch.prototype.start = function() {
            this.dirty = !0
        }, s.WebGLSpriteBatch.prototype.destroy = function() {
            this.vertices = null, this.indices = null, this.gl.deleteBuffer(this.vertexBuffer), this.gl.deleteBuffer(this.indexBuffer), this.currentBaseTexture = null, this.gl = null
        }, s.WebGLFastSpriteBatch = function(t) {
            this.vertSize = 10, this.maxSize = 6e3, this.size = this.maxSize;
            var e = 4 * this.size * this.vertSize,
                i = 6 * this.maxSize;
            this.vertices = new s.Float32Array(e), this.indices = new s.Uint16Array(i), this.vertexBuffer = null, this.indexBuffer = null, this.lastIndexCount = 0;
            for (var n = 0, a = 0; n < i; n += 6, a += 4) this.indices[n + 0] = a + 0, this.indices[n + 1] = a + 1, this.indices[n + 2] = a + 2, this.indices[n + 3] = a + 0, this.indices[n + 4] = a + 2, this.indices[n + 5] = a + 3;
            this.drawing = !1, this.currentBatchSize = 0, this.currentBaseTexture = null, this.currentBlendMode = 0, this.renderSession = null, this.shader = null, this.matrix = null, this.setContext(t)
        }, s.WebGLFastSpriteBatch.prototype.constructor = s.WebGLFastSpriteBatch, s.WebGLFastSpriteBatch.prototype.setContext = function(t) {
            this.gl = t, this.vertexBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.indices, t.STATIC_DRAW), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertices, t.DYNAMIC_DRAW)
        }, s.WebGLFastSpriteBatch.prototype.begin = function(t, e) {
            this.renderSession = e, this.shader = this.renderSession.shaderManager.fastShader, this.matrix = t.worldTransform.toArray(!0), this.start()
        }, s.WebGLFastSpriteBatch.prototype.end = function() {
            this.flush()
        }, s.WebGLFastSpriteBatch.prototype.render = function(t) {
            var e = t.children,
                i = e[0];
            if (i.texture._uvs) {
                this.currentBaseTexture = i.texture.baseTexture, i.blendMode !== this.renderSession.blendModeManager.currentBlendMode && (this.flush(), this.renderSession.blendModeManager.setBlendMode(i.blendMode));
                for (var s = 0, n = e.length; s < n; s++) this.renderSprite(e[s]);
                this.flush()
            }
        }, s.WebGLFastSpriteBatch.prototype.renderSprite = function(t) {
            if (t.visible && (t.texture.baseTexture === this.currentBaseTexture || t.texture.baseTexture.skipRender || (this.flush(), this.currentBaseTexture = t.texture.baseTexture, t.texture._uvs))) {
                var e, i = this.vertices,
                    s, n, a, o, r, h, l;
                if (e = t.texture._uvs, s = t.texture.frame.width, n = t.texture.frame.height, t.texture.trim) {
                    var c = t.texture.trim;
                    o = c.x - t.anchor.x * c.width, a = o + t.texture.crop.width, h = c.y - t.anchor.y * c.height, r = h + t.texture.crop.height
                } else a = t.texture.frame.width * (1 - t.anchor.x), o = t.texture.frame.width * -t.anchor.x, r = t.texture.frame.height * (1 - t.anchor.y), h = t.texture.frame.height * -t.anchor.y;
                l = 4 * this.currentBatchSize * this.vertSize, i[l++] = o, i[l++] = h, i[l++] = t.position.x, i[l++] = t.position.y, i[l++] = t.scale.x, i[l++] = t.scale.y, i[l++] = t.rotation, i[l++] = e.x0, i[l++] = e.y1, i[l++] = t.alpha, i[l++] = a, i[l++] = h, i[l++] = t.position.x, i[l++] = t.position.y, i[l++] = t.scale.x, i[l++] = t.scale.y, i[l++] = t.rotation, i[l++] = e.x1, i[l++] = e.y1, i[l++] = t.alpha, i[l++] = a, i[l++] = r, i[l++] = t.position.x, i[l++] = t.position.y, i[l++] = t.scale.x, i[l++] = t.scale.y, i[l++] = t.rotation, i[l++] = e.x2, i[l++] = e.y2, i[l++] = t.alpha, i[l++] = o, i[l++] = r, i[l++] = t.position.x, i[l++] = t.position.y, i[l++] = t.scale.x, i[l++] = t.scale.y, i[l++] = t.rotation, i[l++] = e.x3, i[l++] = e.y3, i[l++] = t.alpha, this.currentBatchSize++, this.currentBatchSize >= this.size && this.flush()
            }
        }, s.WebGLFastSpriteBatch.prototype.flush = function() {
            if (0 !== this.currentBatchSize) {
                var t = this.gl;
                if (this.currentBaseTexture._glTextures[t.id] || this.renderSession.renderer.updateTexture(this.currentBaseTexture, t), t.bindTexture(t.TEXTURE_2D, this.currentBaseTexture._glTextures[t.id]), this.currentBatchSize > .5 * this.size) t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertices);
                else {
                    var e = this.vertices.subarray(0, 4 * this.currentBatchSize * this.vertSize);
                    t.bufferSubData(t.ARRAY_BUFFER, 0, e)
                }
                t.drawElements(t.TRIANGLES, 6 * this.currentBatchSize, t.UNSIGNED_SHORT, 0), this.currentBatchSize = 0, this.renderSession.drawCount++
            }
        }, s.WebGLFastSpriteBatch.prototype.stop = function() {
            this.flush()
        }, s.WebGLFastSpriteBatch.prototype.start = function() {
            var t = this.gl;
            t.activeTexture(t.TEXTURE0), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            var e = this.renderSession.projection;
            t.uniform2f(this.shader.projectionVector, e.x, e.y), t.uniformMatrix3fv(this.shader.uMatrix, !1, this.matrix);
            var i = 4 * this.vertSize;
            t.vertexAttribPointer(this.shader.aVertexPosition, 2, t.FLOAT, !1, i, 0), t.vertexAttribPointer(this.shader.aPositionCoord, 2, t.FLOAT, !1, i, 8), t.vertexAttribPointer(this.shader.aScale, 2, t.FLOAT, !1, i, 16), t.vertexAttribPointer(this.shader.aRotation, 1, t.FLOAT, !1, i, 24), t.vertexAttribPointer(this.shader.aTextureCoord, 2, t.FLOAT, !1, i, 28), t.vertexAttribPointer(this.shader.colorAttribute, 1, t.FLOAT, !1, i, 36)
        }, s.WebGLFilterManager = function() {
            this.filterStack = [], this.offsetX = 0, this.offsetY = 0
        }, s.WebGLFilterManager.prototype.constructor = s.WebGLFilterManager, s.WebGLFilterManager.prototype.setContext = function(t) {
            this.gl = t, this.texturePool = [], this.initShaderBuffers()
        }, s.WebGLFilterManager.prototype.begin = function(t, e) {
            this.renderSession = t, this.defaultShader = t.shaderManager.defaultShader;
            var i = this.renderSession.projection;
            this.width = 2 * i.x, this.height = 2 * -i.y, this.buffer = e
        }, s.WebGLFilterManager.prototype.pushFilter = function(t) {
            var e = this.gl,
                i = this.renderSession.projection,
                n = this.renderSession.offset;
            t._filterArea = t.target.filterArea || t.target.getBounds(), t._previous_stencil_mgr = this.renderSession.stencilManager, this.renderSession.stencilManager = new s.WebGLStencilManager, this.renderSession.stencilManager.setContext(e), e.disable(e.STENCIL_TEST), this.filterStack.push(t);
            var a = t.filterPasses[0];
            this.offsetX += t._filterArea.x, this.offsetY += t._filterArea.y;
            var o = this.texturePool.pop();
            o ? o.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution) : o = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), e.bindTexture(e.TEXTURE_2D, o.texture);
            var r = t._filterArea,
                h = a.padding;
            r.x -= h, r.y -= h, r.width += 2 * h, r.height += 2 * h, r.x < 0 && (r.x = 0), r.width > this.width && (r.width = this.width), r.y < 0 && (r.y = 0), r.height > this.height && (r.height = this.height), e.bindFramebuffer(e.FRAMEBUFFER, o.frameBuffer), e.viewport(0, 0, r.width * this.renderSession.resolution, r.height * this.renderSession.resolution), i.x = r.width / 2, i.y = -r.height / 2, n.x = -r.x, n.y = -r.y, e.colorMask(!0, !0, !0, !0), e.clearColor(0, 0, 0, 0), e.clear(e.COLOR_BUFFER_BIT), t._glFilterTexture = o
        }, s.WebGLFilterManager.prototype.popFilter = function() {
            var t = this.gl,
                e = this.filterStack.pop(),
                i = e._filterArea,
                n = e._glFilterTexture,
                a = this.renderSession.projection,
                o = this.renderSession.offset;
            if (e.filterPasses.length > 1) {
                t.viewport(0, 0, i.width * this.renderSession.resolution, i.height * this.renderSession.resolution), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = 0, this.vertexArray[1] = i.height, this.vertexArray[2] = i.width, this.vertexArray[3] = i.height, this.vertexArray[4] = 0, this.vertexArray[5] = 0, this.vertexArray[6] = i.width, this.vertexArray[7] = 0, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray);
                var r = n,
                    h = this.texturePool.pop();
                h || (h = new s.FilterTexture(this.gl, this.width * this.renderSession.resolution, this.height * this.renderSession.resolution)), h.resize(this.width * this.renderSession.resolution, this.height * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.clear(t.COLOR_BUFFER_BIT), t.disable(t.BLEND);
                for (var l = 0; l < e.filterPasses.length - 1; l++) {
                    var c = e.filterPasses[l];
                    t.bindFramebuffer(t.FRAMEBUFFER, h.frameBuffer), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, r.texture), this.applyFilterPass(c, i, i.width, i.height);
                    var u = r;
                    r = h, h = u
                }
                t.enable(t.BLEND), n = r, this.texturePool.push(h)
            }
            var d = e.filterPasses[e.filterPasses.length - 1];
            this.offsetX -= i.x, this.offsetY -= i.y;
            var p = this.width,
                f = this.height,
                g = 0,
                y = 0,
                m = this.buffer;
            if (0 === this.filterStack.length) t.colorMask(!0, !0, !0, !0);
            else {
                var v = this.filterStack[this.filterStack.length - 1];
                i = v._filterArea, p = i.width, f = i.height, g = i.x, y = i.y, m = v._glFilterTexture.frameBuffer
            }
            a.x = p / 2, a.y = -f / 2, o.x = g, o.y = y, i = e._filterArea;
            var b = i.x - g,
                x = i.y - y;
            t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), this.vertexArray[0] = b, this.vertexArray[1] = x + i.height, this.vertexArray[2] = b + i.width, this.vertexArray[3] = x + i.height, this.vertexArray[4] = b, this.vertexArray[5] = x, this.vertexArray[6] = b + i.width, this.vertexArray[7] = x, t.bufferSubData(t.ARRAY_BUFFER, 0, this.vertexArray), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), this.uvArray[2] = i.width / this.width, this.uvArray[5] = i.height / this.height, this.uvArray[6] = i.width / this.width, this.uvArray[7] = i.height / this.height, t.bufferSubData(t.ARRAY_BUFFER, 0, this.uvArray), t.viewport(0, 0, p * this.renderSession.resolution, f * this.renderSession.resolution), t.bindFramebuffer(t.FRAMEBUFFER, m), t.activeTexture(t.TEXTURE0), t.bindTexture(t.TEXTURE_2D, n.texture), this.renderSession.stencilManager && this.renderSession.stencilManager.destroy(), this.renderSession.stencilManager = e._previous_stencil_mgr, e._previous_stencil_mgr = null, this.renderSession.stencilManager.count > 0 ? t.enable(t.STENCIL_TEST) : t.disable(t.STENCIL_TEST), this.applyFilterPass(d, i, p, f), this.texturePool.push(n), e._glFilterTexture = null
        }, s.WebGLFilterManager.prototype.applyFilterPass = function(t, e, i, n) {
            var a = this.gl,
                o = t.shaders[a.id];
            o || (o = new s.PixiShader(a), o.fragmentSrc = t.fragmentSrc, o.uniforms = t.uniforms, o.init(), t.shaders[a.id] = o), this.renderSession.shaderManager.setShader(o), a.uniform2f(o.projectionVector, i / 2, -n / 2), a.uniform2f(o.offsetVector, 0, 0), t.uniforms.dimensions && (t.uniforms.dimensions.value[0] = this.width, t.uniforms.dimensions.value[1] = this.height, t.uniforms.dimensions.value[2] = this.vertexArray[0], t.uniforms.dimensions.value[3] = this.vertexArray[5]), o.syncUniforms(), a.bindBuffer(a.ARRAY_BUFFER, this.vertexBuffer), a.vertexAttribPointer(o.aVertexPosition, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this.uvBuffer), a.vertexAttribPointer(o.aTextureCoord, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ARRAY_BUFFER, this.colorBuffer), a.vertexAttribPointer(o.colorAttribute, 2, a.FLOAT, !1, 0, 0), a.bindBuffer(a.ELEMENT_ARRAY_BUFFER, this.indexBuffer), a.drawElements(a.TRIANGLES, 6, a.UNSIGNED_SHORT, 0), this.renderSession.drawCount++
        }, s.WebGLFilterManager.prototype.initShaderBuffers = function() {
            var t = this.gl;
            this.vertexBuffer = t.createBuffer(), this.uvBuffer = t.createBuffer(), this.colorBuffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.vertexArray = new s.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.vertexBuffer), t.bufferData(t.ARRAY_BUFFER, this.vertexArray, t.STATIC_DRAW), this.uvArray = new s.Float32Array([0, 0, 1, 0, 0, 1, 1, 1]), t.bindBuffer(t.ARRAY_BUFFER, this.uvBuffer), t.bufferData(t.ARRAY_BUFFER, this.uvArray, t.STATIC_DRAW), this.colorArray = new s.Float32Array([1, 16777215, 1, 16777215, 1, 16777215, 1, 16777215]), t.bindBuffer(t.ARRAY_BUFFER, this.colorBuffer), t.bufferData(t.ARRAY_BUFFER, this.colorArray, t.STATIC_DRAW), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 1, 3, 2]), t.STATIC_DRAW)
        }, s.WebGLFilterManager.prototype.destroy = function() {
            var t = this.gl;
            this.filterStack = null, this.offsetX = 0, this.offsetY = 0;
            for (var e = 0; e < this.texturePool.length; e++) this.texturePool[e].destroy();
            this.texturePool = null, t.deleteBuffer(this.vertexBuffer), t.deleteBuffer(this.uvBuffer), t.deleteBuffer(this.colorBuffer), t.deleteBuffer(this.indexBuffer)
        }, s.FilterTexture = function(t, e, i, n) {
            this.gl = t, this.frameBuffer = t.createFramebuffer(), this.texture = t.createTexture(), n = n || s.scaleModes.DEFAULT, t.bindTexture(t.TEXTURE_2D, this.texture), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MAG_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_MIN_FILTER, n === s.scaleModes.LINEAR ? t.LINEAR : t.NEAREST), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_S, t.CLAMP_TO_EDGE), t.texParameteri(t.TEXTURE_2D, t.TEXTURE_WRAP_T, t.CLAMP_TO_EDGE), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.bindFramebuffer(t.FRAMEBUFFER, this.frameBuffer), t.framebufferTexture2D(t.FRAMEBUFFER, t.COLOR_ATTACHMENT0, t.TEXTURE_2D, this.texture, 0), this.renderBuffer = t.createRenderbuffer(), t.bindRenderbuffer(t.RENDERBUFFER, this.renderBuffer), t.framebufferRenderbuffer(t.FRAMEBUFFER, t.DEPTH_STENCIL_ATTACHMENT, t.RENDERBUFFER, this.renderBuffer), this.resize(e, i)
        }, s.FilterTexture.prototype.constructor = s.FilterTexture, s.FilterTexture.prototype.clear = function() {
            var t = this.gl;
            t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT)
        }, s.FilterTexture.prototype.resize = function(t, e) {
            if (this.width !== t || this.height !== e) {
                this.width = t, this.height = e;
                var i = this.gl;
                i.bindTexture(i.TEXTURE_2D, this.texture), i.texImage2D(i.TEXTURE_2D, 0, i.RGBA, t, e, 0, i.RGBA, i.UNSIGNED_BYTE, null), i.bindRenderbuffer(i.RENDERBUFFER, this.renderBuffer), i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t, e)
            }
        }, s.FilterTexture.prototype.destroy = function() {
            var t = this.gl;
            t.deleteFramebuffer(this.frameBuffer), t.deleteTexture(this.texture), this.frameBuffer = null, this.texture = null
        }, s.CanvasBuffer = function(t, e) {
            this.width = t, this.height = e, this.canvas = s.CanvasPool.create(this, this.width, this.height), this.context = this.canvas.getContext("2d"), this.canvas.width = t, this.canvas.height = e
        }, s.CanvasBuffer.prototype.constructor = s.CanvasBuffer, s.CanvasBuffer.prototype.clear = function() {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.clearRect(0, 0, this.width, this.height)
        }, s.CanvasBuffer.prototype.resize = function(t, e) {
            this.width = this.canvas.width = t, this.height = this.canvas.height = e
        }, s.CanvasBuffer.prototype.destroy = function() {
            s.CanvasPool.remove(this)
        }, s.CanvasMaskManager = function() {}, s.CanvasMaskManager.prototype.constructor = s.CanvasMaskManager, s.CanvasMaskManager.prototype.pushMask = function(t, e) {
            var i = e.context;
            i.save();
            var n = t.alpha,
                a = t.worldTransform,
                o = e.resolution;
            i.setTransform(a.a * o, a.b * o, a.c * o, a.d * o, a.tx * o, a.ty * o), s.CanvasGraphics.renderGraphicsMask(t, i), i.clip(), t.worldAlpha = n
        }, s.CanvasMaskManager.prototype.popMask = function(t) {
            t.context.restore()
        }, s.CanvasTinter = function() {}, s.CanvasTinter.getTintedTexture = function(t, e) {
            var i = t.tintedTexture || s.CanvasPool.create(this);
            return s.CanvasTinter.tintMethod(t.texture, e, i), i
        }, s.CanvasTinter.tintWithMultiply = function(t, e, i) {
            var s = i.getContext("2d"),
                n = t.crop;
            i.width === n.width && i.height === n.height || (i.width = n.width, i.height = n.height), s.clearRect(0, 0, n.width, n.height), s.fillStyle = "#" + ("00000" + (0 | e)
                    .toString(16))
                .substr(-6), s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "multiply", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(t.baseTexture.source, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height)
        }, s.CanvasTinter.tintWithPerPixel = function(t, e, i) {
            var n = i.getContext("2d"),
                a = t.crop;
            i.width = a.width, i.height = a.height, n.globalCompositeOperation = "copy", n.drawImage(t.baseTexture.source, a.x, a.y, a.width, a.height, 0, 0, a.width, a.height);
            for (var o = s.hex2rgb(e), r = o[0], h = o[1], l = o[2], c = n.getImageData(0, 0, a.width, a.height), u = c.data, d = 0; d < u.length; d += 4)
                if (u[d + 0] *= r, u[d + 1] *= h, u[d + 2] *= l, !s.CanvasTinter.canHandleAlpha) {
                    var p = u[d + 3];
                    u[d + 0] /= 255 / p, u[d + 1] /= 255 / p, u[d + 2] /= 255 / p
                } n.putImageData(c, 0, 0)
        }, s.CanvasTinter.checkInverseAlpha = function() {
            var t = new s.CanvasBuffer(2, 1);
            t.context.fillStyle = "rgba(10, 20, 30, 0.5)", t.context.fillRect(0, 0, 1, 1);
            var e = t.context.getImageData(0, 0, 1, 1);
            if (null === e) return !1;
            t.context.putImageData(e, 1, 0);
            var i = t.context.getImageData(1, 0, 1, 1);
            return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]
        }, s.CanvasTinter.canHandleAlpha = s.CanvasTinter.checkInverseAlpha(), s.CanvasTinter.canUseMultiply = s.canUseNewCanvasBlendModes(), s.CanvasTinter.tintMethod = s.CanvasTinter.canUseMultiply ? s.CanvasTinter.tintWithMultiply : s.CanvasTinter.tintWithPerPixel, s.CanvasRenderer = function(t) {
            this.game = t, s.defaultRenderer || (s.defaultRenderer = this), this.type = s.CANVAS_RENDERER, this.resolution = t.resolution, this.clearBeforeRender = t.clearBeforeRender, this.transparent = t.transparent, this.autoResize = !1, this.width = t.width * this.resolution, this.height = t.height * this.resolution, this.view = t.canvas, this.context = this.view.getContext("2d", {
                alpha: this.transparent
            }), this.refresh = !0, this.count = 0, this.maskManager = new s.CanvasMaskManager, this.renderSession = {
                context: this.context,
                maskManager: this.maskManager,
                scaleMode: null,
                smoothProperty: Phaser.Canvas.getSmoothingPrefix(this.context),
                roundPixels: !1
            }, this.mapBlendModes(), this.resize(this.width, this.height)
        }, s.CanvasRenderer.prototype.constructor = s.CanvasRenderer, s.CanvasRenderer.prototype.render = function(t) {
            this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.globalAlpha = 1, this.renderSession.currentBlendMode = 0, this.renderSession.shakeX = this.game.camera._shake.x, this.renderSession.shakeY = this.game.camera._shake.y, this.context.globalCompositeOperation = "source-over", navigator.isCocoonJS && this.view.screencanvas && (this.context.fillStyle = "black", this.context.clear()), this.clearBeforeRender && (this.transparent ? this.context.clearRect(0, 0, this.width, this.height) : t._bgColor && (this.context.fillStyle = t._bgColor.rgba, this.context.fillRect(0, 0, this.width, this.height))), this.renderDisplayObject(t)
        }, s.CanvasRenderer.prototype.destroy = function(t) {
            void 0 === t && (t = !0), t && this.view.parent && this.view.parent.removeChild(this.view), this.view = null, this.context = null, this.maskManager = null, this.renderSession = null
        }, s.CanvasRenderer.prototype.resize = function(t, e) {
            this.width = t * this.resolution, this.height = e * this.resolution, this.view.width = this.width, this.view.height = this.height, this.autoResize && (this.view.style.width = this.width / this.resolution + "px", this.view.style.height = this.height / this.resolution + "px"), this.renderSession.smoothProperty && (this.context[this.renderSession.smoothProperty] = this.renderSession.scaleMode === s.scaleModes.LINEAR)
        }, s.CanvasRenderer.prototype.renderDisplayObject = function(t, e, i) {
            this.renderSession.context = e || this.context, this.renderSession.resolution = this.resolution, t._renderCanvas(this.renderSession, i)
        }, s.CanvasRenderer.prototype.mapBlendModes = function() {
            if (!s.blendModesCanvas) {
                var t = [],
                    e = s.blendModes,
                    i = s.canUseNewCanvasBlendModes();
                t[e.NORMAL] = "source-over", t[e.ADD] = "lighter", t[e.MULTIPLY] = i ? "multiply" : "source-over", t[e.SCREEN] = i ? "screen" : "source-over", t[e.OVERLAY] = i ? "overlay" : "source-over", t[e.DARKEN] = i ? "darken" : "source-over", t[e.LIGHTEN] = i ? "lighten" : "source-over", t[e.COLOR_DODGE] = i ? "color-dodge" : "source-over", t[e.COLOR_BURN] = i ? "color-burn" : "source-over", t[e.HARD_LIGHT] = i ? "hard-light" : "source-over", t[e.SOFT_LIGHT] = i ? "soft-light" : "source-over", t[e.DIFFERENCE] = i ? "difference" : "source-over", t[e.EXCLUSION] = i ? "exclusion" : "source-over", t[e.HUE] = i ? "hue" : "source-over", t[e.SATURATION] = i ? "saturation" : "source-over", t[e.COLOR] = i ? "color" : "source-over", t[e.LUMINOSITY] = i ? "luminosity" : "source-over", s.blendModesCanvas = t
            }
        }, s.BaseTexture = function(t, e) {
            this.resolution = 1, this.width = 100, this.height = 100, this.scaleMode = e || s.scaleModes.DEFAULT, this.hasLoaded = !1, this.source = t, this.premultipliedAlpha = !0, this._glTextures = [], this.mipmap = !1, this._dirty = [!0, !0, !0, !0], t && ((this.source.complete || this.source.getContext) && this.source.width && this.source.height && (this.hasLoaded = !0, this.width = this.source.naturalWidth || this.source.width, this.height = this.source.naturalHeight || this.source.height, this.dirty()), this.skipRender = !1, this._powerOf2 = !1)
        }, s.BaseTexture.prototype.constructor = s.BaseTexture, s.BaseTexture.prototype.forceLoaded = function(t, e) {
            this.hasLoaded = !0, this.width = t, this.height = e, this.dirty()
        }, s.BaseTexture.prototype.destroy = function() {
            this.source && s.CanvasPool.removeByCanvas(this.source), this.source = null, this.unloadFromGPU()
        }, s.BaseTexture.prototype.updateSourceImage = function(t) {}, s.BaseTexture.prototype.dirty = function() {
            for (var t = 0; t < this._glTextures.length; t++) this._dirty[t] = !0
        }, s.BaseTexture.prototype.unloadFromGPU = function() {
            this.dirty();
            for (var t = this._glTextures.length - 1; t >= 0; t--) {
                var e = this._glTextures[t],
                    i = s.glContexts[t];
                i && e && i.deleteTexture(e)
            }
            this._glTextures.length = 0, this.dirty()
        }, s.BaseTexture.fromCanvas = function(t, e) {
            return 0 === t.width && (t.width = 1), 0 === t.height && (t.height = 1), new s.BaseTexture(t, e)
        }, s.TextureSilentFail = !1, s.Texture = function(t, e, i, n) {
            this.noFrame = !1, e || (this.noFrame = !0, e = new s.Rectangle(0, 0, 1, 1)), t instanceof s.Texture && (t = t.baseTexture), this.baseTexture = t, this.frame = e, this.trim = n, this.valid = !1, this.isTiling = !1, this.requiresUpdate = !1, this.requiresReTint = !1, this._uvs = null, this.width = 0, this.height = 0, this.crop = i || new s.Rectangle(0, 0, 1, 1), t.hasLoaded && (this.noFrame && (e = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(e))
        }, s.Texture.prototype.constructor = s.Texture, s.Texture.prototype.onBaseTextureLoaded = function() {
            var t = this.baseTexture;
            this.noFrame && (this.frame = new s.Rectangle(0, 0, t.width, t.height)), this.setFrame(this.frame)
        }, s.Texture.prototype.destroy = function(t) {
            t && this.baseTexture.destroy(), this.valid = !1
        }, s.Texture.prototype.setFrame = function(t) {
            if (this.noFrame = !1, this.frame = t, this.width = t.width, this.height = t.height, this.crop.x = t.x, this.crop.y = t.y, this.crop.width = t.width, this.crop.height = t.height, !this.trim && (t.x + t.width > this.baseTexture.width || t.y + t.height > this.baseTexture.height)) {
                if (!s.TextureSilentFail) throw new Error("Texture Error: frame does not fit inside the base Texture dimensions " + this);
                return void(this.valid = !1)
            }
            this.valid = t && t.width && t.height && this.baseTexture.source && this.baseTexture.hasLoaded, this.trim && (this.width = this.trim.width, this.height = this.trim.height, this.frame.width = this.trim.width, this.frame.height = this.trim.height), this.valid && this._updateUvs()
        }, s.Texture.prototype._updateUvs = function() {
            this._uvs || (this._uvs = new s.TextureUvs);
            var t = this.crop,
                e = this.baseTexture.width,
                i = this.baseTexture.height;
            this._uvs.x0 = t.x / e, this._uvs.y0 = t.y / i, this._uvs.x1 = (t.x + t.width) / e, this._uvs.y1 = t.y / i, this._uvs.x2 = (t.x + t.width) / e, this._uvs.y2 = (t.y + t.height) / i, this._uvs.x3 = t.x / e, this._uvs.y3 = (t.y + t.height) / i
        }, s.Texture.fromCanvas = function(t, e) {
            var i = s.BaseTexture.fromCanvas(t, e);
            return new s.Texture(i)
        }, s.TextureUvs = function() {
            this.x0 = 0, this.y0 = 0, this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.x3 = 0, this.y3 = 0
        }, s.RenderTexture = function(t, e, i, n, a) {
            if (this.width = t || 100, this.height = e || 100, this.resolution = a || 1, this.frame = new s.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.crop = new s.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution), this.baseTexture = new s.BaseTexture, this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution, this.baseTexture._glTextures = [], this.baseTexture.resolution = this.resolution, this.baseTexture.scaleMode = n || s.scaleModes.DEFAULT, this.baseTexture.hasLoaded = !0, s.Texture.call(this, this.baseTexture, new s.Rectangle(0, 0, this.width * this.resolution, this.height * this.resolution)), this.renderer = i || s.defaultRenderer, this.renderer.type === s.WEBGL_RENDERER) {
                var o = this.renderer.gl;
                this.baseTexture._dirty[o.id] = !1, this.textureBuffer = new s.FilterTexture(o, this.width, this.height, this.baseTexture.scaleMode), this.baseTexture._glTextures[o.id] = this.textureBuffer.texture, this.render = this.renderWebGL, this.projection = new s.Point(.5 * this.width, .5 * -this.height)
            } else this.render = this.renderCanvas, this.textureBuffer = new s.CanvasBuffer(this.width * this.resolution, this.height * this.resolution), this.baseTexture.source = this.textureBuffer.canvas;
            this.valid = !0, this.tempMatrix = new Phaser.Matrix, this._updateUvs()
        }, s.RenderTexture.prototype = Object.create(s.Texture.prototype), s.RenderTexture.prototype.constructor = s.RenderTexture, s.RenderTexture.prototype.resize = function(t, e, i) {
            t === this.width && e === this.height || (this.valid = t > 0 && e > 0, this.width = t, this.height = e, this.frame.width = this.crop.width = t * this.resolution, this.frame.height = this.crop.height = e * this.resolution, i && (this.baseTexture.width = this.width * this.resolution, this.baseTexture.height = this.height * this.resolution), this.renderer.type === s.WEBGL_RENDERER && (this.projection.x = this.width / 2, this.projection.y = -this.height / 2), this.valid && this.textureBuffer.resize(this.width, this.height))
        }, s.RenderTexture.prototype.clear = function() {
            this.valid && (this.renderer.type === s.WEBGL_RENDERER && this.renderer.gl.bindFramebuffer(this.renderer.gl.FRAMEBUFFER, this.textureBuffer.frameBuffer), this.textureBuffer.clear())
        }, s.RenderTexture.prototype.renderWebGL = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), s.translate(0, 2 * this.projection.y), e && s.append(e), s.scale(1, -1);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                var a = this.renderer.gl;
                a.viewport(0, 0, this.width * this.resolution, this.height * this.resolution), a.bindFramebuffer(a.FRAMEBUFFER, this.textureBuffer.frameBuffer), i && this.textureBuffer.clear(), this.renderer.spriteBatch.dirty = !0, this.renderer.renderDisplayObject(t, this.projection, this.textureBuffer.frameBuffer, e), this.renderer.spriteBatch.dirty = !0
            }
        }, s.RenderTexture.prototype.renderCanvas = function(t, e, i) {
            if (this.valid && 0 !== t.alpha) {
                var s = t.worldTransform;
                s.identity(), e && s.append(e);
                for (var n = 0; n < t.children.length; n++) t.children[n].updateTransform();
                i && this.textureBuffer.clear();
                var a = this.renderer.resolution;
                this.renderer.resolution = this.resolution, this.renderer.renderDisplayObject(t, this.textureBuffer.context, e), this.renderer.resolution = a
            }
        }, s.RenderTexture.prototype.getImage = function() {
            var t = new Image;
            return t.src = this.getBase64(), t
        }, s.RenderTexture.prototype.getBase64 = function() {
            return this.getCanvas()
                .toDataURL()
        }, s.RenderTexture.prototype.getCanvas = function() {
            if (this.renderer.type === s.WEBGL_RENDERER) {
                var t = this.renderer.gl,
                    e = this.textureBuffer.width,
                    i = this.textureBuffer.height,
                    n = new Uint8Array(4 * e * i);
                t.bindFramebuffer(t.FRAMEBUFFER, this.textureBuffer.frameBuffer), t.readPixels(0, 0, e, i, t.RGBA, t.UNSIGNED_BYTE, n), t.bindFramebuffer(t.FRAMEBUFFER, null);
                var a = new s.CanvasBuffer(e, i),
                    o = a.context.getImageData(0, 0, e, i);
                return o.data.set(n), a.context.putImageData(o, 0, 0), a.canvas
            }
            return this.textureBuffer.canvas
        }, s.AbstractFilter = function(t, e) {
            this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.uniforms = e || {}, this.fragmentSrc = t || []
        }, s.AbstractFilter.prototype.constructor = s.AbstractFilter, s.AbstractFilter.prototype.syncUniforms = function() {
            for (var t = 0, e = this.shaders.length; t < e; t++) this.shaders[t].dirty = !0
        }, s.Strip = function(t) {
            s.DisplayObjectContainer.call(this), this.texture = t, this.uvs = new s.Float32Array([0, 1, 1, 1, 1, 0, 0, 1]), this.vertices = new s.Float32Array([0, 0, 100, 0, 100, 100, 0, 100]), this.colors = new s.Float32Array([1, 1, 1, 1]), this.indices = new s.Uint16Array([0, 1, 2, 3]), this.dirty = !0, this.blendMode = s.blendModes.NORMAL, this.canvasPadding = 0, this.drawMode = s.Strip.DrawModes.TRIANGLE_STRIP
        }, s.Strip.prototype = Object.create(s.DisplayObjectContainer.prototype), s.Strip.prototype.constructor = s.Strip, s.Strip.prototype._renderWebGL = function(t) {
            !this.visible || this.alpha <= 0 || (t.spriteBatch.stop(), this._vertexBuffer || this._initWebGL(t), t.shaderManager.setShader(t.shaderManager.stripShader), this._renderStrip(t), t.spriteBatch.start())
        }, s.Strip.prototype._initWebGL = function(t) {
            var e = t.gl;
            this._vertexBuffer = e.createBuffer(), this._indexBuffer = e.createBuffer(), this._uvBuffer = e.createBuffer(), this._colorBuffer = e.createBuffer(), e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.DYNAMIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.bindBuffer(e.ARRAY_BUFFER, this._colorBuffer), e.bufferData(e.ARRAY_BUFFER, this.colors, e.STATIC_DRAW), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)
        }, s.Strip.prototype._renderStrip = function(t) {
            var e = t.gl,
                i = t.projection,
                n = t.offset,
                a = t.shaderManager.stripShader,
                o = this.drawMode === s.Strip.DrawModes.TRIANGLE_STRIP ? e.TRIANGLE_STRIP : e.TRIANGLES;
            t.blendModeManager.setBlendMode(this.blendMode), e.uniformMatrix3fv(a.translationMatrix, !1, this.worldTransform.toArray(!0)), e.uniform2f(a.projectionVector, i.x, -i.y), e.uniform2f(a.offsetVector, -n.x, -n.y), e.uniform1f(a.alpha, this.worldAlpha), this.dirty ? (this.dirty = !1, e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferData(e.ARRAY_BUFFER, this.vertices, e.STATIC_DRAW), e.vertexAttribPointer(a.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.bufferData(e.ARRAY_BUFFER, this.uvs, e.STATIC_DRAW), e.vertexAttribPointer(a.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer), e.bufferData(e.ELEMENT_ARRAY_BUFFER, this.indices, e.STATIC_DRAW)) : (e.bindBuffer(e.ARRAY_BUFFER, this._vertexBuffer), e.bufferSubData(e.ARRAY_BUFFER, 0, this.vertices), e.vertexAttribPointer(a.aVertexPosition, 2, e.FLOAT, !1, 0, 0), e.bindBuffer(e.ARRAY_BUFFER, this._uvBuffer), e.vertexAttribPointer(a.aTextureCoord, 2, e.FLOAT, !1, 0, 0), e.activeTexture(e.TEXTURE0), this.texture.baseTexture._dirty[e.id] ? t.renderer.updateTexture(this.texture.baseTexture) : e.bindTexture(e.TEXTURE_2D, this.texture.baseTexture._glTextures[e.id]), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, this._indexBuffer)), e.drawElements(o, this.indices.length, e.UNSIGNED_SHORT, 0)
        }, s.Strip.prototype._renderCanvas = function(t) {
            var e = t.context,
                i = this.worldTransform,
                n = i.tx * t.resolution + t.shakeX,
                a = i.ty * t.resolution + t.shakeY;
            t.roundPixels ? e.setTransform(i.a, i.b, i.c, i.d, 0 | n, 0 | a) : e.setTransform(i.a, i.b, i.c, i.d, n, a), this.drawMode === s.Strip.DrawModes.TRIANGLE_STRIP ? this._renderCanvasTriangleStrip(e) : this._renderCanvasTriangles(e)
        }, s.Strip.prototype._renderCanvasTriangleStrip = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = e.length / 2;
            this.count++;
            for (var n = 0; n < s - 2; n++) {
                var a = 2 * n;
                this._renderCanvasDrawTriangle(t, e, i, a, a + 2, a + 4)
            }
        }, s.Strip.prototype._renderCanvasTriangles = function(t) {
            var e = this.vertices,
                i = this.uvs,
                s = this.indices,
                n = s.length;
            this.count++;
            for (var a = 0; a < n; a += 3) {
                var o = 2 * s[a],
                    r = 2 * s[a + 1],
                    h = 2 * s[a + 2];
                this._renderCanvasDrawTriangle(t, e, i, o, r, h)
            }
        }, s.Strip.prototype._renderCanvasDrawTriangle = function(t, e, i, s, n, a) {
            var o = this.texture.baseTexture.source,
                r = this.texture.width,
                h = this.texture.height,
                l = e[s],
                c = e[n],
                u = e[a],
                d = e[s + 1],
                p = e[n + 1],
                f = e[a + 1],
                g = i[s] * r,
                y = i[n] * r,
                m = i[a] * r,
                v = i[s + 1] * h,
                b = i[n + 1] * h,
                x = i[a + 1] * h;
            if (this.canvasPadding > 0) {
                var _ = this.canvasPadding / this.worldTransform.a,
                    w = this.canvasPadding / this.worldTransform.d,
                    C = (l + c + u) / 3,
                    P = (d + p + f) / 3,
                    T = l - C,
                    S = d - P,
                    A = Math.sqrt(T * T + S * S);
                l = C + T / A * (A + _), d = P + S / A * (A + w), T = c - C, S = p - P, A = Math.sqrt(T * T + S * S), c = C + T / A * (A + _), p = P + S / A * (A + w), T = u - C, S = f - P, A = Math.sqrt(T * T + S * S), u = C + T / A * (A + _), f = P + S / A * (A + w)
            }
            t.save(), t.beginPath(), t.moveTo(l, d), t.lineTo(c, p), t.lineTo(u, f), t.closePath(), t.clip();
            var E = g * b + v * m + y * x - b * m - v * y - g * x,
                I = l * b + v * u + c * x - b * u - v * c - l * x,
                M = g * c + l * m + y * u - c * m - l * y - g * u,
                O = g * b * u + v * c * m + l * y * x - l * b * m - v * y * u - g * c * x,
                B = d * b + v * f + p * x - b * f - v * p - d * x,
                R = g * p + d * m + y * f - p * m - d * y - g * f,
                k = g * b * f + v * p * m + d * y * x - d * b * m - v * y * f - g * p * x;
            t.transform(I / E, B / E, M / E, R / E, O / E, k / E), t.drawImage(o, 0, 0), t.restore()
        }, s.Strip.prototype.renderStripFlat = function(t) {
            var e = this.context,
                i = t.vertices,
                s = i.length / 2;
            this.count++, e.beginPath();
            for (var n = 1; n < s - 2; n++) {
                var a = 2 * n,
                    o = i[a],
                    r = i[a + 2],
                    h = i[a + 4],
                    l = i[a + 1],
                    c = i[a + 3],
                    u = i[a + 5];
                e.moveTo(o, l), e.lineTo(r, c), e.lineTo(h, u)
            }
            e.fillStyle = "#FF0000", e.fill(), e.closePath()
        }, s.Strip.prototype.onTextureUpdate = function() {
            this.updateFrame = !0
        }, s.Strip.prototype.getBounds = function(t) {
            for (var e = t || this.worldTransform, i = e.a, n = e.b, a = e.c, o = e.d, r = e.tx, h = e.ty, l = -1 / 0, c = -1 / 0, u = 1 / 0, d = 1 / 0, p = this.vertices, f = 0, g = p.length; f < g; f += 2) {
                var y = p[f],
                    m = p[f + 1],
                    v = i * y + a * m + r,
                    b = o * m + n * y + h;
                u = v < u ? v : u, d = b < d ? b : d, l = v > l ? v : l, c = b > c ? b : c
            }
            if (u === -1 / 0 || c === 1 / 0) return s.EmptyRectangle;
            var x = this._bounds;
            return x.x = u, x.width = l - u, x.y = d, x.height = c - d, this._currentBounds = x, x
        }, s.Strip.DrawModes = {
            TRIANGLE_STRIP: 0,
            TRIANGLES: 1
        }, s.Rope = function(t, e) {
            s.Strip.call(this, t), this.points = e, this.vertices = new s.Float32Array(4 * e.length), this.uvs = new s.Float32Array(4 * e.length), this.colors = new s.Float32Array(2 * e.length), this.indices = new s.Uint16Array(2 * e.length), this.refresh()
        }, s.Rope.prototype = Object.create(s.Strip.prototype), s.Rope.prototype.constructor = s.Rope, s.Rope.prototype.refresh = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = this.uvs,
                    i = t[0],
                    s = this.indices,
                    n = this.colors;
                this.count -= .2, e[0] = 0, e[1] = 0, e[2] = 0, e[3] = 1, n[0] = 1, n[1] = 1, s[0] = 0, s[1] = 1;
                for (var a = t.length, o, r, h, l = 1; l < a; l++) o = t[l], r = 4 * l, h = l / (a - 1), e[r] = h, e[r + 1] = 0, e[r + 2] = h, e[r + 3] = 1, r = 2 * l, n[r] = 1, n[r + 1] = 1, r = 2 * l, s[r] = r, s[r + 1] = r + 1, i = o
            }
        }, s.Rope.prototype.updateTransform = function() {
            var t = this.points;
            if (!(t.length < 1)) {
                var e = t[0],
                    i, n = {
                        x: 0,
                        y: 0
                    };
                this.count -= .2;
                for (var a = this.vertices, o = t.length, r, h, l, c, u, d = 0; d < o; d++) r = t[d], h = 4 * d, i = d < t.length - 1 ? t[d + 1] : r, n.y = -(i.x - e.x), n.x = i.y - e.y, l = 10 * (1 - d / (o - 1)), l > 1 && (l = 1), c = Math.sqrt(n.x * n.x + n.y * n.y), u = this.texture.height / 2, n.x /= c, n.y /= c, n.x *= u, n.y *= u, a[h] = r.x + n.x, a[h + 1] = r.y + n.y, a[h + 2] = r.x - n.x, a[h + 3] = r.y - n.y, e = r;
                s.DisplayObjectContainer.prototype.updateTransform.call(this)
            }
        }, s.Rope.prototype.setTexture = function(t) {
            this.texture = t
        }, s.TilingSprite = function(t, e, i) {
            s.Sprite.call(this, t), this._width = e || 128, this._height = i || 128, this.tileScale = new s.Point(1, 1), this.tileScaleOffset = new s.Point(1, 1), this.tilePosition = new s.Point, this.renderable = !0, this.tint = 16777215, this.textureDebug = !1, this.blendMode = s.blendModes.NORMAL, this.canvasBuffer = null, this.tilingTexture = null, this.tilePattern = null, this.refreshTexture = !0, this.frameWidth = 0, this.frameHeight = 0
        }, s.TilingSprite.prototype = Object.create(s.Sprite.prototype), s.TilingSprite.prototype.constructor = s.TilingSprite, s.TilingSprite.prototype.setTexture = function(t) {
            this.texture !== t && (this.texture = t, this.refreshTexture = !0, this.cachedTint = 16777215)
        }, s.TilingSprite.prototype._renderWebGL = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                if (this._mask && (t.spriteBatch.stop(), t.maskManager.pushMask(this.mask, t), t.spriteBatch.start()), this._filters && (t.spriteBatch.flush(), t.filterManager.pushFilter(this._filterBlock)), this.refreshTexture) {
                    if (this.generateTilingTexture(!0, t), !this.tilingTexture) return;
                    this.tilingTexture.needsUpdate && (t.renderer.updateTexture(this.tilingTexture.baseTexture), this.tilingTexture.needsUpdate = !1)
                }
                t.spriteBatch.renderTilingSprite(this);
                for (var e = 0; e < this.children.length; e++) this.children[e]._renderWebGL(t);
                t.spriteBatch.stop(), this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this._mask, t), t.spriteBatch.start()
            }
        }, s.TilingSprite.prototype._renderCanvas = function(t) {
            if (this.visible && this.renderable && 0 !== this.alpha) {
                var e = t.context;
                this._mask && t.maskManager.pushMask(this._mask, t), e.globalAlpha = this.worldAlpha;
                var i = this.worldTransform,
                    n = t.resolution,
                    a = i.tx * n + t.shakeX,
                    o = i.ty * n + t.shakeY;
                if (e.setTransform(i.a * n, i.b * n, i.c * n, i.d * n, a, o), this.refreshTexture) {
                    if (this.generateTilingTexture(!1, t), !this.tilingTexture) return;
                    this.tilePattern = e.createPattern(this.tilingTexture.baseTexture.source, "repeat")
                }
                var r = t.currentBlendMode;
                this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = s.blendModesCanvas[t.currentBlendMode]);
                var h = this.tilePosition,
                    l = this.tileScale;
                h.x %= this.tilingTexture.baseTexture.width, h.y %= this.tilingTexture.baseTexture.height, e.scale(l.x, l.y), e.translate(h.x + this.anchor.x * -this._width, h.y + this.anchor.y * -this._height), e.fillStyle = this.tilePattern;
                var a = -h.x,
                    o = -h.y,
                    c = this._width / l.x,
                    u = this._height / l.y;
                t.roundPixels && (a |= 0, o |= 0, c |= 0, u |= 0), e.fillRect(a, o, c, u), e.scale(1 / l.x, 1 / l.y), e.translate(-h.x + this.anchor.x * this._width, -h.y + this.anchor.y * this._height), this._mask && t.maskManager.popMask(t);
                for (var d = 0; d < this.children.length; d++) this.children[d]._renderCanvas(t);
                r !== this.blendMode && (t.currentBlendMode = r, e.globalCompositeOperation = s.blendModesCanvas[r])
            }
        }, s.TilingSprite.prototype.onTextureUpdate = function() {}, s.TilingSprite.prototype.generateTilingTexture = function(t, e) {
            if (this.texture.baseTexture.hasLoaded) {
                var i = this.texture,
                    n = i.frame,
                    a = this._frame.sourceSizeW || this._frame.width,
                    o = this._frame.sourceSizeH || this._frame.height,
                    r = 0,
                    h = 0;
                this._frame.trimmed && (r = this._frame.spriteSourceSizeX, h = this._frame.spriteSourceSizeY), t && (a = s.getNextPowerOfTwo(a), o = s.getNextPowerOfTwo(o)), this.canvasBuffer ? (this.canvasBuffer.resize(a, o), this.tilingTexture.baseTexture.width = a, this.tilingTexture.baseTexture.height = o, this.tilingTexture.needsUpdate = !0) : (this.canvasBuffer = new s.CanvasBuffer(a, o), this.tilingTexture = s.Texture.fromCanvas(this.canvasBuffer.canvas), this.tilingTexture.isTiling = !0, this.tilingTexture.needsUpdate = !0), this.textureDebug && (this.canvasBuffer.context.strokeStyle = "#00ff00", this.canvasBuffer.context.strokeRect(0, 0, a, o));
                var l = i.crop.width,
                    c = i.crop.height;
                l === a && c === o || (l = a, c = o), this.canvasBuffer.context.drawImage(i.baseTexture.source, i.crop.x, i.crop.y, i.crop.width, i.crop.height, r, h, l, c), this.tileScaleOffset.x = n.width / a, this.tileScaleOffset.y = n.height / o, this.refreshTexture = !1, this.tilingTexture.baseTexture._powerOf2 = !0
            }
        }, s.TilingSprite.prototype.getBounds = function() {
            var t = this._width,
                e = this._height,
                i = t * (1 - this.anchor.x),
                s = t * -this.anchor.x,
                n = e * (1 - this.anchor.y),
                a = e * -this.anchor.y,
                o = this.worldTransform,
                r = o.a,
                h = o.b,
                l = o.c,
                c = o.d,
                u = o.tx,
                d = o.ty,
                p = r * s + l * a + u,
                f = c * a + h * s + d,
                g = r * i + l * a + u,
                y = c * a + h * i + d,
                m = r * i + l * n + u,
                v = c * n + h * i + d,
                b = r * s + l * n + u,
                x = c * n + h * s + d,
                _ = -1 / 0,
                w = -1 / 0,
                C = 1 / 0,
                P = 1 / 0;
            C = p < C ? p : C, C = g < C ? g : C, C = m < C ? m : C, C = b < C ? b : C, P = f < P ? f : P, P = y < P ? y : P, P = v < P ? v : P, P = x < P ? x : P, _ = p > _ ? p : _, _ = g > _ ? g : _, _ = m > _ ? m : _, _ = b > _ ? b : _, w = f > w ? f : w, w = y > w ? y : w, w = v > w ? v : w, w = x > w ? x : w;
            var T = this._bounds;
            return T.x = C, T.width = _ - C, T.y = P, T.height = w - P, this._currentBounds = T, T
        }, s.TilingSprite.prototype.destroy = function() {
            s.Sprite.prototype.destroy.call(this), this.canvasBuffer && (this.canvasBuffer.destroy(), this.canvasBuffer = null), this.tileScale = null, this.tileScaleOffset = null, this.tilePosition = null, this.tilingTexture && (this.tilingTexture.destroy(!0), this.tilingTexture = null)
        }, Object.defineProperty(s.TilingSprite.prototype, "width", {
            get: function() {
                return this._width
            },
            set: function(t) {
                this._width = t
            }
        }), Object.defineProperty(s.TilingSprite.prototype, "height", {
            get: function() {
                return this._height
            },
            set: function(t) {
                this._height = t
            }
        }), void 0 !== t && t.exports && (e = t.exports = s), e.PIXI = s, s
    })
    .call(this)
}, function(t, e, i) {
    (function(i) {
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2016 Photon Storm Ltd.
         * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
         *
         * @overview
         *
         * Phaser - http://phaser.io
         *
         * v2.6.4 "Kore Springs" - Built: Thu Nov 16 2017 13:53:52
         *
         * By Richard Davey http://www.photonstorm.com @photonstorm
         *
         * Phaser is a fun, free and fast 2D game framework for making HTML5 games
         * for desktop and mobile web browsers, supporting Canvas and WebGL rendering.
         *
         * Phaser uses Pixi.js for rendering, created by Mat Groves http://matgroves.com @Doormat23
         * Phaser uses p2.js for full-body physics, created by Stefan Hedman https://github.com/schteppe/p2.js @schteppe
         * Phaser contains a port of N+ Physics, converted by Richard Davey, original by http://www.metanetsoftware.com
         *
         * Many thanks to Adam Saltsman (@ADAMATOMIC) for releasing Flixel, from which both Phaser and my love of framework development originate.
         *
         * Follow development at http://phaser.io and on our forum
         *
         * "If you want your children to be intelligent,  read them fairy tales."
         * "If you want them to be more intelligent, read them more fairy tales."
         *                                                     -- Albert Einstein
         */
        /**
         * @author       Richard Davey <rich@photonstorm.com>
         * @copyright    2016 Photon Storm Ltd.
         * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
         */
        (function() {
            function s(t, e) {
                this._scaleFactor = t, this._deltaMode = e, this.originalEvent = null
            }
            var n = this,
                a = a || {
                    VERSION: "2.6.4",
                    GAMES: [],
                    AUTO: 0,
                    CANVAS: 1,
                    WEBGL: 2,
                    HEADLESS: 3,
                    NONE: 0,
                    LEFT: 1,
                    RIGHT: 2,
                    UP: 3,
                    DOWN: 4,
                    SPRITE: 0,
                    BUTTON: 1,
                    IMAGE: 2,
                    GRAPHICS: 3,
                    TEXT: 4,
                    TILESPRITE: 5,
                    BITMAPTEXT: 6,
                    GROUP: 7,
                    RENDERTEXTURE: 8,
                    TILEMAP: 9,
                    TILEMAPLAYER: 10,
                    EMITTER: 11,
                    POLYGON: 12,
                    BITMAPDATA: 13,
                    CANVAS_FILTER: 14,
                    WEBGL_FILTER: 15,
                    ELLIPSE: 16,
                    SPRITEBATCH: 17,
                    RETROFONT: 18,
                    POINTER: 19,
                    ROPE: 20,
                    CIRCLE: 21,
                    RECTANGLE: 22,
                    LINE: 23,
                    MATRIX: 24,
                    POINT: 25,
                    ROUNDEDRECTANGLE: 26,
                    CREATURE: 27,
                    VIDEO: 28,
                    PENDING_ATLAS: -1,
                    HORIZONTAL: 0,
                    VERTICAL: 1,
                    LANDSCAPE: 0,
                    PORTRAIT: 1,
                    ANGLE_UP: 270,
                    ANGLE_DOWN: 90,
                    ANGLE_LEFT: 180,
                    ANGLE_RIGHT: 0,
                    ANGLE_NORTH_EAST: 315,
                    ANGLE_NORTH_WEST: 225,
                    ANGLE_SOUTH_EAST: 45,
                    ANGLE_SOUTH_WEST: 135,
                    TOP_LEFT: 0,
                    TOP_CENTER: 1,
                    TOP_RIGHT: 2,
                    LEFT_TOP: 3,
                    LEFT_CENTER: 4,
                    LEFT_BOTTOM: 5,
                    CENTER: 6,
                    RIGHT_TOP: 7,
                    RIGHT_CENTER: 8,
                    RIGHT_BOTTOM: 9,
                    BOTTOM_LEFT: 10,
                    BOTTOM_CENTER: 11,
                    BOTTOM_RIGHT: 12,
                    blendModes: {
                        NORMAL: 0,
                        ADD: 1,
                        MULTIPLY: 2,
                        SCREEN: 3,
                        OVERLAY: 4,
                        DARKEN: 5,
                        LIGHTEN: 6,
                        COLOR_DODGE: 7,
                        COLOR_BURN: 8,
                        HARD_LIGHT: 9,
                        SOFT_LIGHT: 10,
                        DIFFERENCE: 11,
                        EXCLUSION: 12,
                        HUE: 13,
                        SATURATION: 14,
                        COLOR: 15,
                        LUMINOSITY: 16
                    },
                    scaleModes: {
                        DEFAULT: 0,
                        LINEAR: 0,
                        NEAREST: 1
                    },
                    PIXI: PIXI || {}
                };
            if (
                /**
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                Math.trunc || (Math.trunc = function t(e) {
                    return e < 0 ? Math.ceil(e) : Math.floor(e)
                }), Function.prototype.bind || (Function.prototype.bind = function() {
                    var t = Array.prototype.slice;
                    return function(e) {
                        function i() {
                            var a = n.concat(t.call(arguments));
                            s.apply(this instanceof i ? this : e, a)
                        }
                        var s = this,
                            n = t.call(arguments, 1);
                        if ("function" != typeof s) throw new TypeError;
                        return i.prototype = function t(e) {
                            if (e && (t.prototype = e), !(this instanceof t)) return new t
                        }(s.prototype), i
                    }
                }()), Array.isArray || (Array.isArray = function(t) {
                    return "[object Array]" === Object.prototype.toString.call(t)
                }), Array.prototype.forEach || (Array.prototype.forEach = function(t) {
                    "use strict";
                    if (void 0 === this || null === this) throw new TypeError;
                    var e = Object(this),
                        i = e.length >>> 0;
                    if ("function" != typeof t) throw new TypeError;
                    for (var s = arguments.length >= 2 ? arguments[1] : void 0, n = 0; n < i; n++) n in e && t.call(s, e[n], n, e)
                }), "function" != typeof window.Uint32Array && "object" != typeof window.Uint32Array) {
                var o = function(t) {
                    var e = new Array;
                    window[t] = function(t) {
                        if ("number" == typeof t) {
                            Array.call(this, t), this.length = t;
                            for (var e = 0; e < this.length; e++) this[e] = 0
                        } else {
                            Array.call(this, t.length), this.length = t.length;
                            for (var e = 0; e < this.length; e++) this[e] = t[e]
                        }
                    }, window[t].prototype = e, window[t].constructor = window[t]
                };
                o("Uint32Array"), o("Int16Array")
            }
            window.console || (window.console = {}, window.console.log = window.console.assert = function() {}, window.console.warn = window.console.assert = function() {}), /firefox/i.test(navigator.userAgent) && (window.oldGetComputedStyle = window.getComputedStyle, window.getComputedStyle = function(t, e) {
                    var i = window.oldGetComputedStyle(t, e);
                    return null === i ? {
                        getPropertyValue: function() {}
                    } : i
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Utils = {
                    reverseString: function(t) {
                        return t.split("")
                            .reverse()
                            .join("")
                    },
                    getProperty: function(t, e) {
                        for (var i = e.split("."), s = i.pop(), n = i.length, a = 1, o = i[0]; a < n && (t = t[o]);) o = i[a], a++;
                        return t ? t[s] : null
                    },
                    setProperty: function(t, e, i) {
                        for (var s = e.split("."), n = s.pop(), a = s.length, o = 1, r = s[0]; o < a && (t = t[r]);) r = s[o], o++;
                        return t && (t[n] = i), t
                    },
                    chanceRoll: function(t) {
                        return void 0 === t && (t = 50), t > 0 && 100 * Math.random() <= t
                    },
                    randomChoice: function(t, e) {
                        return Math.random() < .5 ? t : e
                    },
                    parseDimension: function(t, e) {
                        var i = 0,
                            s = 0;
                        return "string" == typeof t ? "%" === t.substr(-1) ? (i = parseInt(t, 10) / 100, s = 0 === e ? window.innerWidth * i : window.innerHeight * i) : s = parseInt(t, 10) : s = t, s
                    },
                    pad: function(t, e, i, s) {
                        if (void 0 === e) var e = 0;
                        if (void 0 === i) var i = " ";
                        if (void 0 === s) var s = 3;
                        t = t.toString();
                        var n = 0;
                        if (e + 1 >= t.length) switch (s) {
                            case 1:
                                t = new Array(e + 1 - t.length)
                                    .join(i) + t;
                                break;
                            case 3:
                                var a = Math.ceil((n = e - t.length) / 2),
                                    o = n - a;
                                t = new Array(o + 1)
                                    .join(i) + t + new Array(a + 1)
                                    .join(i);
                                break;
                            default:
                                t += new Array(e + 1 - t.length)
                                    .join(i)
                        }
                        return t
                    },
                    isPlainObject: function(t) {
                        if ("object" != typeof t || t.nodeType || t === t.window) return !1;
                        try {
                            if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, "isPrototypeOf")) return !1
                        } catch (t) {
                            return !1
                        }
                        return !0
                    },
                    extend: function() {
                        var t, e, i, s, n, o, r = arguments[0] || {},
                            h = 1,
                            l = arguments.length,
                            c = !1;
                        for ("boolean" == typeof r && (c = r, r = arguments[1] || {}, h = 2), l === h && (r = this, --h); h < l; h++)
                            if (null != (t = arguments[h]))
                                for (e in t) i = r[e], s = t[e], r !== s && (c && s && (a.Utils.isPlainObject(s) || (n = Array.isArray(s))) ? (n ? (n = !1, o = i && Array.isArray(i) ? i : []) : o = i && a.Utils.isPlainObject(i) ? i : {}, r[e] = a.Utils.extend(c, o, s)) : void 0 !== s && (r[e] = s));
                        return r
                    },
                    mixinPrototype: function(t, e, i) {
                        void 0 === i && (i = !1);
                        for (var s = Object.keys(e), n = 0; n < s.length; n++) {
                            var a = s[n],
                                o = e[a];
                            !i && a in t || (!o || "function" != typeof o.get && "function" != typeof o.set ? t[a] = o : "function" == typeof o.clone ? t[a] = o.clone() : Object.defineProperty(t, a, o))
                        }
                    },
                    mixin: function(t, e) {
                        if (!t || "object" != typeof t) return e;
                        for (var i in t) {
                            var s = t[i];
                            if (!s.childNodes && !s.cloneNode) {
                                var n = typeof t[i];
                                t[i] && "object" === n ? typeof e[i] === n ? e[i] = a.Utils.mixin(t[i], e[i]) : e[i] = a.Utils.mixin(t[i], new s.constructor) : e[i] = t[i]
                            }
                        }
                        return e
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Circle = function(t, e, i) {
                    t = t || 0, e = e || 0, i = i || 0, this.x = t, this.y = e, this._diameter = i, this._radius = 0, i > 0 && (this._radius = .5 * i), this.type = a.CIRCLE
                }, a.Circle.prototype = {
                    circumference: function() {
                        return Math.PI * this._radius * 2
                    },
                    random: function(t) {
                        void 0 === t && (t = new a.Point);
                        var e = 2 * Math.PI * Math.random(),
                            i = Math.random() + Math.random(),
                            s = i > 1 ? 2 - i : i,
                            n = s * Math.cos(e),
                            o = s * Math.sin(e);
                        return t.x = this.x + n * this.radius, t.y = this.y + o * this.radius, t
                    },
                    getBounds: function() {
                        return new a.Rectangle(this.x - this.radius, this.y - this.radius, this.diameter, this.diameter)
                    },
                    setTo: function(t, e, i) {
                        return this.x = t, this.y = e, this._diameter = i, this._radius = .5 * i, this
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.diameter)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.diameter = this._diameter, t
                    },
                    distance: function(t, e) {
                        var i = a.Math.distance(this.x, this.y, t.x, t.y);
                        return e ? Math.round(i) : i
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new a.Circle(this.x, this.y, this.diameter) : t.setTo(this.x, this.y, this.diameter), t
                    },
                    contains: function(t, e) {
                        return a.Circle.contains(this, t, e)
                    },
                    circumferencePoint: function(t, e, i) {
                        return a.Circle.circumferencePoint(this, t, e, i)
                    },
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    toString: function() {
                        return "[{Phaser.Circle (x=" + this.x + " y=" + this.y + " diameter=" + this.diameter + " radius=" + this.radius + ")}]"
                    }
                }, a.Circle.prototype.constructor = a.Circle, Object.defineProperty(a.Circle.prototype, "diameter", {
                    get: function() {
                        return this._diameter
                    },
                    set: function(t) {
                        t > 0 && (this._diameter = t, this._radius = .5 * t)
                    }
                }), Object.defineProperty(a.Circle.prototype, "radius", {
                    get: function() {
                        return this._radius
                    },
                    set: function(t) {
                        t > 0 && (this._radius = t, this._diameter = 2 * t)
                    }
                }), Object.defineProperty(a.Circle.prototype, "left", {
                    get: function() {
                        return this.x - this._radius
                    },
                    set: function(t) {
                        t > this.x ? (this._radius = 0, this._diameter = 0) : this.radius = this.x - t
                    }
                }), Object.defineProperty(a.Circle.prototype, "right", {
                    get: function() {
                        return this.x + this._radius
                    },
                    set: function(t) {
                        t < this.x ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.x
                    }
                }), Object.defineProperty(a.Circle.prototype, "top", {
                    get: function() {
                        return this.y - this._radius
                    },
                    set: function(t) {
                        t > this.y ? (this._radius = 0, this._diameter = 0) : this.radius = this.y - t
                    }
                }), Object.defineProperty(a.Circle.prototype, "bottom", {
                    get: function() {
                        return this.y + this._radius
                    },
                    set: function(t) {
                        t < this.y ? (this._radius = 0, this._diameter = 0) : this.radius = t - this.y
                    }
                }), Object.defineProperty(a.Circle.prototype, "area", {
                    get: function() {
                        return this._radius > 0 ? Math.PI * this._radius * this._radius : 0
                    }
                }), Object.defineProperty(a.Circle.prototype, "empty", {
                    get: function() {
                        return 0 === this._diameter
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0)
                    }
                }), a.Circle.contains = function(t, e, i) {
                    if (t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom) {
                        return (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius
                    }
                    return !1
                }, a.Circle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.diameter === e.diameter
                }, a.Circle.intersects = function(t, e) {
                    return a.Math.distance(t.x, t.y, e.x, e.y) <= t.radius + e.radius
                }, a.Circle.circumferencePoint = function(t, e, i, s) {
                    return void 0 === i && (i = !1), void 0 === s && (s = new a.Point), !0 === i && (e = a.Math.degToRad(e)), s.x = t.x + t.radius * Math.cos(e), s.y = t.y + t.radius * Math.sin(e), s
                }, a.Circle.intersectsRectangle = function(t, e) {
                    var i = Math.abs(t.x - e.x - e.halfWidth);
                    if (i > e.halfWidth + t.radius) return !1;
                    var s = Math.abs(t.y - e.y - e.halfHeight);
                    if (s > e.halfHeight + t.radius) return !1;
                    if (i <= e.halfWidth || s <= e.halfHeight) return !0;
                    var n = i - e.halfWidth,
                        a = s - e.halfHeight;
                    return n * n + a * a <= t.radius * t.radius
                }, PIXI.Circle = a.Circle,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @author       Chad Engler <chad@pantherdev.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Ellipse = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = a.ELLIPSE
                }, a.Ellipse.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    getBounds: function() {
                        return new a.Rectangle(this.x - this.width, this.y - this.height, this.width, this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new a.Ellipse(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                    },
                    contains: function(t, e) {
                        return a.Ellipse.contains(this, t, e)
                    },
                    random: function(t) {
                        void 0 === t && (t = new a.Point);
                        var e = Math.random() * Math.PI * 2,
                            i = Math.random();
                        return t.x = Math.sqrt(i) * Math.cos(e), t.y = Math.sqrt(i) * Math.sin(e), t.x = this.x + t.x * this.width / 2, t.y = this.y + t.y * this.height / 2, t
                    },
                    toString: function() {
                        return "[{Phaser.Ellipse (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + ")}]"
                    }
                }, a.Ellipse.prototype.constructor = a.Ellipse, Object.defineProperty(a.Ellipse.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        this.x = t
                    }
                }), Object.defineProperty(a.Ellipse.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t < this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(a.Ellipse.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        this.y = t
                    }
                }), Object.defineProperty(a.Ellipse.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t < this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(a.Ellipse.prototype, "empty", {
                    get: function() {
                        return 0 === this.width || 0 === this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), a.Ellipse.contains = function(t, e, i) {
                    if (t.width <= 0 || t.height <= 0) return !1;
                    var s = (e - t.x) / t.width - .5,
                        n = (i - t.y) / t.height - .5;
                    return s *= s, n *= n, s + n < .25
                }, PIXI.Ellipse = a.Ellipse,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Line = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.start = new a.Point(t, e), this.end = new a.Point(i, s), this.type = a.LINE
                }, a.Line.prototype = {
                    setTo: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(i, s), this
                    },
                    fromSprite: function(t, e, i) {
                        return void 0 === i && (i = !1), i ? this.setTo(t.center.x, t.center.y, e.center.x, e.center.y) : this.setTo(t.x, t.y, e.x, e.y)
                    },
                    fromAngle: function(t, e, i, s) {
                        return this.start.setTo(t, e), this.end.setTo(t + Math.cos(i) * s, e + Math.sin(i) * s), this
                    },
                    rotate: function(t, e) {
                        var i = (this.start.x + this.end.x) / 2,
                            s = (this.start.y + this.end.y) / 2;
                        return this.start.rotate(i, s, t, e), this.end.rotate(i, s, t, e), this
                    },
                    rotateAround: function(t, e, i, s) {
                        return this.start.rotate(t, e, i, s), this.end.rotate(t, e, i, s), this
                    },
                    intersects: function(t, e, i) {
                        return a.Line.intersectsPoints(this.start, this.end, t.start, t.end, e, i)
                    },
                    reflect: function(t) {
                        return a.Line.reflect(this, t)
                    },
                    midPoint: function(t) {
                        return void 0 === t && (t = new a.Point), t.x = (this.start.x + this.end.x) / 2, t.y = (this.start.y + this.end.y) / 2, t
                    },
                    centerOn: function(t, e) {
                        var i = (this.start.x + this.end.x) / 2,
                            s = (this.start.y + this.end.y) / 2,
                            n = t - i,
                            a = e - s;
                        this.start.add(n, a), this.end.add(n, a)
                    },
                    pointOnLine: function(t, e) {
                        return (t - this.start.x) * (this.end.y - this.start.y) == (this.end.x - this.start.x) * (e - this.start.y)
                    },
                    pointOnSegment: function(t, e) {
                        var i = Math.min(this.start.x, this.end.x),
                            s = Math.max(this.start.x, this.end.x),
                            n = Math.min(this.start.y, this.end.y),
                            a = Math.max(this.start.y, this.end.y);
                        return this.pointOnLine(t, e) && t >= i && t <= s && e >= n && e <= a
                    },
                    random: function(t) {
                        void 0 === t && (t = new a.Point);
                        var e = Math.random();
                        return t.x = this.start.x + e * (this.end.x - this.start.x), t.y = this.start.y + e * (this.end.y - this.start.y), t
                    },
                    coordinatesOnLine: function(t, e) {
                        void 0 === t && (t = 1), void 0 === e && (e = []);
                        var i = Math.round(this.start.x),
                            s = Math.round(this.start.y),
                            n = Math.round(this.end.x),
                            a = Math.round(this.end.y),
                            o = Math.abs(n - i),
                            r = Math.abs(a - s),
                            h = i < n ? 1 : -1,
                            l = s < a ? 1 : -1,
                            c = o - r;
                        e.push([i, s]);
                        for (var u = 1; i !== n || s !== a;) {
                            var d = c << 1;
                            d > -r && (c -= r, i += h), d < o && (c += o, s += l), u % t == 0 && e.push([i, s]), u++
                        }
                        return e
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new a.Line(this.start.x, this.start.y, this.end.x, this.end.y) : t.setTo(this.start.x, this.start.y, this.end.x, this.end.y), t
                    }
                }, Object.defineProperty(a.Line.prototype, "length", {
                    get: function() {
                        return Math.sqrt((this.end.x - this.start.x) * (this.end.x - this.start.x) + (this.end.y - this.start.y) * (this.end.y - this.start.y))
                    }
                }), Object.defineProperty(a.Line.prototype, "angle", {
                    get: function() {
                        return Math.atan2(this.end.y - this.start.y, this.end.x - this.start.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "slope", {
                    get: function() {
                        return (this.end.y - this.start.y) / (this.end.x - this.start.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "perpSlope", {
                    get: function() {
                        return -(this.end.x - this.start.x) / (this.end.y - this.start.y)
                    }
                }), Object.defineProperty(a.Line.prototype, "x", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "y", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(a.Line.prototype, "left", {
                    get: function() {
                        return Math.min(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "right", {
                    get: function() {
                        return Math.max(this.start.x, this.end.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "top", {
                    get: function() {
                        return Math.min(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(a.Line.prototype, "bottom", {
                    get: function() {
                        return Math.max(this.start.y, this.end.y)
                    }
                }), Object.defineProperty(a.Line.prototype, "width", {
                    get: function() {
                        return Math.abs(this.start.x - this.end.x)
                    }
                }), Object.defineProperty(a.Line.prototype, "height", {
                    get: function() {
                        return Math.abs(this.start.y - this.end.y)
                    }
                }), Object.defineProperty(a.Line.prototype, "normalX", {
                    get: function() {
                        return Math.cos(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(a.Line.prototype, "normalY", {
                    get: function() {
                        return Math.sin(this.angle - 1.5707963267948966)
                    }
                }), Object.defineProperty(a.Line.prototype, "normalAngle", {
                    get: function() {
                        return a.Math.wrap(this.angle - 1.5707963267948966, -Math.PI, Math.PI)
                    }
                }), a.Line.intersectsPoints = function(t, e, i, s, n, o) {
                    void 0 === n && (n = !0), void 0 === o && (o = new a.Point);
                    var r = e.y - t.y,
                        h = s.y - i.y,
                        l = t.x - e.x,
                        c = i.x - s.x,
                        u = e.x * t.y - t.x * e.y,
                        d = s.x * i.y - i.x * s.y,
                        p = r * c - h * l;
                    if (0 === p) return null;
                    if (o.x = (l * d - c * u) / p, o.y = (h * u - r * d) / p, n) {
                        var f = (s.y - i.y) * (e.x - t.x) - (s.x - i.x) * (e.y - t.y),
                            g = ((s.x - i.x) * (t.y - i.y) - (s.y - i.y) * (t.x - i.x)) / f,
                            y = ((e.x - t.x) * (t.y - i.y) - (e.y - t.y) * (t.x - i.x)) / f;
                        return g >= 0 && g <= 1 && y >= 0 && y <= 1 ? o : null
                    }
                    return o
                }, a.Line.intersects = function(t, e, i, s) {
                    return a.Line.intersectsPoints(t.start, t.end, e.start, e.end, i, s)
                }, a.Line.intersectsRectangle = function(t, e) {
                    if (!a.Rectangle.intersects(t, e)) return !1;
                    var i = t.start.x,
                        s = t.start.y,
                        n = t.end.x,
                        o = t.end.y,
                        r = e.x,
                        h = e.y,
                        l = e.right,
                        c = e.bottom,
                        u = 0;
                    if (i >= r && i <= l && s >= h && s <= c || n >= r && n <= l && o >= h && o <= c) return !0;
                    if (i < r && n >= r) {
                        if ((u = s + (o - s) * (r - i) / (n - i)) > h && u <= c) return !0
                    } else if (i > l && n <= l && (u = s + (o - s) * (l - i) / (n - i)) >= h && u <= c) return !0;
                    if (s < h && o >= h) {
                        if ((u = i + (n - i) * (h - s) / (o - s)) >= r && u <= l) return !0
                    } else if (s > c && o <= c && (u = i + (n - i) * (c - s) / (o - s)) >= r && u <= l) return !0;
                    return !1
                }, a.Line.reflect = function(t, e) {
                    return 2 * e.normalAngle - 3.141592653589793 - t.angle
                },
                /**
                 * @author       Mat Groves http://matgroves.com/ @Doormat23
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Matrix = function(t, e, i, s, n, o) {
                    void 0 !== t && null !== t || (t = 1), void 0 !== e && null !== e || (e = 0), void 0 !== i && null !== i || (i = 0), void 0 !== s && null !== s || (s = 1), void 0 !== n && null !== n || (n = 0), void 0 !== o && null !== o || (o = 0), this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = o, this.type = a.MATRIX
                }, a.Matrix.prototype = {
                    fromArray: function(t) {
                        return this.setTo(t[0], t[1], t[3], t[4], t[2], t[5])
                    },
                    setTo: function(t, e, i, s, n, a) {
                        return this.a = t, this.b = e, this.c = i, this.d = s, this.tx = n, this.ty = a, this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new a.Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty) : (t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty), t
                    },
                    copyTo: function(t) {
                        return t.copyFrom(this), t
                    },
                    copyFrom: function(t) {
                        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
                    },
                    toArray: function(t, e) {
                        return void 0 === e && (e = new PIXI.Float32Array(9)), t ? (e[0] = this.a, e[1] = this.b, e[2] = 0, e[3] = this.c, e[4] = this.d, e[5] = 0, e[6] = this.tx, e[7] = this.ty, e[8] = 1) : (e[0] = this.a, e[1] = this.c, e[2] = this.tx, e[3] = this.b, e[4] = this.d, e[5] = this.ty, e[6] = 0, e[7] = 0, e[8] = 1), e
                    },
                    apply: function(t, e) {
                        return void 0 === e && (e = new a.Point), e.x = this.a * t.x + this.c * t.y + this.tx, e.y = this.b * t.x + this.d * t.y + this.ty, e
                    },
                    applyInverse: function(t, e) {
                        void 0 === e && (e = new a.Point);
                        var i = 1 / (this.a * this.d + this.c * -this.b),
                            s = t.x,
                            n = t.y;
                        return e.x = this.d * i * s + -this.c * i * n + (this.ty * this.c - this.tx * this.d) * i, e.y = this.a * i * n + -this.b * i * s + (-this.ty * this.a + this.tx * this.b) * i, e
                    },
                    translate: function(t, e) {
                        return this.tx += t, this.ty += e, this
                    },
                    scale: function(t, e) {
                        return this.a *= t, this.d *= e, this.c *= t, this.b *= e, this.tx *= t, this.ty *= e, this
                    },
                    rotate: function(t) {
                        var e = Math.cos(t),
                            i = Math.sin(t),
                            s = this.a,
                            n = this.c,
                            a = this.tx;
                        return this.a = s * e - this.b * i, this.b = s * i + this.b * e, this.c = n * e - this.d * i, this.d = n * i + this.d * e, this.tx = a * e - this.ty * i, this.ty = a * i + this.ty * e, this
                    },
                    append: function(t) {
                        var e = this.a,
                            i = this.b,
                            s = this.c,
                            n = this.d;
                        return this.a = t.a * e + t.b * s, this.b = t.a * i + t.b * n, this.c = t.c * e + t.d * s, this.d = t.c * i + t.d * n, this.tx = t.tx * e + t.ty * s + this.tx, this.ty = t.tx * i + t.ty * n + this.ty, this
                    },
                    identity: function() {
                        return this.setTo(1, 0, 0, 1, 0, 0)
                    }
                }, a.identityMatrix = new a.Matrix, PIXI.Matrix = a.Matrix, PIXI.identityMatrix = a.identityMatrix,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Point = function(t, e) {
                    t = t || 0, e = e || 0, this.x = t, this.y = e, this.type = a.POINT
                }, a.Point.prototype = {
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y)
                    },
                    invert: function() {
                        return this.setTo(this.y, this.x)
                    },
                    setTo: function(t, e) {
                        return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                    },
                    set: function(t, e) {
                        return this.x = t || 0, this.y = e || (0 !== e ? this.x : 0), this
                    },
                    add: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    subtract: function(t, e) {
                        return this.x -= t, this.y -= e, this
                    },
                    multiply: function(t, e) {
                        return this.x *= t, this.y *= e, this
                    },
                    divide: function(t, e) {
                        return this.x /= t, this.y /= e, this
                    },
                    clampX: function(t, e) {
                        return this.x = a.Math.clamp(this.x, t, e), this
                    },
                    clampY: function(t, e) {
                        return this.y = a.Math.clamp(this.y, t, e), this
                    },
                    clamp: function(t, e) {
                        return this.x = a.Math.clamp(this.x, t, e), this.y = a.Math.clamp(this.y, t, e), this
                    },
                    clone: function(t) {
                        return void 0 === t || null === t ? t = new a.Point(this.x, this.y) : t.setTo(this.x, this.y), t
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t
                    },
                    distance: function(t, e) {
                        return a.Point.distance(this, t, e)
                    },
                    equals: function(t) {
                        return t.x === this.x && t.y === this.y
                    },
                    angle: function(t, e) {
                        return void 0 === e && (e = !1), e ? a.Math.radToDeg(Math.atan2(t.y - this.y, t.x - this.x)) : Math.atan2(t.y - this.y, t.x - this.x)
                    },
                    rotate: function(t, e, i, s, n) {
                        return a.Point.rotate(this, t, e, i, s, n)
                    },
                    getMagnitude: function() {
                        return Math.sqrt(this.x * this.x + this.y * this.y)
                    },
                    getMagnitudeSq: function() {
                        return this.x * this.x + this.y * this.y
                    },
                    setMagnitude: function(t) {
                        return this.normalize()
                            .multiply(t, t)
                    },
                    normalize: function() {
                        if (!this.isZero()) {
                            var t = this.getMagnitude();
                            this.x /= t, this.y /= t
                        }
                        return this
                    },
                    isZero: function() {
                        return 0 === this.x && 0 === this.y
                    },
                    dot: function(t) {
                        return this.x * t.x + this.y * t.y
                    },
                    cross: function(t) {
                        return this.x * t.y - this.y * t.x
                    },
                    perp: function() {
                        return this.setTo(-this.y, this.x)
                    },
                    rperp: function() {
                        return this.setTo(this.y, -this.x)
                    },
                    normalRightHand: function() {
                        return this.setTo(-1 * this.y, this.x)
                    },
                    floor: function() {
                        return this.setTo(Math.floor(this.x), Math.floor(this.y))
                    },
                    ceil: function() {
                        return this.setTo(Math.ceil(this.x), Math.ceil(this.y))
                    },
                    toString: function() {
                        return "[{Point (x=" + this.x + " y=" + this.y + ")}]"
                    }
                }, a.Point.prototype.constructor = a.Point, a.Point.add = function(t, e, i) {
                    return void 0 === i && (i = new a.Point), i.x = t.x + e.x, i.y = t.y + e.y, i
                }, a.Point.subtract = function(t, e, i) {
                    return void 0 === i && (i = new a.Point), i.x = t.x - e.x, i.y = t.y - e.y, i
                }, a.Point.multiply = function(t, e, i) {
                    return void 0 === i && (i = new a.Point), i.x = t.x * e.x, i.y = t.y * e.y, i
                }, a.Point.divide = function(t, e, i) {
                    return void 0 === i && (i = new a.Point), i.x = t.x / e.x, i.y = t.y / e.y, i
                }, a.Point.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, a.Point.angle = function(t, e) {
                    return Math.atan2(t.y - e.y, t.x - e.x)
                }, a.Point.negative = function(t, e) {
                    return void 0 === e && (e = new a.Point), e.setTo(-t.x, -t.y)
                }, a.Point.multiplyAdd = function(t, e, i, s) {
                    return void 0 === s && (s = new a.Point), s.setTo(t.x + e.x * i, t.y + e.y * i)
                }, a.Point.interpolate = function(t, e, i, s) {
                    return void 0 === s && (s = new a.Point), s.setTo(t.x + (e.x - t.x) * i, t.y + (e.y - t.y) * i)
                }, a.Point.perp = function(t, e) {
                    return void 0 === e && (e = new a.Point), e.setTo(-t.y, t.x)
                }, a.Point.rperp = function(t, e) {
                    return void 0 === e && (e = new a.Point), e.setTo(t.y, -t.x)
                }, a.Point.distance = function(t, e, i) {
                    var s = a.Math.distance(t.x, t.y, e.x, e.y);
                    return i ? Math.round(s) : s
                }, a.Point.project = function(t, e, i) {
                    void 0 === i && (i = new a.Point);
                    var s = t.dot(e) / e.getMagnitudeSq();
                    return 0 !== s && i.setTo(s * e.x, s * e.y), i
                }, a.Point.projectUnit = function(t, e, i) {
                    void 0 === i && (i = new a.Point);
                    var s = t.dot(e);
                    return 0 !== s && i.setTo(s * e.x, s * e.y), i
                }, a.Point.normalRightHand = function(t, e) {
                    return void 0 === e && (e = new a.Point), e.setTo(-1 * t.y, t.x)
                }, a.Point.normalize = function(t, e) {
                    void 0 === e && (e = new a.Point);
                    var i = t.getMagnitude();
                    return 0 !== i && e.setTo(t.x / i, t.y / i), e
                }, a.Point.rotate = function(t, e, i, s, n, o) {
                    if (n && (s = a.Math.degToRad(s)), void 0 === o) {
                        t.subtract(e, i);
                        var r = Math.sin(s),
                            h = Math.cos(s),
                            l = h * t.x - r * t.y,
                            c = r * t.x + h * t.y;
                        t.x = l + e, t.y = c + i
                    } else {
                        var u = s + Math.atan2(t.y - i, t.x - e);
                        t.x = e + o * Math.cos(u), t.y = i + o * Math.sin(u)
                    }
                    return t
                }, a.Point.centroid = function(t, e) {
                    if (void 0 === e && (e = new a.Point), "[object Array]" !== Object.prototype.toString.call(t)) throw new Error("Phaser.Point. Parameter 'points' must be an array");
                    var i = t.length;
                    if (i < 1) throw new Error("Phaser.Point. Parameter 'points' array must not be empty");
                    if (1 === i) return e.copyFrom(t[0]), e;
                    for (var s = 0; s < i; s++) a.Point.add(e, t[s], e);
                    return e.divide(i, i), e
                }, a.Point.parse = function(t, e, i) {
                    e = e || "x", i = i || "y";
                    var s = new a.Point;
                    return t[e] && (s.x = parseInt(t[e], 10)), t[i] && (s.y = parseInt(t[i], 10)), s
                }, PIXI.Point = a.Point,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @author       Adrien Brault <adrien.brault@gmail.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Polygon = function() {
                    this.area = 0, this._points = [], arguments.length > 0 && this.setTo.apply(this, arguments), this.closed = !0, this.flattened = !1, this.type = a.POLYGON
                }, a.Polygon.prototype = {
                    toNumberArray: function(t) {
                        void 0 === t && (t = []);
                        for (var e = 0; e < this._points.length; e++) "number" == typeof this._points[e] ? (t.push(this._points[e]), t.push(this._points[e + 1]), e++) : (t.push(this._points[e].x), t.push(this._points[e].y));
                        return t
                    },
                    flatten: function() {
                        return this._points = this.toNumberArray(), this.flattened = !0, this
                    },
                    clone: function(t) {
                        var e = this._points.slice();
                        return void 0 === t || null === t ? t = new a.Polygon(e) : t.setTo(e), t
                    },
                    contains: function(t, e) {
                        var i = !1;
                        if (this.flattened)
                            for (var s = -2, n = this._points.length - 2;
                                (s += 2) < this._points.length; n = s) {
                                var a = this._points[s],
                                    o = this._points[s + 1],
                                    r = this._points[n],
                                    h = this._points[n + 1];
                                (o <= e && e < h || h <= e && e < o) && t < (r - a) * (e - o) / (h - o) + a && (i = !i)
                            } else
                                for (var s = -1, n = this._points.length - 1; ++s < this._points.length; n = s) {
                                    var a = this._points[s].x,
                                        o = this._points[s].y,
                                        r = this._points[n].x,
                                        h = this._points[n].y;
                                    (o <= e && e < h || h <= e && e < o) && t < (r - a) * (e - o) / (h - o) + a && (i = !i)
                                }
                        return i
                    },
                    setTo: function(t) {
                        if (this.area = 0, this._points = [], arguments.length > 0) {
                            Array.isArray(t) || (t = Array.prototype.slice.call(arguments));
                            for (var e = Number.MAX_VALUE, i = 0, s = t.length; i < s; i++) {
                                if ("number" == typeof t[i]) {
                                    var n = new PIXI.Point(t[i], t[i + 1]);
                                    i++
                                } else if (Array.isArray(t[i])) var n = new PIXI.Point(t[i][0], t[i][1]);
                                else var n = new PIXI.Point(t[i].x, t[i].y);
                                this._points.push(n), n.y < e && (e = n.y)
                            }
                            this.calculateArea(e)
                        }
                        return this
                    },
                    calculateArea: function(t) {
                        for (var e, i, s, n, a = 0, o = this._points.length; a < o; a++) e = this._points[a], i = a === o - 1 ? this._points[0] : this._points[a + 1], s = (e.y - t + (i.y - t)) / 2, n = e.x - i.x, this.area += s * n;
                        return this.area
                    }
                }, a.Polygon.prototype.constructor = a.Polygon, Object.defineProperty(a.Polygon.prototype, "points", {
                    get: function() {
                        return this._points
                    },
                    set: function(t) {
                        null != t ? this.setTo(t) : this.setTo()
                    }
                }), PIXI.Polygon = a.Polygon,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Rectangle = function(t, e, i, s) {
                    t = t || 0, e = e || 0, i = i || 0, s = s || 0, this.x = t, this.y = e, this.width = i, this.height = s, this.type = a.RECTANGLE
                }, a.Rectangle.prototype = {
                    offset: function(t, e) {
                        return this.x += t, this.y += e, this
                    },
                    offsetPoint: function(t) {
                        return this.offset(t.x, t.y)
                    },
                    setTo: function(t, e, i, s) {
                        return this.x = t, this.y = e, this.width = i, this.height = s, this
                    },
                    scale: function(t, e) {
                        return void 0 === e && (e = t), this.width *= t, this.height *= e, this
                    },
                    centerOn: function(t, e) {
                        return this.centerX = t, this.centerY = e, this
                    },
                    floor: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y)
                    },
                    floorAll: function() {
                        this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.width = Math.floor(this.width), this.height = Math.floor(this.height)
                    },
                    ceil: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y)
                    },
                    ceilAll: function() {
                        this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.width = Math.ceil(this.width), this.height = Math.ceil(this.height)
                    },
                    copyFrom: function(t) {
                        return this.setTo(t.x, t.y, t.width, t.height)
                    },
                    copyTo: function(t) {
                        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
                    },
                    inflate: function(t, e) {
                        return a.Rectangle.inflate(this, t, e)
                    },
                    size: function(t) {
                        return a.Rectangle.size(this, t)
                    },
                    resize: function(t, e) {
                        return this.width = t, this.height = e, this
                    },
                    clone: function(t) {
                        return a.Rectangle.clone(this, t)
                    },
                    contains: function(t, e) {
                        return a.Rectangle.contains(this, t, e)
                    },
                    containsRect: function(t) {
                        return a.Rectangle.containsRect(t, this)
                    },
                    equals: function(t) {
                        return a.Rectangle.equals(this, t)
                    },
                    intersection: function(t, e) {
                        return a.Rectangle.intersection(this, t, e)
                    },
                    intersects: function(t) {
                        return a.Rectangle.intersects(this, t)
                    },
                    intersectsRaw: function(t, e, i, s, n) {
                        return a.Rectangle.intersectsRaw(this, t, e, i, s, n)
                    },
                    union: function(t, e) {
                        return a.Rectangle.union(this, t, e)
                    },
                    random: function(t) {
                        return void 0 === t && (t = new a.Point), t.x = this.randomX, t.y = this.randomY, t
                    },
                    getPoint: function(t, e) {
                        switch (void 0 === e && (e = new a.Point), t) {
                            default:
                            case a.TOP_LEFT:
                                return e.set(this.x, this.y);
                            case a.TOP_CENTER:
                                return e.set(this.centerX, this.y);
                            case a.TOP_RIGHT:
                                return e.set(this.right, this.y);
                            case a.LEFT_CENTER:
                                return e.set(this.x, this.centerY);
                            case a.CENTER:
                                return e.set(this.centerX, this.centerY);
                            case a.RIGHT_CENTER:
                                return e.set(this.right, this.centerY);
                            case a.BOTTOM_LEFT:
                                return e.set(this.x, this.bottom);
                            case a.BOTTOM_CENTER:
                                return e.set(this.centerX, this.bottom);
                            case a.BOTTOM_RIGHT:
                                return e.set(this.right, this.bottom)
                        }
                    },
                    toString: function() {
                        return "[{Rectangle (x=" + this.x + " y=" + this.y + " width=" + this.width + " height=" + this.height + " empty=" + this.empty + ")}]"
                    }
                }, Object.defineProperty(a.Rectangle.prototype, "halfWidth", {
                    get: function() {
                        return Math.round(this.width / 2)
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "halfHeight", {
                    get: function() {
                        return Math.round(this.height / 2)
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "bottom", {
                    get: function() {
                        return this.y + this.height
                    },
                    set: function(t) {
                        t <= this.y ? this.height = 0 : this.height = t - this.y
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "bottomLeft", {
                    get: function() {
                        return new a.Point(this.x, this.bottom)
                    },
                    set: function(t) {
                        this.x = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "bottomRight", {
                    get: function() {
                        return new a.Point(this.right, this.bottom)
                    },
                    set: function(t) {
                        this.right = t.x, this.bottom = t.y
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "left", {
                    get: function() {
                        return this.x
                    },
                    set: function(t) {
                        t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "right", {
                    get: function() {
                        return this.x + this.width
                    },
                    set: function(t) {
                        t <= this.x ? this.width = 0 : this.width = t - this.x
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "volume", {
                    get: function() {
                        return this.width * this.height
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "perimeter", {
                    get: function() {
                        return 2 * this.width + 2 * this.height
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "centerX", {
                    get: function() {
                        return this.x + this.halfWidth
                    },
                    set: function(t) {
                        this.x = t - this.halfWidth
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "centerY", {
                    get: function() {
                        return this.y + this.halfHeight
                    },
                    set: function(t) {
                        this.y = t - this.halfHeight
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "randomX", {
                    get: function() {
                        return this.x + Math.random() * this.width
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "randomY", {
                    get: function() {
                        return this.y + Math.random() * this.height
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "top", {
                    get: function() {
                        return this.y
                    },
                    set: function(t) {
                        t >= this.bottom ? (this.height = 0, this.y = t) : this.height = this.bottom - t
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "topLeft", {
                    get: function() {
                        return new a.Point(this.x, this.y)
                    },
                    set: function(t) {
                        this.x = t.x, this.y = t.y
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "topRight", {
                    get: function() {
                        return new a.Point(this.x + this.width, this.y)
                    },
                    set: function(t) {
                        this.right = t.x, this.y = t.y
                    }
                }), Object.defineProperty(a.Rectangle.prototype, "empty", {
                    get: function() {
                        return !this.width || !this.height
                    },
                    set: function(t) {
                        !0 === t && this.setTo(0, 0, 0, 0)
                    }
                }), a.Rectangle.prototype.constructor = a.Rectangle, a.Rectangle.inflate = function(t, e, i) {
                    return t.x -= e, t.width += 2 * e, t.y -= i, t.height += 2 * i, t
                }, a.Rectangle.inflatePoint = function(t, e) {
                    return a.Rectangle.inflate(t, e.x, e.y)
                }, a.Rectangle.size = function(t, e) {
                    return void 0 === e || null === e ? e = new a.Point(t.width, t.height) : e.setTo(t.width, t.height), e
                }, a.Rectangle.clone = function(t, e) {
                    return void 0 === e || null === e ? e = new a.Rectangle(t.x, t.y, t.width, t.height) : e.setTo(t.x, t.y, t.width, t.height), e
                }, a.Rectangle.contains = function(t, e, i) {
                    return !(t.width <= 0 || t.height <= 0) && (e >= t.x && e < t.right && i >= t.y && i < t.bottom)
                }, a.Rectangle.containsRaw = function(t, e, i, s, n, a) {
                    return n >= t && n < t + i && a >= e && a < e + s
                }, a.Rectangle.containsPoint = function(t, e) {
                    return a.Rectangle.contains(t, e.x, e.y)
                }, a.Rectangle.containsRect = function(t, e) {
                    return !(t.volume > e.volume) && (t.x >= e.x && t.y >= e.y && t.right < e.right && t.bottom < e.bottom)
                }, a.Rectangle.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
                }, a.Rectangle.sameDimensions = function(t, e) {
                    return t.width === e.width && t.height === e.height
                }, a.Rectangle.intersection = function(t, e, i) {
                    return void 0 === i && (i = new a.Rectangle), a.Rectangle.intersects(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i
                }, a.Rectangle.intersects = function(t, e) {
                    return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom)
                }, a.Rectangle.intersectsRaw = function(t, e, i, s, n, a) {
                    return void 0 === a && (a = 0), !(e > t.right + a || i < t.left - a || s > t.bottom + a || n < t.top - a)
                }, a.Rectangle.union = function(t, e, i) {
                    return void 0 === i && (i = new a.Rectangle), i.setTo(Math.min(t.x, e.x), Math.min(t.y, e.y), Math.max(t.right, e.right) - Math.min(t.left, e.left), Math.max(t.bottom, e.bottom) - Math.min(t.top, e.top))
                }, a.Rectangle.aabb = function(t, e) {
                    void 0 === e && (e = new a.Rectangle);
                    var i = Number.NEGATIVE_INFINITY,
                        s = Number.POSITIVE_INFINITY,
                        n = Number.NEGATIVE_INFINITY,
                        o = Number.POSITIVE_INFINITY;
                    return t.forEach(function(t) {
                        t.x > i && (i = t.x), t.x < s && (s = t.x), t.y > n && (n = t.y), t.y < o && (o = t.y)
                    }), e.setTo(s, o, i - s, n - o), e
                }, PIXI.Rectangle = a.Rectangle, PIXI.EmptyRectangle = new a.Rectangle(0, 0, 0, 0),
                /**
                 * @author       Mat Groves http://matgroves.com/
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.RoundedRectangle = function(t, e, i, s, n) {
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = 20), this.x = t, this.y = e, this.width = i, this.height = s, this.radius = n || 20, this.type = a.ROUNDEDRECTANGLE
                }, a.RoundedRectangle.prototype = {
                    clone: function() {
                        return new a.RoundedRectangle(this.x, this.y, this.width, this.height, this.radius)
                    },
                    contains: function(t, e) {
                        if (this.width <= 0 || this.height <= 0) return !1;
                        var i = this.x;
                        if (t >= i && t <= i + this.width) {
                            var s = this.y;
                            if (e >= s && e <= s + this.height) return !0
                        }
                        return !1
                    }
                }, a.RoundedRectangle.prototype.constructor = a.RoundedRectangle, PIXI.RoundedRectangle = a.RoundedRectangle,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Camera = function(t, e, i, s, n, o) {
                    this.game = t, this.world = t.world, this.id = 0, this.view = new a.Rectangle(i, s, n, o), this.bounds = new a.Rectangle(i, s, n, o), this.deadzone = null, this.visible = !0, this.roundPx = !0, this.atLimit = {
                        x: !1,
                        y: !1
                    }, this.target = null, this.displayObject = null, this.scale = null, this.totalInView = 0, this.lerp = new a.Point(1, 1), this.onShakeComplete = new a.Signal, this.onFlashComplete = new a.Signal, this.onFadeComplete = new a.Signal, this.fx = null, this._targetPosition = new a.Point, this._edge = 0, this._position = new a.Point, this._shake = {
                        intensity: 0,
                        duration: 0,
                        horizontal: !1,
                        vertical: !1,
                        shakeBounds: !0,
                        x: 0,
                        y: 0
                    }, this._fxDuration = 0, this._fxType = 0
                }, a.Camera.FOLLOW_LOCKON = 0, a.Camera.FOLLOW_PLATFORMER = 1, a.Camera.FOLLOW_TOPDOWN = 2, a.Camera.FOLLOW_TOPDOWN_TIGHT = 3, a.Camera.SHAKE_BOTH = 4, a.Camera.SHAKE_HORIZONTAL = 5, a.Camera.SHAKE_VERTICAL = 6, a.Camera.ENABLE_FX = !0, a.Camera.prototype = {
                    boot: function() {
                        this.displayObject = this.game.world, this.scale = this.game.world.scale, this.game.camera = this, a.Graphics && a.Camera.ENABLE_FX && (this.fx = new a.Graphics(this.game), this.game.stage.addChild(this.fx))
                    },
                    preUpdate: function() {
                        this.totalInView = 0
                    },
                    follow: function(t, e, i, s) {
                        void 0 === e && (e = a.Camera.FOLLOW_LOCKON), void 0 === i && (i = 1), void 0 === s && (s = 1), this.target = t, this.lerp.set(i, s);
                        var n;
                        switch (e) {
                            case a.Camera.FOLLOW_PLATFORMER:
                                var o = this.width / 8,
                                    r = this.height / 3;
                                this.deadzone = new a.Rectangle((this.width - o) / 2, (this.height - r) / 2 - .25 * r, o, r);
                                break;
                            case a.Camera.FOLLOW_TOPDOWN:
                                n = Math.max(this.width, this.height) / 4, this.deadzone = new a.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                                break;
                            case a.Camera.FOLLOW_TOPDOWN_TIGHT:
                                n = Math.max(this.width, this.height) / 8, this.deadzone = new a.Rectangle((this.width - n) / 2, (this.height - n) / 2, n, n);
                                break;
                            case a.Camera.FOLLOW_LOCKON:
                            default:
                                this.deadzone = null
                        }
                    },
                    unfollow: function() {
                        this.target = null
                    },
                    focusOn: function(t) {
                        this.setPosition(Math.round(t.x - this.view.halfWidth), Math.round(t.y - this.view.halfHeight))
                    },
                    focusOnXY: function(t, e) {
                        this.setPosition(Math.round(t - this.view.halfWidth), Math.round(e - this.view.halfHeight))
                    },
                    shake: function(t, e, i, s, n) {
                        return void 0 === t && (t = .05), void 0 === e && (e = 500), void 0 === i && (i = !0), void 0 === s && (s = a.Camera.SHAKE_BOTH), void 0 === n && (n = !0), !(!i && this._shake.duration > 0) && (this._shake.intensity = t, this._shake.duration = e, this._shake.shakeBounds = n, this._shake.x = 0, this._shake.y = 0, this._shake.horizontal = s === a.Camera.SHAKE_BOTH || s === a.Camera.SHAKE_HORIZONTAL, this._shake.vertical = s === a.Camera.SHAKE_BOTH || s === a.Camera.SHAKE_VERTICAL, !0)
                    },
                    flash: function(t, e, i) {
                        return void 0 === t && (t = 16777215), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 1, this._fxDuration = e, this._fxType = 0, !0)
                    },
                    fade: function(t, e, i) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 500), void 0 === i && (i = !1), !(!this.fx || !i && this._fxDuration > 0) && (this.fx.clear(), this.fx.beginFill(t), this.fx.drawRect(0, 0, this.width, this.height), this.fx.endFill(), this.fx.alpha = 0, this._fxDuration = e, this._fxType = 1, !0)
                    },
                    update: function() {
                        this._fxDuration > 0 && this.updateFX(), this._shake.duration > 0 && this.updateShake(), this.bounds && this.checkBounds(), this.roundPx && (this.view.floor(), this._shake.x = Math.floor(this._shake.x), this._shake.y = Math.floor(this._shake.y)), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    updateFX: function() {
                        0 === this._fxType ? (this.fx.alpha -= this.game.time.elapsedMS / this._fxDuration, this.fx.alpha <= 0 && (this._fxDuration = 0, this.fx.alpha = 0, this.onFlashComplete.dispatch())) : (this.fx.alpha += this.game.time.elapsedMS / this._fxDuration, this.fx.alpha >= 1 && (this._fxDuration = 0, this.fx.alpha = 1, this.onFadeComplete.dispatch()))
                    },
                    updateShake: function() {
                        this._shake.duration -= this.game.time.elapsedMS, this._shake.duration <= 0 ? (this.onShakeComplete.dispatch(), this._shake.x = 0, this._shake.y = 0) : (this._shake.horizontal && (this._shake.x = this.game.rnd.frac() * this._shake.intensity * this.view.width * 2 - this._shake.intensity * this.view.width), this._shake.vertical && (this._shake.y = this.game.rnd.frac() * this._shake.intensity * this.view.height * 2 - this._shake.intensity * this.view.height))
                    },
                    updateTarget: function() {
                        this._targetPosition.x = this.view.x + this.target.worldPosition.x, this._targetPosition.y = this.view.y + this.target.worldPosition.y, this.deadzone ? (this._edge = this._targetPosition.x - this.view.x, this._edge < this.deadzone.left ? this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.left, this.lerp.x) : this._edge > this.deadzone.right && (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.deadzone.right, this.lerp.x)), this._edge = this._targetPosition.y - this.view.y, this._edge < this.deadzone.top ? this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.top, this.lerp.y) : this._edge > this.deadzone.bottom && (this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.deadzone.bottom, this.lerp.y))) : (this.view.x = this.game.math.linear(this.view.x, this._targetPosition.x - this.view.halfWidth, this.lerp.x), this.view.y = this.game.math.linear(this.view.y, this._targetPosition.y - this.view.halfHeight, this.lerp.y)), this.bounds && this.checkBounds(), this.roundPx && this.view.floor(), this.displayObject.position.x = -this.view.x, this.displayObject.position.y = -this.view.y
                    },
                    setBoundsToWorld: function() {
                        this.bounds && this.bounds.copyFrom(this.game.world.bounds)
                    },
                    checkBounds: function() {
                        this.atLimit.x = !1, this.atLimit.y = !1;
                        var t = this.view.x + this._shake.x,
                            e = this.view.right + this._shake.x,
                            i = this.view.y + this._shake.y,
                            s = this.view.bottom + this._shake.y;
                        t <= this.bounds.x * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.x * this.scale.x, this._shake.shakeBounds || (this._shake.x = 0)), e >= this.bounds.right * this.scale.x && (this.atLimit.x = !0, this.view.x = this.bounds.right * this.scale.x - this.width, this._shake.shakeBounds || (this._shake.x = 0)), i <= this.bounds.top * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.top * this.scale.y, this._shake.shakeBounds || (this._shake.y = 0)), s >= this.bounds.bottom * this.scale.y && (this.atLimit.y = !0, this.view.y = this.bounds.bottom * this.scale.y - this.height, this._shake.shakeBounds || (this._shake.y = 0))
                    },
                    setPosition: function(t, e) {
                        this.view.x = t, this.view.y = e, this.bounds && this.checkBounds()
                    },
                    setSize: function(t, e) {
                        this.view.width = t, this.view.height = e
                    },
                    reset: function() {
                        this.target = null, this.view.x = 0, this.view.y = 0, this._shake.duration = 0, this.resetFX()
                    },
                    resetFX: function() {
                        this.fx.clear(), this.fx.alpha = 0, this._fxDuration = 0
                    }
                }, a.Camera.prototype.constructor = a.Camera, Object.defineProperty(a.Camera.prototype, "x", {
                    get: function() {
                        return this.view.x
                    },
                    set: function(t) {
                        this.view.x = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(a.Camera.prototype, "y", {
                    get: function() {
                        return this.view.y
                    },
                    set: function(t) {
                        this.view.y = t, this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(a.Camera.prototype, "position", {
                    get: function() {
                        return this._position.set(this.view.x, this.view.y), this._position
                    },
                    set: function(t) {
                        void 0 !== t.x && (this.view.x = t.x), void 0 !== t.y && (this.view.y = t.y), this.bounds && this.checkBounds()
                    }
                }), Object.defineProperty(a.Camera.prototype, "width", {
                    get: function() {
                        return this.view.width
                    },
                    set: function(t) {
                        this.view.width = t
                    }
                }), Object.defineProperty(a.Camera.prototype, "height", {
                    get: function() {
                        return this.view.height
                    },
                    set: function(t) {
                        this.view.height = t
                    }
                }), Object.defineProperty(a.Camera.prototype, "shakeIntensity", {
                    get: function() {
                        return this._shake.intensity
                    },
                    set: function(t) {
                        this._shake.intensity = t
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.State = function() {
                    this.game = null, this.key = "", this.add = null, this.make = null, this.camera = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.sound = null, this.scale = null, this.stage = null, this.state = null, this.time = null, this.tweens = null, this.world = null, this.particles = null, this.physics = null, this.rnd = null
                }, a.State.prototype = {
                    init: function() {},
                    preload: function() {},
                    loadUpdate: function() {},
                    loadRender: function() {},
                    create: function() {},
                    update: function() {},
                    preRender: function() {},
                    render: function() {},
                    resize: function() {},
                    paused: function() {},
                    resumed: function() {},
                    pauseUpdate: function() {},
                    shutdown: function() {}
                }, a.State.prototype.constructor = a.State,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.StateManager = function(t, e) {
                    this.game = t, this.states = {}, this._pendingState = null, void 0 !== e && null !== e && (this._pendingState = e), this._clearWorld = !1, this._clearCache = !1, this._created = !1, this._args = [], this.current = "", this.onStateChange = new a.Signal, this.onInitCallback = null, this.onPreloadCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPreRenderCallback = null, this.onLoadUpdateCallback = null, this.onLoadRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.onShutDownCallback = null
                }, a.StateManager.prototype = {
                    boot: function() {
                        this.game.onPause.add(this.pause, this), this.game.onResume.add(this.resume, this), null !== this._pendingState && "string" != typeof this._pendingState && this.add("default", this._pendingState, !0)
                    },
                    add: function(t, e, i) {
                        void 0 === i && (i = !1);
                        var s;
                        return e instanceof a.State ? s = e : "object" == typeof e ? (s = e, s.game = this.game) : "function" == typeof e && (s = new e(this.game)), this.states[t] = s, i && (this.game.isBooted ? this.start(t) : this._pendingState = t), s
                    },
                    remove: function(t) {
                        this.current === t && (this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onPreRenderCallback = null, this.onRenderCallback = null, this.onResizeCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null), delete this.states[t]
                    },
                    start: function(t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = !1), this.checkState(t) && (this._pendingState = t, this._clearWorld = e, this._clearCache = i, arguments.length > 3 && (this._args = Array.prototype.splice.call(arguments, 3)))
                    },
                    restart: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !1), this._pendingState = this.current, this._clearWorld = t, this._clearCache = e, arguments.length > 2 && (this._args = Array.prototype.slice.call(arguments, 2))
                    },
                    dummy: function() {},
                    preUpdate: function() {
                        if (this._pendingState && this.game.isBooted) {
                            var t = this.current;
                            if (this.clearCurrentState(), this.setCurrentState(this._pendingState), this.onStateChange.dispatch(this.current, t), this.current !== this._pendingState) return;
                            this._pendingState = null, this.onPreloadCallback ? (this.game.load.reset(!0), this.onPreloadCallback.call(this.callbackContext, this.game), 0 === this.game.load.totalQueuedFiles() && 0 === this.game.load.totalQueuedPacks() ? this.loadComplete() : this.game.load.start()) : this.loadComplete()
                        }
                    },
                    clearCurrentState: function() {
                        this.current && (this.onShutDownCallback && this.onShutDownCallback.call(this.callbackContext, this.game), this.game.tweens.removeAll(), this.game.camera.reset(), this.game.input.reset(!0), this.game.physics.clear(), this.game.time.removeAll(), this.game.scale.reset(this._clearWorld), this.game.debug && this.game.debug.reset(), this._clearWorld && (this.game.world.shutdown(), this._clearCache && this.game.cache.destroy()))
                    },
                    checkState: function(t) {
                        return !!this.states[t] && !!(this.states[t].preload || this.states[t].create || this.states[t].update || this.states[t].render)
                    },
                    link: function(t) {
                        this.states[t].game = this.game, this.states[t].add = this.game.add, this.states[t].make = this.game.make, this.states[t].camera = this.game.camera, this.states[t].cache = this.game.cache, this.states[t].input = this.game.input, this.states[t].load = this.game.load, this.states[t].math = this.game.math, this.states[t].sound = this.game.sound, this.states[t].scale = this.game.scale, this.states[t].state = this, this.states[t].stage = this.game.stage, this.states[t].time = this.game.time, this.states[t].tweens = this.game.tweens, this.states[t].world = this.game.world, this.states[t].particles = this.game.particles, this.states[t].rnd = this.game.rnd, this.states[t].physics = this.game.physics, this.states[t].key = t
                    },
                    unlink: function(t) {
                        this.states[t] && (this.states[t].game = null, this.states[t].add = null, this.states[t].make = null, this.states[t].camera = null, this.states[t].cache = null, this.states[t].input = null, this.states[t].load = null, this.states[t].math = null, this.states[t].sound = null, this.states[t].scale = null, this.states[t].state = null, this.states[t].stage = null, this.states[t].time = null, this.states[t].tweens = null, this.states[t].world = null, this.states[t].particles = null, this.states[t].rnd = null, this.states[t].physics = null)
                    },
                    setCurrentState: function(t) {
                        this.callbackContext = this.states[t], this.link(t), this.onInitCallback = this.states[t].init || this.dummy, this.onPreloadCallback = this.states[t].preload || null, this.onLoadRenderCallback = this.states[t].loadRender || null, this.onLoadUpdateCallback = this.states[t].loadUpdate || null, this.onCreateCallback = this.states[t].create || null, this.onUpdateCallback = this.states[t].update || null, this.onPreRenderCallback = this.states[t].preRender || null, this.onRenderCallback = this.states[t].render || null, this.onResizeCallback = this.states[t].resize || null, this.onPausedCallback = this.states[t].paused || null, this.onResumedCallback = this.states[t].resumed || null, this.onPauseUpdateCallback = this.states[t].pauseUpdate || null, this.onShutDownCallback = this.states[t].shutdown || this.dummy, "" !== this.current && this.game.physics.reset(), this.current = t, this._created = !1, this.onInitCallback.apply(this.callbackContext, this._args), t === this._pendingState && (this._args = []), this.game._kickstart = !0
                    },
                    getCurrentState: function() {
                        return this.states[this.current]
                    },
                    loadComplete: function() {
                        !1 === this._created && this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game), !1 === this._created && this.onCreateCallback ? (this._created = !0, this.onCreateCallback.call(this.callbackContext, this.game)) : this._created = !0
                    },
                    pause: function() {
                        this._created && this.onPausedCallback && this.onPausedCallback.call(this.callbackContext, this.game)
                    },
                    resume: function() {
                        this._created && this.onResumedCallback && this.onResumedCallback.call(this.callbackContext, this.game)
                    },
                    update: function() {
                        this._created ? this.onUpdateCallback && this.onUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    pauseUpdate: function() {
                        this._created ? this.onPauseUpdateCallback && this.onPauseUpdateCallback.call(this.callbackContext, this.game) : this.onLoadUpdateCallback && this.onLoadUpdateCallback.call(this.callbackContext, this.game)
                    },
                    preRender: function(t) {
                        this._created && this.onPreRenderCallback && this.onPreRenderCallback.call(this.callbackContext, this.game, t)
                    },
                    resize: function(t, e) {
                        this.onResizeCallback && this.onResizeCallback.call(this.callbackContext, t, e)
                    },
                    render: function() {
                        this._created ? this.onRenderCallback && (this.game.renderType === a.CANVAS ? (this.game.context.save(), this.game.context.setTransform(1, 0, 0, 1, 0, 0), this.onRenderCallback.call(this.callbackContext, this.game), this.game.context.restore()) : this.onRenderCallback.call(this.callbackContext, this.game)) : this.onLoadRenderCallback && this.onLoadRenderCallback.call(this.callbackContext, this.game)
                    },
                    destroy: function() {
                        this._clearWorld = !0, this._clearCache = !0, this.clearCurrentState(), this.callbackContext = null, this.onInitCallback = null, this.onShutDownCallback = null, this.onPreloadCallback = null, this.onLoadRenderCallback = null, this.onLoadUpdateCallback = null, this.onCreateCallback = null, this.onUpdateCallback = null, this.onRenderCallback = null, this.onPausedCallback = null, this.onResumedCallback = null, this.onPauseUpdateCallback = null, this.game = null, this.states = {}, this._pendingState = null, this.current = ""
                    }
                }, a.StateManager.prototype.constructor = a.StateManager, Object.defineProperty(a.StateManager.prototype, "created", {
                    get: function() {
                        return this._created
                    }
                }),
                /**
                 * @author       Miller Medeiros http://millermedeiros.github.com/js-signals/
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Signal = function() {}, a.Signal.prototype = {
                    _bindings: null,
                    _prevParams: null,
                    memorize: !1,
                    _shouldPropagate: !0,
                    active: !0,
                    _boundDispatch: !1,
                    validateListener: function(t, e) {
                        if ("function" != typeof t) throw new Error("Phaser.Signal: listener is a required param of {fn}() and should be a Function.".replace("{fn}", e))
                    },
                    _registerListener: function(t, e, i, s, n) {
                        var o = this._indexOfListener(t, i),
                            r;
                        if (-1 !== o) {
                            if (r = this._bindings[o], r.isOnce() !== e) throw new Error("You cannot add" + (e ? "" : "Once") + "() then add" + (e ? "Once" : "") + "() the same listener without removing the relationship first.")
                        } else r = new a.SignalBinding(this, t, e, i, s, n), this._addBinding(r);
                        return this.memorize && this._prevParams && r.execute(this._prevParams), r
                    },
                    _addBinding: function(t) {
                        this._bindings || (this._bindings = []);
                        var e = this._bindings.length;
                        do {
                            e--
                        } while (this._bindings[e] && t._priority <= this._bindings[e]._priority);
                        this._bindings.splice(e + 1, 0, t)
                    },
                    _indexOfListener: function(t, e) {
                        if (!this._bindings) return -1;
                        void 0 === e && (e = null);
                        for (var i = this._bindings.length, s; i--;)
                            if (s = this._bindings[i], s._listener === t && s.context === e) return i;
                        return -1
                    },
                    has: function(t, e) {
                        return -1 !== this._indexOfListener(t, e)
                    },
                    add: function(t, e, i) {
                        this.validateListener(t, "add");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !1, e, i, s)
                    },
                    addOnce: function(t, e, i) {
                        this.validateListener(t, "addOnce");
                        var s = [];
                        if (arguments.length > 3)
                            for (var n = 3; n < arguments.length; n++) s.push(arguments[n]);
                        return this._registerListener(t, !0, e, i, s)
                    },
                    remove: function(t, e) {
                        this.validateListener(t, "remove");
                        var i = this._indexOfListener(t, e);
                        return -1 !== i && (this._bindings[i]._destroy(), this._bindings.splice(i, 1)), t
                    },
                    removeAll: function(t) {
                        if (void 0 === t && (t = null), this._bindings) {
                            for (var e = this._bindings.length; e--;) t ? this._bindings[e].context === t && (this._bindings[e]._destroy(), this._bindings.splice(e, 1)) : this._bindings[e]._destroy();
                            t || (this._bindings.length = 0)
                        }
                    },
                    getNumListeners: function() {
                        return this._bindings ? this._bindings.length : 0
                    },
                    halt: function() {
                        this._shouldPropagate = !1
                    },
                    dispatch: function() {
                        if (this.active && this._bindings) {
                            var t = Array.prototype.slice.call(arguments),
                                e = this._bindings.length,
                                i;
                            if (this.memorize && (this._prevParams = t), e) {
                                i = this._bindings.slice(), this._shouldPropagate = !0;
                                do {
                                    e--
                                } while (i[e] && this._shouldPropagate && !1 !== i[e].execute(t))
                            }
                        }
                    },
                    forget: function() {
                        this._prevParams && (this._prevParams = null)
                    },
                    dispose: function() {
                        this.removeAll(), this._bindings = null, this._prevParams && (this._prevParams = null)
                    },
                    toString: function() {
                        return "[Phaser.Signal active:" + this.active + " numListeners:" + this.getNumListeners() + "]"
                    }
                }, Object.defineProperty(a.Signal.prototype, "boundDispatch", {
                    get: function() {
                        var t = this;
                        return this._boundDispatch || (this._boundDispatch = function() {
                            return t.dispatch.apply(t, arguments)
                        })
                    }
                }), a.Signal.prototype.constructor = a.Signal,
                /**
                 * @author       Miller Medeiros http://millermedeiros.github.com/js-signals/
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.SignalBinding = function(t, e, i, s, n, a) {
                    this._listener = e, i && (this._isOnce = !0), null != s && (this.context = s), this._signal = t, n && (this._priority = n), a && a.length && (this._args = a)
                }, a.SignalBinding.prototype = {
                    context: null,
                    _isOnce: !1,
                    _priority: 0,
                    _args: null,
                    callCount: 0,
                    active: !0,
                    params: null,
                    execute: function(t) {
                        var e, i;
                        return this.active && this._listener && (i = this.params ? this.params.concat(t) : t, this._args && (i = i.concat(this._args)), e = this._listener.apply(this.context, i), this.callCount++, this._isOnce && this.detach()), e
                    },
                    detach: function() {
                        return this.isBound() ? this._signal.remove(this._listener, this.context) : null
                    },
                    isBound: function() {
                        return !!this._signal && !!this._listener
                    },
                    isOnce: function() {
                        return this._isOnce
                    },
                    getListener: function() {
                        return this._listener
                    },
                    getSignal: function() {
                        return this._signal
                    },
                    _destroy: function() {
                        delete this._signal, delete this._listener, delete this.context
                    },
                    toString: function() {
                        return "[Phaser.SignalBinding isOnce:" + this._isOnce + ", isBound:" + this.isBound() + ", active:" + this.active + "]"
                    }
                }, a.SignalBinding.prototype.constructor = a.SignalBinding,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Filter = function(t, e, i) {
                    this.game = t, this.type = a.WEBGL_FILTER, this.passes = [this], this.shaders = [], this.dirty = !0, this.padding = 0, this.prevPoint = new a.Point;
                    var s = new Date;
                    if (this.uniforms = {
                            resolution: {
                                type: "2f",
                                value: {
                                    x: 256,
                                    y: 256
                                }
                            },
                            time: {
                                type: "1f",
                                value: 0
                            },
                            mouse: {
                                type: "2f",
                                value: {
                                    x: 0,
                                    y: 0
                                }
                            },
                            date: {
                                type: "4fv",
                                value: [s.getFullYear(), s.getMonth(), s.getDate(), 60 * s.getHours() * 60 + 60 * s.getMinutes() + s.getSeconds()]
                            },
                            sampleRate: {
                                type: "1f",
                                value: 44100
                            },
                            iChannel0: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel1: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel2: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            },
                            iChannel3: {
                                type: "sampler2D",
                                value: null,
                                textureData: {
                                    repeat: !0
                                }
                            }
                        }, e)
                        for (var n in e) this.uniforms[n] = e[n];
                    this.fragmentSrc = i || ""
                }, a.Filter.prototype = {
                    init: function() {},
                    setResolution: function(t, e) {
                        this.uniforms.resolution.value.x = t, this.uniforms.resolution.value.y = e
                    },
                    update: function(t) {
                        if (void 0 !== t) {
                            var e = t.x / this.game.width,
                                i = 1 - t.y / this.game.height;
                            e === this.prevPoint.x && i === this.prevPoint.y || (this.uniforms.mouse.value.x = e.toFixed(2), this.uniforms.mouse.value.y = i.toFixed(2), this.prevPoint.set(e, i))
                        }
                        this.uniforms.time.value = this.game.time.totalElapsedSeconds()
                    },
                    addToWorld: function(t, e, i, s, n, a) {
                        void 0 === n && (n = 0), void 0 === a && (a = 0), void 0 !== i && null !== i ? this.width = i : i = this.width, void 0 !== s && null !== s ? this.height = s : s = this.height;
                        var o = this.game.add.image(t, e, "__default");
                        return o.width = i, o.height = s, o.anchor.set(n, a), o.filters = [this], o
                    },
                    destroy: function() {
                        this.game = null
                    }
                }, a.Filter.prototype.constructor = a.Filter, Object.defineProperty(a.Filter.prototype, "width", {
                    get: function() {
                        return this.uniforms.resolution.value.x
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.x = t
                    }
                }), Object.defineProperty(a.Filter.prototype, "height", {
                    get: function() {
                        return this.uniforms.resolution.value.y
                    },
                    set: function(t) {
                        this.uniforms.resolution.value.y = t
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Plugin = function(t, e) {
                    void 0 === e && (e = null), this.game = t, this.parent = e, this.active = !1, this.visible = !1, this.hasPreUpdate = !1, this.hasUpdate = !1, this.hasPostUpdate = !1, this.hasRender = !1, this.hasPostRender = !1
                }, a.Plugin.prototype = {
                    preUpdate: function() {},
                    update: function() {},
                    render: function() {},
                    postRender: function() {},
                    destroy: function() {
                        this.game = null, this.parent = null, this.active = !1, this.visible = !1
                    }
                }, a.Plugin.prototype.constructor = a.Plugin,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.PluginManager = function(t) {
                    this.game = t, this.plugins = [], this._len = 0, this._i = 0
                }, a.PluginManager.prototype = {
                    add: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            i = !1;
                        return "function" == typeof t ? t = new t(this.game, this) : (t.game = this.game, t.parent = this), "function" == typeof t.preUpdate && (t.hasPreUpdate = !0, i = !0), "function" == typeof t.update && (t.hasUpdate = !0, i = !0), "function" == typeof t.postUpdate && (t.hasPostUpdate = !0, i = !0), "function" == typeof t.render && (t.hasRender = !0, i = !0), "function" == typeof t.postRender && (t.hasPostRender = !0, i = !0), i ? ((t.hasPreUpdate || t.hasUpdate || t.hasPostUpdate) && (t.active = !0), (t.hasRender || t.hasPostRender) && (t.visible = !0), this._len = this.plugins.push(t), "function" == typeof t.init && t.init.apply(t, e), t) : null
                    },
                    remove: function(t, e) {
                        for (void 0 === e && (e = !0), this._i = this._len; this._i--;)
                            if (this.plugins[this._i] === t) return e && t.destroy(), this.plugins.splice(this._i, 1), void this._len--
                    },
                    removeAll: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].destroy();
                        this.plugins.length = 0, this._len = 0
                    },
                    preUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPreUpdate && this.plugins[this._i].preUpdate()
                    },
                    update: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasUpdate && this.plugins[this._i].update()
                    },
                    postUpdate: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].active && this.plugins[this._i].hasPostUpdate && this.plugins[this._i].postUpdate()
                    },
                    render: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasRender && this.plugins[this._i].render()
                    },
                    postRender: function() {
                        for (this._i = this._len; this._i--;) this.plugins[this._i].visible && this.plugins[this._i].hasPostRender && this.plugins[this._i].postRender()
                    },
                    destroy: function() {
                        this.removeAll(), this.game = null
                    }
                }, a.PluginManager.prototype.constructor = a.PluginManager,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Stage = function(t) {
                    this.game = t, PIXI.DisplayObjectContainer.call(this), this.name = "_stage_root", this.disableVisibilityChange = !1, this.exists = !0, this.worldTransform = new PIXI.Matrix, this.stage = this, this.currentRenderOrderID = 0, this._hiddenVar = "hidden", this._onChange = null, this._bgColor = {
                        r: 0,
                        g: 0,
                        b: 0,
                        a: 0,
                        color: 0,
                        rgba: "#000000"
                    }, this.game.transparent || (this._bgColor.a = 1), t.config && this.parseConfig(t.config)
                }, a.Stage.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), a.Stage.prototype.constructor = a.Stage, a.Stage.prototype.parseConfig = function(t) {
                    t.disableVisibilityChange && (this.disableVisibilityChange = t.disableVisibilityChange), t.backgroundColor && this.setBackgroundColor(t.backgroundColor)
                }, a.Stage.prototype.boot = function() {
                    a.DOM.getOffset(this.game.canvas, this.offset), a.Canvas.setUserSelect(this.game.canvas, "none"), a.Canvas.setTouchAction(this.game.canvas, "none"), this.checkVisibility()
                }, a.Stage.prototype.preUpdate = function() {
                    this.currentRenderOrderID = 0;
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate()
                }, a.Stage.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, a.Stage.prototype.postUpdate = function() {
                    this.game.camera.update(), this.game.camera.target && (this.game.camera.target.postUpdate(), this.updateTransform(), this.game.camera.updateTarget());
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate();
                    this.updateTransform()
                }, a.Stage.prototype.updateTransform = function() {
                    this.worldAlpha = 1;
                    for (var t = 0; t < this.children.length; t++) this.children[t].updateTransform()
                }, a.Stage.prototype.checkVisibility = function() {
                    void 0 !== document.hidden ? this._hiddenVar = "visibilitychange" : void 0 !== document.webkitHidden ? this._hiddenVar = "webkitvisibilitychange" : void 0 !== document.mozHidden ? this._hiddenVar = "mozvisibilitychange" : void 0 !== document.msHidden ? this._hiddenVar = "msvisibilitychange" : this._hiddenVar = null;
                    var t = this;
                    this._onChange = function(e) {
                        return t.visibilityChange(e)
                    }, this._hiddenVar && document.addEventListener(this._hiddenVar, this._onChange, !1), window.onblur = this._onChange, window.onfocus = this._onChange, window.onpagehide = this._onChange, window.onpageshow = this._onChange, this.game.device.cocoonJSApp && (CocoonJS.App.onSuspended.addEventListener(function() {
                        a.Stage.prototype.visibilityChange.call(t, {
                            type: "pause"
                        })
                    }), CocoonJS.App.onActivated.addEventListener(function() {
                        a.Stage.prototype.visibilityChange.call(t, {
                            type: "resume"
                        })
                    }))
                }, a.Stage.prototype.visibilityChange = function(t) {
                    if ("pagehide" === t.type || "blur" === t.type || "pageshow" === t.type || "focus" === t.type) return void("pagehide" === t.type || "blur" === t.type ? this.game.focusLoss(t) : "pageshow" !== t.type && "focus" !== t.type || this.game.focusGain(t));
                    this.disableVisibilityChange || (document.hidden || document.mozHidden || document.msHidden || document.webkitHidden || "pause" === t.type ? this.game.gamePaused(t) : this.game.gameResumed(t))
                }, a.Stage.prototype.setBackgroundColor = function(t) {
                    this.game.transparent || (a.Color.valueToColor(t, this._bgColor), a.Color.updateColor(this._bgColor), this._bgColor.r /= 255, this._bgColor.g /= 255, this._bgColor.b /= 255, this._bgColor.a = 1)
                }, a.Stage.prototype.destroy = function() {
                    this._hiddenVar && document.removeEventListener(this._hiddenVar, this._onChange, !1), window.onpagehide = null, window.onpageshow = null, window.onblur = null, window.onfocus = null
                }, Object.defineProperty(a.Stage.prototype, "backgroundColor", {
                    get: function() {
                        return this._bgColor.color
                    },
                    set: function(t) {
                        this.setBackgroundColor(t)
                    }
                }), Object.defineProperty(a.Stage.prototype, "smoothed", {
                    get: function() {
                        return PIXI.scaleModes.DEFAULT === PIXI.scaleModes.LINEAR
                    },
                    set: function(t) {
                        PIXI.scaleModes.DEFAULT = t ? PIXI.scaleModes.LINEAR : PIXI.scaleModes.NEAREST
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Group = function(t, e, i, s, n, o) {
                    void 0 === s && (s = !1), void 0 === n && (n = !1), void 0 === o && (o = a.Physics.ARCADE), this.game = t, void 0 === e && (e = t.world), this.name = i || "group", this.z = 0, PIXI.DisplayObjectContainer.call(this), s ? (this.game.stage.addChild(this), this.z = this.game.stage.children.length) : e && (e.addChild(this), this.z = e.children.length), this.type = a.GROUP, this.physicsType = a.GROUP, this.alive = !0, this.exists = !0, this.ignoreDestroy = !1, this.pendingDestroy = !1, this.classType = a.Sprite, this.cursor = null, this.inputEnableChildren = !1, this.onChildInputDown = new a.Signal, this.onChildInputUp = new a.Signal, this.onChildInputOver = new a.Signal, this.onChildInputOut = new a.Signal, this.enableBody = n, this.enableBodyDebug = !1, this.physicsBodyType = o, this.physicsSortDirection = null, this.onDestroy = new a.Signal, this.cursorIndex = 0, this.fixedToCamera = !1, this.cameraOffset = new a.Point, this.hash = [], this._sortProperty = "z"
                }, a.Group.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), a.Group.prototype.constructor = a.Group, a.Group.RETURN_NONE = 0, a.Group.RETURN_TOTAL = 1, a.Group.RETURN_CHILD = 2, a.Group.RETURN_ALL = 3, a.Group.SORT_ASCENDING = -1, a.Group.SORT_DESCENDING = 1, a.Group.prototype.add = function(t, e, i) {
                    return void 0 === e && (e = !1), t.parent === this ? t : (t.body && t.parent && t.parent.hash && t.parent.removeFromHash(t), void 0 === i ? (t.z = this.children.length, this.addChild(t)) : (this.addChildAt(t, i), this.updateZ()), this.enableBody && t.hasOwnProperty("body") && null === t.body ? this.game.physics.enable(t, this.physicsBodyType) : t.body && this.addToHash(t), !this.inputEnableChildren || t.input && !t.inputEnabled || (t.inputEnabled = !0), !e && t.events && t.events.onAddedToGroup$dispatch(t, this), null === this.cursor && (this.cursor = t), t)
                }, a.Group.prototype.addAt = function(t, e, i) {
                    this.add(t, i, e)
                }, a.Group.prototype.addToHash = function(t) {
                    if (t.parent === this) {
                        if (-1 === this.hash.indexOf(t)) return this.hash.push(t), !0
                    }
                    return !1
                }, a.Group.prototype.removeFromHash = function(t) {
                    if (t) {
                        var e = this.hash.indexOf(t);
                        if (-1 !== e) return this.hash.splice(e, 1), !0
                    }
                    return !1
                }, a.Group.prototype.addMultiple = function(t, e) {
                    if (t instanceof a.Group) t.moveAll(this, e);
                    else if (Array.isArray(t))
                        for (var i = 0; i < t.length; i++) this.add(t[i], e);
                    return t
                }, a.Group.prototype.getAt = function(t) {
                    return t < 0 || t >= this.children.length ? -1 : this.getChildAt(t)
                }, a.Group.prototype.create = function(t, e, i, s, n, a) {
                    void 0 === n && (n = !0);
                    var o = new this.classType(this.game, t, e, i, s);
                    return o.exists = n, o.visible = n, o.alive = n, this.add(o, !1, a)
                }, a.Group.prototype.createMultiple = function(t, e, i, s) {
                    void 0 === i && (i = 0), void 0 === s && (s = !1), Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]);
                    var n = this,
                        a = [];
                    return e.forEach(function(e) {
                        i.forEach(function(i) {
                            for (var o = 0; o < t; o++) a.push(n.create(0, 0, e, i, s))
                        })
                    }), a
                }, a.Group.prototype.updateZ = function() {
                    for (var t = this.children.length; t--;) this.children[t].z = t
                };
            a.Group.prototype.align = function(t, e, i, s, n, o) {
                    if (void 0 === n && (n = a.TOP_LEFT), void 0 === o && (o = 0), 0 === this.children.length || o > this.children.length || -1 === t && -1 === e) return !1;
                    for (var r = new a.Rectangle(0, 0, i, s), h = t * i, l = e * s, c = o; c < this.children.length; c++) {
                        var u = this.children[c];
                        if (u.alignIn)
                            if (u.alignIn(r, n), -1 === t) r.y += s, r.y === l && (r.x += i, r.y = 0);
                            else if (-1 === e) r.x += i, r.x === h && (r.x = 0, r.y += s);
                        else if (r.x += i, r.x === h && (r.x = 0, r.y += s, r.y === l)) return !0
                    }
                    return !0
                }, a.Group.prototype.resetCursor = function(t) {
                    if (void 0 === t && (t = 0), t > this.children.length - 1 && (t = 0), this.cursor) return this.cursorIndex = t, this.cursor = this.children[this.cursorIndex], this.cursor
                }, a.Group.prototype.next = function() {
                    if (this.cursor) return this.cursorIndex >= this.children.length - 1 ? this.cursorIndex = 0 : this.cursorIndex++, this.cursor = this.children[this.cursorIndex], this.cursor
                }, a.Group.prototype.previous = function() {
                    if (this.cursor) return 0 === this.cursorIndex ? this.cursorIndex = this.children.length - 1 : this.cursorIndex--, this.cursor = this.children[this.cursorIndex], this.cursor
                }, a.Group.prototype.swap = function(t, e) {
                    this.swapChildren(t, e), this.updateZ()
                }, a.Group.prototype.bringToTop = function(t) {
                    return t.parent === this && this.getIndex(t) < this.children.length && (this.remove(t, !1, !0), this.add(t, !0)), t
                }, a.Group.prototype.sendToBack = function(t) {
                    return t.parent === this && this.getIndex(t) > 0 && (this.remove(t, !1, !0), this.addAt(t, 0, !0)), t
                }, a.Group.prototype.moveUp = function(t) {
                    if (t.parent === this && this.getIndex(t) < this.children.length - 1) {
                        var e = this.getIndex(t),
                            i = this.getAt(e + 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, a.Group.prototype.moveDown = function(t) {
                    if (t.parent === this && this.getIndex(t) > 0) {
                        var e = this.getIndex(t),
                            i = this.getAt(e - 1);
                        i && this.swap(t, i)
                    }
                    return t
                }, a.Group.prototype.xy = function(t, e, i) {
                    if (t < 0 || t > this.children.length) return -1;
                    this.getChildAt(t)
                        .x = e, this.getChildAt(t)
                        .y = i
                }, a.Group.prototype.reverse = function() {
                    this.children.reverse(), this.updateZ()
                }, a.Group.prototype.getIndex = function(t) {
                    return this.children.indexOf(t)
                }, a.Group.prototype.getByName = function(t) {
                    for (var e = 0; e < this.children.length; e++)
                        if (this.children[e].name === t) return this.children[e];
                    return null
                }, a.Group.prototype.replace = function(t, e) {
                    var i = this.getIndex(t);
                    if (-1 !== i) return e.parent && (e.parent instanceof a.Group ? e.parent.remove(e) : e.parent.removeChild(e)), this.remove(t), this.addAt(e, i), t
                }, a.Group.prototype.hasProperty = function(t, e) {
                    var i = e.length;
                    return 1 === i && e[0] in t || (2 === i && e[0] in t && e[1] in t[e[0]] || (3 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] || 4 === i && e[0] in t && e[1] in t[e[0]] && e[2] in t[e[0]][e[1]] && e[3] in t[e[0]][e[1]][e[2]]))
                }, a.Group.prototype.setProperty = function(t, e, i, s, n) {
                    if (void 0 === n && (n = !1), s = s || 0, !this.hasProperty(t, e) && (!n || s > 0)) return !1;
                    var a = e.length;
                    return 1 === a ? 0 === s ? t[e[0]] = i : 1 === s ? t[e[0]] += i : 2 === s ? t[e[0]] -= i : 3 === s ? t[e[0]] *= i : 4 === s && (t[e[0]] /= i) : 2 === a ? 0 === s ? t[e[0]][e[1]] = i : 1 === s ? t[e[0]][e[1]] += i : 2 === s ? t[e[0]][e[1]] -= i : 3 === s ? t[e[0]][e[1]] *= i : 4 === s && (t[e[0]][e[1]] /= i) : 3 === a ? 0 === s ? t[e[0]][e[1]][e[2]] = i : 1 === s ? t[e[0]][e[1]][e[2]] += i : 2 === s ? t[e[0]][e[1]][e[2]] -= i : 3 === s ? t[e[0]][e[1]][e[2]] *= i : 4 === s && (t[e[0]][e[1]][e[2]] /= i) : 4 === a && (0 === s ? t[e[0]][e[1]][e[2]][e[3]] = i : 1 === s ? t[e[0]][e[1]][e[2]][e[3]] += i : 2 === s ? t[e[0]][e[1]][e[2]][e[3]] -= i : 3 === s ? t[e[0]][e[1]][e[2]][e[3]] *= i : 4 === s && (t[e[0]][e[1]][e[2]][e[3]] /= i)), !0
                }, a.Group.prototype.checkProperty = function(t, e, i, s) {
                    return void 0 === s && (s = !1), !(!a.Utils.getProperty(t, e) && s) && a.Utils.getProperty(t, e) === i
                }, a.Group.prototype.set = function(t, e, i, s, n, a, o) {
                    if (void 0 === o && (o = !1), e = e.split("."), void 0 === s && (s = !1), void 0 === n && (n = !1), (!1 === s || s && t.alive) && (!1 === n || n && t.visible)) return this.setProperty(t, e, i, a, o)
                }, a.Group.prototype.setAll = function(t, e, i, s, n, a) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === a && (a = !1), t = t.split("."), n = n || 0;
                    for (var o = 0; o < this.children.length; o++)(!i || i && this.children[o].alive) && (!s || s && this.children[o].visible) && this.setProperty(this.children[o], t, e, n, a)
                }, a.Group.prototype.setAllChildren = function(t, e, i, s, n, o) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === o && (o = !1), n = n || 0;
                    for (var r = 0; r < this.children.length; r++)(!i || i && this.children[r].alive) && (!s || s && this.children[r].visible) && (this.children[r] instanceof a.Group ? this.children[r].setAllChildren(t, e, i, s, n, o) : this.setProperty(this.children[r], t.split("."), e, n, o))
                }, a.Group.prototype.checkAll = function(t, e, i, s, n) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), void 0 === n && (n = !1);
                    for (var a = 0; a < this.children.length; a++)
                        if ((!i || i && this.children[a].alive) && (!s || s && this.children[a].visible) && !this.checkProperty(this.children[a], t, e, n)) return !1;
                    return !0
                }, a.Group.prototype.addAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 1)
                }, a.Group.prototype.subAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 2)
                }, a.Group.prototype.multiplyAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 3)
                }, a.Group.prototype.divideAll = function(t, e, i, s) {
                    this.setAll(t, e, i, s, 4)
                }, a.Group.prototype.callAllExists = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    for (var s = 0; s < this.children.length; s++) this.children[s].exists === e && this.children[s][t] && this.children[s][t].apply(this.children[s], i)
                }, a.Group.prototype.callbackFromArray = function(t, e, i) {
                    if (1 === i) {
                        if (t[e[0]]) return t[e[0]]
                    } else if (2 === i) {
                        if (t[e[0]][e[1]]) return t[e[0]][e[1]]
                    } else if (3 === i) {
                        if (t[e[0]][e[1]][e[2]]) return t[e[0]][e[1]][e[2]]
                    } else if (4 === i) {
                        if (t[e[0]][e[1]][e[2]][e[3]]) return t[e[0]][e[1]][e[2]][e[3]]
                    } else if (t[e]) return t[e];
                    return !1
                }, a.Group.prototype.callAll = function(t, e) {
                    if (void 0 !== t) {
                        t = t.split(".");
                        var i = t.length;
                        if (void 0 === e || null === e || "" === e) e = null;
                        else if ("string" == typeof e) {
                            e = e.split(".");
                            var s = e.length
                        }
                        var n;
                        if (arguments.length > 2) {
                            n = [];
                            for (var a = 2; a < arguments.length; a++) n.push(arguments[a])
                        }
                        for (var o = null, r = null, a = 0; a < this.children.length; a++) o = this.callbackFromArray(this.children[a], t, i), e && o ? (r = this.callbackFromArray(this.children[a], e, s), o && o.apply(r, n)) : o && o.apply(this.children[a], n)
                    }
                }, a.Group.prototype.preUpdate = function() {
                    if (this.pendingDestroy) return this.destroy(), !1;
                    if (!this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }, a.Group.prototype.update = function() {
                    for (var t = this.children.length; t--;) this.children[t].update()
                }, a.Group.prototype.postUpdate = function() {
                    this.fixedToCamera && (this.x = this.game.camera.view.x + this.cameraOffset.x, this.y = this.game.camera.view.y + this.cameraOffset.y);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, a.Group.prototype.filter = function(t, e) {
                    for (var i = -1, s = this.children.length, n = []; ++i < s;) {
                        var o = this.children[i];
                        (!e || e && o.exists) && t(o, i, this.children) && n.push(o)
                    }
                    return new a.ArraySet(n)
                }, a.Group.prototype.forEach = function(t, e, i) {
                    if (void 0 === i && (i = !1), arguments.length <= 3)
                        for (var s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && t.call(e, this.children[s]);
                    else {
                        for (var n = [null], s = 3; s < arguments.length; s++) n.push(arguments[s]);
                        for (var s = 0; s < this.children.length; s++)(!i || i && this.children[s].exists) && (n[0] = this.children[s], t.apply(e, n))
                    }
                }, a.Group.prototype.forEachExists = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("exists", !0, a.Group.RETURN_TOTAL, t, e, i)
                }, a.Group.prototype.forEachAlive = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !0, a.Group.RETURN_TOTAL, t, e, i)
                }, a.Group.prototype.forEachDead = function(t, e) {
                    var i;
                    if (arguments.length > 2) {
                        i = [null];
                        for (var s = 2; s < arguments.length; s++) i.push(arguments[s])
                    }
                    this.iterate("alive", !1, a.Group.RETURN_TOTAL, t, e, i)
                }, a.Group.prototype.sort = function(t, e) {
                    this.children.length < 2 || (void 0 === t && (t = "z"), void 0 === e && (e = a.Group.SORT_ASCENDING), this._sortProperty = t, e === a.Group.SORT_ASCENDING ? this.children.sort(this.ascendingSortHandler.bind(this)) : this.children.sort(this.descendingSortHandler.bind(this)), this.updateZ())
                }, a.Group.prototype.customSort = function(t, e) {
                    this.children.length < 2 || (this.children.sort(t.bind(e)), this.updateZ())
                }, a.Group.prototype.ascendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? -1 : t[this._sortProperty] > e[this._sortProperty] ? 1 : t.z < e.z ? -1 : 1
                }, a.Group.prototype.descendingSortHandler = function(t, e) {
                    return t[this._sortProperty] < e[this._sortProperty] ? 1 : t[this._sortProperty] > e[this._sortProperty] ? -1 : 0
                }, a.Group.prototype.iterate = function(t, e, i, s, n, o) {
                    if (0 === this.children.length) {
                        if (i === a.Group.RETURN_TOTAL) return 0;
                        if (i === a.Group.RETURN_ALL) return []
                    }
                    var r = 0;
                    if (i === a.Group.RETURN_ALL) var h = [];
                    for (var l = 0; l < this.children.length; l++)
                        if (this.children[l][t] === e) {
                            if (r++, s && (o ? (o[0] = this.children[l], s.apply(n, o)) : s.call(n, this.children[l])), i === a.Group.RETURN_CHILD) return this.children[l];
                            i === a.Group.RETURN_ALL && h.push(this.children[l])
                        } return i === a.Group.RETURN_TOTAL ? r : i === a.Group.RETURN_ALL ? h : null
                }, a.Group.prototype.getFirstExists = function(t, e, i, s, n, o) {
                    void 0 === e && (e = !1), "boolean" != typeof t && (t = !0);
                    var r = this.iterate("exists", t, a.Group.RETURN_CHILD);
                    return null === r && e ? this.create(i, s, n, o) : this.resetChild(r, i, s, n, o)
                }, a.Group.prototype.getFirstAlive = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var o = this.iterate("alive", !0, a.Group.RETURN_CHILD);
                    return null === o && t ? this.create(e, i, s, n) : this.resetChild(o, e, i, s, n)
                }, a.Group.prototype.getFirstDead = function(t, e, i, s, n) {
                    void 0 === t && (t = !1);
                    var o = this.iterate("alive", !1, a.Group.RETURN_CHILD);
                    return null === o && t ? this.create(e, i, s, n) : this.resetChild(o, e, i, s, n)
                }, a.Group.prototype.resetChild = function(t, e, i, s, n) {
                    return null === t ? null : (void 0 === e && (e = null), void 0 === i && (i = null), null !== e && null !== i && t.reset(e, i), void 0 !== s && t.loadTexture(s, n), t)
                }, a.Group.prototype.getTop = function() {
                    if (this.children.length > 0) return this.children[this.children.length - 1]
                }, a.Group.prototype.getBottom = function() {
                    if (this.children.length > 0) return this.children[0]
                }, a.Group.prototype.getClosestTo = function(t, e, i) {
                    for (var s = Number.MAX_VALUE, n = 0, o = null, r = 0; r < this.children.length; r++) {
                        var h = this.children[r];
                        h.exists && (n = Math.abs(a.Point.distance(t, h))) < s && (!e || e.call(i, h, n)) && (s = n, o = h)
                    }
                    return o
                }, a.Group.prototype.getFurthestFrom = function(t, e, i) {
                    for (var s = 0, n = 0, o = null, r = 0; r < this.children.length; r++) {
                        var h = this.children[r];
                        h.exists && (n = Math.abs(a.Point.distance(t, h))) > s && (!e || e.call(i, h, n)) && (s = n, o = h)
                    }
                    return o
                }, a.Group.prototype.countLiving = function() {
                    return this.iterate("alive", !0, a.Group.RETURN_TOTAL)
                }, a.Group.prototype.countDead = function() {
                    return this.iterate("alive", !1, a.Group.RETURN_TOTAL)
                }, a.Group.prototype.getRandom = function(t, e) {
                    return void 0 === t && (t = 0), void 0 === e && (e = this.children.length), 0 === e ? null : a.ArrayUtils.getRandomItem(this.children, t, e)
                }, a.Group.prototype.getRandomExists = function(t, e) {
                    var i = this.getAll("exists", !0, t, e);
                    return this.game.rnd.pick(i)
                }, a.Group.prototype.getAll = function(t, e, i, s) {
                    void 0 === i && (i = 0), void 0 === s && (s = this.children.length);
                    for (var n = [], a = i; a < s; a++) {
                        var o = this.children[a];
                        t && o[t] === e && n.push(o)
                    }
                    return n
                }, a.Group.prototype.remove = function(t, e, i) {
                    if (void 0 === e && (e = !1), void 0 === i && (i = !1), 0 === this.children.length || -1 === this.children.indexOf(t)) return !1;
                    i || !t.events || t.destroyPhase || t.events.onRemovedFromGroup$dispatch(t, this);
                    var s = this.removeChild(t);
                    return this.removeFromHash(t), this.updateZ(), this.cursor === t && this.next(), e && s && s.destroy(!0), !0
                }, a.Group.prototype.moveAll = function(t, e) {
                    if (void 0 === e && (e = !1), this.children.length > 0 && t instanceof a.Group) {
                        do {
                            t.add(this.children[0], e)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                    return t
                }, a.Group.prototype.removeAll = function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), 0 !== this.children.length) {
                        do {
                            !e && this.children[0].events && this.children[0].events.onRemovedFromGroup$dispatch(this.children[0], this);
                            var s = this.removeChild(this.children[0]);
                            this.removeFromHash(s), t && s && s.destroy(!0, i)
                        } while (this.children.length > 0);
                        this.hash = [], this.cursor = null
                    }
                }, a.Group.prototype.removeBetween = function(t, e, i, s) {
                    if (void 0 === e && (e = this.children.length - 1), void 0 === i && (i = !1), void 0 === s && (s = !1), 0 !== this.children.length) {
                        if (t > e || t < 0 || e > this.children.length) return !1;
                        for (var n = e; n >= t;) {
                            !s && this.children[n].events && this.children[n].events.onRemovedFromGroup$dispatch(this.children[n], this);
                            var a = this.removeChild(this.children[n]);
                            this.removeFromHash(a), i && a && a.destroy(!0), this.cursor === this.children[n] && (this.cursor = null), n--
                        }
                        this.updateZ()
                    }
                }, a.Group.prototype.destroy = function(t, e) {
                    null === this.game || this.ignoreDestroy || (void 0 === t && (t = !0), void 0 === e && (e = !1), this.onDestroy.dispatch(this, t, e), this.removeAll(t), this.cursor = null, this.filters = null, this.pendingDestroy = !1, e || (this.parent && this.parent.removeChild(this), this.game = null, this.exists = !1))
                }, Object.defineProperty(a.Group.prototype, "total", {
                    get: function() {
                        return this.iterate("exists", !0, a.Group.RETURN_TOTAL)
                    }
                }), Object.defineProperty(a.Group.prototype, "length", {
                    get: function() {
                        return this.children.length
                    }
                }), Object.defineProperty(a.Group.prototype, "angle", {
                    get: function() {
                        return a.Math.radToDeg(this.rotation)
                    },
                    set: function(t) {
                        this.rotation = a.Math.degToRad(t)
                    }
                }), Object.defineProperty(a.Group.prototype, "centerX", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .centerX
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.halfWidth
                    }
                }), Object.defineProperty(a.Group.prototype, "centerY", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .centerY
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.halfHeight
                    }
                }), Object.defineProperty(a.Group.prototype, "left", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .left
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i
                    }
                }), Object.defineProperty(a.Group.prototype, "right", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .right
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.x - e.x;
                        this.x = t + i - e.width
                    }
                }), Object.defineProperty(a.Group.prototype, "top", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .top
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i
                    }
                }), Object.defineProperty(a.Group.prototype, "bottom", {
                    get: function() {
                        return this.getBounds(this.parent)
                            .bottom
                    },
                    set: function(t) {
                        var e = this.getBounds(this.parent),
                            i = this.y - e.y;
                        this.y = t + i - e.height
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.World = function(t) {
                    a.Group.call(this, t, null, "__world", !1), this.bounds = new a.Rectangle(0, 0, t.width, t.height), this.camera = null, this._definedSize = !1, this._width = t.width, this._height = t.height, this.game.state.onStateChange.add(this.stateChange, this)
                }, a.World.prototype = Object.create(a.Group.prototype), a.World.prototype.constructor = a.World, a.World.prototype.boot = function() {
                    this.camera = new a.Camera(this.game, 0, 0, 0, this.game.width, this.game.height), this.game.stage.addChild(this), this.camera.boot()
                }, a.World.prototype.stateChange = function() {
                    this.x = 0, this.y = 0, this.camera.reset()
                }, a.World.prototype.setBounds = function(t, e, i, s) {
                    this._definedSize = !0, this._width = i, this._height = s, this.bounds.setTo(t, e, i, s), this.x = t, this.y = e, this.camera.bounds && this.camera.bounds.setTo(t, e, Math.max(i, this.game.width), Math.max(s, this.game.height)), this.game.physics.setBoundsToWorld()
                }, a.World.prototype.resize = function(t, e) {
                    this._definedSize && (t < this._width && (t = this._width), e < this._height && (e = this._height)), this.bounds.width = t, this.bounds.height = e, this.game.camera.setBoundsToWorld(), this.game.physics.setBoundsToWorld()
                }, a.World.prototype.shutdown = function() {
                    this.destroy(!0, !0)
                }, a.World.prototype.wrap = function(t, e, i, s, n) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), void 0 === s && (s = !0), void 0 === n && (n = !0), i ? (t.getBounds(), s && (t.x + t._currentBounds.width < this.bounds.x ? t.x = this.bounds.right : t.x > this.bounds.right && (t.x = this.bounds.left)), n && (t.y + t._currentBounds.height < this.bounds.top ? t.y = this.bounds.bottom : t.y > this.bounds.bottom && (t.y = this.bounds.top))) : (s && t.x + e < this.bounds.x ? t.x = this.bounds.right + e : s && t.x - e > this.bounds.right && (t.x = this.bounds.left - e), n && t.y + e < this.bounds.top ? t.y = this.bounds.bottom + e : n && t.y - e > this.bounds.bottom && (t.y = this.bounds.top - e))
                }, Object.defineProperty(a.World.prototype, "width", {
                    get: function() {
                        return this.bounds.width
                    },
                    set: function(t) {
                        t < this.game.width && (t = this.game.width), this.bounds.width = t, this._width = t, this._definedSize = !0
                    }
                }), Object.defineProperty(a.World.prototype, "height", {
                    get: function() {
                        return this.bounds.height
                    },
                    set: function(t) {
                        t < this.game.height && (t = this.game.height), this.bounds.height = t, this._height = t, this._definedSize = !0
                    }
                }), Object.defineProperty(a.World.prototype, "centerX", {
                    get: function() {
                        return this.bounds.halfWidth + this.bounds.x
                    }
                }), Object.defineProperty(a.World.prototype, "centerY", {
                    get: function() {
                        return this.bounds.halfHeight + this.bounds.y
                    }
                }), Object.defineProperty(a.World.prototype, "randomX", {
                    get: function() {
                        return this.bounds.x < 0 ? this.game.rnd.between(this.bounds.x, this.bounds.width - Math.abs(this.bounds.x)) : this.game.rnd.between(this.bounds.x, this.bounds.width)
                    }
                }), Object.defineProperty(a.World.prototype, "randomY", {
                    get: function() {
                        return this.bounds.y < 0 ? this.game.rnd.between(this.bounds.y, this.bounds.height - Math.abs(this.bounds.y)) : this.game.rnd.between(this.bounds.y, this.bounds.height)
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Game = function(t, e, i, s, n, o, r, h) {
                    return this.id = a.GAMES.push(this) - 1, this.config = null, this.physicsConfig = h, this.parent = "", this.width = 800, this.height = 600, this.resolution = 1, this._width = 800, this._height = 600, this.transparent = !1, this.antialias = !0, this.preserveDrawingBuffer = !1, this.clearBeforeRender = !0, this.renderer = null, this.renderType = a.AUTO, this.state = null, this.isBooted = !1, this.isRunning = !1, this.raf = null, this.add = null, this.make = null, this.cache = null, this.input = null, this.load = null, this.math = null, this.net = null, this.scale = null, this.sound = null, this.stage = null, this.time = null, this.tweens = null, this.world = null, this.physics = null, this.plugins = null, this.rnd = null, this.device = a.Device, this.camera = null, this.canvas = null, this.context = null, this.debug = null, this.particles = null, this.create = null, this.lockRender = !1, this.stepping = !1, this.pendingStep = !1, this.stepCount = 0, this.onPause = null, this.onResume = null, this.onBlur = null, this.onFocus = null, this._paused = !1, this._codePaused = !1, this.currentUpdateID = 0, this.updatesThisFrame = 1, this._deltaTime = 0, this._lastCount = 0, this._spiraling = 0, this._kickstart = !0, this.fpsProblemNotifier = new a.Signal, this.forceSingleUpdate = !0, this._nextFpsNotification = 0, 1 === arguments.length && "object" == typeof arguments[0] ? this.parseConfig(arguments[0]) : (this.config = {
                        enableDebug: !0
                    }, void 0 !== t && (this._width = t), void 0 !== e && (this._height = e), void 0 !== i && (this.renderType = i), void 0 !== s && (this.parent = s), void 0 !== o && (this.transparent = o), void 0 !== r && (this.antialias = r), this.rnd = new a.RandomDataGenerator([(Date.now() * Math.random())
                        .toString()]), this.state = new a.StateManager(this, n)), this.device.whenReady(this.boot, this), this
                }, a.Game.prototype = {
                    parseConfig: function(t) {
                        this.config = t, void 0 === t.enableDebug && (this.config.enableDebug = !0), t.width && (this._width = t.width), t.height && (this._height = t.height), t.renderer && (this.renderType = t.renderer), t.parent && (this.parent = t.parent), void 0 !== t.transparent && (this.transparent = t.transparent), void 0 !== t.antialias && (this.antialias = t.antialias), t.resolution && (this.resolution = t.resolution), void 0 !== t.preserveDrawingBuffer && (this.preserveDrawingBuffer = t.preserveDrawingBuffer), t.physicsConfig && (this.physicsConfig = t.physicsConfig);
                        var e = [(Date.now() * Math.random())
                            .toString()];
                        t.seed && (e = t.seed), this.rnd = new a.RandomDataGenerator(e);
                        var i = null;
                        t.state && (i = t.state), this.state = new a.StateManager(this, i)
                    },
                    boot: function() {
                        this.isBooted || (this.onPause = new a.Signal, this.onResume = new a.Signal, this.onBlur = new a.Signal, this.onFocus = new a.Signal, this.isBooted = !0, PIXI.game = this, this.math = a.Math, this.scale = new a.ScaleManager(this, this._width, this._height), this.stage = new a.Stage(this), this.setUpRenderer(), this.world = new a.World(this), this.add = new a.GameObjectFactory(this), this.make = new a.GameObjectCreator(this), this.cache = new a.Cache(this), this.load = new a.Loader(this), this.time = new a.Time(this), this.tweens = new a.TweenManager(this), this.input = new a.Input(this), this.sound = new a.SoundManager(this), this.physics = new a.Physics(this, this.physicsConfig), this.particles = new a.Particles(this), this.create = new a.Create(this), this.plugins = new a.PluginManager(this), this.net = new a.Net(this), this.time.boot(), this.stage.boot(), this.world.boot(), this.scale.boot(), this.input.boot(), this.sound.boot(), this.state.boot(), this.config.enableDebug ? (this.debug = new a.Utils.Debug(this), this.debug.boot()) : this.debug = {
                            preUpdate: function() {},
                            update: function() {},
                            reset: function() {}
                        }, this.showDebugHeader(), this.isRunning = !0, this.config && this.config.forceSetTimeOut ? this.raf = new a.RequestAnimationFrame(this, this.config.forceSetTimeOut) : this.raf = new a.RequestAnimationFrame(this, !1), this._kickstart = !0, window.focus && (!window.PhaserGlobal || window.PhaserGlobal && !window.PhaserGlobal.stopFocus) && window.focus(), this.raf.start())
                    },
                    showDebugHeader: function() {
                        if (!window.PhaserGlobal || !window.PhaserGlobal.hideBanner) {
                            var t = a.VERSION,
                                e = "Canvas",
                                i = "HTML Audio",
                                s = 1;
                            if (this.renderType === a.WEBGL ? (e = "WebGL", s++) : this.renderType === a.HEADLESS && (e = "Headless"), this.device.webAudio && (i = "WebAudio", s++), this.device.chrome)
                                for (var n = ["%c %c %c @orange-games/phaser v" + t + " | Pixi.js | " + e + " | " + i + "  %c %c %c http://phaser.io %c♥%c♥%c♥", "background: #F47820", "background: #ED873F", "color: #ffffff; background: #DD6612;", "background: #ED873F", "background: #F47820", "background: #ffffff"], o = 0; o < 3; o++) o < s ? n.push("color: #ff2424; background: #fff") : n.push("color: #959595; background: #fff");
                            else window.console
                        }
                    },
                    setUpRenderer: function() {
                        if (this.config.canvas ? this.canvas = this.config.canvas : this.canvas = a.Canvas.create(this, this.width, this.height, this.config.canvasID, !0), this.config.canvasStyle ? this.canvas.style = this.config.canvasStyle : this.canvas.style["-webkit-full-screen"] = "width: 100%; height: 100%", this.renderType === a.HEADLESS || this.renderType === a.CANVAS || this.renderType === a.AUTO && !this.device.webGL) {
                            if (!this.device.canvas) throw new Error("Phaser.Game - Cannot create Canvas or WebGL context, aborting.");
                            this.renderType = a.CANVAS, this.renderer = new PIXI.CanvasRenderer(this), this.context = this.renderer.context
                        } else this.renderType = a.WEBGL, this.renderer = new PIXI.WebGLRenderer(this), this.context = null, this.canvas.addEventListener("webglcontextlost", this.contextLost.bind(this), !1), this.canvas.addEventListener("webglcontextrestored", this.contextRestored.bind(this), !1);
                        this.device.cocoonJS && (this.canvas.screencanvas = this.renderType === a.CANVAS), this.renderType !== a.HEADLESS && (this.stage.smoothed = this.antialias, a.Canvas.addToDOM(this.canvas, this.parent, !1), a.Canvas.setTouchAction(this.canvas))
                    },
                    contextLost: function(t) {
                        t.preventDefault(), this.renderer.contextLost = !0
                    },
                    contextRestored: function() {
                        this.renderer.initContext(), this.cache.clearGLTextures(), this.renderer.contextLost = !1
                    },
                    update: function(t) {
                        if (this.time.update(t), this._kickstart) return this.updateLogic(this.time.desiredFpsMult), this.updateRender(this.time.slowMotion * this.time.desiredFps), void(this._kickstart = !1);
                        if (this._spiraling > 1 && !this.forceSingleUpdate) this.time.time > this._nextFpsNotification && (this._nextFpsNotification = this.time.time + 1e4, this.fpsProblemNotifier.dispatch()), this._deltaTime = 0, this._spiraling = 0, this.updateRender(this.time.slowMotion * this.time.desiredFps);
                        else {
                            var e = 1e3 * this.time.slowMotion / this.time.desiredFps;
                            this._deltaTime += Math.max(Math.min(3 * e, this.time.elapsed), 0);
                            var i = 0;
                            for (this.updatesThisFrame = Math.floor(this._deltaTime / e), this.forceSingleUpdate && (this.updatesThisFrame = Math.min(1, this.updatesThisFrame)); this._deltaTime >= e && (this._deltaTime -= e, this.currentUpdateID = i, this.updateLogic(this.time.desiredFpsMult), i++, !this.forceSingleUpdate || 1 !== i);) this.time.refresh();
                            i > this._lastCount ? this._spiraling++ : i < this._lastCount && (this._spiraling = 0), this._lastCount = i, this.updateRender(this._deltaTime / e)
                        }
                    },
                    updateLogic: function(t) {
                        this._paused || this.pendingStep ? (this.scale.pauseUpdate(), this.state.pauseUpdate(), this.debug.preUpdate()) : (this.stepping && (this.pendingStep = !0), this.scale.preUpdate(), this.debug.preUpdate(), this.camera.preUpdate(), this.physics.preUpdate(), this.state.preUpdate(t), this.plugins.preUpdate(t), this.stage.preUpdate(), this.state.update(), this.stage.update(), this.tweens.update(), this.sound.update(), this.input.update(), this.physics.update(), this.particles.update(), this.plugins.update(), this.stage.postUpdate(), this.plugins.postUpdate()), this.stage.updateTransform()
                    },
                    updateRender: function(t) {
                        this.lockRender || (this.state.preRender(t), this.renderType !== a.HEADLESS && (this.renderer.render(this.stage), this.plugins.render(t), this.state.render(t)), this.plugins.postRender(t))
                    },
                    enableStep: function() {
                        this.stepping = !0, this.pendingStep = !1, this.stepCount = 0
                    },
                    disableStep: function() {
                        this.stepping = !1, this.pendingStep = !1
                    },
                    step: function() {
                        this.pendingStep = !1, this.stepCount++
                    },
                    destroy: function() {
                        this.raf.stop(), this.state.destroy(), this.sound.destroy(), this.scale.destroy(), this.stage.destroy(), this.input.destroy(), this.physics.destroy(), this.plugins.destroy(), this.state = null, this.sound = null, this.scale = null, this.stage = null, this.input = null, this.physics = null, this.plugins = null, this.cache = null, this.load = null, this.time = null, this.world = null, this.isBooted = !1, this.renderer.destroy(!1), a.Canvas.removeFromDOM(this.canvas), PIXI.defaultRenderer = null, a.GAMES[this.id] = null
                    },
                    gamePaused: function(t) {
                        this._paused || (this._paused = !0, this.time.gamePaused(), this.sound.muteOnPause && this.sound.setMute(), this.onPause.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !0))
                    },
                    gameResumed: function(t) {
                        this._paused && !this._codePaused && (this._paused = !1, this.time.gameResumed(), this.input.reset(), this.sound.muteOnPause && this.sound.unsetMute(), this.onResume.dispatch(t), this.device.cordova && this.device.iOS && (this.lockRender = !1))
                    },
                    focusLoss: function(t) {
                        this.onBlur.dispatch(t), this.stage.disableVisibilityChange || this.gamePaused(t)
                    },
                    focusGain: function(t) {
                        this.onFocus.dispatch(t), this.stage.disableVisibilityChange || this.gameResumed(t)
                    }
                }, a.Game.prototype.constructor = a.Game, Object.defineProperty(a.Game.prototype, "paused", {
                    get: function() {
                        return this._paused
                    },
                    set: function(t) {
                        !0 === t ? (!1 === this._paused && (this._paused = !0, this.sound.setMute(), this.time.gamePaused(), this.onPause.dispatch(this)), this._codePaused = !0) : (this._paused && (this._paused = !1, this.input.reset(), this.sound.unsetMute(), this.time.gameResumed(), this.onResume.dispatch(this)), this._codePaused = !1)
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Input = function(t) {
                    this.game = t, this.hitCanvas = null, this.hitContext = null, this.moveCallbacks = [], this.customCandidateHandler = null, this.customCandidateHandlerContext = null, this.pollRate = 0, this.enabled = !0, this.multiInputOverride = a.Input.MOUSE_TOUCH_COMBINE, this.position = null, this.speed = null, this.circle = null, this.scale = null, this.maxPointers = -1, this.tapRate = 200, this.doubleTapRate = 300, this.holdRate = 2e3, this.justPressedRate = 200, this.justReleasedRate = 200, this.recordPointerHistory = !1, this.recordRate = 100, this.recordLimit = 100, this.pointer1 = null, this.pointer2 = null, this.pointer3 = null, this.pointer4 = null, this.pointer5 = null, this.pointer6 = null, this.pointer7 = null, this.pointer8 = null, this.pointer9 = null, this.pointer10 = null, this.pointers = [], this.activePointer = null, this.mousePointer = null, this.mouse = null, this.keyboard = null, this.touch = null, this.mspointer = null, this.gamepad = null, this.resetLocked = !1, this.onDown = null, this.onUp = null, this.onTap = null, this.onHold = null, this.minPriorityID = 0, this.interactiveItems = new a.ArraySet, this._localPoint = new a.Point, this._pollCounter = 0, this._oldPosition = null, this._x = 0, this._y = 0
                }, a.Input.MOUSE_OVERRIDES_TOUCH = 0, a.Input.TOUCH_OVERRIDES_MOUSE = 1, a.Input.MOUSE_TOUCH_COMBINE = 2, a.Input.MAX_POINTERS = 10, a.Input.prototype = {
                    boot: function() {
                        this.mousePointer = new a.Pointer(this.game, 0, a.PointerMode.CURSOR), this.addPointer(), this.addPointer(), this.mouse = new a.Mouse(this.game), this.touch = new a.Touch(this.game), this.mspointer = new a.MSPointer(this.game), a.Keyboard && (this.keyboard = new a.Keyboard(this.game)), a.Gamepad && (this.gamepad = new a.Gamepad(this.game)), this.onDown = new a.Signal, this.onUp = new a.Signal, this.onTap = new a.Signal, this.onHold = new a.Signal, this.scale = new a.Point(1, 1), this.speed = new a.Point, this.position = new a.Point, this._oldPosition = new a.Point, this.circle = new a.Circle(0, 0, 44), this.activePointer = this.mousePointer, this.hitCanvas = PIXI.CanvasPool.create(this, 1, 1), this.hitContext = this.hitCanvas.getContext("2d"), this.mouse.start(), this.touch.start(), this.mspointer.start(), this.mousePointer.active = !0, this.keyboard && this.keyboard.start();
                        var t = this;
                        this._onClickTrampoline = function(e) {
                            t.onClickTrampoline(e)
                        }, this.game.canvas.addEventListener("click", this._onClickTrampoline, !1)
                    },
                    destroy: function() {
                        this.mouse.stop(), this.touch.stop(), this.mspointer.stop(), this.keyboard && this.keyboard.stop(), this.gamepad && this.gamepad.stop(), this.moveCallbacks = [], PIXI.CanvasPool.remove(this), this.game.canvas.removeEventListener("click", this._onClickTrampoline)
                    },
                    setInteractiveCandidateHandler: function(t, e) {
                        this.customCandidateHandler = t, this.customCandidateHandlerContext = e
                    },
                    addMoveCallback: function(t, e) {
                        this.moveCallbacks.push({
                            callback: t,
                            context: e
                        })
                    },
                    deleteMoveCallback: function(t, e) {
                        for (var i = this.moveCallbacks.length; i--;)
                            if (this.moveCallbacks[i].callback === t && this.moveCallbacks[i].context === e) return void this.moveCallbacks.splice(i, 1)
                    },
                    addPointer: function() {
                        if (this.pointers.length >= a.Input.MAX_POINTERS) return null;
                        var t = this.pointers.length + 1,
                            e = new a.Pointer(this.game, t, a.PointerMode.TOUCH);
                        return this.pointers.push(e), this["pointer" + t] = e, e
                    },
                    update: function() {
                        if (this.keyboard && this.keyboard.update(), this.pollRate > 0 && this._pollCounter < this.pollRate) return void this._pollCounter++;
                        this.speed.x = this.position.x - this._oldPosition.x, this.speed.y = this.position.y - this._oldPosition.y, this._oldPosition.copyFrom(this.position), this.mousePointer.update(), this.gamepad && this.gamepad.active && this.gamepad.update();
                        for (var t = 0; t < this.pointers.length; t++) this.pointers[t].update();
                        this._pollCounter = 0
                    },
                    reset: function(t) {
                        if (this.game.isBooted && !this.resetLocked) {
                            void 0 === t && (t = !1), this.mousePointer.reset(), this.keyboard && this.keyboard.reset(t), this.gamepad && this.gamepad.reset();
                            for (var e = 0; e < this.pointers.length; e++) this.pointers[e].reset();
                            "none" !== this.game.canvas.style.cursor && (this.game.canvas.style.cursor = "inherit"), t && (this.onDown.dispose(), this.onUp.dispose(), this.onTap.dispose(), this.onHold.dispose(), this.onDown = new a.Signal, this.onUp = new a.Signal, this.onTap = new a.Signal, this.onHold = new a.Signal, this.moveCallbacks = []), this._pollCounter = 0
                        }
                    },
                    resetSpeed: function(t, e) {
                        this._oldPosition.setTo(t, e), this.speed.setTo(0, 0)
                    },
                    startPointer: function(t) {
                        if (this.maxPointers >= 0 && this.countActivePointers(this.maxPointers) >= this.maxPointers) return null;
                        if (!this.pointer1.active) return this.pointer1.start(t);
                        if (!this.pointer2.active) return this.pointer2.start(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (!i.active) return i.start(t)
                        }
                        return null
                    },
                    updatePointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.move(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.move(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.move(t)
                        }
                        return null
                    },
                    stopPointer: function(t) {
                        if (this.pointer1.active && this.pointer1.identifier === t.identifier) return this.pointer1.stop(t);
                        if (this.pointer2.active && this.pointer2.identifier === t.identifier) return this.pointer2.stop(t);
                        for (var e = 2; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active && i.identifier === t.identifier) return i.stop(t)
                        }
                        return null
                    },
                    countActivePointers: function(t) {
                        void 0 === t && (t = this.pointers.length);
                        for (var e = t, i = 0; i < this.pointers.length && e > 0; i++) {
                            this.pointers[i].active && e--
                        }
                        return t - e
                    },
                    getPointer: function(t) {
                        void 0 === t && (t = !1);
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.active === t) return i
                        }
                        return null
                    },
                    getPointerFromIdentifier: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.identifier === t) return i
                        }
                        return null
                    },
                    getPointerFromId: function(t) {
                        for (var e = 0; e < this.pointers.length; e++) {
                            var i = this.pointers[e];
                            if (i.pointerId === t) return i
                        }
                        return null
                    },
                    getLocalPosition: function(t, e, i) {
                        void 0 === i && (i = new a.Point);
                        var s = t.worldTransform,
                            n = 1 / (s.a * s.d + s.c * -s.b);
                        return i.setTo(s.d * n * e.x + -s.c * n * e.y + (s.ty * s.c - s.tx * s.d) * n, s.a * n * e.y + -s.b * n * e.x + (-s.ty * s.a + s.tx * s.b) * n)
                    },
                    hitTest: function(t, e, i) {
                        if (!t.worldVisible) return !1;
                        if (this.getLocalPosition(t, e, this._localPoint), i.copyFrom(this._localPoint), t.hitArea && t.hitArea.contains) return t.hitArea.contains(this._localPoint.x, this._localPoint.y);
                        if (t instanceof a.TileSprite) {
                            var s = t.width,
                                n = t.height,
                                o = -s * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                                var r = -n * t.anchor.y;
                                if (this._localPoint.y >= r && this._localPoint.y < r + n) return !0
                            }
                        } else if (t instanceof PIXI.Sprite) {
                            var s = t.texture.frame.width,
                                n = t.texture.frame.height,
                                o = -s * t.anchor.x;
                            if (this._localPoint.x >= o && this._localPoint.x < o + s) {
                                var r = -n * t.anchor.y;
                                if (this._localPoint.y >= r && this._localPoint.y < r + n) return !0
                            }
                        } else if (t instanceof a.Graphics)
                            for (var h = 0; h < t.graphicsData.length; h++) {
                                var l = t.graphicsData[h];
                                if (l.fill && (l.shape && l.shape.contains(this._localPoint.x, this._localPoint.y))) return !0
                            }
                        for (var h = 0; h < t.children.length; h++)
                            if (this.hitTest(t.children[h], e, i)) return !0;
                        return !1
                    },
                    onClickTrampoline: function() {
                        this.activePointer.processClickTrampolines()
                    }
                }, a.Input.prototype.constructor = a.Input, Object.defineProperty(a.Input.prototype, "x", {
                    get: function() {
                        return this._x
                    },
                    set: function(t) {
                        this._x = Math.floor(t)
                    }
                }), Object.defineProperty(a.Input.prototype, "y", {
                    get: function() {
                        return this._y
                    },
                    set: function(t) {
                        this._y = Math.floor(t)
                    }
                }), Object.defineProperty(a.Input.prototype, "pollLocked", {
                    get: function() {
                        return this.pollRate > 0 && this._pollCounter < this.pollRate
                    }
                }), Object.defineProperty(a.Input.prototype, "totalInactivePointers", {
                    get: function() {
                        return this.pointers.length - this.countActivePointers()
                    }
                }), Object.defineProperty(a.Input.prototype, "totalActivePointers", {
                    get: function() {
                        return this.countActivePointers()
                    }
                }), Object.defineProperty(a.Input.prototype, "worldX", {
                    get: function() {
                        return this.game.camera.view.x + this.x
                    }
                }), Object.defineProperty(a.Input.prototype, "worldY", {
                    get: function() {
                        return this.game.camera.view.y + this.y
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Mouse = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.mouseDownCallback = null, this.mouseUpCallback = null, this.mouseOutCallback = null, this.mouseOverCallback = null, this.mouseWheelCallback = null, this.capture = !1, this.button = -1, this.wheelDelta = 0, this.enabled = !0, this.locked = !1, this.stopOnGameOut = !1, this.pointerLock = new a.Signal, this.event = null, this._onMouseDown = null, this._onMouseMove = null, this._onMouseUp = null, this._onMouseOut = null, this._onMouseOver = null, this._onMouseWheel = null, this._wheelEvent = null
                }, a.Mouse.NO_BUTTON = -1, a.Mouse.LEFT_BUTTON = 0, a.Mouse.MIDDLE_BUTTON = 1, a.Mouse.RIGHT_BUTTON = 2, a.Mouse.BACK_BUTTON = 3, a.Mouse.FORWARD_BUTTON = 4, a.Mouse.WHEEL_UP = 1, a.Mouse.WHEEL_DOWN = -1, a.Mouse.prototype = {
                    start: function() {
                        if ((!this.game.device.android || !1 !== this.game.device.chrome) && null === this._onMouseDown) {
                            var t = this;
                            this._onMouseDown = function(e) {
                                return t.onMouseDown(e)
                            }, this._onMouseMove = function(e) {
                                return t.onMouseMove(e)
                            }, this._onMouseUp = function(e) {
                                return t.onMouseUp(e)
                            }, this._onMouseUpGlobal = function(e) {
                                return t.onMouseUpGlobal(e)
                            }, this._onMouseOutGlobal = function(e) {
                                return t.onMouseOutGlobal(e)
                            }, this._onMouseOut = function(e) {
                                return t.onMouseOut(e)
                            }, this._onMouseOver = function(e) {
                                return t.onMouseOver(e)
                            }, this._onMouseWheel = function(e) {
                                return t.onMouseWheel(e)
                            };
                            var e = this.game.canvas;
                            e.addEventListener("mousedown", this._onMouseDown, !0), e.addEventListener("mousemove", this._onMouseMove, !0), e.addEventListener("mouseup", this._onMouseUp, !0), this.game.device.cocoonJS || (window.addEventListener("mouseup", this._onMouseUpGlobal, !0), window.addEventListener("mouseout", this._onMouseOutGlobal, !0), e.addEventListener("mouseover", this._onMouseOver, !0), e.addEventListener("mouseout", this._onMouseOut, !0));
                            var i = this.game.device.wheelEvent;
                            i && (e.addEventListener(i, this._onMouseWheel, !0), "mousewheel" === i ? this._wheelEvent = new s(-.025, 1) : "DOMMouseScroll" === i && (this._wheelEvent = new s(1, 1)))
                        }
                    },
                    onMouseDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseDownCallback && this.mouseDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.start(t))
                    },
                    onMouseMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseMoveCallback && this.mouseMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.move(t))
                    },
                    onMouseUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseUpGlobal: function(t) {
                        this.input.mousePointer.withinGame || (this.mouseUpCallback && this.mouseUpCallback.call(this.callbackContext, t), t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOutGlobal: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.input.enabled && this.enabled && (this.input.mousePointer.stop(t), this.input.mousePointer.leftButton.stop(t), this.input.mousePointer.rightButton.stop(t))
                    },
                    onMouseOut: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !1, this.mouseOutCallback && this.mouseOutCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && this.stopOnGameOut && (t.identifier = 0, this.input.mousePointer.stop(t))
                    },
                    onMouseOver: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.input.mousePointer.withinGame = !0, this.mouseOverCallback && this.mouseOverCallback.call(this.callbackContext, t)
                    },
                    onMouseWheel: function(t) {
                        this._wheelEvent && (t = this._wheelEvent.bindEvent(t)), this.event = t, this.capture && t.preventDefault(), this.wheelDelta = a.Math.clamp(-t.deltaY, -1, 1), this.mouseWheelCallback && this.mouseWheelCallback.call(this.callbackContext, t)
                    },
                    requestPointerLock: function() {
                        if (this.game.device.pointerLock) {
                            var t = this.game.canvas;
                            t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock();
                            var e = this;
                            this._pointerLockChange = function(t) {
                                return e.pointerLockChange(t)
                            }, document.addEventListener("pointerlockchange", this._pointerLockChange, !0), document.addEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.addEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                        }
                    },
                    pointerLockChange: function(t) {
                        var e = this.game.canvas;
                        document.pointerLockElement === e || document.mozPointerLockElement === e || document.webkitPointerLockElement === e ? (this.locked = !0, this.pointerLock.dispatch(!0, t)) : (this.locked = !1, this.pointerLock.dispatch(!1, t))
                    },
                    releasePointerLock: function() {
                        document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock(), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("mousedown", this._onMouseDown, !0), t.removeEventListener("mousemove", this._onMouseMove, !0), t.removeEventListener("mouseup", this._onMouseUp, !0), t.removeEventListener("mouseover", this._onMouseOver, !0), t.removeEventListener("mouseout", this._onMouseOut, !0);
                        var e = this.game.device.wheelEvent;
                        e && t.removeEventListener(e, this._onMouseWheel, !0), window.removeEventListener("mouseup", this._onMouseUpGlobal, !0), window.removeEventListener("mouseout", this._onMouseOutGlobal, !0), document.removeEventListener("pointerlockchange", this._pointerLockChange, !0), document.removeEventListener("mozpointerlockchange", this._pointerLockChange, !0), document.removeEventListener("webkitpointerlockchange", this._pointerLockChange, !0)
                    }
                }, a.Mouse.prototype.constructor = a.Mouse, s.prototype = {}, s.prototype.constructor = s, s.prototype.bindEvent = function(t) {
                    if (!s._stubsGenerated && t) {
                        var e = function(t) {
                            return function() {
                                var e = this.originalEvent[t];
                                return "function" != typeof e ? e : e.bind(this.originalEvent)
                            }
                        };
                        for (var i in t) i in s.prototype || Object.defineProperty(s.prototype, i, {
                            get: e(i)
                        });
                        s._stubsGenerated = !0
                    }
                    return this.originalEvent = t, this
                }, Object.defineProperties(s.prototype, {
                    type: {
                        value: "wheel"
                    },
                    deltaMode: {
                        get: function() {
                            return this._deltaMode
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this._scaleFactor * (this.originalEvent.wheelDelta || this.originalEvent.detail) || 0
                        }
                    },
                    deltaX: {
                        get: function() {
                            return this._scaleFactor * this.originalEvent.wheelDeltaX || 0
                        }
                    },
                    deltaZ: {
                        value: 0
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.MSPointer = function(t) {
                    this.game = t, this.input = t.input, this.callbackContext = this.game, this.pointerDownCallback = null, this.pointerMoveCallback = null, this.pointerUpCallback = null, this.capture = !0, this.button = -1, this.event = null, this.enabled = !0, this._onMSPointerDown = null, this._onMSPointerMove = null, this._onMSPointerUp = null, this._onMSPointerUpGlobal = null, this._onMSPointerOut = null, this._onMSPointerOver = null
                }, a.MSPointer.prototype = {
                    start: function() {
                        if (null === this._onMSPointerDown) {
                            var t = this;
                            if (this.game.device.mspointer) {
                                this._onMSPointerDown = function(e) {
                                    return t.onPointerDown(e)
                                }, this._onMSPointerMove = function(e) {
                                    return t.onPointerMove(e)
                                }, this._onMSPointerUp = function(e) {
                                    return t.onPointerUp(e)
                                }, this._onMSPointerUpGlobal = function(e) {
                                    return t.onPointerUpGlobal(e)
                                }, this._onMSPointerOut = function(e) {
                                    return t.onPointerOut(e)
                                }, this._onMSPointerOver = function(e) {
                                    return t.onPointerOver(e)
                                };
                                var e = this.game.canvas;
                                e.addEventListener("MSPointerDown", this._onMSPointerDown, !1), e.addEventListener("MSPointerMove", this._onMSPointerMove, !1), e.addEventListener("MSPointerUp", this._onMSPointerUp, !1), e.addEventListener("pointerdown", this._onMSPointerDown, !1), e.addEventListener("pointermove", this._onMSPointerMove, !1), e.addEventListener("pointerup", this._onMSPointerUp, !1), e.style["-ms-content-zooming"] = "none", e.style["-ms-touch-action"] = "none", this.game.device.cocoonJS || (window.addEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), e.addEventListener("MSPointerOver", this._onMSPointerOver, !0), e.addEventListener("MSPointerOut", this._onMSPointerOut, !0), window.addEventListener("pointerup", this._onMSPointerUpGlobal, !0), e.addEventListener("pointerover", this._onMSPointerOver, !0), e.addEventListener("pointerout", this._onMSPointerOut, !0))
                            }
                        }
                    },
                    onPointerDown: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerDownCallback && this.pointerDownCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.start(t) : this.input.startPointer(t))
                    },
                    onPointerMove: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerMoveCallback && this.pointerMoveCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.move(t) : this.input.updatePointer(t))
                    },
                    onPointerUp: function(t) {
                        this.event = t, this.capture && t.preventDefault(), this.pointerUpCallback && this.pointerUpCallback.call(this.callbackContext, t), this.input.enabled && this.enabled && (t.identifier = t.pointerId, "mouse" === t.pointerType || 4 === t.pointerType ? this.input.mousePointer.stop(t) : this.input.stopPointer(t))
                    },
                    onPointerUpGlobal: function(t) {
                        if ("mouse" !== t.pointerType && 4 !== t.pointerType || this.input.mousePointer.withinGame) {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && e.withinGame && this.onPointerUp(t)
                        } else this.onPointerUp(t)
                    },
                    onPointerOut: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !1;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !1)
                        }
                        this.input.mouse.mouseOutCallback && this.input.mouse.mouseOutCallback.call(this.input.mouse.callbackContext, t), this.input.enabled && this.enabled && this.input.mouse.stopOnGameOut && (t.identifier = 0, e ? e.stop(t) : this.input.mousePointer.stop(t))
                    },
                    onPointerOver: function(t) {
                        if (this.event = t, this.capture && t.preventDefault(), "mouse" === t.pointerType || 4 === t.pointerType) this.input.mousePointer.withinGame = !0;
                        else {
                            var e = this.input.getPointerFromIdentifier(t.identifier);
                            e && (e.withinGame = !0)
                        }
                        this.input.mouse.mouseOverCallback && this.input.mouse.mouseOverCallback.call(this.input.mouse.callbackContext, t)
                    },
                    stop: function() {
                        var t = this.game.canvas;
                        t.removeEventListener("MSPointerDown", this._onMSPointerDown, !1), t.removeEventListener("MSPointerMove", this._onMSPointerMove, !1), t.removeEventListener("MSPointerUp", this._onMSPointerUp, !1), t.removeEventListener("pointerdown", this._onMSPointerDown, !1), t.removeEventListener("pointermove", this._onMSPointerMove, !1), t.removeEventListener("pointerup", this._onMSPointerUp, !1), window.removeEventListener("MSPointerUp", this._onMSPointerUpGlobal, !0), t.removeEventListener("MSPointerOver", this._onMSPointerOver, !0), t.removeEventListener("MSPointerOut", this._onMSPointerOut, !0), window.removeEventListener("pointerup", this._onMSPointerUpGlobal, !0), t.removeEventListener("pointerover", this._onMSPointerOver, !0), t.removeEventListener("pointerout", this._onMSPointerOut, !0)
                    }
                }, a.MSPointer.prototype.constructor = a.MSPointer,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @author       @karlmacklin <tacklemcclean@gmail.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.DeviceButton = function(t, e) {
                    this.parent = t, this.game = t.game, this.event = null, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1, this.value = 0, this.buttonCode = e, this.onDown = new a.Signal, this.onUp = new a.Signal, this.onFloat = new a.Signal
                }, a.DeviceButton.prototype = {
                    start: function(t, e) {
                        this.isDown || (this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.repeats = 0, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onDown.dispatch(this, e))
                    },
                    stop: function(t, e) {
                        this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.event = t, this.value = e, t && (this.altKey = t.altKey, this.shiftKey = t.shiftKey, this.ctrlKey = t.ctrlKey), this.onUp.dispatch(this, e))
                    },
                    padFloat: function(t) {
                        this.value = t, this.onFloat.dispatch(this, t)
                    },
                    justPressed: function(t) {
                        return t = t || 250, this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || 250, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    reset: function() {
                        this.isDown = !1, this.isUp = !0, this.timeDown = this.game.time.time, this.repeats = 0, this.altKey = !1, this.shiftKey = !1, this.ctrlKey = !1
                    },
                    destroy: function() {
                        this.onDown.dispose(), this.onUp.dispose(), this.onFloat.dispose(), this.parent = null, this.game = null
                    }
                }, a.DeviceButton.prototype.constructor = a.DeviceButton, Object.defineProperty(a.DeviceButton.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Pointer = function(t, e, i) {
                    this.game = t, this.id = e, this.type = a.POINTER, this.exists = !0, this.identifier = 0, this.pointerId = null, this.pointerMode = i || a.PointerMode.CURSOR | a.PointerMode.CONTACT, this.target = null, this.button = null, this.leftButton = new a.DeviceButton(this, a.Pointer.LEFT_BUTTON), this.middleButton = new a.DeviceButton(this, a.Pointer.MIDDLE_BUTTON), this.rightButton = new a.DeviceButton(this, a.Pointer.RIGHT_BUTTON), this.backButton = new a.DeviceButton(this, a.Pointer.BACK_BUTTON), this.forwardButton = new a.DeviceButton(this, a.Pointer.FORWARD_BUTTON), this.eraserButton = new a.DeviceButton(this, a.Pointer.ERASER_BUTTON), this._holdSent = !1, this._history = [], this._nextDrop = 0, this._stateReset = !1, this.withinGame = !1, this.clientX = -1, this.clientY = -1, this.pageX = -1, this.pageY = -1, this.screenX = -1, this.screenY = -1, this.rawMovementX = 0, this.rawMovementY = 0, this.movementX = 0, this.movementY = 0, this.x = -1, this.y = -1, this.isMouse = 0 === e, this.isDown = !1, this.isUp = !0, this.timeDown = 0, this.timeUp = 0, this.previousTapTime = 0, this.totalTouches = 0, this.msSinceLastClick = Number.MAX_VALUE, this.targetObject = null, this.interactiveCandidates = [], this.active = !1, this.dirty = !1, this.position = new a.Point, this.positionDown = new a.Point, this.positionUp = new a.Point, this.circle = new a.Circle(0, 0, 44), this._clickTrampolines = null, this._trampolineTargetObject = null
                }, a.Pointer.NO_BUTTON = 0, a.Pointer.LEFT_BUTTON = 1, a.Pointer.RIGHT_BUTTON = 2, a.Pointer.MIDDLE_BUTTON = 4, a.Pointer.BACK_BUTTON = 8, a.Pointer.FORWARD_BUTTON = 16, a.Pointer.ERASER_BUTTON = 32, a.Pointer.prototype = {
                    resetButtons: function() {
                        this.isDown = !1, this.isUp = !0, this.isMouse && (this.leftButton.reset(), this.middleButton.reset(), this.rightButton.reset(), this.backButton.reset(), this.forwardButton.reset(), this.eraserButton.reset())
                    },
                    processButtonsDown: function(t, e) {
                        a.Pointer.LEFT_BUTTON & t && this.leftButton.start(e), a.Pointer.RIGHT_BUTTON & t && this.rightButton.start(e), a.Pointer.MIDDLE_BUTTON & t && this.middleButton.start(e), a.Pointer.BACK_BUTTON & t && this.backButton.start(e), a.Pointer.FORWARD_BUTTON & t && this.forwardButton.start(e), a.Pointer.ERASER_BUTTON & t && this.eraserButton.start(e)
                    },
                    processButtonsUp: function(t, e) {
                        t === a.Mouse.LEFT_BUTTON && this.leftButton.stop(e), t === a.Mouse.RIGHT_BUTTON && this.rightButton.stop(e), t === a.Mouse.MIDDLE_BUTTON && this.middleButton.stop(e), t === a.Mouse.BACK_BUTTON && this.backButton.stop(e), t === a.Mouse.FORWARD_BUTTON && this.forwardButton.stop(e), 5 === t && this.eraserButton.stop(e)
                    },
                    updateButtons: function(t) {
                        this.button = t.button;
                        var e = "down" === t.type.toLowerCase()
                            .substr(-4);
                        void 0 !== t.buttons ? e ? this.processButtonsDown(t.buttons, t) : this.processButtonsUp(t.button, t) : e ? this.leftButton.start(t) : (this.leftButton.stop(t), this.rightButton.stop(t)), 1 === t.buttons && t.ctrlKey && this.leftButton.isDown && (this.leftButton.stop(t), this.rightButton.start(t)), this.isUp = !0, this.isDown = !1, (this.leftButton.isDown || this.rightButton.isDown || this.middleButton.isDown || this.backButton.isDown || this.forwardButton.isDown || this.eraserButton.isDown) && (this.isUp = !1, this.isDown = !0)
                    },
                    start: function(t) {
                        var e = this.game.input;
                        return t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.isMouse ? this.updateButtons(t) : (this.isDown = !0, this.isUp = !1), this.active = !0, this.withinGame = !0, this.dirty = !1, this._history = [], this._clickTrampolines = null, this._trampolineTargetObject = null, this.msSinceLastClick = this.game.time.time - this.timeDown, this.timeDown = this.game.time.time, this._holdSent = !1, this.move(t, !0), this.positionDown.setTo(this.x, this.y), (e.multiInputOverride === a.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === a.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === a.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.x = this.x, e.y = this.y, e.position.setTo(this.x, this.y), e.onDown.dispatch(this, t), e.resetSpeed(this.x, this.y)), this._stateReset = !1, this.totalTouches++, null !== this.targetObject && this.targetObject._touchedHandler(this), this
                    },
                    update: function() {
                        var t = this.game.input;
                        this.active && (this.dirty && (t.interactiveItems.total > 0 && this.processInteractiveObjects(!1), this.dirty = !1), !1 === this._holdSent && this.duration >= t.holdRate && ((t.multiInputOverride === a.Input.MOUSE_OVERRIDES_TOUCH || t.multiInputOverride === a.Input.MOUSE_TOUCH_COMBINE || t.multiInputOverride === a.Input.TOUCH_OVERRIDES_MOUSE && 0 === t.totalActivePointers) && t.onHold.dispatch(this), this._holdSent = !0), t.recordPointerHistory && this.game.time.time >= this._nextDrop && (this._nextDrop = this.game.time.time + t.recordRate, this._history.push({
                            x: this.position.x,
                            y: this.position.y
                        }), this._history.length > t.recordLimit && this._history.shift()))
                    },
                    move: function(t, e) {
                        var i = this.game.input;
                        if (!i.pollLocked) {
                            if (void 0 === e && (e = !1), void 0 !== t.button && (this.button = t.button), e && this.isMouse && this.updateButtons(t), this.clientX = t.clientX, this.clientY = t.clientY, this.pageX = t.pageX, this.pageY = t.pageY, this.screenX = t.screenX, this.screenY = t.screenY, this.isMouse && i.mouse.locked && !e && (this.rawMovementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.rawMovementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0, this.movementX += this.rawMovementX, this.movementY += this.rawMovementY), this.x = (this.pageX - this.game.scale.offset.x) * i.scale.x, this.y = (this.pageY - this.game.scale.offset.y) * i.scale.y, this.position.setTo(this.x, this.y), this.circle.x = this.x, this.circle.y = this.y, (i.multiInputOverride === a.Input.MOUSE_OVERRIDES_TOUCH || i.multiInputOverride === a.Input.MOUSE_TOUCH_COMBINE || i.multiInputOverride === a.Input.TOUCH_OVERRIDES_MOUSE && 0 === i.totalActivePointers) && (i.activePointer = this, i.x = this.x, i.y = this.y, i.position.setTo(i.x, i.y), i.circle.x = i.x, i.circle.y = i.y), this.withinGame = this.game.scale.bounds.contains(this.pageX, this.pageY), this.game.paused) return this;
                            for (var s = i.moveCallbacks.length; s--;) i.moveCallbacks[s].callback.call(i.moveCallbacks[s].context, this, this.x, this.y, e);
                            return null !== this.targetObject && !0 === this.targetObject.isDragged ? !1 === this.targetObject.update(this) && (this.targetObject = null) : i.interactiveItems.total > 0 && this.processInteractiveObjects(e), this
                        }
                    },
                    processInteractiveObjects: function(t) {
                        var e = 0,
                            i = -1,
                            s = null,
                            n = this.game.input.interactiveItems.first;
                        for (this.interactiveCandidates = []; n;) n.checked = !1, n.validForInput(i, e, !1) && (n.checked = !0, (t && n.checkPointerDown(this, !0) || !t && n.checkPointerOver(this, !0)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n))), n = this.game.input.interactiveItems.next;
                        for (n = this.game.input.interactiveItems.first; n;) !n.checked && n.validForInput(i, e, !0) && (t && n.checkPointerDown(this, !1) || !t && n.checkPointerOver(this, !1)) && (e = n.sprite.renderOrderID, i = n.priorityID, s = n, this.interactiveCandidates.push(n)), n = this.game.input.interactiveItems.next;
                        return this.game.input.customCandidateHandler && (s = this.game.input.customCandidateHandler.call(this.game.input.customCandidateHandlerContext, this, this.interactiveCandidates, s)), this.swapTarget(s, !1), null !== this.targetObject
                    },
                    swapTarget: function(t, e) {
                        void 0 === e && (e = !1), null === t ? this.targetObject && (this.targetObject._pointerOutHandler(this, e), this.targetObject = null) : null === this.targetObject ? (this.targetObject = t, t._pointerOverHandler(this, e)) : this.targetObject === t ? !1 === t.update(this) && (this.targetObject = null) : (this.targetObject._pointerOutHandler(this, e), this.targetObject = t, this.targetObject._pointerOverHandler(this, e))
                    },
                    leave: function(t) {
                        this.withinGame = !1, this.move(t, !1)
                    },
                    stop: function(t) {
                        var e = this.game.input;
                        return this._stateReset && this.withinGame ? void t.preventDefault() : (this.timeUp = this.game.time.time, (e.multiInputOverride === a.Input.MOUSE_OVERRIDES_TOUCH || e.multiInputOverride === a.Input.MOUSE_TOUCH_COMBINE || e.multiInputOverride === a.Input.TOUCH_OVERRIDES_MOUSE && 0 === e.totalActivePointers) && (e.onUp.dispatch(this, t), this.duration >= 0 && this.duration <= e.tapRate && (this.timeUp - this.previousTapTime < e.doubleTapRate ? e.onTap.dispatch(this, !0) : e.onTap.dispatch(this, !1), this.previousTapTime = this.timeUp)), this.isMouse ? this.updateButtons(t) : (this.isDown = !1, this.isUp = !0), this.id > 0 && (this.active = !1), this.withinGame = this.game.scale.bounds.contains(t.pageX, t.pageY), this.pointerId = null, this.identifier = null, this.positionUp.setTo(this.x, this.y), !1 === this.isMouse && e.currentPointers--, e.interactiveItems.callAll("_releasedHandler", this), this._clickTrampolines && (this._trampolineTargetObject = this.targetObject), this.targetObject = null, this)
                    },
                    justPressed: function(t) {
                        return t = t || this.game.input.justPressedRate, !0 === this.isDown && this.timeDown + t > this.game.time.time
                    },
                    justReleased: function(t) {
                        return t = t || this.game.input.justReleasedRate, this.isUp && this.timeUp + t > this.game.time.time
                    },
                    addClickTrampoline: function(t, e, i, s) {
                        if (this.isDown) {
                            for (var n = this._clickTrampolines = this._clickTrampolines || [], a = 0; a < n.length; a++)
                                if (n[a].name === t) {
                                    n.splice(a, 1);
                                    break
                                } n.push({
                                name: t,
                                targetObject: this.targetObject,
                                callback: e,
                                callbackContext: i,
                                callbackArgs: s
                            })
                        }
                    },
                    processClickTrampolines: function() {
                        var t = this._clickTrampolines;
                        if (t) {
                            for (var e = 0; e < t.length; e++) {
                                var i = t[e];
                                i.targetObject === this._trampolineTargetObject && i.callback.apply(i.callbackContext, i.callbackArgs)
                            }
                            this._clickTrampolines = null, this._trampolineTargetObject = null
                        }
                    },
                    reset: function() {
                        !1 === this.isMouse && (this.active = !1), this.pointerId = null, this.identifier = null, this.dirty = !1, this.totalTouches = 0, this._holdSent = !1, this._history.length = 0, this._stateReset = !0, this.resetButtons(), this.targetObject && this.targetObject._releasedHandler(this), this.targetObject = null
                    },
                    resetMovement: function() {
                        this.movementX = 0, this.movementY = 0
                    }
                }, a.Pointer.prototype.constructor = a.Pointer, Object.defineProperty(a.Pointer.prototype, "duration", {
                    get: function() {
                        return this.isUp ? -1 : this.game.time.time - this.timeDown
                    }
                }), Object.defineProperty(a.Pointer.prototype, "worldX", {
                    get: function() {
                        return this.game.world.camera.x + this.x
                    }
                }), Object.defineProperty(a.Pointer.prototype, "worldY", {
                    get: function() {
                        return this.game.world.camera.y + this.y
                    }
                }), a.PointerMode = {
                    CURSOR: 1,
                    CONTACT: 2
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Touch = function(t) {
                    this.game = t, this.enabled = !0, this.touchLockCallbacks = [], this.callbackContext = this.game, this.touchStartCallback = null, this.touchMoveCallback = null, this.touchEndCallback = null, this.touchEnterCallback = null, this.touchLeaveCallback = null, this.touchCancelCallback = null, this.preventDefault = !0, this.event = null, this._onTouchStart = null, this._onTouchMove = null, this._onTouchEnd = null, this._onTouchEnter = null, this._onTouchLeave = null, this._onTouchCancel = null, this._onTouchMove = null
                }, a.Touch.prototype = {
                    start: function() {
                        if (null === this._onTouchStart) {
                            var t = this;
                            this.game.device.touch && (this._onTouchStart = function(e) {
                                return t.onTouchStart(e)
                            }, this._onTouchMove = function(e) {
                                return t.onTouchMove(e)
                            }, this._onTouchEnd = function(e) {
                                return t.onTouchEnd(e)
                            }, this._onTouchEnter = function(e) {
                                return t.onTouchEnter(e)
                            }, this._onTouchLeave = function(e) {
                                return t.onTouchLeave(e)
                            }, this._onTouchCancel = function(e) {
                                return t.onTouchCancel(e)
                            }, this.game.canvas.addEventListener("touchstart", this._onTouchStart, !1), this.game.canvas.addEventListener("touchmove", this._onTouchMove, !1), this.game.canvas.addEventListener("touchend", this._onTouchEnd, !1), this.game.canvas.addEventListener("touchcancel", this._onTouchCancel, !1), this.game.device.cocoonJS || (this.game.canvas.addEventListener("touchenter", this._onTouchEnter, !1), this.game.canvas.addEventListener("touchleave", this._onTouchLeave, !1)))
                        }
                    },
                    consumeDocumentTouches: function() {
                        this._documentTouchMove = function(t) {
                            t.preventDefault()
                        }, document.addEventListener("touchmove", this._documentTouchMove, !1)
                    },
                    addTouchLockCallback: function(t, e, i) {
                        void 0 === i && (i = !1), this.touchLockCallbacks.push({
                            callback: t,
                            context: e,
                            onEnd: i
                        })
                    },
                    removeTouchLockCallback: function(t, e) {
                        for (var i = this.touchLockCallbacks.length; i--;)
                            if (this.touchLockCallbacks[i].callback === t && this.touchLockCallbacks[i].context === e) return this.touchLockCallbacks.splice(i, 1), !0;
                        return !1
                    },
                    onTouchStart: function(t) {
                        for (var e = this.touchLockCallbacks.length; e--;) {
                            var i = this.touchLockCallbacks[e];
                            !i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                        }
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            this.touchStartCallback && this.touchStartCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.startPointer(t.changedTouches[e])
                        }
                    },
                    onTouchCancel: function(t) {
                        if (this.event = t, this.touchCancelCallback && this.touchCancelCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled) {
                            this.preventDefault && t.preventDefault();
                            for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                        }
                    },
                    onTouchEnter: function(t) {
                        this.event = t, this.touchEnterCallback && this.touchEnterCallback.call(this.callbackContext, t), this.game.input.enabled && this.enabled && this.preventDefault && t.preventDefault()
                    },
                    onTouchLeave: function(t) {
                        this.event = t, this.touchLeaveCallback && this.touchLeaveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault()
                    },
                    onTouchMove: function(t) {
                        this.event = t, this.touchMoveCallback && this.touchMoveCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.updatePointer(t.changedTouches[e])
                    },
                    onTouchEnd: function(t) {
                        for (var e = this.touchLockCallbacks.length; e--;) {
                            var i = this.touchLockCallbacks[e];
                            i.onEnd && i.callback.call(i.context, this, t) && this.touchLockCallbacks.splice(e, 1)
                        }
                        this.event = t, this.touchEndCallback && this.touchEndCallback.call(this.callbackContext, t), this.preventDefault && t.preventDefault();
                        for (var e = 0; e < t.changedTouches.length; e++) this.game.input.stopPointer(t.changedTouches[e])
                    },
                    stop: function() {
                        this.game.device.touch && (this.game.canvas.removeEventListener("touchstart", this._onTouchStart), this.game.canvas.removeEventListener("touchmove", this._onTouchMove), this.game.canvas.removeEventListener("touchend", this._onTouchEnd), this.game.canvas.removeEventListener("touchenter", this._onTouchEnter), this.game.canvas.removeEventListener("touchleave", this._onTouchLeave), this.game.canvas.removeEventListener("touchcancel", this._onTouchCancel))
                    }
                }, a.Touch.prototype.constructor = a.Touch,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.InputHandler = function(t) {
                    this.sprite = t, this.game = t.game, this.enabled = !1, this.checked = !1, this.priorityID = 0, this.useHandCursor = !1, this._setHandCursor = !1, this.isDragged = !1, this.allowHorizontalDrag = !0, this.allowVerticalDrag = !0, this.bringToTop = !1, this.snapOffset = null, this.snapOnDrag = !1, this.snapOnRelease = !1, this.snapX = 0, this.snapY = 0, this.snapOffsetX = 0, this.snapOffsetY = 0, this.pixelPerfectOver = !1, this.pixelPerfectClick = !1, this.pixelPerfectAlpha = 255, this.draggable = !1, this.boundsRect = null, this.boundsSprite = null, this.scaleLayer = !1, this.dragOffset = new a.Point, this.dragFromCenter = !1, this.dragStopBlocksInputUp = !1, this.dragStartPoint = new a.Point, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this.downPoint = new a.Point, this.snapPoint = new a.Point, this._dragPoint = new a.Point, this._dragPhase = !1, this._pendingDrag = !1, this._dragTimePass = !1, this._dragDistancePass = !1, this._wasEnabled = !1, this._tempPoint = new a.Point, this._pointerData = [], this._pointerData.push({
                        id: 0,
                        x: 0,
                        y: 0,
                        camX: 0,
                        camY: 0,
                        isDown: !1,
                        isUp: !1,
                        isOver: !1,
                        isOut: !1,
                        timeOver: 0,
                        timeOut: 0,
                        timeDown: 0,
                        timeUp: 0,
                        downDuration: 0,
                        isDragged: !1
                    })
                }, a.InputHandler.prototype = {
                    start: function(t, e) {
                        if (t = t || 0, void 0 === e && (e = !1), !1 === this.enabled) {
                            this.game.input.interactiveItems.add(this), this.useHandCursor = e, this.priorityID = t;
                            for (var i = 0; i < 10; i++) this._pointerData[i] = {
                                id: i,
                                x: 0,
                                y: 0,
                                isDown: !1,
                                isUp: !1,
                                isOver: !1,
                                isOut: !1,
                                timeOver: 0,
                                timeOut: 0,
                                timeDown: 0,
                                timeUp: 0,
                                downDuration: 0,
                                isDragged: !1
                            };
                            this.snapOffset = new a.Point, this.enabled = !0, this._wasEnabled = !0
                        }
                        return this.sprite.events.onAddedToGroup.add(this.addedToGroup, this), this.sprite.events.onRemovedFromGroup.add(this.removedFromGroup, this), this.sprite
                    },
                    addedToGroup: function() {
                        this._dragPhase || this._wasEnabled && !this.enabled && this.start()
                    },
                    removedFromGroup: function() {
                        this._dragPhase || (this.enabled ? (this._wasEnabled = !0, this.stop()) : this._wasEnabled = !1)
                    },
                    reset: function() {
                        this.enabled = !1;
                        for (var t = 0; t < 10; t++) this._pointerData[t] = {
                            id: t,
                            x: 0,
                            y: 0,
                            isDown: !1,
                            isUp: !1,
                            isOver: !1,
                            isOut: !1,
                            timeOver: 0,
                            timeOut: 0,
                            timeDown: 0,
                            timeUp: 0,
                            downDuration: 0,
                            isDragged: !1
                        }
                    },
                    stop: function() {
                        !1 !== this.enabled && (this.enabled = !1, this.game.input.interactiveItems.remove(this))
                    },
                    destroy: function() {
                        this.sprite && (this._setHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), this.enabled = !1, this.game.input.interactiveItems.remove(this), this._pointerData.length = 0, this.boundsRect = null, this.boundsSprite = null, this.sprite = null)
                    },
                    validForInput: function(t, e, i) {
                        return void 0 === i && (i = !0), !(!this.enabled || 0 === this.sprite.scale.x || 0 === this.sprite.scale.y || this.priorityID < this.game.input.minPriorityID || this.sprite.parent && this.sprite.parent.ignoreChildInput) && (!(!i && (this.pixelPerfectClick || this.pixelPerfectOver)) && (this.priorityID > t || this.priorityID === t && this.sprite.renderOrderID > e))
                    },
                    isPixelPerfect: function() {
                        return this.pixelPerfectClick || this.pixelPerfectOver
                    },
                    pointerX: function(t) {
                        return t = t || 0, this._pointerData[t].x
                    },
                    pointerY: function(t) {
                        return t = t || 0, this._pointerData[t].y
                    },
                    pointerDown: function(t) {
                        return t = t || 0, this._pointerData[t].isDown
                    },
                    pointerUp: function(t) {
                        return t = t || 0, this._pointerData[t].isUp
                    },
                    pointerTimeDown: function(t) {
                        return t = t || 0, this._pointerData[t].timeDown
                    },
                    pointerTimeUp: function(t) {
                        return t = t || 0, this._pointerData[t].timeUp
                    },
                    pointerOver: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 === t) {
                            for (var e = 0; e < 10; e++)
                                if (this._pointerData[e].isOver) return !0;
                            return !1
                        }
                        return this._pointerData[t].isOver
                    },
                    pointerOut: function(t) {
                        if (!this.enabled) return !1;
                        if (void 0 !== t) return this._pointerData[t].isOut;
                        for (var e = 0; e < 10; e++)
                            if (this._pointerData[e].isOut) return !0
                    },
                    pointerTimeOver: function(t) {
                        return t = t || 0, this._pointerData[t].timeOver
                    },
                    pointerTimeOut: function(t) {
                        return t = t || 0, this._pointerData[t].timeOut
                    },
                    pointerDragged: function(t) {
                        return t = t || 0, this._pointerData[t].isDragged
                    },
                    checkPointerDown: function(t, e) {
                        return !!(t.isDown && this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectClick) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPointerOver: function(t, e) {
                        return !!(this.enabled && this.sprite && this.sprite.parent && this.sprite.visible && this.sprite.parent.visible && 0 !== this.sprite.worldScale.x && 0 !== this.sprite.worldScale.y) && (!!this.game.input.hitTest(this.sprite, t, this._tempPoint) && (void 0 === e && (e = !1), !(!e && this.pixelPerfectOver) || this.checkPixel(this._tempPoint.x, this._tempPoint.y)))
                    },
                    checkPixel: function(t, e, i) {
                        if (this.sprite.texture.baseTexture.source) {
                            if (null === t && null === e) {
                                this.game.input.getLocalPosition(this.sprite, i, this._tempPoint);
                                var t = this._tempPoint.x,
                                    e = this._tempPoint.y
                            }
                            if (0 !== this.sprite.anchor.x && (t -= -this.sprite.texture.frame.width * this.sprite.anchor.x), 0 !== this.sprite.anchor.y && (e -= -this.sprite.texture.frame.height * this.sprite.anchor.y), t += this.sprite.texture.frame.x, e += this.sprite.texture.frame.y, this.sprite.texture.trim && (t -= this.sprite.texture.trim.x, e -= this.sprite.texture.trim.y, t < this.sprite.texture.crop.x || t > this.sprite.texture.crop.right || e < this.sprite.texture.crop.y || e > this.sprite.texture.crop.bottom)) return this._dx = t, this._dy = e, !1;
                            this._dx = t, this._dy = e, this.game.input.hitContext.clearRect(0, 0, 1, 1), this.game.input.hitContext.drawImage(this.sprite.texture.baseTexture.source, t, e, 1, 1, 0, 0, 1, 1);
                            if (this.game.input.hitContext.getImageData(0, 0, 1, 1)
                                .data[3] >= this.pixelPerfectAlpha) return !0
                        }
                        return !1
                    },
                    update: function(t) {
                        if (null !== this.sprite && void 0 !== this.sprite.parent) return this.enabled && this.sprite.visible && this.sprite.parent.visible ? this._pendingDrag ? (this._dragDistancePass || (this._dragDistancePass = a.Math.distance(t.x, t.y, this.downPoint.x, this.downPoint.y) >= this.dragDistanceThreshold), this._dragDistancePass && this._dragTimePass && this.startDrag(t), !0) : this.draggable && this._draggedPointerID === t.id ? this.updateDrag(t, !1) : this._pointerData[t.id].isOver ? this.checkPointerOver(t) ? (this._pointerData[t.id].x = t.x - this.sprite.x, this._pointerData[t.id].y = t.y - this.sprite.y, !0) : (this._pointerOutHandler(t), !1) : void 0 : (this._pointerOutHandler(t), !1)
                    },
                    _pointerOverHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            if (!1 === i.isOver || t.dirty) {
                                var s = !1 === i.isOver;
                                i.isOver = !0, i.isOut = !1, i.timeOver = this.game.time.time, i.x = t.x - this.sprite.x, i.y = t.y - this.sprite.y, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "pointer", this._setHandCursor = !0), !e && s && this.sprite && this.sprite.events && this.sprite.events.onInputOver$dispatch(this.sprite, t), this.sprite.parent && this.sprite.parent.type === a.GROUP && this.sprite.parent.onChildInputOver.dispatch(this.sprite, t)
                            }
                        }
                    },
                    _pointerOutHandler: function(t, e) {
                        if (null !== this.sprite) {
                            var i = this._pointerData[t.id];
                            i.isOver = !1, i.isOut = !0, i.timeOut = this.game.time.time, this.useHandCursor && !1 === i.isDragged && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), !e && this.sprite && this.sprite.events && (this.sprite.events.onInputOut$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === a.GROUP && this.sprite.parent.onChildInputOut.dispatch(this.sprite, t))
                        }
                    },
                    _touchedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (!e.isDown && e.isOver) {
                                if (this.pixelPerfectClick && !this.checkPixel(null, null, t)) return;
                                if (e.isDown = !0, e.isUp = !1, e.timeDown = this.game.time.time, this.downPoint.set(t.x, t.y), t.dirty = !0, this.sprite && this.sprite.events && (this.sprite.events.onInputDown$dispatch(this.sprite, t), this.sprite && this.sprite.parent && this.sprite.parent.type === a.GROUP && this.sprite.parent.onChildInputDown.dispatch(this.sprite, t), null === this.sprite)) return;
                                this.draggable && !1 === this.isDragged && (0 === this.dragTimeThreshold && 0 === this.dragDistanceThreshold ? this.startDrag(t) : (this._pendingDrag = !0, this._dragDistancePass = 0 === this.dragDistanceThreshold, this.dragTimeThreshold > 0 ? (this._dragTimePass = !1, this.game.time.events.add(this.dragTimeThreshold, this.dragTimeElapsed, this, t)) : this._dragTimePass = !0)), this.bringToTop && this.sprite.bringToTop()
                            }
                        }
                    },
                    dragTimeElapsed: function(t) {
                        this._dragTimePass = !0, this._pendingDrag && this.sprite && this._dragDistancePass && this.startDrag(t)
                    },
                    _releasedHandler: function(t) {
                        if (null !== this.sprite) {
                            var e = this._pointerData[t.id];
                            if (e.isDown && t.isUp) {
                                e.isDown = !1, e.isUp = !0, e.timeUp = this.game.time.time, e.downDuration = e.timeUp - e.timeDown;
                                var i = this.checkPointerOver(t);
                                this.sprite && this.sprite.events && (this.dragStopBlocksInputUp && (!this.dragStopBlocksInputUp || this.draggable && this.isDragged && this._draggedPointerID === t.id) || this.sprite.events.onInputUp$dispatch(this.sprite, t, i), this.sprite && this.sprite.parent && this.sprite.parent.type === a.GROUP && this.sprite.parent.onChildInputUp.dispatch(this.sprite, t, i), i && (i = this.checkPointerOver(t))), e.isOver = i, !i && this.useHandCursor && (this.game.canvas.style.cursor = "default", this._setHandCursor = !1), t.dirty = !0, this._pendingDrag = !1, this.draggable && this.isDragged && this._draggedPointerID === t.id && this.stopDrag(t)
                            }
                        }
                    },
                    updateDrag: function(t, e) {
                        if (void 0 === e && (e = !1), t.isUp) return this.stopDrag(t), !1;
                        var i = this.globalToLocalX(t.x) + this._dragPoint.x + this.dragOffset.x,
                            s = this.globalToLocalY(t.y) + this._dragPoint.y + this.dragOffset.y;
                        if (this.sprite.fixedToCamera) this.allowHorizontalDrag && (this.sprite.cameraOffset.x = i), this.allowVerticalDrag && (this.sprite.cameraOffset.y = s), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.cameraOffset.x, this.sprite.cameraOffset.y));
                        else {
                            var n = this.game.camera.x - this._pointerData[t.id].camX,
                                a = this.game.camera.y - this._pointerData[t.id].camY;
                            this.allowHorizontalDrag && (this.sprite.x = i + n), this.allowVerticalDrag && (this.sprite.y = s + a), this.boundsRect && this.checkBoundsRect(), this.boundsSprite && this.checkBoundsSprite(), this.snapOnDrag && (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY, this.snapPoint.set(this.sprite.x, this.sprite.y))
                        }
                        return this.sprite.events.onDragUpdate.dispatch(this.sprite, t, i, s, this.snapPoint, e), !0
                    },
                    justOver: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOver && this.overDuration(t) < e
                    },
                    justOut: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isOut && this.game.time.time - this._pointerData[t].timeOut < e
                    },
                    justPressed: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isDown && this.downDuration(t) < e
                    },
                    justReleased: function(t, e) {
                        return t = t || 0, e = e || 500, this._pointerData[t].isUp && this.game.time.time - this._pointerData[t].timeUp < e
                    },
                    overDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isOver ? this.game.time.time - this._pointerData[t].timeOver : -1
                    },
                    downDuration: function(t) {
                        return t = t || 0, this._pointerData[t].isDown ? this.game.time.time - this._pointerData[t].timeDown : -1
                    },
                    enableDrag: function(t, e, i, s, n, o) {
                        void 0 === t && (t = !1), void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === s && (s = 255), void 0 === n && (n = null), void 0 === o && (o = null), this._dragPoint = new a.Point, this.draggable = !0, this.bringToTop = e, this.dragOffset = new a.Point, this.dragFromCenter = t, this.pixelPerfectClick = i, this.pixelPerfectAlpha = s, n && (this.boundsRect = n), o && (this.boundsSprite = o)
                    },
                    disableDrag: function() {
                        if (this._pointerData)
                            for (var t = 0; t < 10; t++) this._pointerData[t].isDragged = !1;
                        this.draggable = !1, this.isDragged = !1, this._draggedPointerID = -1, this._pendingDrag = !1
                    },
                    startDrag: function(t) {
                        var e = this.sprite.x,
                            i = this.sprite.y;
                        if (this.isDragged = !0, this._draggedPointerID = t.id, this._pointerData[t.id].camX = this.game.camera.x, this._pointerData[t.id].camY = this.game.camera.y, this._pointerData[t.id].isDragged = !0, this.sprite.fixedToCamera) {
                            if (this.dragFromCenter) {
                                var s = this.sprite.getBounds();
                                this.sprite.cameraOffset.x = this.globalToLocalX(t.x) + (this.sprite.cameraOffset.x - s.centerX), this.sprite.cameraOffset.y = this.globalToLocalY(t.y) + (this.sprite.cameraOffset.y - s.centerY)
                            }
                            this._dragPoint.setTo(this.sprite.cameraOffset.x - t.x, this.sprite.cameraOffset.y - t.y)
                        } else {
                            if (this.dragFromCenter) {
                                var s = this.sprite.getBounds();
                                this.sprite.x = this.globalToLocalX(t.x) + (this.sprite.x - s.centerX), this.sprite.y = this.globalToLocalY(t.y) + (this.sprite.y - s.centerY)
                            }
                            this._dragPoint.setTo(this.sprite.x - this.globalToLocalX(t.x), this.sprite.y - this.globalToLocalY(t.y))
                        }
                        this.updateDrag(t, !0), this.bringToTop && (this._dragPhase = !0, this.sprite.bringToTop()), this.dragStartPoint.set(e, i), this.sprite.events.onDragStart$dispatch(this.sprite, t, e, i), this._pendingDrag = !1
                    },
                    globalToLocalX: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.x, t *= this.game.scale.grid.scaleFluidInversed.x), t
                    },
                    globalToLocalY: function(t) {
                        return this.scaleLayer && (t -= this.game.scale.grid.boundsFluid.y, t *= this.game.scale.grid.scaleFluidInversed.y), t
                    },
                    stopDrag: function(t) {
                        this.isDragged = !1, this._draggedPointerID = -1, this._pointerData[t.id].isDragged = !1, this._dragPhase = !1, this._pendingDrag = !1, this.snapOnRelease && (this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x = Math.round((this.sprite.cameraOffset.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.cameraOffset.y = Math.round((this.sprite.cameraOffset.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY) : (this.sprite.x = Math.round((this.sprite.x - this.snapOffsetX % this.snapX) / this.snapX) * this.snapX + this.snapOffsetX % this.snapX, this.sprite.y = Math.round((this.sprite.y - this.snapOffsetY % this.snapY) / this.snapY) * this.snapY + this.snapOffsetY % this.snapY)), this.sprite.events.onDragStop$dispatch(this.sprite, t), !1 === this.checkPointerOver(t) && this._pointerOutHandler(t)
                    },
                    setDragLock: function(t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = !0), this.allowHorizontalDrag = t, this.allowVerticalDrag = e
                    },
                    enableSnap: function(t, e, i, s, n, a) {
                        void 0 === i && (i = !0), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === a && (a = 0), this.snapX = t, this.snapY = e, this.snapOffsetX = n, this.snapOffsetY = a, this.snapOnDrag = i, this.snapOnRelease = s
                    },
                    disableSnap: function() {
                        this.snapOnDrag = !1, this.snapOnRelease = !1
                    },
                    checkBoundsRect: function() {
                        this.sprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsRect.left ? this.sprite.cameraOffset.x = this.boundsRect.left : this.sprite.cameraOffset.x + this.sprite.width > this.boundsRect.right && (this.sprite.cameraOffset.x = this.boundsRect.right - this.sprite.width), this.sprite.cameraOffset.y < this.boundsRect.top ? this.sprite.cameraOffset.y = this.boundsRect.top : this.sprite.cameraOffset.y + this.sprite.height > this.boundsRect.bottom && (this.sprite.cameraOffset.y = this.boundsRect.bottom - this.sprite.height)) : (this.sprite.left < this.boundsRect.left ? this.sprite.x = this.boundsRect.x + this.sprite.offsetX : this.sprite.right > this.boundsRect.right && (this.sprite.x = this.boundsRect.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsRect.top ? this.sprite.y = this.boundsRect.top + this.sprite.offsetY : this.sprite.bottom > this.boundsRect.bottom && (this.sprite.y = this.boundsRect.bottom - (this.sprite.height - this.sprite.offsetY)))
                    },
                    checkBoundsSprite: function() {
                        this.sprite.fixedToCamera && this.boundsSprite.fixedToCamera ? (this.sprite.cameraOffset.x < this.boundsSprite.cameraOffset.x ? this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x : this.sprite.cameraOffset.x + this.sprite.width > this.boundsSprite.cameraOffset.x + this.boundsSprite.width && (this.sprite.cameraOffset.x = this.boundsSprite.cameraOffset.x + this.boundsSprite.width - this.sprite.width), this.sprite.cameraOffset.y < this.boundsSprite.cameraOffset.y ? this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y : this.sprite.cameraOffset.y + this.sprite.height > this.boundsSprite.cameraOffset.y + this.boundsSprite.height && (this.sprite.cameraOffset.y = this.boundsSprite.cameraOffset.y + this.boundsSprite.height - this.sprite.height)) : (this.sprite.left < this.boundsSprite.left ? this.sprite.x = this.boundsSprite.left + this.sprite.offsetX : this.sprite.right > this.boundsSprite.right && (this.sprite.x = this.boundsSprite.right - (this.sprite.width - this.sprite.offsetX)), this.sprite.top < this.boundsSprite.top ? this.sprite.y = this.boundsSprite.top + this.sprite.offsetY : this.sprite.bottom > this.boundsSprite.bottom && (this.sprite.y = this.boundsSprite.bottom - (this.sprite.height - this.sprite.offsetY)))
                    }
                }, a.InputHandler.prototype.constructor = a.InputHandler,
                /**
                 * @author       @karlmacklin <tacklemcclean@gmail.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Gamepad = function(t) {
                    this.game = t, this._gamepadIndexMap = {}, this._rawPads = [], this._active = !1, this.enabled = !0, this._gamepadSupportAvailable = !!navigator.webkitGetGamepads || !!navigator.webkitGamepads || -1 !== navigator.userAgent.indexOf("Firefox/") || !!navigator.getGamepads, this._prevRawGamepadTypes = [], this._prevTimestamps = [], this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this._ongamepadconnected = null, this._gamepaddisconnected = null, this._gamepads = [new a.SinglePad(t, this), new a.SinglePad(t, this), new a.SinglePad(t, this), new a.SinglePad(t, this)]
                }, a.Gamepad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    start: function() {
                        if (!this._active) {
                            this._active = !0;
                            var t = this;
                            this._onGamepadConnected = function(e) {
                                return t.onGamepadConnected(e)
                            }, this._onGamepadDisconnected = function(e) {
                                return t.onGamepadDisconnected(e)
                            }, window.addEventListener("gamepadconnected", this._onGamepadConnected, !1), window.addEventListener("gamepaddisconnected", this._onGamepadDisconnected, !1)
                        }
                    },
                    onGamepadConnected: function(t) {
                        var e = t.gamepad;
                        this._rawPads.push(e), this._gamepads[e.index].connect(e)
                    },
                    onGamepadDisconnected: function(t) {
                        var e = t.gamepad;
                        for (var i in this._rawPads) this._rawPads[i].index === e.index && this._rawPads.splice(i, 1);
                        this._gamepads[e.index].disconnect()
                    },
                    update: function() {
                        this._pollGamepads(), this.pad1.pollStatus(), this.pad2.pollStatus(), this.pad3.pollStatus(), this.pad4.pollStatus()
                    },
                    _pollGamepads: function() {
                        if (this._active) {
                            if (navigator.getGamepads) var t = navigator.getGamepads();
                            else if (navigator.webkitGetGamepads) var t = navigator.webkitGetGamepads();
                            else if (navigator.webkitGamepads) var t = navigator.webkitGamepads();
                            if (t) {
                                this._rawPads = [];
                                for (var e = !1, i = 0; i < t.length && (typeof t[i] !== this._prevRawGamepadTypes[i] && (e = !0, this._prevRawGamepadTypes[i] = typeof t[i]), t[i] && this._rawPads.push(t[i]), 3 !== i); i++);
                                for (var s = 0; s < this._gamepads.length; s++) this._gamepads[s]._rawPad = this._rawPads[s];
                                if (e) {
                                    for (var n = {
                                            rawIndices: {},
                                            padIndices: {}
                                        }, a, o = 0; o < this._gamepads.length; o++)
                                        if (a = this._gamepads[o], a.connected)
                                            for (var r = 0; r < this._rawPads.length; r++) this._rawPads[r].index === a.index && (n.rawIndices[a.index] = !0, n.padIndices[o] = !0);
                                    for (var h = 0; h < this._gamepads.length; h++)
                                        if (a = this._gamepads[h], !n.padIndices[h]) {
                                            this._rawPads.length < 1 && a.disconnect();
                                            for (var l = 0; l < this._rawPads.length && !n.padIndices[h]; l++) {
                                                var c = this._rawPads[l];
                                                if (c) {
                                                    if (n.rawIndices[c.index]) {
                                                        a.disconnect();
                                                        continue
                                                    }
                                                    a.connect(c), n.rawIndices[c.index] = !0, n.padIndices[h] = !0
                                                } else a.disconnect()
                                            }
                                        }
                                }
                            }
                        }
                    },
                    setDeadZones: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++) this._gamepads[e].deadZone = t
                    },
                    stop: function() {
                        this._active = !1, window.removeEventListener("gamepadconnected", this._onGamepadConnected), window.removeEventListener("gamepaddisconnected", this._onGamepadDisconnected)
                    },
                    reset: function() {
                        this.update();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].reset()
                    },
                    justPressed: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justPressed(t, e)) return !0;
                        return !1
                    },
                    justReleased: function(t, e) {
                        for (var i = 0; i < this._gamepads.length; i++)
                            if (!0 === this._gamepads[i].justReleased(t, e)) return !0;
                        return !1
                    },
                    isDown: function(t) {
                        for (var e = 0; e < this._gamepads.length; e++)
                            if (!0 === this._gamepads[e].isDown(t)) return !0;
                        return !1
                    },
                    destroy: function() {
                        this.stop();
                        for (var t = 0; t < this._gamepads.length; t++) this._gamepads[t].destroy()
                    }
                }, a.Gamepad.prototype.constructor = a.Gamepad, Object.defineProperty(a.Gamepad.prototype, "active", {
                    get: function() {
                        return this._active
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "supported", {
                    get: function() {
                        return this._gamepadSupportAvailable
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "padsConnected", {
                    get: function() {
                        return this._rawPads.length
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "pad1", {
                    get: function() {
                        return this._gamepads[0]
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "pad2", {
                    get: function() {
                        return this._gamepads[1]
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "pad3", {
                    get: function() {
                        return this._gamepads[2]
                    }
                }), Object.defineProperty(a.Gamepad.prototype, "pad4", {
                    get: function() {
                        return this._gamepads[3]
                    }
                }), a.Gamepad.BUTTON_0 = 0, a.Gamepad.BUTTON_1 = 1, a.Gamepad.BUTTON_2 = 2, a.Gamepad.BUTTON_3 = 3, a.Gamepad.BUTTON_4 = 4, a.Gamepad.BUTTON_5 = 5, a.Gamepad.BUTTON_6 = 6, a.Gamepad.BUTTON_7 = 7, a.Gamepad.BUTTON_8 = 8, a.Gamepad.BUTTON_9 = 9, a.Gamepad.BUTTON_10 = 10, a.Gamepad.BUTTON_11 = 11, a.Gamepad.BUTTON_12 = 12, a.Gamepad.BUTTON_13 = 13, a.Gamepad.BUTTON_14 = 14, a.Gamepad.BUTTON_15 = 15, a.Gamepad.AXIS_0 = 0, a.Gamepad.AXIS_1 = 1, a.Gamepad.AXIS_2 = 2, a.Gamepad.AXIS_3 = 3, a.Gamepad.AXIS_4 = 4, a.Gamepad.AXIS_5 = 5, a.Gamepad.AXIS_6 = 6, a.Gamepad.AXIS_7 = 7, a.Gamepad.AXIS_8 = 8, a.Gamepad.AXIS_9 = 9, a.Gamepad.XBOX360_A = 0, a.Gamepad.XBOX360_B = 1, a.Gamepad.XBOX360_X = 2, a.Gamepad.XBOX360_Y = 3, a.Gamepad.XBOX360_LEFT_BUMPER = 4, a.Gamepad.XBOX360_RIGHT_BUMPER = 5, a.Gamepad.XBOX360_LEFT_TRIGGER = 6, a.Gamepad.XBOX360_RIGHT_TRIGGER = 7, a.Gamepad.XBOX360_BACK = 8, a.Gamepad.XBOX360_START = 9, a.Gamepad.XBOX360_STICK_LEFT_BUTTON = 10, a.Gamepad.XBOX360_STICK_RIGHT_BUTTON = 11, a.Gamepad.XBOX360_DPAD_LEFT = 14, a.Gamepad.XBOX360_DPAD_RIGHT = 15, a.Gamepad.XBOX360_DPAD_UP = 12, a.Gamepad.XBOX360_DPAD_DOWN = 13, a.Gamepad.XBOX360_STICK_LEFT_X = 0, a.Gamepad.XBOX360_STICK_LEFT_Y = 1, a.Gamepad.XBOX360_STICK_RIGHT_X = 2, a.Gamepad.XBOX360_STICK_RIGHT_Y = 3, a.Gamepad.PS3XC_X = 0;
            a.Gamepad.PS3XC_CIRCLE = 1, a.Gamepad.PS3XC_SQUARE = 2, a.Gamepad.PS3XC_TRIANGLE = 3, a.Gamepad.PS3XC_L1 = 4, a.Gamepad.PS3XC_R1 = 5, a.Gamepad.PS3XC_L2 = 6, a.Gamepad.PS3XC_R2 = 7, a.Gamepad.PS3XC_SELECT = 8, a.Gamepad.PS3XC_START = 9, a.Gamepad.PS3XC_STICK_LEFT_BUTTON = 10, a.Gamepad.PS3XC_STICK_RIGHT_BUTTON = 11, a.Gamepad.PS3XC_DPAD_UP = 12, a.Gamepad.PS3XC_DPAD_DOWN = 13, a.Gamepad.PS3XC_DPAD_LEFT = 14, a.Gamepad.PS3XC_DPAD_RIGHT = 15, a.Gamepad.PS3XC_STICK_LEFT_X = 0, a.Gamepad.PS3XC_STICK_LEFT_Y = 1, a.Gamepad.PS3XC_STICK_RIGHT_X = 2, a.Gamepad.PS3XC_STICK_RIGHT_Y = 3,
                /**
                 * @author       @karlmacklin <tacklemcclean@gmail.com>
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.SinglePad = function(t, e) {
                    this.game = t, this.index = null, this.connected = !1, this.callbackContext = this, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null, this.deadZone = .26, this._padParent = e, this._rawPad = null, this._prevTimestamp = null, this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0
                }, a.SinglePad.prototype = {
                    addCallbacks: function(t, e) {
                        void 0 !== e && (this.onConnectCallback = "function" == typeof e.onConnect ? e.onConnect : this.onConnectCallback, this.onDisconnectCallback = "function" == typeof e.onDisconnect ? e.onDisconnect : this.onDisconnectCallback, this.onDownCallback = "function" == typeof e.onDown ? e.onDown : this.onDownCallback, this.onUpCallback = "function" == typeof e.onUp ? e.onUp : this.onUpCallback, this.onAxisCallback = "function" == typeof e.onAxis ? e.onAxis : this.onAxisCallback, this.onFloatCallback = "function" == typeof e.onFloat ? e.onFloat : this.onFloatCallback, this.callbackContext = t)
                    },
                    getButton: function(t) {
                        return this._buttons[t] ? this._buttons[t] : null
                    },
                    pollStatus: function() {
                        if (this.connected && this.game.input.enabled && this.game.input.gamepad.enabled && (!this._rawPad.timestamp || this._rawPad.timestamp !== this._prevTimestamp)) {
                            for (var t = 0; t < this._buttonsLen; t++) {
                                var e = isNaN(this._rawPad.buttons[t]) ? this._rawPad.buttons[t].value : this._rawPad.buttons[t];
                                e !== this._buttons[t].value && (1 === e ? this.processButtonDown(t, e) : 0 === e ? this.processButtonUp(t, e) : this.processButtonFloat(t, e))
                            }
                            for (var i = 0; i < this._axesLen; i++) {
                                var s = this._rawPad.axes[i];
                                s > 0 && s > this.deadZone || s < 0 && s < -this.deadZone ? this.processAxisChange(i, s) : this.processAxisChange(i, 0)
                            }
                            this._prevTimestamp = this._rawPad.timestamp
                        }
                    },
                    connect: function(t) {
                        var e = !this.connected;
                        this.connected = !0, this.index = t.index, this._rawPad = t, this._buttons = [], this._buttonsLen = t.buttons.length, this._axes = [], this._axesLen = t.axes.length;
                        for (var i = 0; i < this._axesLen; i++) this._axes[i] = t.axes[i];
                        for (var s in t.buttons) s = parseInt(s, 10), this._buttons[s] = new a.DeviceButton(this, s);
                        e && this._padParent.onConnectCallback && this._padParent.onConnectCallback.call(this._padParent.callbackContext, this.index), e && this.onConnectCallback && this.onConnectCallback.call(this.callbackContext)
                    },
                    disconnect: function() {
                        var t = this.connected,
                            e = this.index;
                        this.connected = !1, this.index = null, this._rawPad = void 0;
                        for (var i = 0; i < this._buttonsLen; i++) this._buttons[i].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, t && this._padParent.onDisconnectCallback && this._padParent.onDisconnectCallback.call(this._padParent.callbackContext, e), t && this.onDisconnectCallback && this.onDisconnectCallback.call(this.callbackContext)
                    },
                    destroy: function() {
                        this._rawPad = void 0;
                        for (var t = 0; t < this._buttonsLen; t++) this._buttons[t].destroy();
                        this._buttons = [], this._buttonsLen = 0, this._axes = [], this._axesLen = 0, this.onConnectCallback = null, this.onDisconnectCallback = null, this.onDownCallback = null, this.onUpCallback = null, this.onAxisCallback = null, this.onFloatCallback = null
                    },
                    processAxisChange: function(t, e) {
                        this._axes[t] !== e && (this._axes[t] = e, this._padParent.onAxisCallback && this._padParent.onAxisCallback.call(this._padParent.callbackContext, this, t, e), this.onAxisCallback && this.onAxisCallback.call(this.callbackContext, this, t, e))
                    },
                    processButtonDown: function(t, e) {
                        this._buttons[t] && this._buttons[t].start(null, e), this._padParent.onDownCallback && this._padParent.onDownCallback.call(this._padParent.callbackContext, t, e, this.index), this.onDownCallback && this.onDownCallback.call(this.callbackContext, t, e)
                    },
                    processButtonUp: function(t, e) {
                        this._padParent.onUpCallback && this._padParent.onUpCallback.call(this._padParent.callbackContext, t, e, this.index), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].stop(null, e)
                    },
                    processButtonFloat: function(t, e) {
                        this._padParent.onFloatCallback && this._padParent.onFloatCallback.call(this._padParent.callbackContext, t, e, this.index), this.onFloatCallback && this.onFloatCallback.call(this.callbackContext, t, e), this._buttons[t] && this._buttons[t].padFloat(e)
                    },
                    axis: function(t) {
                        return !!this._axes[t] && this._axes[t]
                    },
                    isDown: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isDown
                    },
                    isUp: function(t) {
                        return !!this._buttons[t] && this._buttons[t].isUp
                    },
                    justReleased: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justReleased(e)
                    },
                    justPressed: function(t, e) {
                        if (this._buttons[t]) return this._buttons[t].justPressed(e)
                    },
                    buttonValue: function(t) {
                        return this._buttons[t] ? this._buttons[t].value : null
                    },
                    reset: function() {
                        for (var t = 0; t < this._axes.length; t++) this._axes[t] = 0
                    }
                }, a.SinglePad.prototype.constructor = a.SinglePad,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Key = function(t, e) {
                    this.game = t, this._enabled = !0, this.event = null, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = -2500, this.repeats = 0, this.keyCode = e, this.onDown = new a.Signal, this.onHoldCallback = null, this.onHoldContext = null, this.onUp = new a.Signal, this._justDown = !1, this._justUp = !1
                }, a.Key.prototype = {
                    update: function() {
                        this._enabled && this.isDown && (this.duration = this.game.time.time - this.timeDown, this.repeats++, this.onHoldCallback && this.onHoldCallback.call(this.onHoldContext, this))
                    },
                    processKeyDown: function(t) {
                        this._enabled && (this.event = t, this.isDown || (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.isDown = !0, this.isUp = !1, this.timeDown = this.game.time.time, this.duration = 0, this.repeats = 0, this._justDown = !0, this.onDown.dispatch(this)))
                    },
                    processKeyUp: function(t) {
                        this._enabled && (this.event = t, this.isUp || (this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = this.game.time.time - this.timeDown, this._justUp = !0, this.onUp.dispatch(this)))
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.isDown = !1, this.isUp = !0, this.timeUp = this.game.time.time, this.duration = 0, this._enabled = !0, this._justDown = !1, this._justUp = !1, t && (this.onDown.removeAll(), this.onUp.removeAll(), this.onHoldCallback = null, this.onHoldContext = null)
                    },
                    downDuration: function(t) {
                        return void 0 === t && (t = 50), this.isDown && this.duration < t
                    },
                    upDuration: function(t) {
                        return void 0 === t && (t = 50), !this.isDown && this.game.time.time - this.timeUp < t
                    }
                }, Object.defineProperty(a.Key.prototype, "justDown", {
                    get: function() {
                        var t = this._justDown;
                        return this._justDown = !1, t
                    }
                }), Object.defineProperty(a.Key.prototype, "justUp", {
                    get: function() {
                        var t = this._justUp;
                        return this._justUp = !1, t
                    }
                }), Object.defineProperty(a.Key.prototype, "enabled", {
                    get: function() {
                        return this._enabled
                    },
                    set: function(t) {
                        (t = !!t) !== this._enabled && (t || this.reset(!1), this._enabled = t)
                    }
                }), a.Key.prototype.constructor = a.Key,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Keyboard = function(t) {
                    this.game = t, this.enabled = !0, this.event = null, this.pressEvent = null, this.callbackContext = this, this.onDownCallback = null, this.onPressCallback = null, this.onUpCallback = null, this._keys = [], this._capture = [], this._onKeyDown = null, this._onKeyPress = null, this._onKeyUp = null, this._i = 0, this._k = 0
                }, a.Keyboard.prototype = {
                    addCallbacks: function(t, e, i, s) {
                        this.callbackContext = t, void 0 !== e && null !== e && (this.onDownCallback = e), void 0 !== i && null !== i && (this.onUpCallback = i), void 0 !== s && null !== s && (this.onPressCallback = s)
                    },
                    addKey: function(t) {
                        return this._keys[t] || (this._keys[t] = new a.Key(this.game, t), this.addKeyCapture(t)), this._keys[t]
                    },
                    addKeys: function(t) {
                        var e = {};
                        for (var i in t) e[i] = this.addKey(t[i]);
                        return e
                    },
                    removeKey: function(t) {
                        this._keys[t] && (this._keys[t] = null, this.removeKeyCapture(t))
                    },
                    createCursorKeys: function() {
                        return this.addKeys({
                            up: a.KeyCode.UP,
                            down: a.KeyCode.DOWN,
                            left: a.KeyCode.LEFT,
                            right: a.KeyCode.RIGHT
                        })
                    },
                    start: function() {
                        if (!this.game.device.cocoonJS && null === this._onKeyDown) {
                            var t = this;
                            this._onKeyDown = function(e) {
                                return t.processKeyDown(e)
                            }, this._onKeyUp = function(e) {
                                return t.processKeyUp(e)
                            }, this._onKeyPress = function(e) {
                                return t.processKeyPress(e)
                            }, window.addEventListener("keydown", this._onKeyDown, !1), window.addEventListener("keyup", this._onKeyUp, !1), window.addEventListener("keypress", this._onKeyPress, !1)
                        }
                    },
                    stop: function() {
                        window.removeEventListener("keydown", this._onKeyDown), window.removeEventListener("keyup", this._onKeyUp), window.removeEventListener("keypress", this._onKeyPress), this._onKeyDown = null, this._onKeyUp = null, this._onKeyPress = null
                    },
                    destroy: function() {
                        this.stop(), this.clearCaptures(), this._keys.length = 0, this._i = 0
                    },
                    addKeyCapture: function(t) {
                        if ("object" == typeof t)
                            for (var e in t) this._capture[t[e]] = !0;
                        else this._capture[t] = !0
                    },
                    removeKeyCapture: function(t) {
                        delete this._capture[t]
                    },
                    clearCaptures: function() {
                        this._capture = {}
                    },
                    update: function() {
                        for (this._i = this._keys.length; this._i--;) this._keys[this._i] && this._keys[this._i].update()
                    },
                    processKeyDown: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new a.Key(this.game, e)), this._keys[e].processKeyDown(t), this._k = e, this.onDownCallback && this.onDownCallback.call(this.callbackContext, t)
                        }
                    },
                    processKeyPress: function(t) {
                        this.pressEvent = t, this.game.input.enabled && this.enabled && this.onPressCallback && this.onPressCallback.call(this.callbackContext, String.fromCharCode(t.charCode), t)
                    },
                    processKeyUp: function(t) {
                        if (this.event = t, this.game.input.enabled && this.enabled) {
                            var e = t.keyCode;
                            this._capture[e] && t.preventDefault(), this._keys[e] || (this._keys[e] = new a.Key(this.game, e)), this._keys[e].processKeyUp(t), this.onUpCallback && this.onUpCallback.call(this.callbackContext, t)
                        }
                    },
                    reset: function(t) {
                        void 0 === t && (t = !0), this.event = null;
                        for (var e = this._keys.length; e--;) this._keys[e] && this._keys[e].reset(t)
                    },
                    downDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].downDuration(e) : null
                    },
                    upDuration: function(t, e) {
                        return this._keys[t] ? this._keys[t].upDuration(e) : null
                    },
                    isDown: function(t) {
                        return this._keys[t] ? this._keys[t].isDown : null
                    }
                }, Object.defineProperty(a.Keyboard.prototype, "lastChar", {
                    get: function() {
                        return 32 === this.event.charCode ? "" : String.fromCharCode(this.pressEvent.charCode)
                    }
                }), Object.defineProperty(a.Keyboard.prototype, "lastKey", {
                    get: function() {
                        return this._keys[this._k]
                    }
                }), a.Keyboard.prototype.constructor = a.Keyboard, a.KeyCode = {
                    A: "A".charCodeAt(0),
                    B: "B".charCodeAt(0),
                    C: "C".charCodeAt(0),
                    D: "D".charCodeAt(0),
                    E: "E".charCodeAt(0),
                    F: "F".charCodeAt(0),
                    G: "G".charCodeAt(0),
                    H: "H".charCodeAt(0),
                    I: "I".charCodeAt(0),
                    J: "J".charCodeAt(0),
                    K: "K".charCodeAt(0),
                    L: "L".charCodeAt(0),
                    M: "M".charCodeAt(0),
                    N: "N".charCodeAt(0),
                    O: "O".charCodeAt(0),
                    P: "P".charCodeAt(0),
                    Q: "Q".charCodeAt(0),
                    R: "R".charCodeAt(0),
                    S: "S".charCodeAt(0),
                    T: "T".charCodeAt(0),
                    U: "U".charCodeAt(0),
                    V: "V".charCodeAt(0),
                    W: "W".charCodeAt(0),
                    X: "X".charCodeAt(0),
                    Y: "Y".charCodeAt(0),
                    Z: "Z".charCodeAt(0),
                    ZERO: "0".charCodeAt(0),
                    ONE: "1".charCodeAt(0),
                    TWO: "2".charCodeAt(0),
                    THREE: "3".charCodeAt(0),
                    FOUR: "4".charCodeAt(0),
                    FIVE: "5".charCodeAt(0),
                    SIX: "6".charCodeAt(0),
                    SEVEN: "7".charCodeAt(0),
                    EIGHT: "8".charCodeAt(0),
                    NINE: "9".charCodeAt(0),
                    NUMPAD_0: 96,
                    NUMPAD_1: 97,
                    NUMPAD_2: 98,
                    NUMPAD_3: 99,
                    NUMPAD_4: 100,
                    NUMPAD_5: 101,
                    NUMPAD_6: 102,
                    NUMPAD_7: 103,
                    NUMPAD_8: 104,
                    NUMPAD_9: 105,
                    NUMPAD_MULTIPLY: 106,
                    NUMPAD_ADD: 107,
                    NUMPAD_ENTER: 108,
                    NUMPAD_SUBTRACT: 109,
                    NUMPAD_DECIMAL: 110,
                    NUMPAD_DIVIDE: 111,
                    F1: 112,
                    F2: 113,
                    F3: 114,
                    F4: 115,
                    F5: 116,
                    F6: 117,
                    F7: 118,
                    F8: 119,
                    F9: 120,
                    F10: 121,
                    F11: 122,
                    F12: 123,
                    F13: 124,
                    F14: 125,
                    F15: 126,
                    COLON: 186,
                    EQUALS: 187,
                    COMMA: 188,
                    UNDERSCORE: 189,
                    PERIOD: 190,
                    QUESTION_MARK: 191,
                    TILDE: 192,
                    OPEN_BRACKET: 219,
                    BACKWARD_SLASH: 220,
                    CLOSED_BRACKET: 221,
                    QUOTES: 222,
                    BACKSPACE: 8,
                    TAB: 9,
                    CLEAR: 12,
                    ENTER: 13,
                    SHIFT: 16,
                    CONTROL: 17,
                    ALT: 18,
                    CAPS_LOCK: 20,
                    ESC: 27,
                    SPACEBAR: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    PLUS: 43,
                    MINUS: 44,
                    INSERT: 45,
                    DELETE: 46,
                    HELP: 47,
                    NUM_LOCK: 144
                };
            for (var r in a.KeyCode) a.KeyCode.hasOwnProperty(r) && !r.match(/[a-z]/) && (a.Keyboard[r] = a.KeyCode[r]);
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            a.Component = function() {},
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Angle = function() {}, a.Component.Angle.prototype = {
                    angle: {
                        get: function() {
                            return a.Math.wrapAngle(a.Math.radToDeg(this.rotation))
                        },
                        set: function(t) {
                            this.rotation = a.Math.degToRad(a.Math.wrapAngle(t))
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Animation = function() {}, a.Component.Animation.prototype = {
                    play: function(t, e, i, s) {
                        if (this.animations) return this.animations.play(t, e, i, s)
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.AutoCull = function() {}, a.Component.AutoCull.prototype = {
                    autoCull: !1,
                    inCamera: {
                        get: function() {
                            return this.autoCull || this.checkWorldBounds || (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y), this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Bounds = function() {}, a.Component.Bounds.prototype = {
                    offsetX: {
                        get: function() {
                            return this.anchor.x * this.width
                        }
                    },
                    offsetY: {
                        get: function() {
                            return this.anchor.y * this.height
                        }
                    },
                    centerX: {
                        get: function() {
                            return this.x - this.offsetX + .5 * this.width
                        },
                        set: function(t) {
                            this.x = t + this.offsetX - .5 * this.width
                        }
                    },
                    centerY: {
                        get: function() {
                            return this.y - this.offsetY + .5 * this.height
                        },
                        set: function(t) {
                            this.y = t + this.offsetY - .5 * this.height
                        }
                    },
                    left: {
                        get: function() {
                            return this.x - this.offsetX
                        },
                        set: function(t) {
                            this.x = t + this.offsetX
                        }
                    },
                    right: {
                        get: function() {
                            return this.x + this.width - this.offsetX
                        },
                        set: function(t) {
                            this.x = t - this.width + this.offsetX
                        }
                    },
                    top: {
                        get: function() {
                            return this.y - this.offsetY
                        },
                        set: function(t) {
                            this.y = t + this.offsetY
                        }
                    },
                    bottom: {
                        get: function() {
                            return this.y + this.height - this.offsetY
                        },
                        set: function(t) {
                            this.y = t - this.height + this.offsetY
                        }
                    },
                    alignIn: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                            case a.TOP_LEFT:
                                this.left = t.left - i, this.top = t.top - s;
                                break;
                            case a.TOP_CENTER:
                                this.centerX = t.centerX + i, this.top = t.top - s;
                                break;
                            case a.TOP_RIGHT:
                                this.right = t.right + i, this.top = t.top - s;
                                break;
                            case a.LEFT_CENTER:
                                this.left = t.left - i, this.centerY = t.centerY + s;
                                break;
                            case a.CENTER:
                                this.centerX = t.centerX + i, this.centerY = t.centerY + s;
                                break;
                            case a.RIGHT_CENTER:
                                this.right = t.right + i, this.centerY = t.centerY + s;
                                break;
                            case a.BOTTOM_LEFT:
                                this.left = t.left - i, this.bottom = t.bottom + s;
                                break;
                            case a.BOTTOM_CENTER:
                                this.centerX = t.centerX + i, this.bottom = t.bottom + s;
                                break;
                            case a.BOTTOM_RIGHT:
                                this.right = t.right + i, this.bottom = t.bottom + s
                        }
                        return this
                    },
                    alignTo: function(t, e, i, s) {
                        switch (void 0 === i && (i = 0), void 0 === s && (s = 0), e) {
                            default:
                            case a.TOP_LEFT:
                                this.left = t.left - i, this.bottom = t.top - s;
                                break;
                            case a.TOP_CENTER:
                                this.centerX = t.centerX + i, this.bottom = t.top - s;
                                break;
                            case a.TOP_RIGHT:
                                this.right = t.right + i, this.bottom = t.top - s;
                                break;
                            case a.LEFT_TOP:
                                this.right = t.left - i, this.top = t.top - s;
                                break;
                            case a.LEFT_CENTER:
                                this.right = t.left - i, this.centerY = t.centerY + s;
                                break;
                            case a.LEFT_BOTTOM:
                                this.right = t.left - i, this.bottom = t.bottom + s;
                                break;
                            case a.RIGHT_TOP:
                                this.left = t.right + i, this.top = t.top - s;
                                break;
                            case a.RIGHT_CENTER:
                                this.left = t.right + i, this.centerY = t.centerY + s;
                                break;
                            case a.RIGHT_BOTTOM:
                                this.left = t.right + i, this.bottom = t.bottom + s;
                                break;
                            case a.BOTTOM_LEFT:
                                this.left = t.left - i, this.top = t.bottom + s;
                                break;
                            case a.BOTTOM_CENTER:
                                this.centerX = t.centerX + i, this.top = t.bottom + s;
                                break;
                            case a.BOTTOM_RIGHT:
                                this.right = t.right + i, this.top = t.bottom + s
                        }
                        return this
                    }
                }, a.Group.prototype.alignIn = a.Component.Bounds.prototype.alignIn, a.Group.prototype.alignTo = a.Component.Bounds.prototype.alignTo,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.BringToTop = function() {}, a.Component.BringToTop.prototype.bringToTop = function() {
                    return this.parent && this.parent.bringToTop(this), this
                }, a.Component.BringToTop.prototype.sendToBack = function() {
                    return this.parent && this.parent.sendToBack(this), this
                }, a.Component.BringToTop.prototype.moveUp = function() {
                    return this.parent && this.parent.moveUp(this), this
                }, a.Component.BringToTop.prototype.moveDown = function() {
                    return this.parent && this.parent.moveDown(this), this
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Core = function() {}, a.Component.Core.install = function(t) {
                    a.Utils.mixinPrototype(this, a.Component.Core.prototype), this.components = {};
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e],
                            s = !1;
                        "Destroy" === i && (s = !0), a.Utils.mixinPrototype(this, a.Component[i].prototype, s), this.components[i] = !0
                    }
                }, a.Component.Core.init = function(t, e, i, s, n) {
                    this.game = t, this.key = s, this.data = {}, this.position.set(e, i), this.world = new a.Point(e, i), this.previousPosition = new a.Point(e, i), this.events = new a.Events(this), this._bounds = new a.Rectangle, this.components.PhysicsBody && (this.body = this.body), this.components.Animation && (this.animations = new a.AnimationManager(this)), this.components.LoadTexture && null !== s && this.loadTexture(s, n), this.components.FixedToCamera && (this.cameraOffset = new a.Point(e, i))
                }, a.Component.Core.preUpdate = function() {
                    if (this.pendingDestroy) return void this.destroy();
                    if (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !this.exists || !this.parent.exists) return this.renderOrderID = -1, !1;
                    this.world.setTo(this.game.camera.x + this.worldTransform.tx, this.game.camera.y + this.worldTransform.ty), this.visible && (this.renderOrderID = this.game.stage.currentRenderOrderID++), this.animations && this.animations.update(), this.body && this.body.preUpdate();
                    for (var t = 0; t < this.children.length; t++) this.children[t].preUpdate();
                    return !0
                }, a.Component.Core.prototype = {
                    game: null,
                    name: "",
                    data: {},
                    components: {},
                    z: 0,
                    events: void 0,
                    animations: void 0,
                    key: "",
                    world: null,
                    debug: !1,
                    previousPosition: null,
                    previousRotation: 0,
                    renderOrderID: 0,
                    fresh: !0,
                    pendingDestroy: !1,
                    _bounds: null,
                    _exists: !0,
                    exists: {
                        get: function() {
                            return this._exists
                        },
                        set: function(t) {
                            t ? (this._exists = !0, this.body && this.body.type === a.Physics.P2JS && this.body.addToWorld(), this.visible = !0) : (this._exists = !1, this.body && this.body.type === a.Physics.P2JS && this.body.removeFromWorld(), this.visible = !1)
                        }
                    },
                    update: function() {},
                    postUpdate: function() {
                        this.customRender && this.key.render(), this.components.PhysicsBody && a.Component.PhysicsBody.postUpdate.call(this), this.components.FixedToCamera && a.Component.FixedToCamera.postUpdate.call(this);
                        for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Crop = function() {}, a.Component.Crop.prototype = {
                    cropRect: null,
                    _crop: null,
                    crop: function(t, e) {
                        void 0 === e && (e = !1), t ? (e && null !== this.cropRect ? this.cropRect.setTo(t.x, t.y, t.width, t.height) : e && null === this.cropRect ? this.cropRect = new a.Rectangle(t.x, t.y, t.width, t.height) : this.cropRect = t, this.updateCrop()) : (this._crop = null, this.cropRect = null, this.resetFrame())
                    },
                    updateCrop: function() {
                        if (this.cropRect) {
                            var t = this.texture.crop.x,
                                e = this.texture.crop.y,
                                i = this.texture.crop.width,
                                s = this.texture.crop.height;
                            this._crop = a.Rectangle.clone(this.cropRect, this._crop), this._crop.x += this._frame.x, this._crop.y += this._frame.y;
                            var n = Math.max(this._frame.x, this._crop.x),
                                o = Math.max(this._frame.y, this._crop.y),
                                r = Math.min(this._frame.right, this._crop.right) - n,
                                h = Math.min(this._frame.bottom, this._crop.bottom) - o;
                            this.texture.crop.x = n, this.texture.crop.y = o, this.texture.crop.width = r, this.texture.crop.height = h, this.texture.frame.width = Math.min(r, this.cropRect.width), this.texture.frame.height = Math.min(h, this.cropRect.height), this.texture.width = this.texture.frame.width, this.texture.height = this.texture.frame.height, this.texture._updateUvs(), 16777215 === this.tint || t === n && e === o && i === r && s === h || (this.texture.requiresReTint = !0)
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Delta = function() {}, a.Component.Delta.prototype = {
                    deltaX: {
                        get: function() {
                            return this.world.x - this.previousPosition.x
                        }
                    },
                    deltaY: {
                        get: function() {
                            return this.world.y - this.previousPosition.y
                        }
                    },
                    deltaZ: {
                        get: function() {
                            return this.rotation - this.previousRotation
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Destroy = function() {}, a.Component.Destroy.prototype = {
                    destroyPhase: !1,
                    destroy: function(t, e) {
                        if (null !== this.game && !this.destroyPhase) {
                            void 0 === t && (t = !0), void 0 === e && (e = !1), this.destroyPhase = !0, this.events && this.events.onDestroy$dispatch(this), this.parent && (this.parent instanceof a.Group ? this.parent.remove(this) : this.parent.removeChild(this)), this.input && this.input.destroy(), this.animations && this.animations.destroy(), this.body && this.body.destroy(), this.events && this.events.destroy(), this.game.tweens.removeFrom(this);
                            var i = this.children.length;
                            if (t)
                                for (; i--;) this.children[i].destroy(t);
                            else
                                for (; i--;) this.removeChild(this.children[i]);
                            this._crop && (this._crop = null, this.cropRect = null), this._frame && (this._frame = null), a.Video && this.key instanceof a.Video && this.key.onChangeSource.remove(this.resizeFrame, this), a.BitmapText && this._glyphs && (this._glyphs = []), this.alive = !1, this.exists = !1, this.visible = !1, this.filters = null, this.mask = null, this.game = null, this.data = {}, this.renderable = !1, this.transformCallback && (this.transformCallback = null, this.transformCallbackContext = null), this.hitArea = null, this.parent = null, this.stage = null, this.worldTransform = null, this.filterArea = null, this._bounds = null, this._currentBounds = null, this._mask = null, this._destroyCachedSprite(), e && this.texture.destroy(!0), this.destroyPhase = !1, this.pendingDestroy = !1
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Events = function(t) {
                    this.parent = t
                }, a.Events.prototype = {
                    destroy: function() {
                        this._parent = null, this._onDestroy && this._onDestroy.dispose(), this._onAddedToGroup && this._onAddedToGroup.dispose(), this._onRemovedFromGroup && this._onRemovedFromGroup.dispose(), this._onRemovedFromWorld && this._onRemovedFromWorld.dispose(), this._onKilled && this._onKilled.dispose(), this._onRevived && this._onRevived.dispose(), this._onEnterBounds && this._onEnterBounds.dispose(), this._onOutOfBounds && this._onOutOfBounds.dispose(), this._onInputOver && this._onInputOver.dispose(), this._onInputOut && this._onInputOut.dispose(), this._onInputDown && this._onInputDown.dispose(), this._onInputUp && this._onInputUp.dispose(), this._onDragStart && this._onDragStart.dispose(), this._onDragUpdate && this._onDragUpdate.dispose(), this._onDragStop && this._onDragStop.dispose(), this._onAnimationStart && this._onAnimationStart.dispose(), this._onAnimationComplete && this._onAnimationComplete.dispose(), this._onAnimationLoop && this._onAnimationLoop.dispose()
                    },
                    onAddedToGroup: null,
                    onRemovedFromGroup: null,
                    onRemovedFromWorld: null,
                    onDestroy: null,
                    onKilled: null,
                    onRevived: null,
                    onOutOfBounds: null,
                    onEnterBounds: null,
                    onInputOver: null,
                    onInputOut: null,
                    onInputDown: null,
                    onInputUp: null,
                    onDragStart: null,
                    onDragUpdate: null,
                    onDragStop: null,
                    onAnimationStart: null,
                    onAnimationComplete: null,
                    onAnimationLoop: null
                }, a.Events.prototype.constructor = a.Events;
            for (var h in a.Events.prototype) a.Events.prototype.hasOwnProperty(h) && 0 === h.indexOf("on") && null === a.Events.prototype[h] && function(t, e) {
                "use strict";
                Object.defineProperty(a.Events.prototype, t, {
                    get: function() {
                        return this[e] || (this[e] = new a.Signal)
                    }
                }), a.Events.prototype[t + "$dispatch"] = function() {
                    return this[e] ? this[e].dispatch.apply(this[e], arguments) : null
                }
            }(h, "_" + h);
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            a.Component.FixedToCamera = function() {}, a.Component.FixedToCamera.postUpdate = function() {
                    this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y)
                }, a.Component.FixedToCamera.prototype = {
                    _fixedToCamera: !1,
                    fixedToCamera: {
                        get: function() {
                            return this._fixedToCamera
                        },
                        set: function(t) {
                            t ? (this._fixedToCamera = !0, this.cameraOffset.set(this.x, this.y)) : this._fixedToCamera = !1
                        }
                    },
                    cameraOffset: new a.Point
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Health = function() {}, a.Component.Health.prototype = {
                    health: 1,
                    maxHealth: 100,
                    damage: function(t) {
                        return this.alive && (this.health -= t, this.health <= 0 && this.kill()), this
                    },
                    setHealth: function(t) {
                        return this.health = t, this.health > this.maxHealth && (this.health = this.maxHealth), this
                    },
                    heal: function(t) {
                        return this.alive && (this.health += t, this.health > this.maxHealth && (this.health = this.maxHealth)), this
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.InCamera = function() {}, a.Component.InCamera.prototype = {
                    inCamera: {
                        get: function() {
                            return this.game.world.camera.view.intersects(this._bounds)
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.InputEnabled = function() {}, a.Component.InputEnabled.prototype = {
                    input: null,
                    inputEnabled: {
                        get: function() {
                            return this.input && this.input.enabled
                        },
                        set: function(t) {
                            t ? null === this.input ? (this.input = new a.InputHandler(this), this.input.start()) : this.input && !this.input.enabled && this.input.start() : this.input && this.input.enabled && this.input.stop()
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.InWorld = function() {}, a.Component.InWorld.preUpdate = function() {
                    if (this.autoCull || this.checkWorldBounds) {
                        if (this._bounds.copyFrom(this.getBounds()), this._bounds.x += this.game.camera.view.x, this._bounds.y += this.game.camera.view.y, this.autoCull)
                            if (this.game.world.camera.view.intersects(this._bounds)) this.renderable = !0, this.game.world.camera.totalInView++;
                            else if (this.renderable = !1, this.outOfCameraBoundsKill) return this.kill(), !1;
                        if (this.checkWorldBounds)
                            if (this._outOfBoundsFired && this.game.world.bounds.intersects(this._bounds)) this._outOfBoundsFired = !1, this.events.onEnterBounds$dispatch(this);
                            else if (!this._outOfBoundsFired && !this.game.world.bounds.intersects(this._bounds) && (this._outOfBoundsFired = !0, this.events.onOutOfBounds$dispatch(this), this.outOfBoundsKill)) return this.kill(), !1
                    }
                    return !0
                }, a.Component.InWorld.prototype = {
                    checkWorldBounds: !1,
                    outOfBoundsKill: !1,
                    outOfCameraBoundsKill: !1,
                    _outOfBoundsFired: !1,
                    inWorld: {
                        get: function() {
                            return this.game.world.bounds.intersects(this.getBounds())
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.LifeSpan = function() {}, a.Component.LifeSpan.preUpdate = function() {
                    return !(this.lifespan > 0 && (this.lifespan -= this.game.time.physicsElapsedMS, this.lifespan <= 0)) || (this.kill(), !1)
                }, a.Component.LifeSpan.prototype = {
                    alive: !0,
                    lifespan: 0,
                    revive: function(t) {
                        return void 0 === t && (t = 100), this.alive = !0, this.exists = !0, this.visible = !0, "function" == typeof this.setHealth && this.setHealth(t), this.events && this.events.onRevived$dispatch(this), this
                    },
                    kill: function() {
                        return this.alive = !1, this.exists = !1, this.visible = !1, this.events && this.events.onKilled$dispatch(this), this
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.LoadTexture = function() {}, a.Component.LoadTexture.prototype = {
                    customRender: !1,
                    _frame: null,
                    loadTexture: function(t, e, i) {
                        t === a.PENDING_ATLAS ? (t = e, e = 0) : e = e || 0, (i || void 0 === i) && this.animations && this.animations.stop(), this.key = t, this.customRender = !1;
                        var s = this.game.cache,
                            n = !0,
                            o = !this.texture.baseTexture.scaleMode;
                        if (a.RenderTexture && t instanceof a.RenderTexture) this.key = t.key, this.setTexture(t);
                        else if (a.BitmapData && t instanceof a.BitmapData) this.customRender = !0, this.setTexture(t.texture), n = s.hasFrameData(t.key, a.Cache.BITMAPDATA) ? !this.animations.loadFrameData(s.getFrameData(t.key, a.Cache.BITMAPDATA), e) : !this.animations.loadFrameData(t.frameData, 0);
                        else if (a.Video && t instanceof a.Video) {
                            this.customRender = !0;
                            var r = t.texture.valid;
                            this.setTexture(t.texture), this.setFrame(t.texture.frame.clone()), t.onChangeSource.add(this.resizeFrame, this), this.texture.valid = r
                        } else if (a.Tilemap && t instanceof a.TilemapLayer) this.setTexture(PIXI.Texture.fromCanvas(t.canvas));
                        else if (t instanceof PIXI.Texture) this.setTexture(t);
                        else {
                            var h = s.getImage(t, !0);
                            this.key = h.key, this.setTexture(new PIXI.Texture(h.base)), this.texture.baseTexture.skipRender = "__default" === t, n = !this.animations.loadFrameData(h.frameData, e)
                        }
                        n && (this._frame = a.Rectangle.clone(this.texture.frame)), o || (this.texture.baseTexture.scaleMode = 1)
                    },
                    setFrame: function(t) {
                        this._frame = t, this.texture.frame.x = t.x, this.texture.frame.y = t.y, this.texture.frame.width = t.width, this.texture.frame.height = t.height, this.texture.crop.x = t.x, this.texture.crop.y = t.y, this.texture.crop.width = t.width, this.texture.crop.height = t.height, t.trimmed ? (this.texture.trim ? (this.texture.trim.x = t.spriteSourceSizeX, this.texture.trim.y = t.spriteSourceSizeY, this.texture.trim.width = t.sourceSizeW, this.texture.trim.height = t.sourceSizeH) : this.texture.trim = {
                            x: t.spriteSourceSizeX,
                            y: t.spriteSourceSizeY,
                            width: t.sourceSizeW,
                            height: t.sourceSizeH
                        }, this.texture.width = t.sourceSizeW, this.texture.height = t.sourceSizeH, this.texture.frame.width = t.sourceSizeW, this.texture.frame.height = t.sourceSizeH) : !t.trimmed && this.texture.trim && (this.texture.trim = null), this.cropRect && this.updateCrop(), this.texture.requiresReTint = !0, this.texture._updateUvs(), this.tilingTexture && (this.refreshTexture = !0)
                    },
                    resizeFrame: function(t, e, i) {
                        this.texture.frame.resize(e, i), this.texture.setFrame(this.texture.frame)
                    },
                    resetFrame: function() {
                        this._frame && this.setFrame(this._frame)
                    },
                    frame: {
                        get: function() {
                            return this.animations.frame
                        },
                        set: function(t) {
                            this.animations.frame = t
                        }
                    },
                    frameName: {
                        get: function() {
                            return this.animations.frameName
                        },
                        set: function(t) {
                            this.animations.frameName = t
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Overlap = function() {}, a.Component.Overlap.prototype = {
                    overlap: function(t) {
                        return a.Rectangle.intersects(this.getBounds(), t.getBounds())
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.PhysicsBody = function() {}, a.Component.PhysicsBody.preUpdate = function() {
                    return this.fresh && this.exists ? (this.world.setTo(this.parent.position.x + this.position.x, this.parent.position.y + this.position.y), this.worldTransform.tx = this.world.x, this.worldTransform.ty = this.world.y, this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, this.body && this.body.preUpdate(), this.fresh = !1, !1) : (this.previousPosition.set(this.world.x, this.world.y), this.previousRotation = this.rotation, !(!this._exists || !this.parent.exists) || (this.renderOrderID = -1, !1))
                }, a.Component.PhysicsBody.postUpdate = function() {
                    this.exists && this.body && this.body.postUpdate()
                }, a.Component.PhysicsBody.prototype = {
                    body: null,
                    x: {
                        get: function() {
                            return this.position.x
                        },
                        set: function(t) {
                            this.position.x = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    },
                    y: {
                        get: function() {
                            return this.position.y
                        },
                        set: function(t) {
                            this.position.y = t, this.body && !this.body.dirty && (this.body._reset = !0)
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Reset = function() {}, a.Component.Reset.prototype.reset = function(t, e, i) {
                    return void 0 === i && (i = 1), this.world.set(t, e), this.position.set(t, e), this.fresh = !0, this.exists = !0, this.visible = !0, this.renderable = !0, this.components.InWorld && (this._outOfBoundsFired = !1), this.components.LifeSpan && (this.alive = !0, this.health = i), this.components.PhysicsBody && this.body && this.body.reset(t, e, !1, !1), this
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.ScaleMinMax = function() {}, a.Component.ScaleMinMax.prototype = {
                    transformCallback: null,
                    transformCallbackContext: this,
                    scaleMin: null,
                    scaleMax: null,
                    checkTransform: function(t) {
                        this.scaleMin && (t.a < this.scaleMin.x && (t.a = this.scaleMin.x), t.d < this.scaleMin.y && (t.d = this.scaleMin.y)), this.scaleMax && (t.a > this.scaleMax.x && (t.a = this.scaleMax.x), t.d > this.scaleMax.y && (t.d = this.scaleMax.y))
                    },
                    setScaleMinMax: function(t, e, i, s) {
                        void 0 === e ? e = i = s = t : void 0 === i && (i = s = e, e = t), null === t ? this.scaleMin = null : this.scaleMin ? this.scaleMin.set(t, e) : this.scaleMin = new a.Point(t, e), null === i ? this.scaleMax = null : this.scaleMax ? this.scaleMax.set(i, s) : this.scaleMax = new a.Point(i, s), null === this.scaleMin ? this.transformCallback = null : (this.transformCallback = this.checkTransform, this.transformCallbackContext = this)
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Component.Smoothed = function() {}, a.Component.Smoothed.prototype = {
                    smoothed: {
                        get: function() {
                            return !this.texture.baseTexture.scaleMode
                        },
                        set: function(t) {
                            t ? this.texture && (this.texture.baseTexture.scaleMode = 0) : this.texture && (this.texture.baseTexture.scaleMode = 1)
                        }
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.GameObjectFactory = function(t) {
                    this.game = t, this.world = this.game.world
                }, a.GameObjectFactory.prototype = {
                    existing: function(t) {
                        return this.world.add(t)
                    },
                    weapon: function(t, e, i, s) {
                        var n = this.game.plugins.add(a.Weapon);
                        return n.createBullets(t, e, i, s), n
                    },
                    image: function(t, e, i, s, n) {
                        return void 0 === n && (n = this.world), n.add(new a.Image(this.game, t, e, i, s))
                    },
                    sprite: function(t, e, i, s, n) {
                        return void 0 === n && (n = this.world), n.create(t, e, i, s)
                    },
                    creature: function(t, e, i, s, n) {
                        void 0 === n && (n = this.world);
                        var o = new a.Creature(this.game, t, e, i, s);
                        return n.add(o), o
                    },
                    tween: function(t) {
                        return this.game.tweens.create(t)
                    },
                    group: function(t, e, i, s, n) {
                        return new a.Group(this.game, t, e, i, s, n)
                    },
                    physicsGroup: function(t, e, i, s) {
                        return new a.Group(this.game, e, i, s, !0, t)
                    },
                    spriteBatch: function(t, e, i) {
                        return void 0 === t && (t = null), void 0 === e && (e = "group"), void 0 === i && (i = !1), new a.SpriteBatch(this.game, t, e, i)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    tileSprite: function(t, e, i, s, n, o, r) {
                        return void 0 === r && (r = this.world), r.add(new a.TileSprite(this.game, t, e, i, s, n, o))
                    },
                    rope: function(t, e, i, s, n, o) {
                        return void 0 === o && (o = this.world), o.add(new a.Rope(this.game, t, e, i, s, n))
                    },
                    text: function(t, e, i, s, n) {
                        return void 0 === n && (n = this.world), n.add(new a.Text(this.game, t, e, i, s))
                    },
                    button: function(t, e, i, s, n, o, r, h, l, c) {
                        return void 0 === c && (c = this.world), c.add(new a.Button(this.game, t, e, i, s, n, o, r, h, l))
                    },
                    graphics: function(t, e, i) {
                        return void 0 === i && (i = this.world), i.add(new a.Graphics(this.game, t, e))
                    },
                    emitter: function(t, e, i) {
                        return this.game.particles.add(new a.Particles.Arcade.Emitter(this.game, t, e, i))
                    },
                    retroFont: function(t, e, i, s, n, o, r, h, l) {
                        return new a.RetroFont(this.game, t, e, i, s, n, o, r, h, l)
                    },
                    bitmapText: function(t, e, i, s, n, o) {
                        return void 0 === o && (o = this.world), o.add(new a.BitmapText(this.game, t, e, i, s, n))
                    },
                    tilemap: function(t, e, i, s, n) {
                        return new a.Tilemap(this.game, t, e, i, s, n)
                    },
                    renderTexture: function(t, e, i, s) {
                        void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                        var n = new a.RenderTexture(this.game, t, e, i);
                        return s && this.game.cache.addRenderTexture(i, n), n
                    },
                    video: function(t, e) {
                        return new a.Video(this.game, t, e)
                    },
                    bitmapData: function(t, e, i, s) {
                        void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                        var n = new a.BitmapData(this.game, i, t, e);
                        return s && this.game.cache.addBitmapData(i, n), n
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            t = new a.Filter[t](this.game);
                        return t.init.apply(t, e), t
                    },
                    plugin: function(t) {
                        return this.game.plugins.add(t)
                    }
                }, a.GameObjectFactory.prototype.constructor = a.GameObjectFactory,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.GameObjectCreator = function(t) {
                    this.game = t, this.world = this.game.world
                }, a.GameObjectCreator.prototype = {
                    image: function(t, e, i, s) {
                        return new a.Image(this.game, t, e, i, s)
                    },
                    sprite: function(t, e, i, s) {
                        return new a.Sprite(this.game, t, e, i, s)
                    },
                    tween: function(t) {
                        return new a.Tween(t, this.game, this.game.tweens)
                    },
                    group: function(t, e, i, s, n) {
                        return new a.Group(this.game, t, e, i, s, n)
                    },
                    spriteBatch: function(t, e, i) {
                        return void 0 === e && (e = "group"), void 0 === i && (i = !1), new a.SpriteBatch(this.game, t, e, i)
                    },
                    audio: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    audioSprite: function(t) {
                        return this.game.sound.addSprite(t)
                    },
                    sound: function(t, e, i, s) {
                        return this.game.sound.add(t, e, i, s)
                    },
                    tileSprite: function(t, e, i, s, n, o) {
                        return new a.TileSprite(this.game, t, e, i, s, n, o)
                    },
                    rope: function(t, e, i, s, n) {
                        return new a.Rope(this.game, t, e, i, s, n)
                    },
                    text: function(t, e, i, s) {
                        return new a.Text(this.game, t, e, i, s)
                    },
                    button: function(t, e, i, s, n, o, r, h, l) {
                        return new a.Button(this.game, t, e, i, s, n, o, r, h, l)
                    },
                    graphics: function(t, e) {
                        return new a.Graphics(this.game, t, e)
                    },
                    emitter: function(t, e, i) {
                        return new a.Particles.Arcade.Emitter(this.game, t, e, i)
                    },
                    retroFont: function(t, e, i, s, n, o, r, h, l) {
                        return new a.RetroFont(this.game, t, e, i, s, n, o, r, h, l)
                    },
                    bitmapText: function(t, e, i, s, n, o) {
                        return new a.BitmapText(this.game, t, e, i, s, n, o)
                    },
                    tilemap: function(t, e, i, s, n) {
                        return new a.Tilemap(this.game, t, e, i, s, n)
                    },
                    renderTexture: function(t, e, i, s) {
                        void 0 !== i && "" !== i || (i = this.game.rnd.uuid()), void 0 === s && (s = !1);
                        var n = new a.RenderTexture(this.game, t, e, i);
                        return s && this.game.cache.addRenderTexture(i, n), n
                    },
                    bitmapData: function(t, e, i, s) {
                        void 0 === s && (s = !1), void 0 !== i && "" !== i || (i = this.game.rnd.uuid());
                        var n = new a.BitmapData(this.game, i, t, e);
                        return s && this.game.cache.addBitmapData(i, n), n
                    },
                    filter: function(t) {
                        var e = Array.prototype.slice.call(arguments, 1),
                            t = new a.Filter[t](this.game);
                        return t.init.apply(t, e), t
                    }
                }, a.GameObjectCreator.prototype.constructor = a.GameObjectCreator,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Sprite = function(t, e, i, s, n) {
                    e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = a.SPRITE, this.physicsType = a.SPRITE, PIXI.Sprite.call(this, a.Cache.DEFAULT), a.Component.Core.init.call(this, t, e, i, s, n)
                }, a.Sprite.prototype = Object.create(PIXI.Sprite.prototype), a.Sprite.prototype.constructor = a.Sprite, a.Component.Core.install.call(a.Sprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), a.Sprite.prototype.preUpdatePhysics = a.Component.PhysicsBody.preUpdate, a.Sprite.prototype.preUpdateLifeSpan = a.Component.LifeSpan.preUpdate, a.Sprite.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.Sprite.prototype.preUpdateCore = a.Component.Core.preUpdate, a.Sprite.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Image = function(t, e, i, s, n) {
                    e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = a.IMAGE, PIXI.Sprite.call(this, a.Cache.DEFAULT), a.Component.Core.init.call(this, t, e, i, s, n)
                }, a.Image.prototype = Object.create(PIXI.Sprite.prototype), a.Image.prototype.constructor = a.Image, a.Component.Core.install.call(a.Image.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Destroy", "FixedToCamera", "InputEnabled", "LifeSpan", "LoadTexture", "Overlap", "Reset", "ScaleMinMax", "Smoothed"]), a.Image.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.Image.prototype.preUpdateCore = a.Component.Core.preUpdate, a.Image.prototype.preUpdate = function() {
                    return !!this.preUpdateInWorld() && this.preUpdateCore()
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Button = function(t, e, i, s, n, o, r, h, l, c) {
                    e = e || 0, i = i || 0, s = s || null, n = n || null, o = o || this, a.Image.call(this, t, e, i, s, h), this.type = a.BUTTON, this.physicsType = a.SPRITE, this._onOverFrame = null, this._onOutFrame = null, this._onDownFrame = null, this._onUpFrame = null, this.onOverSound = null, this.onOutSound = null, this.onDownSound = null, this.onUpSound = null, this.onOverSoundMarker = "", this.onOutSoundMarker = "", this.onDownSoundMarker = "", this.onUpSoundMarker = "", this.onInputOver = new a.Signal, this.onInputOut = new a.Signal, this.onInputDown = new a.Signal, this.onInputUp = new a.Signal, this.onOverMouseOnly = !0, this.justReleasedPreventsOver = a.PointerMode.TOUCH, this.freezeFrames = !1, this.forceOut = !1, this.inputEnabled = !0, this.input.start(0, !0), this.input.useHandCursor = !0, this.setFrames(r, h, l, c), null !== n && this.onInputUp.add(n, o), this.events.onInputOver.add(this.onInputOverHandler, this), this.events.onInputOut.add(this.onInputOutHandler, this), this.events.onInputDown.add(this.onInputDownHandler, this), this.events.onInputUp.add(this.onInputUpHandler, this), this.events.onRemovedFromWorld.add(this.removedFromWorld, this)
                }, a.Button.prototype = Object.create(a.Image.prototype), a.Button.prototype.constructor = a.Button;
            var l = "Over",
                c = "Out",
                u = "Down",
                d = "Up";
            a.Button.prototype.clearFrames = function() {
                    this.setFrames(null, null, null, null)
                }, a.Button.prototype.removedFromWorld = function() {
                    this.inputEnabled = !1
                }, a.Button.prototype.setStateFrame = function(t, e, i) {
                    var s = "_on" + t + "Frame";
                    null !== e ? (this[s] = e, i && this.changeStateFrame(t)) : this[s] = null
                }, a.Button.prototype.changeStateFrame = function(t) {
                    if (this.freezeFrames) return !1;
                    var e = "_on" + t + "Frame",
                        i = this[e];
                    return "string" == typeof i ? (this.frameName = i, !0) : "number" == typeof i && (this.frame = i, !0)
                }, a.Button.prototype.setFrames = function(t, e, i, s) {
                    this.setStateFrame("Over", t, this.input.pointerOver()), this.setStateFrame("Out", e, !this.input.pointerOver()), this.setStateFrame("Down", i, this.input.pointerDown()), this.setStateFrame("Up", s, this.input.pointerUp())
                }, a.Button.prototype.setStateSound = function(t, e, i) {
                    var s = "on" + t + "Sound",
                        n = "on" + t + "SoundMarker";
                    e instanceof a.Sound || e instanceof a.AudioSprite ? (this[s] = e, this[n] = "string" == typeof i ? i : "") : (this[s] = null, this[n] = "")
                }, a.Button.prototype.playStateSound = function(t) {
                    var e = "on" + t + "Sound",
                        i = this[e];
                    if (i) {
                        var s = "on" + t + "SoundMarker",
                            n = this[s];
                        return i.play(n), !0
                    }
                    return !1
                }, a.Button.prototype.setSounds = function(t, e, i, s, n, a, o, r) {
                    this.setStateSound("Over", t, e), this.setStateSound("Out", n, a), this.setStateSound("Down", i, s), this.setStateSound("Up", o, r)
                }, a.Button.prototype.setOverSound = function(t, e) {
                    this.setStateSound("Over", t, e)
                }, a.Button.prototype.setOutSound = function(t, e) {
                    this.setStateSound("Out", t, e)
                }, a.Button.prototype.setDownSound = function(t, e) {
                    this.setStateSound("Down", t, e)
                }, a.Button.prototype.setUpSound = function(t, e) {
                    this.setStateSound("Up", t, e)
                }, a.Button.prototype.onInputOverHandler = function(t, e) {
                    e.justReleased() && (this.justReleasedPreventsOver & e.pointerMode) === e.pointerMode || (this.changeStateFrame("Over"), this.onOverMouseOnly && !e.isMouse || (this.playStateSound("Over"), this.onInputOver && this.onInputOver.dispatch(this, e)))
                }, a.Button.prototype.onInputOutHandler = function(t, e) {
                    this.changeStateFrame("Out"), this.playStateSound("Out"), this.onInputOut && this.onInputOut.dispatch(this, e)
                }, a.Button.prototype.onInputDownHandler = function(t, e) {
                    this.changeStateFrame("Down"), this.playStateSound("Down"), this.onInputDown && this.onInputDown.dispatch(this, e)
                }, a.Button.prototype.onInputUpHandler = function(t, e, i) {
                    if (this.playStateSound("Up"), this.onInputUp && this.onInputUp.dispatch(this, e, i), !this.freezeFrames)
                        if (!0 === this.forceOut || (this.forceOut & e.pointerMode) === e.pointerMode) this.changeStateFrame("Out");
                        else {
                            var s = this.changeStateFrame("Up");
                            s || (i ? this.changeStateFrame("Over") : this.changeStateFrame("Out"))
                        }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.SpriteBatch = function(t, e, i, s) {
                    void 0 !== e && null !== e || (e = t.world), PIXI.SpriteBatch.call(this), a.Group.call(this, t, e, i, s), this.type = a.SPRITEBATCH
                }, a.SpriteBatch.prototype = a.Utils.extend(!0, a.SpriteBatch.prototype, PIXI.SpriteBatch.prototype, a.Group.prototype), a.SpriteBatch.prototype.constructor = a.SpriteBatch,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.BitmapData = function(t, e, i, s, n) {
                    void 0 !== i && 0 !== i || (i = 256), void 0 !== s && 0 !== s || (s = 256), void 0 === n && (n = !1), this.game = t, this.key = e, this.width = i, this.height = s, this.canvas = a.Canvas.create(this, i, s, null, n), this.context = this.canvas.getContext("2d", {
                        alpha: !0
                    }), this.ctx = this.context, this.smoothProperty = t.renderType === a.CANVAS ? t.renderer.renderSession.smoothProperty : a.Canvas.getSmoothingPrefix(this.context), this.imageData = this.context.getImageData(0, 0, i, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data), this.baseTexture = new PIXI.BaseTexture(this.canvas), this.texture = new PIXI.Texture(this.baseTexture), this.frameData = new a.FrameData, this.textureFrame = this.frameData.addFrame(new a.Frame(0, 0, 0, i, s, "bitmapData")), this.texture.frame = this.textureFrame, this.type = a.BITMAPDATA, this.disableTextureUpload = !1, this.dirty = !1, this.cls = this.clear, this._image = null, this._pos = new a.Point, this._size = new a.Point, this._scale = new a.Point, this._rotate = 0, this._alpha = {
                        prev: 1,
                        current: 1
                    }, this._anchor = new a.Point, this._tempR = 0, this._tempG = 0, this._tempB = 0, this._circle = new a.Circle, this._swapCanvas = void 0
                }, a.BitmapData.prototype = {
                    move: function(t, e, i) {
                        return 0 !== t && this.moveH(t, i), 0 !== e && this.moveV(e, i), this
                    },
                    moveH: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                        var i = this._swapCanvas,
                            s = i.getContext("2d"),
                            n = this.height,
                            a = this.canvas;
                        if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            var o = this.width - t;
                            e && s.drawImage(a, 0, 0, t, n, o, 0, t, n), s.drawImage(a, t, 0, o, n, 0, 0, o, n)
                        } else {
                            var o = this.width - t;
                            e && s.drawImage(a, o, 0, t, n, 0, 0, t, n), s.drawImage(a, 0, 0, o, n, t, 0, o, n)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    moveV: function(t, e) {
                        void 0 === e && (e = !0), void 0 === this._swapCanvas && (this._swapCanvas = PIXI.CanvasPool.create(this, this.width, this.height));
                        var i = this._swapCanvas,
                            s = i.getContext("2d"),
                            n = this.width,
                            a = this.canvas;
                        if (s.clearRect(0, 0, this.width, this.height), t < 0) {
                            t = Math.abs(t);
                            var o = this.height - t;
                            e && s.drawImage(a, 0, 0, n, t, 0, o, n, t), s.drawImage(a, 0, t, n, o, 0, 0, n, o)
                        } else {
                            var o = this.height - t;
                            e && s.drawImage(a, 0, o, n, t, 0, 0, n, t), s.drawImage(a, 0, 0, n, o, 0, t, n, o)
                        }
                        return this.clear(), this.copy(this._swapCanvas)
                    },
                    add: function(t) {
                        if (Array.isArray(t))
                            for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                        else t.loadTexture(this);
                        return this
                    },
                    load: function(t) {
                        if ("string" == typeof t && (t = this.game.cache.getImage(t)), t) return this.resize(t.width, t.height), this.cls(), this.draw(t), this.update(), this
                    },
                    clear: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === s && (s = this.height), this.context.clearRect(t, e, i, s), this.dirty = !0, this
                    },
                    fill: function(t, e, i, s) {
                        return void 0 === s && (s = 1), this.context.fillStyle = "rgba(" + t + "," + e + "," + i + "," + s + ")", this.context.fillRect(0, 0, this.width, this.height), this.dirty = !0, this
                    },
                    generateTexture: function(t) {
                        var e = new Image;
                        e.src = this.canvas.toDataURL("image/png");
                        var i = this.game.cache.addImage(t, "", e);
                        return new PIXI.Texture(i.base)
                    },
                    resize: function(t, e) {
                        return t === this.width && e === this.height || (this.width = t, this.height = e, this.canvas.width = t, this.canvas.height = e, void 0 !== this._swapCanvas && (this._swapCanvas.width = t, this._swapCanvas.height = e), this.baseTexture.width = t, this.baseTexture.height = e, this.textureFrame.width = t, this.textureFrame.height = e, this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.update(), this.dirty = !0), this
                    },
                    update: function(t, e, i, s) {
                        return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = Math.max(1, this.width)), void 0 === s && (s = Math.max(1, this.height)), this.imageData = this.context.getImageData(t, e, i, s), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this
                    },
                    processPixelRGB: function(t, e, i, s, n, o) {
                        void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === o && (o = this.height);
                        for (var r = i + n, h = s + o, l = a.Color.createColor(), c = {
                                r: 0,
                                g: 0,
                                b: 0,
                                a: 0
                            }, u = !1, d = s; d < h; d++)
                            for (var p = i; p < r; p++) a.Color.unpackPixel(this.getPixel32(p, d), l), !1 !== (c = t.call(e, l, p, d)) && null !== c && void 0 !== c && (this.setPixel32(p, d, c.r, c.g, c.b, c.a, !1), u = !0);
                        return u && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    processPixel: function(t, e, i, s, n, a) {
                        void 0 === i && (i = 0), void 0 === s && (s = 0), void 0 === n && (n = this.width), void 0 === a && (a = this.height);
                        for (var o = i + n, r = s + a, h = 0, l = 0, c = !1, u = s; u < r; u++)
                            for (var d = i; d < o; d++) h = this.getPixel32(d, u), (l = t.call(e, h, d, u)) !== h && (this.pixels[u * this.width + d] = l, c = !0);
                        return c && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0), this
                    },
                    replaceRGB: function(t, e, i, s, n, o, r, h, l) {
                        var c = 0,
                            u = 0,
                            d = this.width,
                            p = this.height,
                            f = a.Color.packPixel(t, e, i, s);
                        void 0 !== l && l instanceof a.Rectangle && (c = l.x, u = l.y, d = l.width, p = l.height);
                        for (var g = 0; g < p; g++)
                            for (var y = 0; y < d; y++) this.getPixel32(c + y, u + g) === f && this.setPixel32(c + y, u + g, n, o, r, h, !1);
                        return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                    },
                    setHSL: function(t, e, i, s) {
                        var n = t || 0 === t,
                            o = e || 0 === e,
                            r = i || 0 === i;
                        if (n || o || r) {
                            void 0 === s && (s = new a.Rectangle(0, 0, this.width, this.height));
                            for (var h = a.Color.createColor(), l = s.y; l < s.bottom; l++)
                                for (var c = s.x; c < s.right; c++) a.Color.unpackPixel(this.getPixel32(c, l), h, !0), n && (h.h = t), o && (h.s = e), r && (h.l = i), a.Color.HSLtoRGB(h.h, h.s, h.l, h), this.setPixel32(c, l, h.r, h.g, h.b, h.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    shiftHSL: function(t, e, i, s) {
                        if (void 0 !== t && null !== t || (t = !1), void 0 !== e && null !== e || (e = !1), void 0 !== i && null !== i || (i = !1), t || e || i) {
                            void 0 === s && (s = new a.Rectangle(0, 0, this.width, this.height));
                            for (var n = a.Color.createColor(), o = s.y; o < s.bottom; o++)
                                for (var r = s.x; r < s.right; r++) a.Color.unpackPixel(this.getPixel32(r, o), n, !0), t && (n.h = this.game.math.wrap(n.h + t, 0, 1)), e && (n.s = this.game.math.clamp(n.s + e, 0, 1)), i && (n.l = this.game.math.clamp(n.l + i, 0, 1)), a.Color.HSLtoRGB(n.h, n.s, n.l, n), this.setPixel32(r, o, n.r, n.g, n.b, n.a, !1);
                            return this.context.putImageData(this.imageData, 0, 0), this.dirty = !0, this
                        }
                    },
                    setPixel32: function(t, e, i, s, n, o, r) {
                        return void 0 === r && (r = !0), t >= 0 && t <= this.width && e >= 0 && e <= this.height && (a.Device.LITTLE_ENDIAN ? this.pixels[e * this.width + t] = o << 24 | n << 16 | s << 8 | i : this.pixels[e * this.width + t] = i << 24 | s << 16 | n << 8 | o, r && (this.context.putImageData(this.imageData, 0, 0), this.dirty = !0)), this
                    },
                    setPixel: function(t, e, i, s, n, a) {
                        return this.setPixel32(t, e, i, s, n, 255, a)
                    },
                    getPixel: function(t, e, i) {
                        i || (i = a.Color.createColor());
                        var s = ~~(t + e * this.width);
                        return s *= 4, i.r = this.data[s], i.g = this.data[++s], i.b = this.data[++s], i.a = this.data[++s], i
                    },
                    getPixel32: function(t, e) {
                        if (t >= 0 && t <= this.width && e >= 0 && e <= this.height) return this.pixels[e * this.width + t]
                    },
                    getPixelRGB: function(t, e, i, s, n) {
                        return a.Color.unpackPixel(this.getPixel32(t, e), i, s, n)
                    },
                    getPixels: function(t) {
                        return this.context.getImageData(t.x, t.y, t.width, t.height)
                    },
                    getFirstPixel: function(t) {
                        void 0 === t && (t = 0);
                        var e = a.Color.createColor(),
                            i = 0,
                            s = 0,
                            n = 1,
                            o = !1;
                        1 === t ? (n = -1, s = this.height) : 3 === t && (n = -1, i = this.width);
                        do {
                            a.Color.unpackPixel(this.getPixel32(i, s), e), 0 === t || 1 === t ? ++i === this.width && (i = 0, ((s += n) >= this.height || s <= 0) && (o = !0)) : 2 !== t && 3 !== t || ++s === this.height && (s = 0, ((i += n) >= this.width || i <= 0) && (o = !0))
                        } while (0 === e.a && !o);
                        return e.x = i, e.y = s, e
                    },
                    getBounds: function(t) {
                        return void 0 === t && (t = new a.Rectangle), t.x = this.getFirstPixel(2)
                            .x, t.x === this.width ? t.setTo(0, 0, 0, 0) : (t.y = this.getFirstPixel(0)
                                .y, t.width = this.getFirstPixel(3)
                                .x - t.x + 1, t.height = this.getFirstPixel(1)
                                .y - t.y + 1, t)
                    },
                    addToWorld: function(t, e, i, s, n, a) {
                        n = n || 1, a = a || 1;
                        var o = this.game.add.image(t, e, this);
                        return o.anchor.set(i, s), o.scale.set(n, a), o
                    },
                    copy: function(t, e, i, s, n, o, r, h, l, c, u, d, p, f, g, y, m) {
                        if (void 0 !== t && null !== t || (t = this), (t instanceof a.RenderTexture || t instanceof PIXI.RenderTexture) && (t = t.getCanvas()), this._image = t, t instanceof a.Sprite || t instanceof a.Image || t instanceof a.Text || t instanceof PIXI.Sprite) this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), this._scale.set(t.scale.x, t.scale.y), this._anchor.set(t.anchor.x, t.anchor.y), this._rotate = t.rotation, this._alpha.current = t.alpha, t.texture instanceof a.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source, void 0 !== o && null !== o || (o = t.x), void 0 !== r && null !== r || (r = t.y), t.texture.trim && (o += t.texture.trim.x - t.anchor.x * t.texture.trim.width, r += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0));
                        else {
                            if (this._pos.set(0), this._scale.set(1), this._anchor.set(0), this._rotate = 0, this._alpha.current = 1, t instanceof a.BitmapData) this._image = t.canvas;
                            else if ("string" == typeof t) {
                                if (null === (t = this.game.cache.getImage(t))) return;
                                this._image = t
                            }
                            this._size.set(this._image.width, this._image.height)
                        }
                        if (void 0 !== e && null !== e || (e = 0), void 0 !== i && null !== i || (i = 0), s && (this._size.x = s), n && (this._size.y = n), void 0 !== o && null !== o || (o = e), void 0 !== r && null !== r || (r = i), void 0 !== h && null !== h || (h = this._size.x), void 0 !== l && null !== l || (l = this._size.y), "number" == typeof c && (this._rotate = c), "number" == typeof u && (this._anchor.x = u), "number" == typeof d && (this._anchor.y = d), "number" == typeof p && (this._scale.x = p), "number" == typeof f && (this._scale.y = f), "number" == typeof g && (this._alpha.current = g), void 0 === y && (y = null), void 0 === m && (m = !1), !(this._alpha.current <= 0 || 0 === this._scale.x || 0 === this._scale.y || 0 === this._size.x || 0 === this._size.y)) {
                            var v = this.context;
                            return this._alpha.prev = v.globalAlpha, v.save(), v.globalAlpha = this._alpha.current, y && (this.op = y), m && (o |= 0, r |= 0), v.translate(o, r), v.scale(this._scale.x, this._scale.y), v.rotate(this._rotate), v.drawImage(this._image, this._pos.x + e, this._pos.y + i, this._size.x, this._size.y, -h * this._anchor.x, -l * this._anchor.y, h, l), v.restore(), v.globalAlpha = this._alpha.prev, this.dirty = !0, this
                        }
                    },
                    copyTransform: function(t, e, i) {
                        if (void 0 === e && (e = null), void 0 === i && (i = !1), !t.hasOwnProperty("worldTransform") || !t.worldVisible || 0 === t.worldAlpha) return this;
                        var s = t.worldTransform;
                        if (this._pos.set(t.texture.crop.x, t.texture.crop.y), this._size.set(t.texture.crop.width, t.texture.crop.height), 0 === s.a || 0 === s.d || 0 === this._size.x || 0 === this._size.y) return this;
                        t.texture instanceof a.RenderTexture || t.texture instanceof PIXI.RenderTexture ? this._image = t.texture.getCanvas() : this._image = t.texture.baseTexture.source;
                        var n = s.tx,
                            o = s.ty;
                        t.texture.trim && (n += t.texture.trim.x - t.anchor.x * t.texture.trim.width, o += t.texture.trim.y - t.anchor.y * t.texture.trim.height), 16777215 !== t.tint && (t.cachedTint !== t.tint && (t.cachedTint = t.tint, t.tintedTexture = PIXI.CanvasTinter.getTintedTexture(t, t.tint)), this._image = t.tintedTexture, this._pos.set(0)), i && (n |= 0, o |= 0);
                        var r = this.context;
                        return this._alpha.prev = r.globalAlpha, r.save(), r.globalAlpha = this._alpha.current, e && (this.op = e), r[this.smoothProperty] = t.texture.baseTexture.scaleMode === PIXI.scaleModes.LINEAR, r.setTransform(s.a, s.b, s.c, s.d, n, o), r.drawImage(this._image, this._pos.x, this._pos.y, this._size.x, this._size.y, -this._size.x * t.anchor.x, -this._size.y * t.anchor.y, this._size.x, this._size.y), r.restore(), r.globalAlpha = this._alpha.prev, this.dirty = !0, this
                    },
                    copyRect: function(t, e, i, s, n, a, o) {
                        return this.copy(t, e.x, e.y, e.width, e.height, i, s, e.width, e.height, 0, 0, 0, 1, 1, n, a, o)
                    },
                    draw: function(t, e, i, s, n, a, o) {
                        return this.copy(t, null, null, null, null, e, i, s, n, null, null, null, null, null, null, a, o)
                    },
                    drawGroup: function(t, e, i) {
                        return t.total > 0 && t.forEachExists(this.drawGroupProxy, this, e, i), this
                    },
                    drawGroupProxy: function(t, e, i) {
                        if (t.hasOwnProperty("texture") && this.copyTransform(t, e, i), t.type === a.GROUP && t.exists) this.drawGroup(t, e, i);
                        else if (t.hasOwnProperty("children") && t.children.length > 0)
                            for (var s = 0; s < t.children.length; s++) t.children[s].exists && this.copyTransform(t.children[s], e, i)
                    },
                    drawFull: function(t, e, i) {
                        if (!1 === t.worldVisible || 0 === t.worldAlpha || t.hasOwnProperty("exists") && !1 === t.exists) return this;
                        if (t.type !== a.GROUP && t.type !== a.EMITTER && t.type !== a.BITMAPTEXT)
                            if (t.type === a.GRAPHICS) {
                                var s = t.getBounds();
                                this.ctx.save(), this.ctx.translate(s.x, s.y), PIXI.CanvasGraphics.renderGraphics(t, this.ctx), this.ctx.restore()
                            } else this.copy(t, null, null, null, null, t.worldPosition.x, t.worldPosition.y, null, null, t.worldRotation, null, null, t.worldScale.x, t.worldScale.y, t.worldAlpha, e, i);
                        if (t.children)
                            for (var n = 0; n < t.children.length; n++) this.drawFull(t.children[n], e, i);
                        return this
                    },
                    shadow: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 === t || null === t ? n.shadowColor = "rgba(0,0,0,0)" : (n.shadowColor = t, n.shadowBlur = e || 5, n.shadowOffsetX = i || 10, n.shadowOffsetY = s || 10), this
                    },
                    alphaMask: function(t, e, i, s) {
                        return void 0 === s || null === s ? this.draw(e)
                            .blendSourceAtop() : this.draw(e, s.x, s.y, s.width, s.height)
                            .blendSourceAtop(), void 0 === i || null === i ? this.draw(t)
                            .blendReset() : this.draw(t, i.x, i.y, i.width, i.height)
                            .blendReset(), this
                    },
                    extract: function(t, e, i, s, n, a, o, r, h) {
                        return void 0 === n && (n = 255), void 0 === a && (a = !1), void 0 === o && (o = e), void 0 === r && (r = i), void 0 === h && (h = s), a && t.resize(this.width, this.height), this.processPixelRGB(function(a, l, c) {
                            return a.r === e && a.g === i && a.b === s && t.setPixel32(l, c, o, r, h, n, !1), !1
                        }, this), t.context.putImageData(t.imageData, 0, 0), t.dirty = !0, t
                    },
                    rect: function(t, e, i, s, n) {
                        return void 0 !== n && (this.context.fillStyle = n), this.context.fillRect(t, e, i, s), this
                    },
                    text: function(t, e, i, s, n, a) {
                        void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = "14px Courier"), void 0 === n && (n = "rgb(255,255,255)"), void 0 === a && (a = !0);
                        var o = this.context,
                            r = o.font;
                        return o.font = s, a && (o.fillStyle = "rgb(0,0,0)", o.fillText(t, e + 1, i + 1)), o.fillStyle = n, o.fillText(t, e, i), o.font = r, this
                    },
                    circle: function(t, e, i, s) {
                        var n = this.context;
                        return void 0 !== s && (n.fillStyle = s), n.beginPath(), n.arc(t, e, i, 0, 2 * Math.PI, !1), n.closePath(), n.fill(), this
                    },
                    line: function(t, e, i, s, n, a) {
                        void 0 === n && (n = "#fff"), void 0 === a && (a = 1);
                        var o = this.context;
                        return o.beginPath(), o.moveTo(t, e), o.lineTo(i, s), o.lineWidth = a, o.strokeStyle = n, o.stroke(), o.closePath(), this
                    },
                    textureLine: function(t, e, i) {
                        if (void 0 === i && (i = "repeat-x"), "string" != typeof e || (e = this.game.cache.getImage(e))) {
                            var s = t.length;
                            "no-repeat" === i && s > e.width && (s = e.width);
                            var n = this.context;
                            return n.fillStyle = n.createPattern(e, i), this._circle = new a.Circle(t.start.x, t.start.y, e.height), this._circle.circumferencePoint(t.angle - 1.5707963267948966, !1, this._pos), n.save(), n.translate(this._pos.x, this._pos.y), n.rotate(t.angle), n.fillRect(0, 0, s, e.height), n.restore(), this.dirty = !0, this
                        }
                    },
                    render: function() {
                        return !this.disableTextureUpload && this.dirty && (this.baseTexture.dirty(), this.dirty = !1), this
                    },
                    destroy: function() {
                        this.frameData.destroy(), this.texture.destroy(!0), PIXI.CanvasPool.remove(this)
                    },
                    blendReset: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceOver: function() {
                        return this.op = "source-over", this
                    },
                    blendSourceIn: function() {
                        return this.op = "source-in", this
                    },
                    blendSourceOut: function() {
                        return this.op = "source-out", this
                    },
                    blendSourceAtop: function() {
                        return this.op = "source-atop", this
                    },
                    blendDestinationOver: function() {
                        return this.op = "destination-over", this
                    },
                    blendDestinationIn: function() {
                        return this.op = "destination-in", this
                    },
                    blendDestinationOut: function() {
                        return this.op = "destination-out", this
                    },
                    blendDestinationAtop: function() {
                        return this.op = "destination-atop", this
                    },
                    blendXor: function() {
                        return this.op = "xor", this
                    },
                    blendAdd: function() {
                        return this.op = "lighter", this
                    },
                    blendMultiply: function() {
                        return this.op = "multiply", this
                    },
                    blendScreen: function() {
                        return this.op = "screen", this
                    },
                    blendOverlay: function() {
                        return this.op = "overlay", this
                    },
                    blendDarken: function() {
                        return this.op = "darken", this
                    },
                    blendLighten: function() {
                        return this.op = "lighten", this
                    },
                    blendColorDodge: function() {
                        return this.op = "color-dodge", this
                    },
                    blendColorBurn: function() {
                        return this.op = "color-burn", this
                    },
                    blendHardLight: function() {
                        return this.op = "hard-light", this
                    },
                    blendSoftLight: function() {
                        return this.op = "soft-light", this
                    },
                    blendDifference: function() {
                        return this.op = "difference", this
                    },
                    blendExclusion: function() {
                        return this.op = "exclusion", this
                    },
                    blendHue: function() {
                        return this.op = "hue", this
                    },
                    blendSaturation: function() {
                        return this.op = "saturation", this
                    },
                    blendColor: function() {
                        return this.op = "color", this
                    },
                    blendLuminosity: function() {
                        return this.op = "luminosity", this
                    }
                }, Object.defineProperty(a.BitmapData.prototype, "smoothed", {
                    get: function() {
                        a.Canvas.getSmoothingEnabled(this.context)
                    },
                    set: function(t) {
                        a.Canvas.setSmoothingEnabled(this.context, t)
                    }
                }), Object.defineProperty(a.BitmapData.prototype, "op", {
                    get: function() {
                        return this.context.globalCompositeOperation
                    },
                    set: function(t) {
                        this.context.globalCompositeOperation = t
                    }
                }), a.BitmapData.getTransform = function(t, e, i, s, n, a) {
                    return "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), "number" != typeof i && (i = 1), "number" != typeof s && (s = 1), "number" != typeof n && (n = 0), "number" != typeof a && (a = 0), {
                        sx: i,
                        sy: s,
                        scaleX: i,
                        scaleY: s,
                        skewX: n,
                        skewY: a,
                        translateX: t,
                        translateY: e,
                        tx: t,
                        ty: e
                    }
                }, a.BitmapData.prototype.constructor = a.BitmapData, PIXI.Graphics = function() {
                    PIXI.DisplayObjectContainer.call(this), this.renderable = !0, this.fillAlpha = 1, this.lineWidth = 0, this.lineColor = 0, this.graphicsData = [], this.tint = 16777215, this.blendMode = PIXI.blendModes.NORMAL, this.currentPath = null, this._webGL = [], this.isMask = !1, this.boundsPadding = 0, this._localBounds = new PIXI.Rectangle(0, 0, 1, 1), this.dirty = !0, this._boundsDirty = !1, this.webGLDirty = !1, this.cachedSpriteDirty = !1
                }, PIXI.Graphics.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), PIXI.Graphics.prototype.constructor = PIXI.Graphics, PIXI.Graphics.prototype.lineStyle = function(t, e, i) {
                    return this.lineWidth = t || 0, this.lineColor = e || 0, this.lineAlpha = void 0 === i ? 1 : i, this.currentPath && (this.currentPath.shape.points.length ? this.drawShape(new PIXI.Polygon(this.currentPath.shape.points.slice(-2))) : (this.currentPath.lineWidth = this.lineWidth, this.currentPath.lineColor = this.lineColor, this.currentPath.lineAlpha = this.lineAlpha)), this
                }, PIXI.Graphics.prototype.moveTo = function(t, e) {
                    return this.drawShape(new PIXI.Polygon([t, e])), this
                }, PIXI.Graphics.prototype.lineTo = function(t, e) {
                    return this.currentPath || this.moveTo(0, 0), this.currentPath.shape.points.push(t, e), this.dirty = !0, this._boundsDirty = !0, this
                }, PIXI.Graphics.prototype.quadraticCurveTo = function(t, e, i, s) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    var n, a, o = 20,
                        r = this.currentPath.shape.points;
                    0 === r.length && this.moveTo(0, 0);
                    for (var h = r[r.length - 2], l = r[r.length - 1], c = 0, u = 1; u <= o; ++u) c = u / o, n = h + (t - h) * c, a = l + (e - l) * c, r.push(n + (t + (i - t) * c - n) * c, a + (e + (s - e) * c - a) * c);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, PIXI.Graphics.prototype.bezierCurveTo = function(t, e, i, s, n, a) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && (this.currentPath.shape.points = [0, 0]) : this.moveTo(0, 0);
                    for (var o = 20, r, h, l, c, u, d = this.currentPath.shape.points, p = d[d.length - 2], f = d[d.length - 1], g = 0, y = 1; y <= o; ++y) g = y / o, r = 1 - g, h = r * r, l = h * r, c = g * g, u = c * g, d.push(l * p + 3 * h * g * t + 3 * r * c * i + u * n, l * f + 3 * h * g * e + 3 * r * c * s + u * a);
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, PIXI.Graphics.prototype.arcTo = function(t, e, i, s, n) {
                    this.currentPath ? 0 === this.currentPath.shape.points.length && this.currentPath.shape.points.push(t, e) : this.moveTo(t, e);
                    var a = this.currentPath.shape.points,
                        o = a[a.length - 2],
                        r = a[a.length - 1],
                        h = r - e,
                        l = o - t,
                        c = s - e,
                        u = i - t,
                        d = Math.abs(h * u - l * c);
                    if (d < 1e-8 || 0 === n) a[a.length - 2] === t && a[a.length - 1] === e || a.push(t, e);
                    else {
                        var p = h * h + l * l,
                            f = c * c + u * u,
                            g = h * c + l * u,
                            y = n * Math.sqrt(p) / d,
                            m = n * Math.sqrt(f) / d,
                            v = y * g / p,
                            b = m * g / f,
                            x = y * u + m * l,
                            _ = y * c + m * h,
                            w = l * (m + v),
                            C = h * (m + v),
                            P = u * (y + b),
                            T = c * (y + b),
                            S = Math.atan2(C - _, w - x),
                            A = Math.atan2(T - _, P - x);
                        this.arc(x + t, _ + e, n, S, A, l * c > u * h)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, PIXI.Graphics.prototype.arc = function(t, e, i, s, n, a, o) {
                    if (s === n) return this;
                    void 0 === a && (a = !1), void 0 === o && (o = 40), !a && n <= s ? n += 2 * Math.PI : a && s <= n && (s += 2 * Math.PI);
                    var r = a ? -1 * (s - n) : n - s,
                        h = Math.ceil(Math.abs(r) / (2 * Math.PI)) * o;
                    if (0 === r) return this;
                    var l = t + Math.cos(s) * i,
                        c = e + Math.sin(s) * i;
                    a && this.filling ? this.moveTo(t, e) : this.moveTo(l, c);
                    for (var u = this.currentPath.shape.points, d = r / (2 * h), p = 2 * d, f = Math.cos(d), g = Math.sin(d), y = h - 1, m = y % 1 / y, v = 0; v <= y; v++) {
                        var b = v + m * v,
                            x = d + s + p * b,
                            _ = Math.cos(x),
                            w = -Math.sin(x);
                        u.push((f * _ + g * w) * i + t, (f * -w + g * _) * i + e)
                    }
                    return this.dirty = !0, this._boundsDirty = !0, this
                }, PIXI.Graphics.prototype.beginFill = function(t, e) {
                    return this.filling = !0, this.fillColor = t || 0, this.fillAlpha = void 0 === e ? 1 : e, this.currentPath && this.currentPath.shape.points.length <= 2 && (this.currentPath.fill = this.filling, this.currentPath.fillColor = this.fillColor, this.currentPath.fillAlpha = this.fillAlpha), this
                }, PIXI.Graphics.prototype.endFill = function() {
                    return this.filling = !1, this.fillColor = null, this.fillAlpha = 1, this
                }, PIXI.Graphics.prototype.drawRect = function(t, e, i, s) {
                    return this.drawShape(new PIXI.Rectangle(t, e, i, s)), this
                }, PIXI.Graphics.prototype.drawRoundedRect = function(t, e, i, s, n) {
                    return this.drawShape(new PIXI.RoundedRectangle(t, e, i, s, n)), this
                }, PIXI.Graphics.prototype.drawCircle = function(t, e, i) {
                    return this.drawShape(new PIXI.Circle(t, e, i)), this
                }, PIXI.Graphics.prototype.drawEllipse = function(t, e, i, s) {
                    return this.drawShape(new PIXI.Ellipse(t, e, i, s)), this
                }, PIXI.Graphics.prototype.drawPolygon = function(t) {
                    (t instanceof a.Polygon || t instanceof PIXI.Polygon) && (t = t.points);
                    var e = t;
                    if (!Array.isArray(e)) {
                        e = new Array(arguments.length);
                        for (var i = 0; i < e.length; ++i) e[i] = arguments[i]
                    }
                    return this.drawShape(new a.Polygon(e)), this
                }, PIXI.Graphics.prototype.clear = function() {
                    return this.lineWidth = 0, this.filling = !1, this.dirty = !0, this._boundsDirty = !0, this.clearDirty = !0, this.graphicsData = [], this.updateLocalBounds(), this
                }, PIXI.Graphics.prototype.generateTexture = function(t, e, i) {
                    void 0 === t && (t = 1), void 0 === e && (e = PIXI.scaleModes.DEFAULT), void 0 === i && (i = 0);
                    var s = this.getBounds();
                    s.width += i, s.height += i;
                    var n = new PIXI.CanvasBuffer(s.width * t, s.height * t),
                        a = PIXI.Texture.fromCanvas(n.canvas, e);
                    return a.baseTexture.resolution = t, n.context.scale(t, t), n.context.translate(-s.x, -s.y), PIXI.CanvasGraphics.renderGraphics(this, n.context), a
                }, PIXI.Graphics.prototype._renderWebGL = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.worldAlpha = this.worldAlpha, void PIXI.Sprite.prototype._renderWebGL.call(this._cachedSprite, t);
                        if (t.spriteBatch.stop(), t.blendModeManager.setBlendMode(this.blendMode), this._mask && t.maskManager.pushMask(this._mask, t), this._filters && t.filterManager.pushFilter(this._filterBlock), this.blendMode !== t.spriteBatch.currentBlendMode) {
                            t.spriteBatch.currentBlendMode = this.blendMode;
                            var e = PIXI.blendModesWebGL[t.spriteBatch.currentBlendMode];
                            t.spriteBatch.gl.blendFunc(e[0], e[1])
                        }
                        if (this.webGLDirty && (this.dirty = !0, this.webGLDirty = !1), PIXI.WebGLGraphics.renderGraphics(this, t), this.children.length) {
                            t.spriteBatch.start();
                            for (var i = 0; i < this.children.length; i++) this.children[i]._renderWebGL(t);
                            t.spriteBatch.stop()
                        }
                        this._filters && t.filterManager.popFilter(), this._mask && t.maskManager.popMask(this.mask, t), t.drawCount++, t.spriteBatch.start()
                    }
                }, PIXI.Graphics.prototype._renderCanvas = function(t) {
                    if (!1 !== this.visible && 0 !== this.alpha && !0 !== this.isMask) {
                        if (this._prevTint !== this.tint && (this.dirty = !0, this._prevTint = this.tint), this._cacheAsBitmap) return (this.dirty || this.cachedSpriteDirty) && (this._generateCachedSprite(), this.updateCachedSpriteTexture(), this.cachedSpriteDirty = !1, this.dirty = !1), this._cachedSprite.alpha = this.alpha, void PIXI.Sprite.prototype._renderCanvas.call(this._cachedSprite, t);
                        var e = t.context,
                            i = this.worldTransform;
                        this.blendMode !== t.currentBlendMode && (t.currentBlendMode = this.blendMode, e.globalCompositeOperation = PIXI.blendModesCanvas[t.currentBlendMode]), this._mask && t.maskManager.pushMask(this._mask, t);
                        var s = t.resolution,
                            n = i.tx * t.resolution + t.shakeX,
                            a = i.ty * t.resolution + t.shakeY;
                        e.setTransform(i.a * s, i.b * s, i.c * s, i.d * s, n, a), PIXI.CanvasGraphics.renderGraphics(this, e);
                        for (var o = 0; o < this.children.length; o++) this.children[o]._renderCanvas(t);
                        this._mask && t.maskManager.popMask(t)
                    }
                }, PIXI.Graphics.prototype.getBounds = function(t) {
                    if (!this._currentBounds) {
                        if (!this.renderable) return PIXI.EmptyRectangle;
                        this.dirty && (this.updateLocalBounds(), this.webGLDirty = !0, this.cachedSpriteDirty = !0, this.dirty = !1);
                        var e = this._localBounds,
                            i = e.x,
                            s = e.width + e.x,
                            n = e.y,
                            a = e.height + e.y,
                            o = t || this.worldTransform,
                            r = o.a,
                            h = o.b,
                            l = o.c,
                            c = o.d,
                            u = o.tx,
                            d = o.ty,
                            p = r * s + l * a + u,
                            f = c * a + h * s + d,
                            g = r * i + l * a + u,
                            y = c * a + h * i + d,
                            m = r * i + l * n + u,
                            v = c * n + h * i + d,
                            b = r * s + l * n + u,
                            x = c * n + h * s + d,
                            _ = p,
                            w = f,
                            C = p,
                            P = f;
                        C = g < C ? g : C, C = m < C ? m : C, C = b < C ? b : C, P = y < P ? y : P, P = v < P ? v : P, P = x < P ? x : P, _ = g > _ ? g : _, _ = m > _ ? m : _, _ = b > _ ? b : _, w = y > w ? y : w, w = v > w ? v : w, w = x > w ? x : w, this._bounds.x = C, this._bounds.width = _ - C, this._bounds.y = P, this._bounds.height = w - P, this._currentBounds = this._bounds
                    }
                    return this._currentBounds
                }, PIXI.Graphics.prototype.getLocalBounds = function() {
                    var t = this.worldTransform;
                    this.worldTransform = PIXI.identityMatrix;
                    for (var e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    var i = this.getBounds();
                    for (this.worldTransform = t, e = 0; e < this.children.length; e++) this.children[e].updateTransform();
                    return i
                }, PIXI.Graphics.prototype.containsPoint = function(t) {
                    this.worldTransform.applyInverse(t, tempPoint);
                    for (var e = this.graphicsData, i = 0; i < e.length; i++) {
                        var s = e[i];
                        if (s.fill && (s.shape && s.shape.contains(tempPoint.x, tempPoint.y))) return !0
                    }
                    return !1
                }, PIXI.Graphics.prototype.updateLocalBounds = function() {
                    var t = 1 / 0,
                        e = -1 / 0,
                        i = 1 / 0,
                        s = -1 / 0;
                    if (this.graphicsData.length)
                        for (var n, o, r, h, l, c, u = 0; u < this.graphicsData.length; u++) {
                            var d = this.graphicsData[u],
                                p = d.type,
                                f = d.lineWidth;
                            if (n = d.shape, p === PIXI.Graphics.RECT || p === PIXI.Graphics.RREC) r = n.x - f / 2, h = n.y - f / 2, l = n.width + f, c = n.height + f, t = r < t ? r : t, e = r + l > e ? r + l : e, i = h < i ? h : i, s = h + c > s ? h + c : s;
                            else if (p === PIXI.Graphics.CIRC) r = n.x, h = n.y, l = n.radius + f / 2, c = n.radius + f / 2, t = r - l < t ? r - l : t, e = r + l > e ? r + l : e, i = h - c < i ? h - c : i, s = h + c > s ? h + c : s;
                            else if (p === PIXI.Graphics.ELIP) r = n.x, h = n.y, l = n.width + f / 2, c = n.height + f / 2, t = r - l < t ? r - l : t, e = r + l > e ? r + l : e, i = h - c < i ? h - c : i, s = h + c > s ? h + c : s;
                            else {
                                o = n.points;
                                for (var g = 0; g < o.length; g++) o[g] instanceof a.Point ? (r = o[g].x, h = o[g].y) : (r = o[g], h = o[g + 1], g < o.length - 1 && g++), t = r - f < t ? r - f : t, e = r + f > e ? r + f : e, i = h - f < i ? h - f : i, s = h + f > s ? h + f : s
                            }
                        } else t = 0, e = 0, i = 0, s = 0;
                    var y = this.boundsPadding;
                    this._localBounds.x = t - y, this._localBounds.width = e - t + 2 * y, this._localBounds.y = i - y, this._localBounds.height = s - i + 2 * y
                }, PIXI.Graphics.prototype._generateCachedSprite = function() {
                    var t = this.getLocalBounds();
                    if (this._cachedSprite) this._cachedSprite.buffer.resize(t.width, t.height);
                    else {
                        var e = new PIXI.CanvasBuffer(t.width, t.height),
                            i = PIXI.Texture.fromCanvas(e.canvas);
                        this._cachedSprite = new PIXI.Sprite(i), this._cachedSprite.buffer = e, this._cachedSprite.worldTransform = this.worldTransform
                    }
                    this._cachedSprite.anchor.x = -t.x / t.width, this._cachedSprite.anchor.y = -t.y / t.height, this._cachedSprite.buffer.context.translate(-t.x, -t.y), this.worldAlpha = 1, PIXI.CanvasGraphics.renderGraphics(this, this._cachedSprite.buffer.context), this._cachedSprite.alpha = this.alpha
                }, PIXI.Graphics.prototype.updateCachedSpriteTexture = function() {
                    var t = this._cachedSprite,
                        e = t.texture,
                        i = t.buffer.canvas;
                    e.baseTexture.width = i.width, e.baseTexture.height = i.height, e.crop.width = e.frame.width = i.width, e.crop.height = e.frame.height = i.height, t._width = i.width, t._height = i.height, e.baseTexture.dirty()
                }, PIXI.Graphics.prototype.destroyCachedSprite = function() {
                    this._cachedSprite.texture.destroy(!0), this._cachedSprite = null
                }, PIXI.Graphics.prototype.drawShape = function(t) {
                    this.currentPath && this.currentPath.shape.points.length <= 2 && this.graphicsData.pop(), this.currentPath = null, t instanceof a.Polygon && (t = t.clone(), t.flatten());
                    var e = new PIXI.GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.filling, t);
                    return this.graphicsData.push(e), e.type === PIXI.Graphics.POLY && (e.shape.closed = this.filling, this.currentPath = e), this.dirty = !0, this._boundsDirty = !0, e
                }, Object.defineProperty(PIXI.Graphics.prototype, "cacheAsBitmap", {
                    get: function() {
                        return this._cacheAsBitmap
                    },
                    set: function(t) {
                        this._cacheAsBitmap = t, this._cacheAsBitmap ? this._generateCachedSprite() : this.destroyCachedSprite(), this.dirty = !0, this.webGLDirty = !0
                    }
                }), PIXI.GraphicsData = function(t, e, i, s, n, a, o) {
                    this.lineWidth = t, this.lineColor = e, this.lineAlpha = i, this._lineTint = e, this.fillColor = s, this.fillAlpha = n, this._fillTint = s, this.fill = a, this.shape = o, this.type = o.type
                }, PIXI.GraphicsData.prototype.constructor = PIXI.GraphicsData, PIXI.GraphicsData.prototype.clone = function() {
                    return new GraphicsData(this.lineWidth, this.lineColor, this.lineAlpha, this.fillColor, this.fillAlpha, this.fill, this.shape)
                }, PIXI.EarCut = {}, PIXI.EarCut.Triangulate = function(t, e, i) {
                    i = i || 2;
                    var s = e && e.length,
                        n = s ? e[0] * i : t.length,
                        a = PIXI.EarCut.linkedList(t, 0, n, i, !0),
                        o = [];
                    if (!a) return o;
                    var r, h, l, c, u, d, p;
                    if (s && (a = PIXI.EarCut.eliminateHoles(t, e, a, i)), t.length > 80 * i) {
                        r = l = t[0], h = c = t[1];
                        for (var f = i; f < n; f += i) u = t[f], d = t[f + 1], u < r && (r = u), d < h && (h = d), u > l && (l = u), d > c && (c = d);
                        p = Math.max(l - r, c - h)
                    }
                    return PIXI.EarCut.earcutLinked(a, o, i, r, h, p), o
                }, PIXI.EarCut.linkedList = function(t, e, i, s, n) {
                    var a = 0,
                        o, r, h;
                    for (o = e, r = i - s; o < i; o += s) a += (t[r] - t[o]) * (t[o + 1] + t[r + 1]), r = o;
                    if (n === a > 0)
                        for (o = e; o < i; o += s) h = PIXI.EarCut.insertNode(o, t[o], t[o + 1], h);
                    else
                        for (o = i - s; o >= e; o -= s) h = PIXI.EarCut.insertNode(o, t[o], t[o + 1], h);
                    return h
                }, PIXI.EarCut.filterPoints = function(t, e) {
                    if (!t) return t;
                    e || (e = t);
                    var i = t,
                        s;
                    do {
                        if (s = !1, i.steiner || !PIXI.EarCut.equals(i, i.next) && 0 !== PIXI.EarCut.area(i.prev, i, i.next)) i = i.next;
                        else {
                            if (PIXI.EarCut.removeNode(i), (i = e = i.prev) === i.next) return null;
                            s = !0
                        }
                    } while (s || i !== e);
                    return e
                }, PIXI.EarCut.earcutLinked = function(t, e, i, s, n, a, o) {
                    if (t) {
                        !o && a && PIXI.EarCut.indexCurve(t, s, n, a);
                        for (var r = t, h, l; t.prev !== t.next;)
                            if (h = t.prev, l = t.next, a ? PIXI.EarCut.isEarHashed(t, s, n, a) : PIXI.EarCut.isEar(t)) e.push(h.i / i), e.push(t.i / i), e.push(l.i / i), PIXI.EarCut.removeNode(t), t = l.next, r = l.next;
                            else if ((t = l) === r) {
                            o ? 1 === o ? (t = PIXI.EarCut.cureLocalIntersections(t, e, i), PIXI.EarCut.earcutLinked(t, e, i, s, n, a, 2)) : 2 === o && PIXI.EarCut.splitEarcut(t, e, i, s, n, a) : PIXI.EarCut.earcutLinked(PIXI.EarCut.filterPoints(t), e, i, s, n, a, 1);
                            break
                        }
                    }
                }, PIXI.EarCut.isEar = function(t) {
                    var e = t.prev,
                        i = t,
                        s = t.next;
                    if (PIXI.EarCut.area(e, i, s) >= 0) return !1;
                    for (var n = t.next.next; n !== t.prev;) {
                        if (PIXI.EarCut.pointInTriangle(e.x, e.y, i.x, i.y, s.x, s.y, n.x, n.y) && PIXI.EarCut.area(n.prev, n, n.next) >= 0) return !1;
                        n = n.next
                    }
                    return !0
                }, PIXI.EarCut.isEarHashed = function(t, e, i, s) {
                    var n = t.prev,
                        a = t,
                        o = t.next;
                    if (PIXI.EarCut.area(n, a, o) >= 0) return !1;
                    for (var r = n.x < a.x ? n.x < o.x ? n.x : o.x : a.x < o.x ? a.x : o.x, h = n.y < a.y ? n.y < o.y ? n.y : o.y : a.y < o.y ? a.y : o.y, l = n.x > a.x ? n.x > o.x ? n.x : o.x : a.x > o.x ? a.x : o.x, c = n.y > a.y ? n.y > o.y ? n.y : o.y : a.y > o.y ? a.y : o.y, u = PIXI.EarCut.zOrder(r, h, e, i, s), d = PIXI.EarCut.zOrder(l, c, e, i, s), p = t.nextZ; p && p.z <= d;) {
                        if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                        p = p.nextZ
                    }
                    for (p = t.prevZ; p && p.z >= u;) {
                        if (p !== t.prev && p !== t.next && PIXI.EarCut.pointInTriangle(n.x, n.y, a.x, a.y, o.x, o.y, p.x, p.y) && PIXI.EarCut.area(p.prev, p, p.next) >= 0) return !1;
                        p = p.prevZ
                    }
                    return !0
                }, PIXI.EarCut.cureLocalIntersections = function(t, e, i) {
                    var s = t;
                    do {
                        var n = s.prev,
                            a = s.next.next;
                        PIXI.EarCut.intersects(n, s, s.next, a) && PIXI.EarCut.locallyInside(n, a) && PIXI.EarCut.locallyInside(a, n) && (e.push(n.i / i), e.push(s.i / i), e.push(a.i / i), PIXI.EarCut.removeNode(s), PIXI.EarCut.removeNode(s.next), s = t = a), s = s.next
                    } while (s !== t);
                    return s
                }, PIXI.EarCut.splitEarcut = function(t, e, i, s, n, a) {
                    var o = t;
                    do {
                        for (var r = o.next.next; r !== o.prev;) {
                            if (o.i !== r.i && PIXI.EarCut.isValidDiagonal(o, r)) {
                                var h = PIXI.EarCut.splitPolygon(o, r);
                                return o = PIXI.EarCut.filterPoints(o, o.next), h = PIXI.EarCut.filterPoints(h, h.next), PIXI.EarCut.earcutLinked(o, e, i, s, n, a), void PIXI.EarCut.earcutLinked(h, e, i, s, n, a)
                            }
                            r = r.next
                        }
                        o = o.next
                    } while (o !== t)
                }, PIXI.EarCut.eliminateHoles = function(t, e, i, s) {
                    var n = [],
                        a, o, r, h, l;
                    for (a = 0, o = e.length; a < o; a++) r = e[a] * s, h = a < o - 1 ? e[a + 1] * s : t.length, l = PIXI.EarCut.linkedList(t, r, h, s, !1), l === l.next && (l.steiner = !0), n.push(PIXI.EarCut.getLeftmost(l));
                    for (n.sort(compareX), a = 0; a < n.length; a++) PIXI.EarCut.eliminateHole(n[a], i), i = PIXI.EarCut.filterPoints(i, i.next);
                    return i
                }, PIXI.EarCut.compareX = function(t, e) {
                    return t.x - e.x
                }, PIXI.EarCut.eliminateHole = function(t, e) {
                    if (e = PIXI.EarCut.findHoleBridge(t, e)) {
                        var i = PIXI.EarCut.splitPolygon(e, t);
                        PIXI.EarCut.filterPoints(i, i.next)
                    }
                }, PIXI.EarCut.findHoleBridge = function(t, e) {
                    var i = e,
                        s = t.x,
                        n = t.y,
                        a = -1 / 0,
                        o;
                    do {
                        if (n <= i.y && n >= i.next.y) {
                            var r = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
                            r <= s && r > a && (a = r, o = i.x < i.next.x ? i : i.next)
                        }
                        i = i.next
                    } while (i !== e);
                    if (!o) return null;
                    if (t.x === o.x) return o.prev;
                    var h = o,
                        l = 1 / 0,
                        c;
                    for (i = o.next; i !== h;) s >= i.x && i.x >= o.x && PIXI.EarCut.pointInTriangle(n < o.y ? s : a, n, o.x, o.y, n < o.y ? a : s, n, i.x, i.y) && ((c = Math.abs(n - i.y) / (s - i.x)) < l || c === l && i.x > o.x) && PIXI.EarCut.locallyInside(i, t) && (o = i, l = c), i = i.next;
                    return o
                }, PIXI.EarCut.indexCurve = function(t, e, i, s) {
                    var n = t;
                    do {
                        null === n.z && (n.z = PIXI.EarCut.zOrder(n.x, n.y, e, i, s)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next
                    } while (n !== t);
                    n.prevZ.nextZ = null, n.prevZ = null, PIXI.EarCut.sortLinked(n)
                }, PIXI.EarCut.sortLinked = function(t) {
                    var e, i, s, n, a, o, r, h, l = 1;
                    do {
                        for (i = t, t = null, a = null, o = 0; i;) {
                            for (o++, s = i, r = 0, e = 0; e < l && (r++, s = s.nextZ); e++);
                            for (h = l; r > 0 || h > 0 && s;) 0 === r ? (n = s, s = s.nextZ, h--) : 0 !== h && s ? i.z <= s.z ? (n = i, i = i.nextZ, r--) : (n = s, s = s.nextZ, h--) : (n = i, i = i.nextZ, r--), a ? a.nextZ = n : t = n, n.prevZ = a, a = n;
                            i = s
                        }
                        a.nextZ = null, l *= 2
                    } while (o > 1);
                    return t
                }, PIXI.EarCut.zOrder = function(t, e, i, s, n) {
                    return t = 32767 * (t - i) / n, e = 32767 * (e - s) / n, t = 16711935 & (t | t << 8), t = 252645135 & (t | t << 4), t = 858993459 & (t | t << 2), t = 1431655765 & (t | t << 1), e = 16711935 & (e | e << 8), e = 252645135 & (e | e << 4), e = 858993459 & (e | e << 2), e = 1431655765 & (e | e << 1), t | e << 1
                }, PIXI.EarCut.getLeftmost = function(t) {
                    var e = t,
                        i = t;
                    do {
                        e.x < i.x && (i = e), e = e.next
                    } while (e !== t);
                    return i
                }, PIXI.EarCut.pointInTriangle = function(t, e, i, s, n, a, o, r) {
                    return (n - o) * (e - r) - (t - o) * (a - r) >= 0 && (t - o) * (s - r) - (i - o) * (e - r) >= 0 && (i - o) * (a - r) - (n - o) * (s - r) >= 0
                }, PIXI.EarCut.isValidDiagonal = function(t, e) {
                    return PIXI.EarCut.equals(t, e) || t.next.i !== e.i && t.prev.i !== e.i && !PIXI.EarCut.intersectsPolygon(t, e) && PIXI.EarCut.locallyInside(t, e) && PIXI.EarCut.locallyInside(e, t) && PIXI.EarCut.middleInside(t, e)
                }, PIXI.EarCut.area = function(t, e, i) {
                    return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y)
                }, PIXI.EarCut.equals = function(t, e) {
                    return t.x === e.x && t.y === e.y
                }, PIXI.EarCut.intersects = function(t, e, i, s) {
                    return PIXI.EarCut.area(t, e, i) > 0 != PIXI.EarCut.area(t, e, s) > 0 && PIXI.EarCut.area(i, s, t) > 0 != PIXI.EarCut.area(i, s, e) > 0
                }, PIXI.EarCut.intersectsPolygon = function(t, e) {
                    var i = t;
                    do {
                        if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && PIXI.EarCut.intersects(i, i.next, t, e)) return !0;
                        i = i.next
                    } while (i !== t);
                    return !1
                }, PIXI.EarCut.locallyInside = function(t, e) {
                    return PIXI.EarCut.area(t.prev, t, t.next) < 0 ? PIXI.EarCut.area(t, e, t.next) >= 0 && PIXI.EarCut.area(t, t.prev, e) >= 0 : PIXI.EarCut.area(t, e, t.prev) < 0 || PIXI.EarCut.area(t, t.next, e) < 0
                }, PIXI.EarCut.middleInside = function(t, e) {
                    var i = t,
                        s = !1,
                        n = (t.x + e.x) / 2,
                        a = (t.y + e.y) / 2;
                    do {
                        i.y > a != i.next.y > a && n < (i.next.x - i.x) * (a - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next
                    } while (i !== t);
                    return s
                }, PIXI.EarCut.splitPolygon = function(t, e) {
                    var i = new PIXI.EarCut.Node(t.i, t.x, t.y),
                        s = new PIXI.EarCut.Node(e.i, e.x, e.y),
                        n = t.next,
                        a = e.prev;
                    return t.next = e, e.prev = t, i.next = n, n.prev = i, s.next = i, i.prev = s, a.next = s, s.prev = a, s
                }, PIXI.EarCut.insertNode = function(t, e, i, s) {
                    var n = new PIXI.EarCut.Node(t, e, i);
                    return s ? (n.next = s.next, n.prev = s, s.next.prev = n, s.next = n) : (n.prev = n, n.next = n), n
                }, PIXI.EarCut.removeNode = function(t) {
                    t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ)
                }, PIXI.EarCut.Node = function(t, e, i) {
                    this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1
                }, PIXI.WebGLGraphics = function() {}, PIXI.WebGLGraphics.stencilBufferLimit = 6, PIXI.WebGLGraphics.renderGraphics = function(t, e) {
                    var i = e.gl,
                        s = e.projection,
                        n = e.offset,
                        a = e.shaderManager.primitiveShader,
                        o;
                    t.dirty && PIXI.WebGLGraphics.updateGraphics(t, i);
                    for (var r = t._webGL[i.id], h = 0; h < r.data.length; h++) 1 === r.data[h].mode ? (o = r.data[h], e.stencilManager.pushStencil(t, o, e), i.drawElements(i.TRIANGLE_FAN, 4, i.UNSIGNED_SHORT, 2 * (o.indices.length - 4)), e.stencilManager.popStencil(t, o, e)) : (o = r.data[h], e.shaderManager.setShader(a), a = e.shaderManager.primitiveShader, i.uniformMatrix3fv(a.translationMatrix, !1, t.worldTransform.toArray(!0)), i.uniform1f(a.flipY, 1), i.uniform2f(a.projectionVector, s.x, -s.y), i.uniform2f(a.offsetVector, -n.x, -n.y), i.uniform3fv(a.tintColor, PIXI.hex2rgb(t.tint)), i.uniform1f(a.alpha, t.worldAlpha), i.bindBuffer(i.ARRAY_BUFFER, o.buffer), i.vertexAttribPointer(a.aVertexPosition, 2, i.FLOAT, !1, 24, 0), i.vertexAttribPointer(a.colorAttribute, 4, i.FLOAT, !1, 24, 8), i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, o.indexBuffer), i.drawElements(i.TRIANGLE_STRIP, o.indices.length, i.UNSIGNED_SHORT, 0))
                }, PIXI.WebGLGraphics.updateGraphics = function(t, e) {
                    var i = t._webGL[e.id];
                    i || (i = t._webGL[e.id] = {
                        lastIndex: 0,
                        data: [],
                        gl: e
                    }), t.dirty = !1;
                    var s;
                    if (t.clearDirty) {
                        for (t.clearDirty = !1, s = 0; s < i.data.length; s++) {
                            var n = i.data[s];
                            n.reset(), PIXI.WebGLGraphics.graphicsDataPool.push(n)
                        }
                        i.data = [], i.lastIndex = 0
                    }
                    var a;
                    for (s = i.lastIndex; s < t.graphicsData.length; s++) {
                        var o = t.graphicsData[s];
                        if (o.type === PIXI.Graphics.POLY) {
                            if (o.points = o.shape.points.slice(), o.shape.closed && (o.points[0] === o.points[o.points.length - 2] && o.points[1] === o.points[o.points.length - 1] || o.points.push(o.points[0], o.points[1])), o.fill && o.points.length >= PIXI.WebGLGraphics.stencilBufferLimit)
                                if (o.points.length < 2 * PIXI.WebGLGraphics.stencilBufferLimit) {
                                    a = PIXI.WebGLGraphics.switchMode(i, 0);
                                    var r = PIXI.WebGLGraphics.buildPoly(o, a);
                                    r || (a = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a))
                                } else a = PIXI.WebGLGraphics.switchMode(i, 1), PIXI.WebGLGraphics.buildComplexPoly(o, a);
                            o.lineWidth > 0 && (a = PIXI.WebGLGraphics.switchMode(i, 0), PIXI.WebGLGraphics.buildLine(o, a))
                        } else a = PIXI.WebGLGraphics.switchMode(i, 0), o.type === PIXI.Graphics.RECT ? PIXI.WebGLGraphics.buildRectangle(o, a) : o.type === PIXI.Graphics.CIRC || o.type === PIXI.Graphics.ELIP ? PIXI.WebGLGraphics.buildCircle(o, a) : o.type === PIXI.Graphics.RREC && PIXI.WebGLGraphics.buildRoundedRectangle(o, a);
                        i.lastIndex++
                    }
                    for (s = 0; s < i.data.length; s++) a = i.data[s], a.dirty && a.upload()
                }, PIXI.WebGLGraphics.switchMode = function(t, e) {
                    var i;
                    return t.data.length ? (i = t.data[t.data.length - 1], i.mode === e && 1 !== e || (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i))) : (i = PIXI.WebGLGraphics.graphicsDataPool.pop() || new PIXI.WebGLGraphicsData(t.gl), i.mode = e, t.data.push(i)), i.dirty = !0, i
                }, PIXI.WebGLGraphics.buildRectangle = function(t, e) {
                    var i = t.shape,
                        s = i.x,
                        n = i.y,
                        a = i.width,
                        o = i.height;
                    if (t.fill) {
                        var r = PIXI.hex2rgb(t.fillColor),
                            h = t.fillAlpha,
                            l = r[0] * h,
                            c = r[1] * h,
                            u = r[2] * h,
                            d = e.points,
                            p = e.indices,
                            f = d.length / 6;
                        d.push(s, n), d.push(l, c, u, h), d.push(s + a, n), d.push(l, c, u, h), d.push(s, n + o), d.push(l, c, u, h), d.push(s + a, n + o), d.push(l, c, u, h), p.push(f, f, f + 1, f + 2, f + 3, f + 3)
                    }
                    if (t.lineWidth) {
                        var g = t.points;
                        t.points = [s, n, s + a, n, s + a, n + o, s, n + o, s, n], PIXI.WebGLGraphics.buildLine(t, e), t.points = g
                    }
                }, PIXI.WebGLGraphics.buildRoundedRectangle = function(t, e) {
                    var i = t.shape,
                        s = i.x,
                        n = i.y,
                        a = i.width,
                        o = i.height,
                        r = i.radius,
                        h = [];
                    if (h.push(s, n + r), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s, n + o - r, s, n + o, s + r, n + o)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a - r, n + o, s + a, n + o, s + a, n + o - r)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + a, n + r, s + a, n, s + a - r, n)), h = h.concat(PIXI.WebGLGraphics.quadraticBezierCurve(s + r, n, s, n, s, n + r)), t.fill) {
                        var l = PIXI.hex2rgb(t.fillColor),
                            c = t.fillAlpha,
                            u = l[0] * c,
                            d = l[1] * c,
                            p = l[2] * c,
                            f = e.points,
                            g = e.indices,
                            y = f.length / 6,
                            m = PIXI.EarCut.Triangulate(h, null, 2),
                            v = 0;
                        for (v = 0; v < m.length; v += 3) g.push(m[v] + y), g.push(m[v] + y), g.push(m[v + 1] + y), g.push(m[v + 2] + y), g.push(m[v + 2] + y);
                        for (v = 0; v < h.length; v++) f.push(h[v], h[++v], u, d, p, c)
                    }
                    if (t.lineWidth) {
                        var b = t.points;
                        t.points = h, PIXI.WebGLGraphics.buildLine(t, e), t.points = b
                    }
                }, PIXI.WebGLGraphics.quadraticBezierCurve = function(t, e, i, s, n, a) {
                    function o(t, e, i) {
                        return t + (e - t) * i
                    }
                    for (var r, h, l, c, u, d, p = 20, f = [], g = 0, y = 0; y <= p; y++) g = y / p, r = o(t, i, g), h = o(e, s, g), l = o(i, n, g), c = o(s, a, g), u = o(r, l, g), d = o(h, c, g), f.push(u, d);
                    return f
                }, PIXI.WebGLGraphics.buildCircle = function(t, e) {
                    var i = t.shape,
                        s = i.x,
                        n = i.y,
                        a, o;
                    t.type === PIXI.Graphics.CIRC ? (a = i.radius, o = i.radius) : (a = i.width, o = i.height);
                    var r = 40,
                        h = 2 * Math.PI / 40,
                        l = 0;
                    if (t.fill) {
                        var c = PIXI.hex2rgb(t.fillColor),
                            u = t.fillAlpha,
                            d = c[0] * u,
                            p = c[1] * u,
                            f = c[2] * u,
                            g = e.points,
                            y = e.indices,
                            m = g.length / 6;
                        for (y.push(m), l = 0; l < 41; l++) g.push(s, n, d, p, f, u), g.push(s + Math.sin(h * l) * a, n + Math.cos(h * l) * o, d, p, f, u), y.push(m++, m++);
                        y.push(m - 1)
                    }
                    if (t.lineWidth) {
                        var v = t.points;
                        for (t.points = [], l = 0; l < 41; l++) t.points.push(s + Math.sin(h * l) * a, n + Math.cos(h * l) * o);
                        PIXI.WebGLGraphics.buildLine(t, e), t.points = v
                    }
                }, PIXI.WebGLGraphics.buildLine = function(t, e) {
                    var i = 0,
                        s = t.points;
                    if (0 !== s.length) {
                        if (t.lineWidth % 2)
                            for (i = 0; i < s.length; i++) s[i] += .5;
                        var n = new PIXI.Point(s[0], s[1]),
                            a = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
                        if (n.x === a.x && n.y === a.y) {
                            s = s.slice(), s.pop(), s.pop(), a = new PIXI.Point(s[s.length - 2], s[s.length - 1]);
                            var o = a.x + .5 * (n.x - a.x),
                                r = a.y + .5 * (n.y - a.y);
                            s.unshift(o, r), s.push(o, r)
                        }
                        var h = e.points,
                            l = e.indices,
                            c = s.length / 2,
                            u = s.length,
                            d = h.length / 6,
                            p = t.lineWidth / 2,
                            f = PIXI.hex2rgb(t.lineColor),
                            g = t.lineAlpha,
                            y = f[0] * g,
                            m = f[1] * g,
                            v = f[2] * g,
                            b, x, _, w, C, P, T, S, A, E, I, M, O, B, R, k, D, L, F, G, U, N, j;
                        for (_ = s[0], w = s[1], C = s[2], P = s[3], A = -(w - P), E = _ - C, j = Math.sqrt(A * A + E * E), A /= j, E /= j, A *= p, E *= p, h.push(_ - A, w - E, y, m, v, g), h.push(_ + A, w + E, y, m, v, g), i = 1; i < c - 1; i++) _ = s[2 * (i - 1)], w = s[2 * (i - 1) + 1], C = s[2 * i], P = s[2 * i + 1], T = s[2 * (i + 1)], S = s[2 * (i + 1) + 1], A = -(w - P), E = _ - C, j = Math.sqrt(A * A + E * E), A /= j, E /= j, A *= p, E *= p, I = -(P - S), M = C - T, j = Math.sqrt(I * I + M * M), I /= j, M /= j, I *= p, M *= p, R = -E + w - (-E + P), k = -A + C - (-A + _), D = (-A + _) * (-E + P) - (-A + C) * (-E + w), L = -M + S - (-M + P), F = -I + C - (-I + T), G = (-I + T) * (-M + P) - (-I + C) * (-M + S), U = R * F - L * k, Math.abs(U) < .1 ? (U += 10.1, h.push(C - A, P - E, y, m, v, g), h.push(C + A, P + E, y, m, v, g)) : (b = (k * G - F * D) / U, x = (L * D - R * G) / U, N = (b - C) * (b - C) + (x - P) + (x - P), N > 19600 ? (O = A - I, B = E - M, j = Math.sqrt(O * O + B * B), O /= j, B /= j, O *= p, B *= p, h.push(C - O, P - B), h.push(y, m, v, g), h.push(C + O, P + B), h.push(y, m, v, g), h.push(C - O, P - B), h.push(y, m, v, g), u++) : (h.push(b, x), h.push(y, m, v, g), h.push(C - (b - C), P - (x - P)), h.push(y, m, v, g)));
                        for (_ = s[2 * (c - 2)], w = s[2 * (c - 2) + 1], C = s[2 * (c - 1)], P = s[2 * (c - 1) + 1], A = -(w - P), E = _ - C, j = Math.sqrt(A * A + E * E), A /= j, E /= j, A *= p, E *= p, h.push(C - A, P - E), h.push(y, m, v, g), h.push(C + A, P + E), h.push(y, m, v, g), l.push(d), i = 0; i < u; i++) l.push(d++);
                        l.push(d - 1)
                    }
                }, PIXI.WebGLGraphics.buildComplexPoly = function(t, e) {
                    var i = t.points.slice();
                    if (!(i.length < 6)) {
                        var s = e.indices;
                        e.points = i, e.alpha = t.fillAlpha, e.color = PIXI.hex2rgb(t.fillColor);
                        for (var n = 1 / 0, a = -1 / 0, o = 1 / 0, r = -1 / 0, h, l, c = 0; c < i.length; c += 2) h = i[c], l = i[c + 1], n = h < n ? h : n, a = h > a ? h : a, o = l < o ? l : o, r = l > r ? l : r;
                        i.push(n, o, a, o, a, r, n, r);
                        var u = i.length / 2;
                        for (c = 0; c < u; c++) s.push(c)
                    }
                }, PIXI.WebGLGraphics.buildPoly = function(t, e) {
                    var i = t.points;
                    if (!(i.length < 6)) {
                        var s = e.points,
                            n = e.indices,
                            a = i.length / 2,
                            o = PIXI.hex2rgb(t.fillColor),
                            r = t.fillAlpha,
                            h = o[0] * r,
                            l = o[1] * r,
                            c = o[2] * r,
                            u = PIXI.EarCut.Triangulate(i, null, 2);
                        if (!u) return !1;
                        var d = s.length / 6,
                            p = 0;
                        for (p = 0; p < u.length; p += 3) n.push(u[p] + d), n.push(u[p] + d), n.push(u[p + 1] + d), n.push(u[p + 2] + d), n.push(u[p + 2] + d);
                        for (p = 0; p < a; p++) s.push(i[2 * p], i[2 * p + 1], h, l, c, r);
                        return !0
                    }
                }, PIXI.WebGLGraphics.graphicsDataPool = [], PIXI.WebGLGraphicsData = function(t) {
                    this.gl = t, this.color = [0, 0, 0], this.points = [], this.indices = [], this.buffer = t.createBuffer(), this.indexBuffer = t.createBuffer(), this.mode = 1, this.alpha = 1, this.dirty = !0
                }, PIXI.WebGLGraphicsData.prototype.reset = function() {
                    this.points = [], this.indices = []
                }, PIXI.WebGLGraphicsData.prototype.upload = function() {
                    var t = this.gl;
                    this.glPoints = new PIXI.Float32Array(this.points), t.bindBuffer(t.ARRAY_BUFFER, this.buffer), t.bufferData(t.ARRAY_BUFFER, this.glPoints, t.STATIC_DRAW), this.glIndicies = new PIXI.Uint16Array(this.indices), t.bindBuffer(t.ELEMENT_ARRAY_BUFFER, this.indexBuffer), t.bufferData(t.ELEMENT_ARRAY_BUFFER, this.glIndicies, t.STATIC_DRAW), this.dirty = !1
                }, PIXI.CanvasGraphics = function() {}, PIXI.CanvasGraphics.renderGraphics = function(t, e) {
                    var i = t.worldAlpha;
                    t.dirty && (this.updateGraphicsTint(t), t.dirty = !1);
                    for (var s = 0; s < t.graphicsData.length; s++) {
                        var n = t.graphicsData[s],
                            a = n.shape,
                            o = n._fillTint,
                            r = n._lineTint;
                        if (e.lineWidth = n.lineWidth, n.type === PIXI.Graphics.POLY) {
                            e.beginPath();
                            var h = a.points;
                            e.moveTo(h[0], h[1]);
                            for (var l = 1; l < h.length / 2; l++) e.lineTo(h[2 * l], h[2 * l + 1]);
                            a.closed && e.lineTo(h[0], h[1]), h[0] === h[h.length - 2] && h[1] === h[h.length - 1] && e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o)
                                    .toString(16))
                                .substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r)
                                    .toString(16))
                                .substr(-6), e.stroke())
                        } else if (n.type === PIXI.Graphics.RECT)(n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o)
                                .toString(16))
                            .substr(-6), e.fillRect(a.x, a.y, a.width, a.height)), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r)
                                .toString(16))
                            .substr(-6), e.strokeRect(a.x, a.y, a.width, a.height));
                        else if (n.type === PIXI.Graphics.CIRC) e.beginPath(), e.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o)
                                .toString(16))
                            .substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r)
                                .toString(16))
                            .substr(-6), e.stroke());
                        else if (n.type === PIXI.Graphics.ELIP) {
                            var c = 2 * a.width,
                                u = 2 * a.height,
                                d = a.x - c / 2,
                                p = a.y - u / 2;
                            e.beginPath();
                            var f = .5522848,
                                g = c / 2 * f,
                                y = u / 2 * f,
                                m = d + c,
                                v = p + u,
                                b = d + c / 2,
                                x = p + u / 2;
                            e.moveTo(d, x), e.bezierCurveTo(d, x - y, b - g, p, b, p), e.bezierCurveTo(b + g, p, m, x - y, m, x), e.bezierCurveTo(m, x + y, b + g, v, b, v), e.bezierCurveTo(b - g, v, d, x + y, d, x), e.closePath(), n.fill && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o)
                                    .toString(16))
                                .substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r)
                                    .toString(16))
                                .substr(-6), e.stroke())
                        } else if (n.type === PIXI.Graphics.RREC) {
                            var _ = a.x,
                                w = a.y,
                                C = a.width,
                                P = a.height,
                                T = a.radius,
                                S = Math.min(C, P) / 2 | 0;
                            T = T > S ? S : T, e.beginPath(), e.moveTo(_, w + T), e.lineTo(_, w + P - T), e.quadraticCurveTo(_, w + P, _ + T, w + P), e.lineTo(_ + C - T, w + P), e.quadraticCurveTo(_ + C, w + P, _ + C, w + P - T), e.lineTo(_ + C, w + T), e.quadraticCurveTo(_ + C, w, _ + C - T, w), e.lineTo(_ + T, w), e.quadraticCurveTo(_, w, _, w + T), e.closePath(), (n.fillColor || 0 === n.fillColor) && (e.globalAlpha = n.fillAlpha * i, e.fillStyle = "#" + ("00000" + (0 | o)
                                    .toString(16))
                                .substr(-6), e.fill()), n.lineWidth && (e.globalAlpha = n.lineAlpha * i, e.strokeStyle = "#" + ("00000" + (0 | r)
                                    .toString(16))
                                .substr(-6), e.stroke())
                        }
                    }
                }, PIXI.CanvasGraphics.renderGraphicsMask = function(t, e) {
                    var i = t.graphicsData.length;
                    if (0 !== i) {
                        e.beginPath();
                        for (var s = 0; s < i; s++) {
                            var n = t.graphicsData[s],
                                a = n.shape;
                            if (n.type === PIXI.Graphics.POLY) {
                                var o = a.points;
                                e.moveTo(o[0], o[1]);
                                for (var r = 1; r < o.length / 2; r++) e.lineTo(o[2 * r], o[2 * r + 1]);
                                o[0] === o[o.length - 2] && o[1] === o[o.length - 1] && e.closePath()
                            } else if (n.type === PIXI.Graphics.RECT) e.rect(a.x, a.y, a.width, a.height), e.closePath();
                            else if (n.type === PIXI.Graphics.CIRC) e.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), e.closePath();
                            else if (n.type === PIXI.Graphics.ELIP) {
                                var h = 2 * a.width,
                                    l = 2 * a.height,
                                    c = a.x - h / 2,
                                    u = a.y - l / 2,
                                    d = .5522848,
                                    p = h / 2 * d,
                                    f = l / 2 * d,
                                    g = c + h,
                                    y = u + l,
                                    m = c + h / 2,
                                    v = u + l / 2;
                                e.moveTo(c, v), e.bezierCurveTo(c, v - f, m - p, u, m, u), e.bezierCurveTo(m + p, u, g, v - f, g, v), e.bezierCurveTo(g, v + f, m + p, y, m, y), e.bezierCurveTo(m - p, y, c, v + f, c, v), e.closePath()
                            } else if (n.type === PIXI.Graphics.RREC) {
                                var b = a.x,
                                    x = a.y,
                                    _ = a.width,
                                    w = a.height,
                                    C = a.radius,
                                    P = Math.min(_, w) / 2 | 0;
                                C = C > P ? P : C, e.moveTo(b, x + C), e.lineTo(b, x + w - C), e.quadraticCurveTo(b, x + w, b + C, x + w), e.lineTo(b + _ - C, x + w), e.quadraticCurveTo(b + _, x + w, b + _, x + w - C), e.lineTo(b + _, x + C), e.quadraticCurveTo(b + _, x, b + _ - C, x), e.lineTo(b + C, x), e.quadraticCurveTo(b, x, b, x + C), e.closePath()
                            }
                        }
                    }
                }, PIXI.CanvasGraphics.updateGraphicsTint = function(t) {
                    if (16777215 !== t.tint)
                        for (var e = (t.tint >> 16 & 255) / 255, i = (t.tint >> 8 & 255) / 255, s = (255 & t.tint) / 255, n = 0; n < t.graphicsData.length; n++) {
                            var a = t.graphicsData[n],
                                o = 0 | a.fillColor,
                                r = 0 | a.lineColor;
                            a._fillTint = ((o >> 16 & 255) / 255 * e * 255 << 16) + ((o >> 8 & 255) / 255 * i * 255 << 8) + (255 & o) / 255 * s * 255, a._lineTint = ((r >> 16 & 255) / 255 * e * 255 << 16) + ((r >> 8 & 255) / 255 * i * 255 << 8) + (255 & r) / 255 * s * 255
                        }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Graphics = function(t, e, i) {
                    void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = a.GRAPHICS, this.physicsType = a.SPRITE, this.anchor = new a.Point, PIXI.Graphics.call(this), a.Component.Core.init.call(this, t, e, i, "", null)
                }, a.Graphics.prototype = Object.create(PIXI.Graphics.prototype), a.Graphics.prototype.constructor = a.Graphics, a.Component.Core.install.call(a.Graphics.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), a.Graphics.prototype.preUpdatePhysics = a.Component.PhysicsBody.preUpdate, a.Graphics.prototype.preUpdateLifeSpan = a.Component.LifeSpan.preUpdate, a.Graphics.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.Graphics.prototype.preUpdateCore = a.Component.Core.preUpdate, a.Graphics.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, a.Graphics.prototype.postUpdate = function() {
                    a.Component.PhysicsBody.postUpdate.call(this), a.Component.FixedToCamera.postUpdate.call(this), this._boundsDirty && (this.updateLocalBounds(), this._boundsDirty = !1);
                    for (var t = 0; t < this.children.length; t++) this.children[t].postUpdate()
                }, a.Graphics.prototype.destroy = function(t) {
                    this.clear(), a.Component.Destroy.prototype.destroy.call(this, t)
                }, a.Graphics.prototype.drawTriangle = function(t, e) {
                    void 0 === e && (e = !1);
                    var i = new a.Polygon(t);
                    if (e) {
                        var s = new a.Point(this.game.camera.x - t[0].x, this.game.camera.y - t[0].y),
                            n = new a.Point(t[1].x - t[0].x, t[1].y - t[0].y),
                            o = new a.Point(t[1].x - t[2].x, t[1].y - t[2].y),
                            r = o.cross(n);
                        s.dot(r) > 0 && this.drawPolygon(i)
                    } else this.drawPolygon(i)
                }, a.Graphics.prototype.drawTriangles = function(t, e, i) {
                    void 0 === i && (i = !1);
                    var s = new a.Point,
                        n = new a.Point,
                        o = new a.Point,
                        r = [],
                        h;
                    if (e)
                        if (t[0] instanceof a.Point)
                            for (h = 0; h < e.length / 3; h++) r.push(t[e[3 * h]]), r.push(t[e[3 * h + 1]]), r.push(t[e[3 * h + 2]]), 3 === r.length && (this.drawTriangle(r, i), r = []);
                        else
                            for (h = 0; h < e.length; h++) s.x = t[2 * e[h]], s.y = t[2 * e[h] + 1], r.push(s.copyTo({})), 3 === r.length && (this.drawTriangle(r, i), r = []);
                    else if (t[0] instanceof a.Point)
                        for (h = 0; h < t.length / 3; h++) this.drawTriangle([t[3 * h], t[3 * h + 1], t[3 * h + 2]], i);
                    else
                        for (h = 0; h < t.length / 6; h++) s.x = t[6 * h + 0], s.y = t[6 * h + 1], n.x = t[6 * h + 2], n.y = t[6 * h + 3], o.x = t[6 * h + 4], o.y = t[6 * h + 5], this.drawTriangle([s, n, o], i)
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.RenderTexture = function(t, e, i, s, n, o) {
                    void 0 === s && (s = ""), void 0 === n && (n = a.scaleModes.DEFAULT), void 0 === o && (o = 1), this.game = t, this.key = s, this.type = a.RENDERTEXTURE, this._tempMatrix = new PIXI.Matrix, PIXI.RenderTexture.call(this, e, i, this.game.renderer, n, o), this.render = a.RenderTexture.prototype.render
                }, a.RenderTexture.prototype = Object.create(PIXI.RenderTexture.prototype), a.RenderTexture.prototype.constructor = a.RenderTexture, a.RenderTexture.prototype.renderXY = function(t, e, i, s) {
                    t.updateTransform(), this._tempMatrix.copyFrom(t.worldTransform), this._tempMatrix.tx = e, this._tempMatrix.ty = i, this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
                }, a.RenderTexture.prototype.renderRawXY = function(t, e, i, s) {
                    this._tempMatrix.identity()
                        .translate(e, i), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, s) : this.renderCanvas(t, this._tempMatrix, s)
                }, a.RenderTexture.prototype.render = function(t, e, i) {
                    void 0 === e || null === e ? this._tempMatrix.copyFrom(t.worldTransform) : this._tempMatrix.copyFrom(e), this.renderer.type === PIXI.WEBGL_RENDERER ? this.renderWebGL(t, this._tempMatrix, i) : this.renderCanvas(t, this._tempMatrix, i)
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Text = function(t, e, i, s, n) {
                    e = e || 0, i = i || 0, s = void 0 === s || null === s ? "" : s.toString(), n = a.Utils.extend({}, n), this.type = a.TEXT, this.physicsType = a.SPRITE, this.padding = new a.Point, this.textBounds = null, this.canvas = PIXI.CanvasPool.create(this), this.context = this.canvas.getContext("2d"), this.colors = [], this.strokeColors = [], this.fontStyles = [], this.fontWeights = [], this.autoRound = !1, this.useAdvancedWrap = !1, this._res = t.renderer.resolution, this._text = s, this._fontComponents = null, this._lineSpacing = 0, this._charCount = 0, this._width = 0, this._height = 0, a.Sprite.call(this, t, e, i, PIXI.Texture.fromCanvas(this.canvas)), this.setStyle(n), "" !== s && this.updateText()
                }, a.Text.prototype = Object.create(a.Sprite.prototype), a.Text.prototype.constructor = a.Text, a.Text.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, a.Text.prototype.update = function() {}, a.Text.prototype.destroy = function(t) {
                    this.texture.destroy(!0), a.Component.Destroy.prototype.destroy.call(this, t)
                }, a.Text.prototype.setShadow = function(t, e, i, s, n, a) {
                    return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = "rgba(0, 0, 0, 1)"), void 0 === s && (s = 0), void 0 === n && (n = !0), void 0 === a && (a = !0), this.style.shadowOffsetX = t, this.style.shadowOffsetY = e, this.style.shadowColor = i, this.style.shadowBlur = s, this.style.shadowStroke = n, this.style.shadowFill = a, this.dirty = !0, this
                }, a.Text.prototype.setStyle = function(t, e) {
                    void 0 === e && (e = !1), t = t || {}, t.font = t.font || "bold 20pt Arial", t.backgroundColor = t.backgroundColor || null, t.fill = t.fill || "black", t.align = t.align || "left", t.boundsAlignH = t.boundsAlignH || "left", t.boundsAlignV = t.boundsAlignV || "top", t.stroke = t.stroke || "black", t.strokeThickness = t.strokeThickness || 0, t.wordWrap = t.wordWrap || !1, t.wordWrapWidth = t.wordWrapWidth || 100, t.maxLines = t.maxLines || 0, t.shadowOffsetX = t.shadowOffsetX || 0, t.shadowOffsetY = t.shadowOffsetY || 0, t.shadowColor = t.shadowColor || "rgba(0,0,0,0)", t.shadowBlur = t.shadowBlur || 0, t.tabs = t.tabs || 0;
                    var i = this.fontToComponents(t.font);
                    return t.fontStyle && (i.fontStyle = t.fontStyle), t.fontVariant && (i.fontVariant = t.fontVariant), t.fontWeight && (i.fontWeight = t.fontWeight), t.fontSize && ("number" == typeof t.fontSize && (t.fontSize = t.fontSize + "px"), i.fontSize = t.fontSize), this._fontComponents = i, t.font = this.componentsToFont(this._fontComponents), this.style = t, this.dirty = !0, e && this.updateText(), this
                }, a.Text.prototype.updateText = function() {
                    this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font;
                    var t = this.text;
                    this.style.wordWrap && (t = this.runWordWrap(this.text));
                    var e = t.split(/(?:\r\n|\r|\n)/),
                        i = this.style.tabs,
                        s = [],
                        n = 0,
                        a = this.determineFontProperties(this.style.font),
                        o = e.length;
                    this.style.maxLines > 0 && this.style.maxLines < e.length && (o = this.style.maxLines), this._charCount = 0;
                    for (var r = 0; r < o; r++) {
                        if (0 === i) {
                            var h = this.style.strokeThickness + this.padding.x;
                            this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(e[r]) : h += this.context.measureText(e[r])
                                .width, this.style.wordWrap && (h -= this.context.measureText(" ")
                                    .width)
                        } else {
                            var l = e[r].split(/(?:\t)/),
                                h = this.padding.x + this.style.strokeThickness;
                            if (Array.isArray(i))
                                for (var c = 0, u = 0; u < l.length; u++) {
                                    var d = 0;
                                    d = this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.measureLine(l[u]) : Math.ceil(this.context.measureText(l[u])
                                        .width), u > 0 && (c += i[u - 1]), h = c + d
                                } else
                                    for (var u = 0; u < l.length; u++) {
                                        this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? h += this.measureLine(l[u]) : h += Math.ceil(this.context.measureText(l[u])
                                            .width);
                                        var p = this.game.math.snapToCeil(h, i) - h;
                                        h += p
                                    }
                        }
                        s[r] = Math.ceil(h), n = Math.max(n, s[r])
                    }
                    this.canvas.width = n * this._res;
                    var f = a.fontSize + this.style.strokeThickness + this.padding.y,
                        g = f * o,
                        y = this._lineSpacing;
                    y < 0 && Math.abs(y) > f && (y = -f), 0 !== y && (g += y > 0 ? y * e.length : y * (e.length - 1)), this.canvas.height = g * this._res, this.context.scale(this._res, this._res), navigator.isCocoonJS && this.context.clearRect(0, 0, this.canvas.width, this.canvas.height), this.style.backgroundColor && (this.context.fillStyle = this.style.backgroundColor, this.context.fillRect(0, 0, this.canvas.width, this.canvas.height)), this.context.fillStyle = this.style.fill, this.context.font = this.style.font, this.context.strokeStyle = this.style.stroke, this.context.textBaseline = "alphabetic", this.context.lineWidth = this.style.strokeThickness, this.context.lineCap = "round", this.context.lineJoin = "round";
                    var m, v;
                    for (this._charCount = 0, r = 0; r < o; r++) m = this.style.strokeThickness / 2, v = this.style.strokeThickness / 2 + r * f + a.ascent, r > 0 && (v += y * r), "right" === this.style.align ? m += n - s[r] : "center" === this.style.align && (m += (n - s[r]) / 2), this.autoRound && (m = Math.round(m), v = Math.round(v)), this.colors.length > 0 || this.strokeColors.length > 0 || this.fontWeights.length > 0 || this.fontStyles.length > 0 ? this.updateLine(e[r], m, v) : (this.style.stroke && this.style.strokeThickness && (this.updateShadow(this.style.shadowStroke), 0 === i ? this.context.strokeText(e[r], m, v) : this.renderTabLine(e[r], m, v, !1)), this.style.fill && (this.updateShadow(this.style.shadowFill), 0 === i ? this.context.fillText(e[r], m, v) : this.renderTabLine(e[r], m, v, !0)));
                    this.updateTexture(), this.dirty = !1
                }, a.Text.prototype.renderTabLine = function(t, e, i, s) {
                    var n = t.split(/(?:\t)/),
                        a = this.style.tabs,
                        o = 0;
                    if (Array.isArray(a))
                        for (var r = 0, h = 0; h < n.length; h++) h > 0 && (r += a[h - 1]), o = e + r, s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i);
                    else
                        for (var h = 0; h < n.length; h++) {
                            var l = Math.ceil(this.context.measureText(n[h])
                                .width);
                            o = this.game.math.snapToCeil(e, a), s ? this.context.fillText(n[h], o, i) : this.context.strokeText(n[h], o, i), e = o + l
                        }
                }, a.Text.prototype.updateShadow = function(t) {
                    t ? (this.context.shadowOffsetX = this.style.shadowOffsetX, this.context.shadowOffsetY = this.style.shadowOffsetY, this.context.shadowColor = this.style.shadowColor, this.context.shadowBlur = this.style.shadowBlur) : (this.context.shadowOffsetX = 0, this.context.shadowOffsetY = 0, this.context.shadowColor = 0, this.context.shadowBlur = 0)
                }, a.Text.prototype.measureLine = function(t) {
                    for (var e = 0, i = 0; i < t.length; i++) {
                        var s = t[i];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var n = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (n.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (n.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(n)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill)), e += this.context.measureText(s)
                            .width, this._charCount++
                    }
                    return Math.ceil(e)
                }, a.Text.prototype.updateLine = function(t, e, i) {
                    for (var s = 0; s < t.length; s++) {
                        var n = t[s];
                        if (this.fontWeights.length > 0 || this.fontStyles.length > 0) {
                            var a = this.fontToComponents(this.context.font);
                            this.fontStyles[this._charCount] && (a.fontStyle = this.fontStyles[this._charCount]), this.fontWeights[this._charCount] && (a.fontWeight = this.fontWeights[this._charCount]), this.context.font = this.componentsToFont(a)
                        }
                        this.style.stroke && this.style.strokeThickness && (this.strokeColors[this._charCount] && (this.context.strokeStyle = this.strokeColors[this._charCount]), this.updateShadow(this.style.shadowStroke), this.context.strokeText(n, e, i)), this.style.fill && (this.colors[this._charCount] && (this.context.fillStyle = this.colors[this._charCount]), this.updateShadow(this.style.shadowFill), this.context.fillText(n, e, i)), e += this.context.measureText(n)
                            .width, this._charCount++
                    }
                }, a.Text.prototype.clearColors = function() {
                    return this.colors = [], this.strokeColors = [], this.dirty = !0, this
                }, a.Text.prototype.clearFontValues = function() {
                    return this.fontStyles = [], this.fontWeights = [], this.dirty = !0, this
                }, a.Text.prototype.addColor = function(t, e) {
                    return this.colors[e] = t, this.dirty = !0, this
                }, a.Text.prototype.addStrokeColor = function(t, e) {
                    return this.strokeColors[e] = t, this.dirty = !0, this
                }, a.Text.prototype.addFontStyle = function(t, e) {
                    return this.fontStyles[e] = t, this.dirty = !0, this
                }, a.Text.prototype.addFontWeight = function(t, e) {
                    return this.fontWeights[e] = t, this.dirty = !0, this
                }, a.Text.prototype.precalculateWordWrap = function(t) {
                    return this.texture.baseTexture.resolution = this._res, this.context.font = this.style.font, this.runWordWrap(t)
                        .split(/(?:\r\n|\r|\n)/)
                }, a.Text.prototype.runWordWrap = function(t) {
                    return this.useAdvancedWrap ? this.advancedWordWrap(t) : this.basicWordWrap(t)
                }, a.Text.prototype.advancedWordWrap = function(t) {
                    for (var e = this.context, i = this.style.wordWrapWidth, s = "", n = t.replace(/ +/gi, " ")
                            .split(/\r?\n/gi), a = n.length, o = 0; o < a; o++) {
                        var r = n[o],
                            h = "";
                        r = r.replace(/^ *|\s*$/gi, "");
                        if (e.measureText(r)
                            .width < i) s += r + "\n";
                        else {
                            for (var l = i, c = r.split(" "), u = 0; u < c.length; u++) {
                                var d = c[u],
                                    p = d + " ",
                                    f = e.measureText(p)
                                    .width;
                                if (f > l) {
                                    if (0 === u) {
                                        for (var g = p; g.length && (g = g.slice(0, -1), !((f = e.measureText(g)
                                                .width) <= l)););
                                        if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!");
                                        var y = d.substr(g.length);
                                        c[u] = y, h += g
                                    }
                                    var m = c[u].length ? u : u + 1,
                                        v = c.slice(m)
                                        .join(" ")
                                        .replace(/[ \n]*$/gi, "");
                                    n[o + 1] = v + " " + (n[o + 1] || ""), a = n.length;
                                    break
                                }
                                h += p, l -= f
                            }
                            s += h.replace(/[ \n]*$/gi, "") + "\n"
                        }
                    }
                    return s = s.replace(/[\s|\n]*$/gi, "")
                }, a.Text.prototype.basicWordWrap = function(t) {
                    for (var e = "", i = t.split("\n"), s = 0; s < i.length; s++) {
                        for (var n = this.style.wordWrapWidth, a = i[s].split(" "), o = 0; o < a.length; o++) {
                            var r = this.context.measureText(a[o])
                                .width,
                                h = r + this.context.measureText(" ")
                                .width;
                            h > n ? (o > 0 && (e += "\n"), e += a[o] + " ", n = this.style.wordWrapWidth - r) : (n -= h, e += a[o] + " ")
                        }
                        s < i.length - 1 && (e += "\n")
                    }
                    return e
                }, a.Text.prototype.updateFont = function(t) {
                    var e = this.componentsToFont(t);
                    this.style.font !== e && (this.style.font = e, this.dirty = !0, this.parent && this.updateTransform())
                }, a.Text.prototype.fontToComponents = function(t) {
                    var e = t.match(/^\s*(?:\b(normal|italic|oblique|inherit)?\b)\s*(?:\b(normal|small-caps|inherit)?\b)\s*(?:\b(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit)?\b)\s*(?:\b(xx-small|x-small|small|medium|large|x-large|xx-large|larger|smaller|0|\d*(?:[.]\d*)?(?:%|[a-z]{2,5}))?\b)\s*(.*)\s*$/);
                    if (e) {
                        var i = e[5].trim();
                        return /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(i) || /['",]/.exec(i) || (i = "'" + i + "'"), {
                            font: t,
                            fontStyle: e[1] || "normal",
                            fontVariant: e[2] || "normal",
                            fontWeight: e[3] || "normal",
                            fontSize: e[4] || "medium",
                            fontFamily: i
                        }
                    }
                    return {
                        font: t
                    }
                }, a.Text.prototype.componentsToFont = function(t) {
                    var e = [],
                        i;
                    return i = t.fontStyle, i && "normal" !== i && e.push(i), i = t.fontVariant, i && "normal" !== i && e.push(i), i = t.fontWeight, i && "normal" !== i && e.push(i), i = t.fontSize, i && "medium" !== i && e.push(i), i = t.fontFamily, i && e.push(i), e.length || e.push(t.font), e.join(" ")
                }, a.Text.prototype.setText = function(t, e) {
                    return void 0 === e && (e = !1), this.text = t.toString() || "", e ? this.updateText() : this.dirty = !0, this
                }, a.Text.prototype.parseList = function(t) {
                    if (!Array.isArray(t)) return this;
                    for (var e = "", i = 0; i < t.length; i++) Array.isArray(t[i]) ? (e += t[i].join("\t"), i < t.length - 1 && (e += "\n")) : (e += t[i], i < t.length - 1 && (e += "\t"));
                    return this.text = e, this.dirty = !0, this
                }, a.Text.prototype.setTextBounds = function(t, e, i, s) {
                    return void 0 === t ? this.textBounds = null : (this.textBounds ? this.textBounds.setTo(t, e, i, s) : this.textBounds = new a.Rectangle(t, e, i, s), this.style.wordWrapWidth > i && (this.style.wordWrapWidth = i)), this.updateTexture(), this
                }, a.Text.prototype.updateTexture = function() {
                    var t = this.texture.baseTexture,
                        e = this.texture.crop,
                        i = this.texture.frame,
                        s = this.canvas.width,
                        n = this.canvas.height;
                    if (t.width = s, t.height = n, e.width = s, e.height = n, i.width = s, i.height = n, this.texture.width = s, this.texture.height = n, this._width = s, this._height = n, this.textBounds) {
                        var a = this.textBounds.x,
                            o = this.textBounds.y;
                        "right" === this.style.boundsAlignH ? a += this.textBounds.width - this.canvas.width / this.resolution : "center" === this.style.boundsAlignH && (a += this.textBounds.halfWidth - this.canvas.width / this.resolution / 2), "bottom" === this.style.boundsAlignV ? o += this.textBounds.height - this.canvas.height / this.resolution : "middle" === this.style.boundsAlignV && (o += this.textBounds.halfHeight - this.canvas.height / this.resolution / 2), this.pivot.x = -a, this.pivot.y = -o
                    }
                    this.renderable = 0 !== s && 0 !== n, this.texture.requiresReTint = !0, this.texture.baseTexture.dirty()
                }, a.Text.prototype._renderWebGL = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderWebGL.call(this, t)
                }, a.Text.prototype._renderCanvas = function(t) {
                    this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype._renderCanvas.call(this, t)
                }, a.Text.prototype.determineFontProperties = function(t) {
                    var e = a.Text.fontPropertiesCache[t];
                    if (!e) {
                        e = {};
                        var i = a.Text.fontPropertiesCanvas,
                            s = a.Text.fontPropertiesContext;
                        s.font = t;
                        var n = Math.ceil(s.measureText("|MÉq")
                                .width),
                            o = Math.ceil(s.measureText("|MÉq")
                                .width),
                            r = 2 * o;
                        if (o = 1.4 * o | 0, i.width = n, i.height = r, s.fillStyle = "#f00", s.fillRect(0, 0, n, r), s.font = t, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText("|MÉq", 0, o), !s.getImageData(0, 0, n, r)) return e.ascent = o, e.descent = o + 6, e.fontSize = e.ascent + e.descent, a.Text.fontPropertiesCache[t] = e, e;
                        var h = s.getImageData(0, 0, n, r)
                            .data,
                            l = h.length,
                            c = 4 * n,
                            u, d, p = 0,
                            f = !1;
                        for (u = 0; u < o; u++) {
                            for (d = 0; d < c; d += 4)
                                if (255 !== h[p + d]) {
                                    f = !0;
                                    break
                                } if (f) break;
                            p += c
                        }
                        for (e.ascent = o - u, p = l - c, f = !1, u = r; u > o; u--) {
                            for (d = 0; d < c; d += 4)
                                if (255 !== h[p + d]) {
                                    f = !0;
                                    break
                                } if (f) break;
                            p -= c
                        }
                        e.descent = u - o, e.descent += 6, e.fontSize = e.ascent + e.descent, a.Text.fontPropertiesCache[t] = e
                    }
                    return e
                }, a.Text.prototype.getBounds = function(t) {
                    return this.dirty && (this.updateText(), this.dirty = !1), PIXI.Sprite.prototype.getBounds.call(this, t)
                }, Object.defineProperty(a.Text.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(a.Text.prototype, "cssFont", {
                    get: function() {
                        return this.componentsToFont(this._fontComponents)
                    },
                    set: function(t) {
                        t = t || "bold 20pt Arial", this._fontComponents = this.fontToComponents(t), this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "font", {
                    get: function() {
                        return this._fontComponents.fontFamily
                    },
                    set: function(t) {
                        t = t || "Arial", t = t.trim(), /^(?:inherit|serif|sans-serif|cursive|fantasy|monospace)$/.exec(t) || /['",]/.exec(t) || (t = "'" + t + "'"), this._fontComponents.fontFamily = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "fontSize", {
                    get: function() {
                        var t = this._fontComponents.fontSize;
                        return t && /(?:^0$|px$)/.exec(t) ? parseInt(t, 10) : t
                    },
                    set: function(t) {
                        t = t || "0", "number" == typeof t && (t += "px"), this._fontComponents.fontSize = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "fontWeight", {
                    get: function() {
                        return this._fontComponents.fontWeight || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontWeight = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "fontStyle", {
                    get: function() {
                        return this._fontComponents.fontStyle || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontStyle = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "fontVariant", {
                    get: function() {
                        return this._fontComponents.fontVariant || "normal"
                    },
                    set: function(t) {
                        t = t || "normal", this._fontComponents.fontVariant = t, this.updateFont(this._fontComponents)
                    }
                }), Object.defineProperty(a.Text.prototype, "fill", {
                    get: function() {
                        return this.style.fill
                    },
                    set: function(t) {
                        t !== this.style.fill && (this.style.fill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "align", {
                    get: function() {
                        return this.style.align
                    },
                    set: function(t) {
                        t !== this.style.align && (this.style.align = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "resolution", {
                    get: function() {
                        return this._res
                    },
                    set: function(t) {
                        t !== this._res && (this._res = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "tabs", {
                    get: function() {
                        return this.style.tabs
                    },
                    set: function(t) {
                        t !== this.style.tabs && (this.style.tabs = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "boundsAlignH", {
                    get: function() {
                        return this.style.boundsAlignH
                    },
                    set: function(t) {
                        t !== this.style.boundsAlignH && (this.style.boundsAlignH = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "boundsAlignV", {
                    get: function() {
                        return this.style.boundsAlignV
                    },
                    set: function(t) {
                        t !== this.style.boundsAlignV && (this.style.boundsAlignV = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "stroke", {
                    get: function() {
                        return this.style.stroke
                    },
                    set: function(t) {
                        t !== this.style.stroke && (this.style.stroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "strokeThickness", {
                    get: function() {
                        return this.style.strokeThickness
                    },
                    set: function(t) {
                        t !== this.style.strokeThickness && (this.style.strokeThickness = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "wordWrap", {
                    get: function() {
                        return this.style.wordWrap
                    },
                    set: function(t) {
                        t !== this.style.wordWrap && (this.style.wordWrap = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "wordWrapWidth", {
                    get: function() {
                        return this.style.wordWrapWidth
                    },
                    set: function(t) {
                        t !== this.style.wordWrapWidth && (this.style.wordWrapWidth = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "lineSpacing", {
                    get: function() {
                        return this._lineSpacing
                    },
                    set: function(t) {
                        t !== this._lineSpacing && (this._lineSpacing = parseFloat(t), this.dirty = !0, this.parent && this.updateTransform())
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowOffsetX", {
                    get: function() {
                        return this.style.shadowOffsetX
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetX && (this.style.shadowOffsetX = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowOffsetY", {
                    get: function() {
                        return this.style.shadowOffsetY
                    },
                    set: function(t) {
                        t !== this.style.shadowOffsetY && (this.style.shadowOffsetY = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowColor", {
                    get: function() {
                        return this.style.shadowColor
                    },
                    set: function(t) {
                        t !== this.style.shadowColor && (this.style.shadowColor = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowBlur", {
                    get: function() {
                        return this.style.shadowBlur
                    },
                    set: function(t) {
                        t !== this.style.shadowBlur && (this.style.shadowBlur = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowStroke", {
                    get: function() {
                        return this.style.shadowStroke
                    },
                    set: function(t) {
                        t !== this.style.shadowStroke && (this.style.shadowStroke = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "shadowFill", {
                    get: function() {
                        return this.style.shadowFill
                    },
                    set: function(t) {
                        t !== this.style.shadowFill && (this.style.shadowFill = t, this.dirty = !0)
                    }
                }), Object.defineProperty(a.Text.prototype, "width", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.x * this.texture.frame.width
                    },
                    set: function(t) {
                        this.scale.x = t / this.texture.frame.width, this._width = t
                    }
                }), Object.defineProperty(a.Text.prototype, "height", {
                    get: function() {
                        return this.dirty && (this.updateText(), this.dirty = !1), this.scale.y * this.texture.frame.height
                    },
                    set: function(t) {
                        this.scale.y = t / this.texture.frame.height, this._height = t
                    }
                }), a.Text.fontPropertiesCache = {}, a.Text.fontPropertiesCanvas = document.createElement("canvas"), a.Text.fontPropertiesContext = a.Text.fontPropertiesCanvas.getContext("2d"),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.BitmapText = function(t, e, i, s, n, o, r) {
                    e = e || 0, i = i || 0, s = s || "", n = n || "", o = o || 32, r = r || "left", PIXI.DisplayObjectContainer.call(this), this.type = a.BITMAPTEXT, this.physicsType = a.SPRITE, this.textWidth = 0, this.textHeight = 0, this.anchor = new a.Point, this._prevAnchor = new a.Point, this._glyphs = [], this._maxWidth = 0, this._text = n.toString() || "", this._data = t.cache.getBitmapFont(s), this._font = s, this._fontSize = o, this._align = r, this._tint = 16777215, this.updateText(), this.dirty = !1, a.Component.Core.init.call(this, t, e, i, "", null)
                }, a.BitmapText.prototype = Object.create(PIXI.DisplayObjectContainer.prototype), a.BitmapText.prototype.constructor = a.BitmapText, a.Component.Core.install.call(a.BitmapText.prototype, ["Angle", "AutoCull", "Bounds", "Destroy", "FixedToCamera", "InputEnabled", "InWorld", "LifeSpan", "PhysicsBody", "Reset"]), a.BitmapText.prototype.preUpdatePhysics = a.Component.PhysicsBody.preUpdate, a.BitmapText.prototype.preUpdateLifeSpan = a.Component.LifeSpan.preUpdate, a.BitmapText.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.BitmapText.prototype.preUpdateCore = a.Component.Core.preUpdate, a.BitmapText.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, a.BitmapText.prototype.postUpdate = function() {
                    a.Component.PhysicsBody.postUpdate.call(this), a.Component.FixedToCamera.postUpdate.call(this), this.body && this.body.type === a.Physics.ARCADE && (this.textWidth === this.body.sourceWidth && this.textHeight === this.body.sourceHeight || this.body.setSize(this.textWidth, this.textHeight))
                }, a.BitmapText.prototype.setText = function(t) {
                    this.text = t
                };
            a.BitmapText.prototype.scanLine = function(t, e, i) {
                    for (var s = 0, n = 0, a = -1, o = 0, r = null, h = this._maxWidth > 0 ? this._maxWidth : null, l = [], c = 0; c < i.length; c++) {
                        var u = c === i.length - 1;
                        if (/(?:\r\n|\r|\n)/.test(i.charAt(c))) return {
                            width: n,
                            text: i.substr(0, c),
                            end: u,
                            chars: l
                        };
                        var d = i.charCodeAt(c),
                            p = t.chars[d],
                            f = 0;
                        void 0 === p && (d = 32, p = t.chars[d]);
                        var g = r && p.kerning[r] ? p.kerning[r] : 0;
                        if (/(\s)/.test(i.charAt(c)) && (a = c, o = n), f = (g + p.texture.width + p.xOffset) * e, h && n + f >= h && a > -1) return {
                            width: o || n,
                            text: i.substr(0, c - (c - a)),
                            end: u,
                            chars: l
                        };
                        n += (p.xAdvance + g) * e, l.push(s + (p.xOffset + g) * e), s += (p.xAdvance + g) * e, r = d
                    }
                    return {
                        width: n,
                        text: i,
                        end: u,
                        chars: l
                    }
                }, a.BitmapText.prototype.cleanText = function(t, e) {
                    void 0 === e && (e = "");
                    var i = this._data.font;
                    if (!i) return "";
                    for (var s = /\r\n|\n\r|\n|\r/g, n = t.replace(s, "\n")
                            .split("\n"), a = 0; a < n.length; a++) {
                        for (var o = "", r = n[a], h = 0; h < r.length; h++) o = i.chars[r.charCodeAt(h)] ? o.concat(r[h]) : o.concat(e);
                        n[a] = o
                    }
                    return n.join("\n")
                }, a.BitmapText.prototype.updateText = function() {
                    var t = this._data.font;
                    if (t) {
                        var e = this.text,
                            i = this._fontSize / t.size,
                            s = [],
                            n = 0;
                        this.textWidth = 0;
                        do {
                            var a = this.scanLine(t, i, e);
                            a.y = n, s.push(a), a.width > this.textWidth && (this.textWidth = a.width), n += t.lineHeight * i, e = e.substr(a.text.length + 1)
                        } while (!1 === a.end);
                        this.textHeight = n;
                        for (var o = 0, r = 0, h = this.textWidth * this.anchor.x, l = this.textHeight * this.anchor.y, c = 0; c < s.length; c++) {
                            var a = s[c];
                            "right" === this._align ? r = this.textWidth - a.width : "center" === this._align && (r = (this.textWidth - a.width) / 2);
                            for (var u = 0; u < a.text.length; u++) {
                                var d = a.text.charCodeAt(u),
                                    p = t.chars[d];
                                void 0 === p && (d = 32, p = t.chars[d]);
                                var f = this._glyphs[o];
                                f ? f.texture = p.texture : (f = new PIXI.Sprite(p.texture), f.name = a.text[u], this._glyphs.push(f)), f.position.x = a.chars[u] + r - h, f.position.y = a.y + p.yOffset * i - l, f.scale.set(i), f.tint = this.tint, f.texture.requiresReTint = !0, f.parent || this.addChild(f), o++
                            }
                        }
                        for (c = o; c < this._glyphs.length; c++) this.removeChild(this._glyphs[c])
                    }
                }, a.BitmapText.prototype.purgeGlyphs = function() {
                    for (var t = this._glyphs.length, e = [], i = 0; i < this._glyphs.length; i++) this._glyphs[i].parent !== this ? this._glyphs[i].destroy() : e.push(this._glyphs[i]);
                    return this._glyphs = [], this._glyphs = e, this.updateText(), t - e.length
                }, a.BitmapText.prototype.updateTransform = function() {
                    !this.dirty && this.anchor.equals(this._prevAnchor) || (this.updateText(), this.dirty = !1, this._prevAnchor.copyFrom(this.anchor)), PIXI.DisplayObjectContainer.prototype.updateTransform.call(this)
                }, Object.defineProperty(a.BitmapText.prototype, "align", {
                    get: function() {
                        return this._align
                    },
                    set: function(t) {
                        t === this._align || "left" !== t && "center" !== t && "right" !== t || (this._align = t, this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "tint", {
                    get: function() {
                        return this._tint
                    },
                    set: function(t) {
                        t !== this._tint && (this._tint = t, this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "font", {
                    get: function() {
                        return this._font
                    },
                    set: function(t) {
                        t !== this._font && (this._font = t.trim(), this._data = this.game.cache.getBitmapFont(this._font), this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "fontSize", {
                    get: function() {
                        return this._fontSize
                    },
                    set: function(t) {
                        (t = parseInt(t, 10)) !== this._fontSize && t > 0 && (this._fontSize = t, this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        t !== this._text && (this._text = t.toString() || "", this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "maxWidth", {
                    get: function() {
                        return this._maxWidth
                    },
                    set: function(t) {
                        t !== this._maxWidth && (this._maxWidth = t, this.updateText())
                    }
                }), Object.defineProperty(a.BitmapText.prototype, "smoothed", {
                    get: function() {
                        return !this._data.base.scaleMode
                    },
                    set: function(t) {
                        this._data.base.scaleMode = t ? 0 : 1
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.RetroFont = function(t, e, i, s, n, o, r, h, l, c) {
                    if (!t.cache.checkImageKey(e)) return !1;
                    void 0 !== o && null !== o || (o = t.cache.getImage(e)
                        .width / i), this.characterWidth = i, this.characterHeight = s, this.characterSpacingX = r || 0, this.characterSpacingY = h || 0, this.characterPerRow = o, this.offsetX = l || 0, this.offsetY = c || 0, this.align = "left", this.multiLine = !1, this.autoUpperCase = !0, this.customSpacingX = 0, this.customSpacingY = 0, this.fixedWidth = 0, this.fontSet = t.cache.getImage(e), this._text = "", this.grabData = [], this.frameData = new a.FrameData;
                    for (var u = this.offsetX, d = this.offsetY, p = 0, f = 0; f < n.length; f++) {
                        var g = this.frameData.addFrame(new a.Frame(f, u, d, this.characterWidth, this.characterHeight));
                        this.grabData[n.charCodeAt(f)] = g.index, p++, p === this.characterPerRow ? (p = 0, u = this.offsetX, d += this.characterHeight + this.characterSpacingY) : u += this.characterWidth + this.characterSpacingX
                    }
                    t.cache.updateFrameData(e, this.frameData), this.stamp = new a.Image(t, 0, 0, e, 0), a.RenderTexture.call(this, t, 100, 100, "", a.scaleModes.NEAREST), this.type = a.RETROFONT
                }, a.RetroFont.prototype = Object.create(a.RenderTexture.prototype), a.RetroFont.prototype.constructor = a.RetroFont, a.RetroFont.ALIGN_LEFT = "left", a.RetroFont.ALIGN_RIGHT = "right", a.RetroFont.ALIGN_CENTER = "center", a.RetroFont.TEXT_SET1 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", a.RetroFont.TEXT_SET2 = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", a.RetroFont.TEXT_SET3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ", a.RetroFont.TEXT_SET4 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789", a.RetroFont.TEXT_SET5 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", a.RetroFont.TEXT_SET6 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", a.RetroFont.TEXT_SET7 = "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", a.RetroFont.TEXT_SET8 = "0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ", a.RetroFont.TEXT_SET9 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", a.RetroFont.TEXT_SET10 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ", a.RetroFont.TEXT_SET11 = "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789", a.RetroFont.prototype.setFixedWidth = function(t, e) {
                    void 0 === e && (e = "left"), this.fixedWidth = t, this.align = e
                }, a.RetroFont.prototype.setText = function(t, e, i, s, n, a) {
                    this.multiLine = e || !1, this.customSpacingX = i || 0, this.customSpacingY = s || 0, this.align = n || "left", this.autoUpperCase = !a, t.length > 0 && (this.text = t)
                }, a.RetroFont.prototype.buildRetroFontText = function() {
                    var t = 0,
                        e = 0;
                    if (this.clear(), this.multiLine) {
                        var i = this._text.split("\n");
                        this.fixedWidth > 0 ? this.resize(this.fixedWidth, i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0) : this.resize(this.getLongestLine() * (this.characterWidth + this.customSpacingX), i.length * (this.characterHeight + this.customSpacingY) - this.customSpacingY, !0);
                        for (var s = 0; s < i.length; s++) t = 0, this.align === a.RetroFont.ALIGN_RIGHT ? t = this.width - i[s].length * (this.characterWidth + this.customSpacingX) : this.align === a.RetroFont.ALIGN_CENTER && (t = this.width / 2 - i[s].length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(i[s], t, e, this.customSpacingX), e += this.characterHeight + this.customSpacingY
                    } else this.fixedWidth > 0 ? this.resize(this.fixedWidth, this.characterHeight, !0) : this.resize(this._text.length * (this.characterWidth + this.customSpacingX), this.characterHeight, !0), t = 0, this.align === a.RetroFont.ALIGN_RIGHT ? t = this.width - this._text.length * (this.characterWidth + this.customSpacingX) : this.align === a.RetroFont.ALIGN_CENTER && (t = this.width / 2 - this._text.length * (this.characterWidth + this.customSpacingX) / 2, t += this.customSpacingX / 2), t < 0 && (t = 0), this.pasteLine(this._text, t, 0, this.customSpacingX);
                    this.requiresReTint = !0
                }, a.RetroFont.prototype.pasteLine = function(t, e, i, s) {
                    for (var n = 0; n < t.length; n++)
                        if (" " === t.charAt(n)) e += this.characterWidth + s;
                        else if (this.grabData[t.charCodeAt(n)] >= 0 && (this.stamp.frame = this.grabData[t.charCodeAt(n)], this.renderXY(this.stamp, e, i, !1), (e += this.characterWidth + s) > this.width)) break
                }, a.RetroFont.prototype.getLongestLine = function() {
                    var t = 0;
                    if (this._text.length > 0)
                        for (var e = this._text.split("\n"), i = 0; i < e.length; i++) e[i].length > t && (t = e[i].length);
                    return t
                }, a.RetroFont.prototype.removeUnsupportedCharacters = function(t) {
                    for (var e = "", i = 0; i < this._text.length; i++) {
                        var s = this._text[i],
                            n = s.charCodeAt(0);
                        (this.grabData[n] >= 0 || !t && "\n" === s) && (e = e.concat(s))
                    }
                    return e
                }, a.RetroFont.prototype.updateOffset = function(t, e) {
                    if (this.offsetX !== t || this.offsetY !== e) {
                        for (var i = t - this.offsetX, s = e - this.offsetY, n = this.game.cache.getFrameData(this.stamp.key)
                                .getFrames(), a = n.length; a--;) n[a].x += i, n[a].y += s;
                        this.buildRetroFontText()
                    }
                }, Object.defineProperty(a.RetroFont.prototype, "text", {
                    get: function() {
                        return this._text
                    },
                    set: function(t) {
                        var e;
                        (e = this.autoUpperCase ? t.toUpperCase() : t) !== this._text && (this._text = e, this.removeUnsupportedCharacters(this.multiLine), this.buildRetroFontText())
                    }
                }), Object.defineProperty(a.RetroFont.prototype, "smoothed", {
                    get: function() {
                        return this.stamp.smoothed
                    },
                    set: function(t) {
                        this.stamp.smoothed = t, this.buildRetroFontText()
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd, Richard Davey
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Rope = function(t, e, i, s, n, o) {
                    this.points = [], this.points = o, this._hasUpdateAnimation = !1, this._updateAnimationCallback = null, e = e || 0, i = i || 0, s = s || null, n = n || null, this.type = a.ROPE, PIXI.Rope.call(this, a.Cache.DEFAULT, this.points), a.Component.Core.init.call(this, t, e, i, s, n)
                }, a.Rope.prototype = Object.create(PIXI.Rope.prototype), a.Rope.prototype.constructor = a.Rope, a.Component.Core.install.call(a.Rope.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Crop", "Delta", "Destroy", "FixedToCamera", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "ScaleMinMax", "Smoothed"]), a.Rope.prototype.preUpdatePhysics = a.Component.PhysicsBody.preUpdate, a.Rope.prototype.preUpdateLifeSpan = a.Component.LifeSpan.preUpdate, a.Rope.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.Rope.prototype.preUpdateCore = a.Component.Core.preUpdate, a.Rope.prototype.preUpdate = function() {
                    return !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, a.Rope.prototype.update = function() {
                    this._hasUpdateAnimation && this.updateAnimation.call(this)
                }, a.Rope.prototype.reset = function(t, e) {
                    return a.Component.Reset.prototype.reset.call(this, t, e), this
                }, Object.defineProperty(a.Rope.prototype, "updateAnimation", {
                    get: function() {
                        return this._updateAnimation
                    },
                    set: function(t) {
                        t && "function" == typeof t ? (this._hasUpdateAnimation = !0, this._updateAnimation = t) : (this._hasUpdateAnimation = !1, this._updateAnimation = null)
                    }
                }), Object.defineProperty(a.Rope.prototype, "segments", {
                    get: function() {
                        for (var t = [], e, i, s, n, o, r, h, l, c = 0; c < this.points.length; c++) e = 4 * c, i = this.vertices[e] * this.scale.x, s = this.vertices[e + 1] * this.scale.y, n = this.vertices[e + 4] * this.scale.x, o = this.vertices[e + 3] * this.scale.y, r = a.Math.difference(i, n), h = a.Math.difference(s, o), i += this.world.x, s += this.world.y, l = new a.Rectangle(i, s, r, h), t.push(l);
                        return t
                    }
                }),
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.TileSprite = function(t, e, i, s, n, o, r) {
                    e = e || 0, i = i || 0, s = s || 256, n = n || 256, o = o || null, r = r || null, this.type = a.TILESPRITE, this.physicsType = a.SPRITE, this._scroll = new a.Point;
                    var h = t.cache.getImage("__default", !0);
                    PIXI.TilingSprite.call(this, new PIXI.Texture(h.base), s, n), a.Component.Core.init.call(this, t, e, i, o, r)
                }, a.TileSprite.prototype = Object.create(PIXI.TilingSprite.prototype), a.TileSprite.prototype.constructor = a.TileSprite, a.Component.Core.install.call(a.TileSprite.prototype, ["Angle", "Animation", "AutoCull", "Bounds", "BringToTop", "Destroy", "FixedToCamera", "Health", "InCamera", "InputEnabled", "InWorld", "LifeSpan", "LoadTexture", "Overlap", "PhysicsBody", "Reset", "Smoothed"]), a.TileSprite.prototype.preUpdatePhysics = a.Component.PhysicsBody.preUpdate, a.TileSprite.prototype.preUpdateLifeSpan = a.Component.LifeSpan.preUpdate, a.TileSprite.prototype.preUpdateInWorld = a.Component.InWorld.preUpdate, a.TileSprite.prototype.preUpdateCore = a.Component.Core.preUpdate, a.TileSprite.prototype.preUpdate = function() {
                    return 0 !== this._scroll.x && (this.tilePosition.x += this._scroll.x * this.game.time.physicsElapsed), 0 !== this._scroll.y && (this.tilePosition.y += this._scroll.y * this.game.time.physicsElapsed), !!(this.preUpdatePhysics() && this.preUpdateLifeSpan() && this.preUpdateInWorld()) && this.preUpdateCore()
                }, a.TileSprite.prototype.autoScroll = function(t, e) {
                    this._scroll.set(t, e)
                }, a.TileSprite.prototype.stopScroll = function() {
                    this._scroll.set(0, 0)
                }, a.TileSprite.prototype.destroy = function(t) {
                    a.Component.Destroy.prototype.destroy.call(this, t), PIXI.TilingSprite.prototype.destroy.call(this)
                }, a.TileSprite.prototype.reset = function(t, e) {
                    return a.Component.Reset.prototype.reset.call(this, t, e), this.tilePosition.x = 0, this.tilePosition.y = 0, this
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Device = function() {
                    this.deviceReadyAt = 0, this.initialized = !1, this.desktop = !1, this.iOS = !1, this.iOSVersion = 0, this.cocoonJS = !1, this.cocoonJSApp = !1, this.cordova = !1, this.node = !1, this.nodeWebkit = !1, this.electron = !1, this.ejecta = !1, this.crosswalk = !1, this.android = !1, this.chromeOS = !1, this.linux = !1, this.macOS = !1, this.windows = !1, this.windowsPhone = !1, this.canvas = !1, this.canvasBitBltShift = null, this.webGL = !1, this.file = !1, this.fileSystem = !1, this.localStorage = !1, this.worker = !1, this.css3D = !1, this.pointerLock = !1, this.typedArray = !1, this.vibration = !1, this.getUserMedia = !0, this.quirksMode = !1, this.touch = !1, this.mspointer = !1, this.wheelEvent = null, this.arora = !1, this.chrome = !1, this.chromeVersion = 0, this.epiphany = !1, this.firefox = !1, this.firefoxVersion = 0, this.ie = !1, this.ieVersion = 0, this.trident = !1, this.tridentVersion = 0, this.edge = !1, this.mobileSafari = !1, this.midori = !1, this.opera = !1, this.safari = !1, this.safariVersion = 0, this.webApp = !1, this.silk = !1, this.audioData = !1, this.webAudio = !1, this.ogg = !1, this.opus = !1, this.mp3 = !1, this.wav = !1, this.m4a = !1, this.webm = !1, this.dolby = !1, this.oggVideo = !1, this.h264Video = !1, this.mp4Video = !1, this.webmVideo = !1, this.vp9Video = !1, this.hlsVideo = !1, this.iPhone = !1, this.iPhone4 = !1, this.iPad = !1, this.pixelRatio = 0, this.littleEndian = !1, this.LITTLE_ENDIAN = !1, this.support32bit = !1, this.fullscreen = !1, this.requestFullscreen = "", this.cancelFullscreen = "", this.fullscreenKeyboard = !1
                }, a.Device = new a.Device, a.Device.onInitialized = new a.Signal, a.Device.whenReady = function(t, e, i) {
                    var s = this._readyCheck;
                    if (this.deviceReadyAt || !s) t.call(e, this);
                    else if (s._monitor || i) s._queue = s._queue || [], s._queue.push([t, e]);
                    else {
                        s._monitor = s.bind(this), s._queue = s._queue || [], s._queue.push([t, e]);
                        var n = void 0 !== window.cordova,
                            a = navigator.isCocoonJS;
                        "complete" === document.readyState || "interactive" === document.readyState ? window.setTimeout(s._monitor, 0) : n && !a ? document.addEventListener("deviceready", s._monitor, !1) : (document.addEventListener("DOMContentLoaded", s._monitor, !1), window.addEventListener("load", s._monitor, !1))
                    }
                }, a.Device._readyCheck = function() {
                    var t = this._readyCheck;
                    if (document.body) {
                        if (!this.deviceReadyAt) {
                            this.deviceReadyAt = Date.now(), document.removeEventListener("deviceready", t._monitor), document.removeEventListener("DOMContentLoaded", t._monitor), window.removeEventListener("load", t._monitor), this._initialize(), this.initialized = !0, this.onInitialized.dispatch(this);
                            for (var e; e = t._queue.shift();) {
                                var i = e[0],
                                    s = e[1];
                                i.call(s, this)
                            }
                            this._readyCheck = null, this._initialize = null, this.onInitialized = null
                        }
                    } else window.setTimeout(t._monitor, 20)
                }, a.Device._initialize = function() {
                    function t() {
                        var t = navigator.userAgent;
                        /Playstation Vita/.test(t) ? d.vita = !0 : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? d.kindle = !0 : /Android/.test(t) ? d.android = !0 : /CrOS/.test(t) ? d.chromeOS = !0 : /iP[ao]d|iPhone/i.test(t) ? (d.iOS = !0, navigator.appVersion.match(/OS (\d+)/), d.iOSVersion = parseInt(RegExp.$1, 10)) : /Linux/.test(t) ? d.linux = !0 : /Mac OS/.test(t) ? d.macOS = !0 : /Windows/.test(t) && (d.windows = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (d.android = !1, d.iOS = !1, d.macOS = !1, d.windows = !0, d.windowsPhone = !0);
                        var e = /Silk/.test(t);
                        (d.windows || d.macOS || d.linux && !e || d.chromeOS) && (d.desktop = !0), (d.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (d.desktop = !1)
                    }

                    function e() {
                        d.canvas = !!window.CanvasRenderingContext2D || d.cocoonJS;
                        try {
                            d.localStorage = !!localStorage.getItem
                        } catch (t) {
                            d.localStorage = !1
                        }
                        d.file = !!(window.File && window.FileReader && window.FileList && window.Blob), d.fileSystem = !!window.requestFileSystem;
                        var t = {
                            stencil: !0
                        };
                        d.webGL = function() {
                            try {
                                var e = document.createElement("canvas");
                                return e.screencanvas = !1, !!window.WebGLRenderingContext && (e.getContext("webgl", t) || e.getContext("experimental-webgl", t))
                            } catch (t) {
                                return !1
                            }
                        }(), d.webGL = !!d.webGL, d.worker = !!window.Worker, d.pointerLock = "pointerLockElement" in document || "mozPointerLockElement" in document || "webkitPointerLockElement" in document, d.quirksMode = "CSS1Compat" !== document.compatMode, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, d.getUserMedia = d.getUserMedia && !!navigator.getUserMedia && !!window.URL, d.firefox && d.firefoxVersion < 21 && (d.getUserMedia = !1), !d.iOS && (d.ie || d.firefox || d.chrome) && (d.canvasBitBltShift = !0), (d.safari || d.mobileSafari) && (d.canvasBitBltShift = !1)
                    }

                    function s() {
                        ("ontouchstart" in document.documentElement || window.navigator.maxTouchPoints && window.navigator.maxTouchPoints >= 1) && (d.touch = !0), (window.navigator.msPointerEnabled || window.navigator.pointerEnabled) && (d.mspointer = !0), d.cocoonJS || ("onwheel" in window || d.ie && "WheelEvent" in window ? d.wheelEvent = "wheel" : "onmousewheel" in window ? d.wheelEvent = "mousewheel" : d.firefox && "MouseScrollEvent" in window && (d.wheelEvent = "DOMMouseScroll"))
                    }

                    function n() {
                        for (var t = ["requestFullscreen", "requestFullScreen", "webkitRequestFullscreen", "webkitRequestFullScreen", "msRequestFullscreen", "msRequestFullScreen", "mozRequestFullScreen", "mozRequestFullscreen"], e = document.createElement("div"), i = 0; i < t.length; i++)
                            if (e[t[i]]) {
                                d.fullscreen = !0, d.requestFullscreen = t[i];
                                break
                            } var s = ["cancelFullScreen", "exitFullscreen", "webkitCancelFullScreen", "webkitExitFullscreen", "msCancelFullScreen", "msExitFullscreen", "mozCancelFullScreen", "mozExitFullscreen"];
                        if (d.fullscreen)
                            for (var i = 0; i < s.length; i++)
                                if (document[s[i]]) {
                                    d.cancelFullscreen = s[i];
                                    break
                                } window.Element && Element.ALLOW_KEYBOARD_INPUT && (d.fullscreenKeyboard = !0)
                    }

                    function a() {
                        var t = navigator.userAgent;
                        if (/Arora/.test(t) ? d.arora = !0 : /Edge\/\d+/.test(t) ? d.edge = !0 : /Chrome\/(\d+)/.test(t) && !d.windowsPhone ? (d.chrome = !0, d.chromeVersion = parseInt(RegExp.$1, 10)) : /Epiphany/.test(t) ? d.epiphany = !0 : /Firefox\D+(\d+)/.test(t) ? (d.firefox = !0, d.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(t) && d.iOS ? d.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(t) ? (d.ie = !0, d.ieVersion = parseInt(RegExp.$1, 10)) : /Midori/.test(t) ? d.midori = !0 : /Opera/.test(t) ? d.opera = !0 : /Safari\/(\d+)/.test(t) && !d.windowsPhone ? (d.safari = !0, /Version\/(\d+)\./.test(t) && (d.safariVersion = parseInt(RegExp.$1, 10))) : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(t) && (d.ie = !0, d.trident = !0, d.tridentVersion = parseInt(RegExp.$1, 10), d.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(t) && (d.silk = !0), navigator.standalone && (d.webApp = !0), void 0 !== window.cordova && (d.cordova = !0), void 0 !== i && (d.node = !0), d.node && "object" == typeof i.versions && (d.nodeWebkit = !!i.versions["node-webkit"], d.electron = !!i.versions.electron), navigator.isCocoonJS && (d.cocoonJS = !0), d.cocoonJS) try {
                            d.cocoonJSApp = "undefined" != typeof CocoonJS
                        } catch (t) {
                            d.cocoonJSApp = !1
                        }
                        void 0 !== window.ejecta && (d.ejecta = !0), /Crosswalk/.test(t) && (d.crosswalk = !0)
                    }

                    function o() {
                        var t = document.createElement("video"),
                            e = !1;
                        try {
                            (e = !!t.canPlayType) && (t.canPlayType('video/ogg; codecs="theora"')
                                .replace(/^no$/, "") && (d.oggVideo = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"')
                                .replace(/^no$/, "") && (d.h264Video = !0, d.mp4Video = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"')
                                .replace(/^no$/, "") && (d.webmVideo = !0), t.canPlayType('video/webm; codecs="vp9"')
                                .replace(/^no$/, "") && (d.vp9Video = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"')
                                .replace(/^no$/, "") && (d.hlsVideo = !0))
                        } catch (t) {}
                    }

                    function r() {
                        d.audioData = !!window.Audio, d.webAudio = !(!window.AudioContext && !window.webkitAudioContext);
                        var t = document.createElement("audio"),
                            e = !1;
                        try {
                            if ((e = !!t.canPlayType) && (t.canPlayType('audio/ogg; codecs="vorbis"')
                                    .replace(/^no$/, "") && (d.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"')
                                        .replace(/^no$/, "") || t.canPlayType("audio/opus;")
                                        .replace(/^no$/, "")) && (d.opus = !0), t.canPlayType("audio/mpeg;")
                                    .replace(/^no$/, "") && (d.mp3 = !0), t.canPlayType('audio/wav; codecs="1"')
                                    .replace(/^no$/, "") && (d.wav = !0), (t.canPlayType("audio/x-m4a;") || t.canPlayType("audio/aac;")
                                        .replace(/^no$/, "")) && (d.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"')
                                    .replace(/^no$/, "") && (d.webm = !0), "" !== t.canPlayType('audio/mp4;codecs="ec-3"')))
                                if (d.edge) d.dolby = !0;
                                else if (d.safari && d.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) {
                                var i = parseInt(RegExp.$1, 10),
                                    s = parseInt(RegExp.$2, 10);
                                (10 === i && s >= 11 || i > 10) && (d.dolby = !0)
                            }
                        } catch (t) {}
                    }

                    function h() {
                        var t = new ArrayBuffer(4),
                            e = new Uint8Array(t),
                            i = new Uint32Array(t);
                        return e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, 3569595041 === i[0] || 2712847316 !== i[0] && null
                    }

                    function l() {
                        if (void 0 === Uint8ClampedArray) return !1;
                        var t = PIXI.CanvasPool.create(this, 1, 1),
                            e = t.getContext("2d");
                        if (!e) return !1;
                        var i = e.createImageData(1, 1);
                        return PIXI.CanvasPool.remove(this), i.data instanceof Uint8ClampedArray
                    }

                    function c() {
                        d.pixelRatio = window.devicePixelRatio || 1, d.iPhone = -1 !== navigator.userAgent.toLowerCase()
                            .indexOf("iphone"), d.iPhone4 = 2 === d.pixelRatio && d.iPhone, d.iPad = -1 !== navigator.userAgent.toLowerCase()
                            .indexOf("ipad"), "undefined" != typeof Int8Array ? d.typedArray = !0 : d.typedArray = !1, "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array && "undefined" != typeof Uint32Array && (d.littleEndian = h(), d.LITTLE_ENDIAN = d.littleEndian), d.support32bit = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8ClampedArray && "undefined" != typeof Int32Array && null !== d.littleEndian && l(), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (d.vibration = !0)
                    }

                    function u() {
                        var t = document.createElement("p"),
                            e, i = {
                                webkitTransform: "-webkit-transform",
                                OTransform: "-o-transform",
                                msTransform: "-ms-transform",
                                MozTransform: "-moz-transform",
                                transform: "transform"
                            };
                        document.body.insertBefore(t, null);
                        for (var s in i) void 0 !== t.style[s] && (t.style[s] = "translate3d(1px,1px,1px)", e = window.getComputedStyle(t)
                            .getPropertyValue(i[s]));
                        document.body.removeChild(t), d.css3D = void 0 !== e && e.length > 0 && "none" !== e
                    }
                    var d = this;
                    t(), a(), r(), o(), u(), c(), e(), n(), s()
                }, a.Device.canPlayAudio = function(t) {
                    return !("mp3" !== t || !this.mp3) || (!("ogg" !== t || !this.ogg && !this.opus) || (!("m4a" !== t || !this.m4a) || (!("opus" !== t || !this.opus) || (!("wav" !== t || !this.wav) || (!("webm" !== t || !this.webm) || !("mp4" !== t || !this.dolby))))))
                }, a.Device.canPlayVideo = function(t) {
                    return !("webm" !== t || !this.webmVideo && !this.vp9Video) || (!("mp4" !== t || !this.mp4Video && !this.h264Video) || (!("ogg" !== t && "ogv" !== t || !this.oggVideo) || !("mpeg" !== t || !this.hlsVideo)))
                }, a.Device.isConsoleOpen = function() {
                    return !(!window.console || !window.console.firebug) || !(!window.console || (console.clear, !console.profiles)) && console.profiles.length > 0
                }, a.Device.isAndroidStockBrowser = function() {
                    var t = window.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                    return t && t[1] < 537
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Canvas = {
                    create: function(t, e, i, s, n) {
                        e = e || 256, i = i || 256;
                        var a = n ? document.createElement("canvas") : PIXI.CanvasPool.create(t, e, i);
                        return "string" == typeof s && "" !== s && (a.id = s), a.width = e, a.height = i, a.style.display = "block", a
                    },
                    setBackgroundColor: function(t, e) {
                        return e = e || "rgb(0,0,0)", t.style.backgroundColor = e, t
                    },
                    setTouchAction: function(t, e) {
                        return e = e || "none", t.style.msTouchAction = e, t.style["ms-touch-action"] = e, t.style["touch-action"] = e, t
                    },
                    setUserSelect: function(t, e) {
                        return e = e || "none", t.style["-webkit-touch-callout"] = e, t.style["-webkit-user-select"] = e, t.style["-khtml-user-select"] = e, t.style["-moz-user-select"] = e, t.style["-ms-user-select"] = e, t.style["user-select"] = e, t.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)", t
                    },
                    addToDOM: function(t, e, i) {
                        var s;
                        return void 0 === i && (i = !0), e && ("string" == typeof e ? s = document.getElementById(e) : "object" == typeof e && 1 === e.nodeType && (s = e)), s || (s = document.body), i && s.style && (s.style.overflow = "hidden"), s.appendChild(t), t
                    },
                    removeFromDOM: function(t) {
                        t.parentNode && t.parentNode.removeChild(t)
                    },
                    setTransform: function(t, e, i, s, n, a, o) {
                        return t.setTransform(s, a, o, n, e, i), t
                    },
                    setSmoothingEnabled: function(t, e) {
                        var i = a.Canvas.getSmoothingPrefix(t);
                        return i && (t[i] = e), t
                    },
                    getSmoothingPrefix: function(t) {
                        var e = ["i", "webkitI", "msI", "mozI", "oI"];
                        for (var i in e) {
                            var s = e[i] + "mageSmoothingEnabled";
                            if (s in t) return s
                        }
                        return null
                    },
                    getSmoothingEnabled: function(t) {
                        var e = a.Canvas.getSmoothingPrefix(t);
                        if (e) return t[e]
                    },
                    setImageRenderingCrisp: function(t) {
                        for (var e = ["optimizeSpeed", "crisp-edges", "-moz-crisp-edges", "-webkit-optimize-contrast", "optimize-contrast", "pixelated"], i = 0; i < e.length; i++) t.style["image-rendering"] = e[i];
                        return t.style.msInterpolationMode = "nearest-neighbor", t
                    },
                    setImageRenderingBicubic: function(t) {
                        return t.style["image-rendering"] = "auto", t.style.msInterpolationMode = "bicubic", t
                    }
                },
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.RequestAnimationFrame = function(t, e) {
                    void 0 === e && (e = !1), this.game = t, this.isRunning = !1, this.forceSetTimeOut = e;
                    for (var i = ["ms", "moz", "webkit", "o"], s = 0; s < i.length && !window.requestAnimationFrame; s++) window.requestAnimationFrame = window[i[s] + "RequestAnimationFrame"], window.cancelAnimationFrame = window[i[s] + "CancelAnimationFrame"];
                    this._isSetTimeOut = !1, this._onLoop = null, this._timeOutID = null
                }, a.RequestAnimationFrame.prototype = {
                    start: function() {
                        this.isRunning = !0;
                        var t = this;
                        !window.requestAnimationFrame || this.forceSetTimeOut ? (this._isSetTimeOut = !0, this._onLoop = function() {
                            return t.updateSetTimeout()
                        }, this._timeOutID = window.setTimeout(this._onLoop, 0)) : (this._isSetTimeOut = !1, this._onLoop = function(e) {
                            return t.updateRAF(e)
                        }, this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateRAF: function(t) {
                        this.isRunning && (this.game.update(Math.floor(t)), this._timeOutID = window.requestAnimationFrame(this._onLoop))
                    },
                    updateSetTimeout: function() {
                        this.isRunning && (this.game.update(Date.now()), this._timeOutID = window.setTimeout(this._onLoop, this.game.time.timeToCall))
                    },
                    stop: function() {
                        this._isSetTimeOut ? clearTimeout(this._timeOutID) : window.cancelAnimationFrame(this._timeOutID), this.isRunning = !1
                    },
                    isSetTimeOut: function() {
                        return this._isSetTimeOut
                    },
                    isRAF: function() {
                        return !1 === this._isSetTimeOut
                    }
                }, a.RequestAnimationFrame.prototype.constructor = a.RequestAnimationFrame,
                /**
                 * @author       Richard Davey <rich@photonstorm.com>
                 * @copyright    2016 Photon Storm Ltd.
                 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
                 */
                a.Math = {
                    PI2: 2 * Math.PI,
                    between: function(t, e) {
                        return Math.floor(Math.random() * (e - t + 1) + t)
                    },
                    fuzzyEqual: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), Math.abs(t - e) < i
                    },
                    fuzzyLessThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t < e + i
                    },
                    fuzzyGreaterThan: function(t, e, i) {
                        return void 0 === i && (i = 1e-4), t > e - i
                    },
                    fuzzyCeil: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.ceil(t - e)
                    },
                    fuzzyFloor: function(t, e) {
                        return void 0 === e && (e = 1e-4), Math.floor(t + e)
                    },
                    average: function() {
                        for (var t = 0, e = arguments.length, i = 0; i < e; i++) t += +arguments[i];
                        return t / e
                    },
                    shear: function(t) {
                        return t % 1
                    },
                    snapTo: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.round(t / e), i + t)
                    },
                    snapToFloor: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.floor(t / e), i + t)
                    },
                    snapToCeil: function(t, e, i) {
                        return void 0 === i && (i = 0), 0 === e ? t : (t -= i, t = e * Math.ceil(t / e), i + t)
                    },
                    roundTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.round(t * s) / s
                    },
                    floorTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.floor(t * s) / s
                    },
                    ceilTo: function(t, e, i) {
                        void 0 === e && (e = 0), void 0 === i && (i = 10);
                        var s = Math.pow(i, -e);
                        return Math.ceil(t * s) / s
                    },
                    rotateToAngle: function(t, e, i) {
                        return void 0 === i && (i = .05), t === e ? t : (Math.abs(e - t) <= i || Math.abs(e - t) >= a.Math.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += a.Math.PI2 : e -= a.Math.PI2), e > t ? t += i : e < t && (t -= i)), t)
                    },
                    getShortestAngle: function(t, e) {
                        var i = e - t;
                        return 0 === i ? 0 : i - 360 * Math.floor((i - -180) / 360)
                    },
                    angleBetween: function(t, e, i, s) {
                        return Math.atan2(s - e, i - t)
                    },
                    angleBetweenY: function(t, e, i, s) {
                        return Math.atan2(i - t, s - e)
                    },
                    angleBetweenPoints: function(t, e) {
                        return Math.atan2(e.y - t.y, e.x - t.x)
                    },
                    angleBetweenPointsY: function(t, e) {
                        return Math.atan2(e.x - t.x, e.y - t.y)
                    },
                    reverseAngle: function(t) {
                        return this.normalizeAngle(t + Math.PI, !0)
                    },
                    normalizeAngle: function(t) {
                        return t %= 2 * Math.PI, t >= 0 ? t : t + 2 * Math.PI
                    },
                    maxAdd: function(t, e, i) {
                        return Math.min(t + e, i)
                    },
                    minSub: function(t, e, i) {
                        return Math.max(t - e, i)
                    },
                    wrap: function(t, e, i) {
                        var s = i - e;
                        if (s <= 0) return 0;
                        var n = (t - e) % s;
                        return n < 0 && (n += s), n + e
                    },
                    wrapValue: function(t, e, i) {
                        var s;
                        return t = Math.abs(t), e = Math.abs(e), i = Math.abs(i), s = (t + e) % i
                    },
                    isOdd: function(t) {
                        return !!(1 & t)
                    },
                    isEven: function(t) {
                        return !(1 & t)
                    },
                    min: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                        else var t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] < t[i] && (i = e);
                        return t[i]
                    },
                    max: function() {
                        if (1 === arguments.length && "object" == typeof arguments[0]) var t = arguments[0];
                        else var t = arguments;
                        for (var e = 1, i = 0, s = t.length; e < s; e++) t[e] > t[i] && (i = e);
                        return t[i]
                    },
                    minProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                        else var e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] < e[s][t] && (s = i);
                        return e[s][t]
                    },
                    maxProperty: function(t) {
                        if (2 === arguments.length && "object" == typeof arguments[1]) var e = arguments[1];
                        else var e = arguments.slice(1);
                        for (var i = 1, s = 0, n = e.length; i < n; i++) e[i][t] > e[s][t] && (s = i);
                        return e[s][t]
                    },
                    wrapAngle: function(t, e) {
                        return e ? this.wrap(t, -Math.PI, Math.PI) : this.wrap(t, -180, 180)
                    },
                    linearInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return e < 0 ? this.linear(t[0], t[1], s) : e > 1 ? this.linear(t[i], t[i - 1], i - s) : this.linear(t[n], t[n + 1 > i ? i : n + 1], s - n)
                    },
                    bezierInterpolation: function(t, e) {
                        for (var i = 0, s = t.length - 1, n = 0; n <= s; n++) i += Math.pow(1 - e, s - n) * Math.pow(e, n) * t[n] * this.bernstein(s, n);
                        return i
                    },
                    catmullRomInterpolation: function(t, e) {
                        var i = t.length - 1,
                            s = i * e,
                            n = Math.floor(s);
                        return t[0] === t[i] ? (e < 0 && (n = Math.floor(s = i * (1 + e))), this.catmullRom(t[(n - 1 + i) % i], t[n], t[(n + 1) % i], t[(n + 2) % i], s - n)) : e < 0 ? t[0] - (this.catmullRom(t[0], t[0], t[1], t[1], -s) - t[0]) : e > 1 ? t[i] - (this.catmullRom(t[i], t[i], t[i - 1], t[i - 1], s - i) - t[i]) : this.catmullRom(t[n ? n - 1 : 0], t[n], t[i < n + 1 ? i : n + 1], t[i < n + 2 ? i : n + 2], s - n)
                    },
                    linear: function(t, e, i) {
                        return (e - t) * i + t
                    },
                    bernstein: function(t, e) {
                        return this.factorial(t) / this.factorial(e) / this.factorial(t - e)
                    },
                    factorial: function(t) {
                        if (0 === t) return 1;
                        for (var e = t; --t;) e *= t;
                        return e
                    },
                    catmullRom: function(t, e, i, s, n) {
                        var a = .5 * (i - t),
                            o = .5 * (s - e),
                            r = n * n;
                        return (2 * e - 2 * i + a + o) * (n * r) + (-3 * e + 3 * i - 2 * a - o) * r + a * n + e
                    },
                    difference: function(t, e) {
                        return Math.abs(t - e)
                    },
                    roundAwayFromZero: function(t) {
                        return t > 0 ? Math.ceil(t) : Math.floor(t)
                    },
                    sinCosGenerator: function(t, e, i, s) {
                        void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1);
                        for (var n = e, a = i, o = s * Math.PI / t, r = [], h = [], l = 0; l < t; l++) a -= n * o, n += a * o, r[l] = a, h[l] = n;
                        return {
                            sin: h,
                            cos: r,
                            length: t
                        }
                    },
                    distance: function(t, e, i, s) {
                        var n = t - i,
                            a = e - s;
                        return Math.sqrt(n * n + a * a)
                    },
                    distanceSq: function(t, e, i, s) {
                        var n = t - i,
                            a = e - s;
                        return n * n + a * a
                    },
                    distancePow: function(t, e, i, s, n) {
                        return void 0 === n && (n = 2), Math.sqrt(Math.pow(i - t, n) + Math.pow(s - e, n))
                    },
                    clamp: function(t, e, i) {
                        return t < e ? e : i < t ? i : t
                    },
                    clampBottom: function(t, e) {
                        return t < e ? e : t
                    },
                    within: function(t, e, i) {
                        return Math.abs(t - e) <= i
                    },
                    mapLinear: function(t, e, i, s, n) {
                        return s + (t - e) * (n - s) / (i - e)
                    },
                    smoothstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * (3 - 2 * t)
                    },
                    smootherstep: function(t, e, i) {
                        return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10)
                    },
                    sign: function(t) {
                        return t < 0 ? -1 : t > 0 ? 1 : 0
                    },
                    percent: function(t, e, i) {
                        return void 0 === i && (i = 0), t > e || i > e ? 1 : t < i || i > t ? 0 : (t - i) / e
                    }
                };
            var p = Math.PI / 180,
                f = 180 / Math.PI;
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Timo Hausmann
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Jeremy Dowell <jeremy@codevinsky.com>
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Georgios Kaleadis https://github.com/georgiee
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       George https://github.com/georgiee
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            /**
             * @author       Richard Davey <rich@photonstorm.com>
             * @copyright    2016 Photon Storm Ltd.
             * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
             */
            return a.Math.degToRad = function t(e) {
                return e * p
            }, a.Math.radToDeg = function t(e) {
                return e * f
            }, a.RandomDataGenerator = function(t) {
                void 0 === t && (t = []), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, "string" == typeof t ? this.state(t) : this.sow(t)
            }, a.RandomDataGenerator.prototype = {
                rnd: function() {
                    var t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c;
                    return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2
                },
                sow: function(t) {
                    if (this.s0 = this.hash(" "), this.s1 = this.hash(this.s0), this.s2 = this.hash(this.s1), this.c = 1, t)
                        for (var e = 0; e < t.length && null != t[e]; e++) {
                            var i = t[e];
                            this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0)
                        }
                },
                hash: function(t) {
                    var e, i, s;
                    for (s = 4022871197, t = t.toString(), i = 0; i < t.length; i++) s += t.charCodeAt(i), e = .02519603282416938 * s, s = e >>> 0, e -= s, e *= s, s = e >>> 0, e -= s, s += 4294967296 * e;
                    return 2.3283064365386963e-10 * (s >>> 0)
                },
                integer: function() {
                    return 4294967296 * this.rnd.apply(this)
                },
                frac: function() {
                    return this.rnd.apply(this) + 1.1102230246251565e-16 * (2097152 * this.rnd.apply(this) | 0)
                },
                real: function() {
                    return this.integer() + this.frac()
                },
                integerInRange: function(t, e) {
                    return Math.floor(this.realInRange(0, e - t + 1) + t)
                },
                between: function(t, e) {
                    return this.integerInRange(t, e)
                },
                realInRange: function(t, e) {
                    return this.frac() * (e - t) + t
                },
                normal: function() {
                    return 1 - 2 * this.frac()
                },
                uuid: function() {
                    var t = "",
                        e = "";
                    for (e = t = ""; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4)
                        .toString(16) : "-");
                    return e
                },
                pick: function(t) {
                    return t[this.integerInRange(0, t.length - 1)]
                },
                sign: function() {
                    return this.pick([-1, 1])
                },
                weightedPick: function(t) {
                    return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + .5)]
                },
                timestamp: function(t, e) {
                    return this.realInRange(t || 9466848e5, e || 1577862e6)
                },
                angle: function() {
                    return this.integerInRange(-180, 180)
                },
                state: function(t) {
                    return "string" == typeof t && t.match(/^!rnd/) && (t = t.split(","), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ["!rnd", this.c, this.s0, this.s1, this.s2].join(",")
                }
            }, a.RandomDataGenerator.prototype.constructor = a.RandomDataGenerator, a.QuadTree = function(t, e, i, s, n, a, o) {
                this.maxObjects = 10, this.maxLevels = 4, this.level = 0, this.bounds = {}, this.objects = [], this.nodes = [], this._empty = [], this.reset(t, e, i, s, n, a, o)
            }, a.QuadTree.prototype = {
                reset: function(t, e, i, s, n, a, o) {
                    this.maxObjects = n || 10, this.maxLevels = a || 4, this.level = o || 0, this.bounds = {
                        x: Math.round(t),
                        y: Math.round(e),
                        width: i,
                        height: s,
                        subWidth: Math.floor(i / 2),
                        subHeight: Math.floor(s / 2),
                        right: Math.round(t) + Math.floor(i / 2),
                        bottom: Math.round(e) + Math.floor(s / 2)
                    }, this.objects.length = 0, this.nodes.length = 0
                },
                populate: function(t) {
                    t.forEach(this.populateHandler, this, !0)
                },
                populateHandler: function(t) {
                    t.body && t.exists && this.insert(t.body)
                },
                split: function() {
                    this.nodes[0] = new a.QuadTree(this.bounds.right, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[1] = new a.QuadTree(this.bounds.x, this.bounds.y, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[2] = new a.QuadTree(this.bounds.x, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1), this.nodes[3] = new a.QuadTree(this.bounds.right, this.bounds.bottom, this.bounds.subWidth, this.bounds.subHeight, this.maxObjects, this.maxLevels, this.level + 1)
                },
                insert: function(t) {
                    var e = 0,
                        i;
                    if (null != this.nodes[0] && -1 !== (i = this.getIndex(t))) return void this.nodes[i].insert(t);
                    if (this.objects.push(t), this.objects.length > this.maxObjects && this.level < this.maxLevels)
                        for (null == this.nodes[0] && this.split(); e < this.objects.length;) i = this.getIndex(this.objects[e]), -1 !== i ? this.nodes[i].insert(this.objects.splice(e, 1)[0]) : e++
                },
                getIndex: function(t) {
                    var e = -1;
                    return t.x < this.bounds.right && t.right < this.bounds.right ? t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 1 : t.y > this.bounds.bottom && (e = 2) : t.x > this.bounds.right && (t.y < this.bounds.bottom && t.bottom < this.bounds.bottom ? e = 0 : t.y > this.bounds.bottom && (e = 3)), e
                },
                retrieve: function(t) {
                    if (t instanceof a.Rectangle) var e = this.objects,
                        i = this.getIndex(t);
                    else {
                        if (!t.body) return this._empty;
                        var e = this.objects,
                            i = this.getIndex(t.body)
                    }
                    return this.nodes[0] && (-1 !== i ? e = e.concat(this.nodes[i].retrieve(t)) : (e = e.concat(this.nodes[0].retrieve(t)), e = e.concat(this.nodes[1].retrieve(t)), e = e.concat(this.nodes[2].retrieve(t)), e = e.concat(this.nodes[3].retrieve(t)))), e
                },
                clear: function() {
                    this.objects.length = 0;
                    for (var t = this.nodes.length; t--;) this.nodes[t].clear(), this.nodes.splice(t, 1);
                    this.nodes.length = 0
                }
            }, a.QuadTree.prototype.constructor = a.QuadTree, a.Net = function(t) {
                this.game = t
            }, a.Net.prototype = {
                getHostName: function() {
                    return window.location && window.location.hostname ? window.location.hostname : null
                },
                checkDomainName: function(t) {
                    return -1 !== window.location.hostname.indexOf(t)
                },
                updateQueryString: function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 !== s && "" !== s || (s = window.location.href);
                    var n = "",
                        a = new RegExp("([?|&])" + t + "=.*?(&|#|$)(.*)", "gi");
                    if (a.test(s)) n = void 0 !== e && null !== e ? s.replace(a, "$1" + t + "=" + e + "$2$3") : s.replace(a, "$1$3")
                        .replace(/(&|\?)$/, "");
                    else if (void 0 !== e && null !== e) {
                        var o = -1 !== s.indexOf("?") ? "&" : "?",
                            r = s.split("#");
                        s = r[0] + o + t + "=" + e, r[1] && (s += "#" + r[1]), n = s
                    } else n = s;
                    if (!i) return n;
                    window.location.href = n
                },
                getQueryString: function(t) {
                    void 0 === t && (t = "");
                    var e = {},
                        i = location.search.substring(1)
                        .split("&");
                    for (var s in i) {
                        var n = i[s].split("=");
                        if (n.length > 1) {
                            if (t && t === this.decodeURI(n[0])) return this.decodeURI(n[1]);
                            e[this.decodeURI(n[0])] = this.decodeURI(n[1])
                        }
                    }
                    return e
                },
                decodeURI: function(t) {
                    return decodeURIComponent(t.replace(/\+/g, " "))
                }
            }, a.Net.prototype.constructor = a.Net, a.TweenManager = function(t) {
                this.game = t, this.frameBased = !1, this._tweens = [], this._add = [], this.easeMap = {
                    Power0: a.Easing.Power0,
                    Power1: a.Easing.Power1,
                    Power2: a.Easing.Power2,
                    Power3: a.Easing.Power3,
                    Power4: a.Easing.Power4,
                    Linear: a.Easing.Linear.None,
                    Quad: a.Easing.Quadratic.Out,
                    Cubic: a.Easing.Cubic.Out,
                    Quart: a.Easing.Quartic.Out,
                    Quint: a.Easing.Quintic.Out,
                    Sine: a.Easing.Sinusoidal.Out,
                    Expo: a.Easing.Exponential.Out,
                    Circ: a.Easing.Circular.Out,
                    Elastic: a.Easing.Elastic.Out,
                    Back: a.Easing.Back.Out,
                    Bounce: a.Easing.Bounce.Out,
                    "Quad.easeIn": a.Easing.Quadratic.In,
                    "Cubic.easeIn": a.Easing.Cubic.In,
                    "Quart.easeIn": a.Easing.Quartic.In,
                    "Quint.easeIn": a.Easing.Quintic.In,
                    "Sine.easeIn": a.Easing.Sinusoidal.In,
                    "Expo.easeIn": a.Easing.Exponential.In,
                    "Circ.easeIn": a.Easing.Circular.In,
                    "Elastic.easeIn": a.Easing.Elastic.In,
                    "Back.easeIn": a.Easing.Back.In,
                    "Bounce.easeIn": a.Easing.Bounce.In,
                    "Quad.easeOut": a.Easing.Quadratic.Out,
                    "Cubic.easeOut": a.Easing.Cubic.Out,
                    "Quart.easeOut": a.Easing.Quartic.Out,
                    "Quint.easeOut": a.Easing.Quintic.Out,
                    "Sine.easeOut": a.Easing.Sinusoidal.Out,
                    "Expo.easeOut": a.Easing.Exponential.Out,
                    "Circ.easeOut": a.Easing.Circular.Out,
                    "Elastic.easeOut": a.Easing.Elastic.Out,
                    "Back.easeOut": a.Easing.Back.Out,
                    "Bounce.easeOut": a.Easing.Bounce.Out,
                    "Quad.easeInOut": a.Easing.Quadratic.InOut,
                    "Cubic.easeInOut": a.Easing.Cubic.InOut,
                    "Quart.easeInOut": a.Easing.Quartic.InOut,
                    "Quint.easeInOut": a.Easing.Quintic.InOut,
                    "Sine.easeInOut": a.Easing.Sinusoidal.InOut,
                    "Expo.easeInOut": a.Easing.Exponential.InOut,
                    "Circ.easeInOut": a.Easing.Circular.InOut,
                    "Elastic.easeInOut": a.Easing.Elastic.InOut,
                    "Back.easeInOut": a.Easing.Back.InOut,
                    "Bounce.easeInOut": a.Easing.Bounce.InOut
                }, this.game.onPause.add(this._pauseAll, this), this.game.onResume.add(this._resumeAll, this)
            }, a.TweenManager.prototype = {
                getAll: function() {
                    return this._tweens
                },
                removeAll: function() {
                    for (var t = 0; t < this._tweens.length; t++) this._tweens[t].pendingDelete = !0;
                    this._add = []
                },
                removeFrom: function(t, e) {
                    void 0 === e && (e = !0);
                    var i, s;
                    if (Array.isArray(t))
                        for (i = 0, s = t.length; i < s; i++) this.removeFrom(t[i]);
                    else if (t.type === a.GROUP && e)
                        for (var i = 0, s = t.children.length; i < s; i++) this.removeFrom(t.children[i]);
                    else {
                        for (i = 0, s = this._tweens.length; i < s; i++) t === this._tweens[i].target && this.remove(this._tweens[i]);
                        for (i = 0, s = this._add.length; i < s; i++) t === this._add[i].target && this.remove(this._add[i])
                    }
                },
                add: function(t) {
                    t._manager = this, this._add.push(t)
                },
                create: function(t) {
                    return new a.Tween(t, this.game, this)
                },
                remove: function(t) {
                    var e = this._tweens.indexOf(t); - 1 !== e ? this._tweens[e].pendingDelete = !0 : -1 !== (e = this._add.indexOf(t)) && (this._add[e].pendingDelete = !0)
                },
                update: function() {
                    var t = this._add.length,
                        e = this._tweens.length;
                    if (0 === e && 0 === t) return !1;
                    for (var i = 0; i < e;) this._tweens[i].update(this.game.time.time) ? i++ : (this._tweens.splice(i, 1), e--);
                    return t > 0 && (this._tweens = this._tweens.concat(this._add), this._add.length = 0), !0
                },
                isTweening: function(t) {
                    return this._tweens.some(function(e) {
                        return e.target === t
                    })
                },
                _pauseAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._pause()
                },
                _resumeAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t]._resume()
                },
                pauseAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].pause()
                },
                resumeAll: function() {
                    for (var t = this._tweens.length - 1; t >= 0; t--) this._tweens[t].resume(!0)
                }
            }, a.TweenManager.prototype.constructor = a.TweenManager, a.Tween = function(t, e, i) {
                this.game = e, this.target = t, this.manager = i, this.timeline = [], this.reverse = !1, this.timeScale = 1, this.repeatCounter = 0, this.pendingDelete = !1, this.onStart = new a.Signal, this.onLoop = new a.Signal, this.onRepeat = new a.Signal, this.onChildComplete = new a.Signal, this.onComplete = new a.Signal, this.isRunning = !1, this.current = 0, this.properties = {}, this.chainedTween = null, this.isPaused = !1, this.frameBased = i.frameBased, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, this._pausedTime = 0, this._codePaused = !1, this._hasStarted = !1
            }, a.Tween.prototype = {
                to: function(t, e, i, s, n, o, r) {
                    return (void 0 === e || e <= 0) && (e = 1e3), void 0 !== i && null !== i || (i = a.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === r && (r = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? this : (this.timeline.push(new a.TweenData(this)
                        .to(t, e, i, n, o, r)), s && this.start(), this)
                },
                from: function(t, e, i, s, n, o, r) {
                    return void 0 === e && (e = 1e3), void 0 !== i && null !== i || (i = a.Easing.Default), void 0 === s && (s = !1), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === r && (r = !1), "string" == typeof i && this.manager.easeMap[i] && (i = this.manager.easeMap[i]), this.isRunning ? this : (this.timeline.push(new a.TweenData(this)
                        .from(t, e, i, n, o, r)), s && this.start(), this)
                },
                start: function(t) {
                    if (void 0 === t && (t = 0), null === this.game || null === this.target || 0 === this.timeline.length || this.isRunning) return this;
                    for (var e = 0; e < this.timeline.length; e++)
                        for (var i in this.timeline[e].vEnd) this.properties[i] = this.target[i] || 0, Array.isArray(this.properties[i]) || (this.properties[i] *= 1);
                    for (var e = 0; e < this.timeline.length; e++) this.timeline[e].loadValues();
                    return this.manager.add(this), this.isRunning = !0, (t < 0 || t > this.timeline.length - 1) && (t = 0), this.current = t, this.timeline[this.current].start(), this
                },
                stop: function(t) {
                    return void 0 === t && (t = !1), this.isRunning = !1, this._onUpdateCallback = null, this._onUpdateCallbackContext = null, t && (this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start()), this.manager.remove(this), this
                },
                updateTweenData: function(t, e, i) {
                    if (0 === this.timeline.length) return this;
                    if (void 0 === i && (i = 0), -1 === i)
                        for (var s = 0; s < this.timeline.length; s++) this.timeline[s][t] = e;
                    else this.timeline[i][t] = e;
                    return this
                },
                delay: function(t, e) {
                    return this.updateTweenData("delay", t, e)
                },
                repeat: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("repeatCounter", t, i), this.updateTweenData("repeatDelay", e, i)
                },
                repeatDelay: function(t, e) {
                    return this.updateTweenData("repeatDelay", t, e)
                },
                yoyo: function(t, e, i) {
                    return void 0 === e && (e = 0), this.updateTweenData("yoyo", t, i), this.updateTweenData("yoyoDelay", e, i)
                },
                yoyoDelay: function(t, e) {
                    return this.updateTweenData("yoyoDelay", t, e)
                },
                easing: function(t, e) {
                    return "string" == typeof t && this.manager.easeMap[t] && (t = this.manager.easeMap[t]), this.updateTweenData("easingFunction", t, e)
                },
                interpolation: function(t, e, i) {
                    return void 0 === e && (e = a.Math), this.updateTweenData("interpolationFunction", t, i), this.updateTweenData("interpolationContext", e, i)
                },
                repeatAll: function(t) {
                    return void 0 === t && (t = 0), this.repeatCounter = t, this
                },
                chain: function() {
                    for (var t = arguments.length; t--;) t > 0 ? arguments[t - 1].chainedTween = arguments[t] : this.chainedTween = arguments[t];
                    return this
                },
                loop: function(t) {
                    return void 0 === t && (t = !0), this.repeatCounter = t ? -1 : 0, this
                },
                onUpdateCallback: function(t, e) {
                    return this._onUpdateCallback = t, this._onUpdateCallbackContext = e, this
                },
                pause: function() {
                    this.isPaused = !0, this._codePaused = !0, this._pausedTime = this.game.time.time
                },
                _pause: function() {
                    this._codePaused || (this.isPaused = !0, this._pausedTime = this.game.time.time)
                },
                resume: function() {
                    if (this.isPaused) {
                        this.isPaused = !1, this._codePaused = !1;
                        for (var t = 0; t < this.timeline.length; t++) this.timeline[t].isRunning || (this.timeline[t].startTime += this.game.time.time - this._pausedTime)
                    }
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                update: function(t) {
                    if (this.pendingDelete || !this.target) return !1;
                    if (this.isPaused) return !0;
                    var e = this.timeline[this.current].update(t);
                    if (e === a.TweenData.PENDING) return !0;
                    if (e === a.TweenData.RUNNING) return this._hasStarted || (this.onStart.dispatch(this.target, this), this._hasStarted = !0), null !== this._onUpdateCallback && this._onUpdateCallback.call(this._onUpdateCallbackContext, this, this.timeline[this.current].value, this.timeline[this.current]), this.isRunning;
                    if (e === a.TweenData.LOOPED) return -1 === this.timeline[this.current].repeatCounter ? this.onLoop.dispatch(this.target, this) : this.onRepeat.dispatch(this.target, this), !0;
                    if (e === a.TweenData.COMPLETE) {
                        var i = !1;
                        return this.reverse ? --this.current < 0 && (this.current = this.timeline.length - 1, i = !0) : ++this.current === this.timeline.length && (this.current = 0, i = !0), i ? -1 === this.repeatCounter ? (this.timeline[this.current].start(), this.onLoop.dispatch(this.target, this), !0) : this.repeatCounter > 0 ? (this.repeatCounter--, this.timeline[this.current].start(), this.onRepeat.dispatch(this.target, this), !0) : (this.isRunning = !1, this.onComplete.dispatch(this.target, this), this._hasStarted = !1, this.chainedTween && this.chainedTween.start(), !1) : (this.onChildComplete.dispatch(this.target, this), this.timeline[this.current].start(), !0)
                    }
                },
                generateData: function(t, e) {
                    if (null === this.game || null === this.target) return null;
                    void 0 === t && (t = 60), void 0 === e && (e = []);
                    for (var i = 0; i < this.timeline.length; i++)
                        for (var s in this.timeline[i].vEnd) this.properties[s] = this.target[s] || 0, Array.isArray(this.properties[s]) || (this.properties[s] *= 1);
                    for (var i = 0; i < this.timeline.length; i++) this.timeline[i].loadValues();
                    for (var i = 0; i < this.timeline.length; i++) e = e.concat(this.timeline[i].generateData(t));
                    return e
                }
            }, Object.defineProperty(a.Tween.prototype, "totalDuration", {
                get: function() {
                    for (var t = 0, e = 0; e < this.timeline.length; e++) t += this.timeline[e].duration;
                    return t
                }
            }), a.Tween.prototype.constructor = a.Tween, a.TweenData = function(t) {
                this.parent = t, this.game = t.game, this.vStart = {}, this.vStartCache = {}, this.vEnd = {}, this.vEndCache = {}, this.duration = 1e3, this.percent = 0, this.value = 0, this.repeatCounter = 0, this.repeatDelay = 0, this.repeatTotal = 0, this.interpolate = !1, this.yoyo = !1, this.yoyoDelay = 0, this.inReverse = !1, this.delay = 0, this.dt = 0, this.startTime = null, this.easingFunction = a.Easing.Default, this.interpolationFunction = a.Math.linearInterpolation, this.interpolationContext = a.Math, this.isRunning = !1, this.isFrom = !1
            }, a.TweenData.PENDING = 0, a.TweenData.RUNNING = 1, a.TweenData.LOOPED = 2, a.TweenData.COMPLETE = 3, a.TweenData.prototype = {
                to: function(t, e, i, s, n, a) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = a, this.isFrom = !1, this
                },
                from: function(t, e, i, s, n, a) {
                    return this.vEnd = t, this.duration = e, this.easingFunction = i, this.delay = s, this.repeatTotal = n, this.yoyo = a, this.isFrom = !0, this
                },
                start: function() {
                    if (this.startTime = this.game.time.time + this.delay, this.parent.reverse ? this.dt = this.duration : this.dt = 0, this.delay > 0 ? this.isRunning = !1 : this.isRunning = !0, this.isFrom)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t], this.parent.target[t] = this.vStart[t];
                    return this.value = 0, this.yoyoCounter = 0, this.repeatCounter = this.repeatTotal, this
                },
                loadValues: function() {
                    for (var t in this.parent.properties) {
                        if (this.vStart[t] = this.parent.properties[t], Array.isArray(this.vEnd[t])) {
                            if (0 === this.vEnd[t].length) continue;
                            0 === this.percent && (this.vEnd[t] = [this.vStart[t]].concat(this.vEnd[t]))
                        }
                        void 0 !== this.vEnd[t] ? ("string" == typeof this.vEnd[t] && (this.vEnd[t] = this.vStart[t] + parseFloat(this.vEnd[t], 10)), this.parent.properties[t] = this.vEnd[t]) : this.vEnd[t] = this.vStart[t], this.vStartCache[t] = this.vStart[t], this.vEndCache[t] = this.vEnd[t]
                    }
                    return this
                },
                update: function(t) {
                    if (this.isRunning) {
                        if (t < this.startTime) return a.TweenData.RUNNING
                    } else {
                        if (!(t >= this.startTime)) return a.TweenData.PENDING;
                        this.isRunning = !0
                    }
                    var e = this.parent.frameBased ? this.game.time.physicsElapsedMS : this.game.time.elapsedMS;
                    this.parent.reverse ? (this.dt -= e * this.parent.timeScale, this.dt = Math.max(this.dt, 0)) : (this.dt += e * this.parent.timeScale, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                    for (var i in this.vEnd) {
                        var s = this.vStart[i],
                            n = this.vEnd[i];
                        Array.isArray(n) ? this.parent.target[i] = this.interpolationFunction.call(this.interpolationContext, n, this.value) : this.parent.target[i] = s + (n - s) * this.value
                    }
                    return !this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent ? this.repeat() : a.TweenData.RUNNING
                },
                generateData: function(t) {
                    this.parent.reverse ? this.dt = this.duration : this.dt = 0;
                    var e = [],
                        i = !1,
                        s = 1 / t * 1e3;
                    do {
                        this.parent.reverse ? (this.dt -= s, this.dt = Math.max(this.dt, 0)) : (this.dt += s, this.dt = Math.min(this.dt, this.duration)), this.percent = this.dt / this.duration, this.value = this.easingFunction(this.percent);
                        var n = {};
                        for (var a in this.vEnd) {
                            var o = this.vStart[a],
                                r = this.vEnd[a];
                            Array.isArray(r) ? n[a] = this.interpolationFunction(r, this.value) : n[a] = o + (r - o) * this.value
                        }
                        e.push(n), (!this.parent.reverse && 1 === this.percent || this.parent.reverse && 0 === this.percent) && (i = !0)
                    } while (!i);
                    if (this.yoyo) {
                        var h = e.slice();
                        h.reverse(), e = e.concat(h)
                    }
                    return e
                },
                repeat: function() {
                    if (this.yoyo) {
                        if (this.inReverse && 0 === this.repeatCounter) {
                            for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                            return this.inReverse = !1, a.TweenData.COMPLETE
                        }
                        this.inReverse = !this.inReverse
                    } else if (0 === this.repeatCounter) return a.TweenData.COMPLETE;
                    if (this.inReverse)
                        for (var t in this.vStartCache) this.vStart[t] = this.vEndCache[t], this.vEnd[t] = this.vStartCache[t];
                    else {
                        for (var t in this.vStartCache) this.vStart[t] = this.vStartCache[t], this.vEnd[t] = this.vEndCache[t];
                        this.repeatCounter > 0 && this.repeatCounter--
                    }
                    return this.startTime = this.game.time.time, this.yoyo && this.inReverse ? this.startTime += this.yoyoDelay : this.inReverse || (this.startTime += this.repeatDelay), this.parent.reverse ? this.dt = this.duration : this.dt = 0, a.TweenData.LOOPED
                }
            }, a.TweenData.prototype.constructor = a.TweenData, a.Easing = {
                Linear: {
                    None: function(t) {
                        return t
                    }
                },
                Quadratic: {
                    In: function(t) {
                        return t * t
                    },
                    Out: function(t) {
                        return t * (2 - t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t : -.5 * (--t * (t - 2) - 1)
                    }
                },
                Cubic: {
                    In: function(t) {
                        return t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t : .5 * ((t -= 2) * t * t + 2)
                    }
                },
                Quartic: {
                    In: function(t) {
                        return t * t * t * t
                    },
                    Out: function(t) {
                        return 1 - --t * t * t * t
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t : -.5 * ((t -= 2) * t * t * t - 2)
                    }
                },
                Quintic: {
                    In: function(t) {
                        return t * t * t * t * t
                    },
                    Out: function(t) {
                        return --t * t * t * t * t + 1
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? .5 * t * t * t * t * t : .5 * ((t -= 2) * t * t * t * t + 2)
                    }
                },
                Sinusoidal: {
                    In: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : 1 - Math.cos(t * Math.PI / 2)
                    },
                    Out: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : Math.sin(t * Math.PI / 2)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : .5 * (1 - Math.cos(Math.PI * t))
                    }
                },
                Exponential: {
                    In: function(t) {
                        return 0 === t ? 0 : Math.pow(1024, t - 1)
                    },
                    Out: function(t) {
                        return 1 === t ? 1 : 1 - Math.pow(2, -10 * t)
                    },
                    InOut: function(t) {
                        return 0 === t ? 0 : 1 === t ? 1 : (t *= 2) < 1 ? .5 * Math.pow(1024, t - 1) : .5 * (2 - Math.pow(2, -10 * (t - 1)))
                    }
                },
                Circular: {
                    In: function(t) {
                        return 1 - Math.sqrt(1 - t * t)
                    },
                    Out: function(t) {
                        return Math.sqrt(1 - --t * t)
                    },
                    InOut: function(t) {
                        return (t *= 2) < 1 ? -.5 * (Math.sqrt(1 - t * t) - 1) : .5 * (Math.sqrt(1 - (t -= 2) * t) + 1)
                    }
                },
                Elastic: {
                    In: function(t) {
                        var e, i = .1,
                            s = .4;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = s * Math.asin(1 / i) / (2 * Math.PI), -i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / s))
                    },
                    Out: function(t) {
                        var e, i = .1,
                            s = .4;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = s * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * t) * Math.sin((t - e) * (2 * Math.PI) / s) + 1)
                    },
                    InOut: function(t) {
                        var e, i = .1,
                            s = .4;
                        return 0 === t ? 0 : 1 === t ? 1 : (!i || i < 1 ? (i = 1, e = .1) : e = s * Math.asin(1 / i) / (2 * Math.PI), (t *= 2) < 1 ? i * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / s) * -.5 : i * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - e) * (2 * Math.PI) / s) * .5 + 1)
                    }
                },
                Back: {
                    In: function(t) {
                        var e = 1.70158;
                        return t * t * ((e + 1) * t - e)
                    },
                    Out: function(t) {
                        var e = 1.70158;
                        return --t * t * ((e + 1) * t + e) + 1
                    },
                    InOut: function(t) {
                        var e = 2.5949095;
                        return (t *= 2) < 1 ? t * t * ((e + 1) * t - e) * .5 : .5 * ((t -= 2) * t * ((e + 1) * t + e) + 2)
                    }
                },
                Bounce: {
                    In: function(t) {
                        return 1 - a.Easing.Bounce.Out(1 - t)
                    },
                    Out: function(t) {
                        return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375
                    },
                    InOut: function(t) {
                        return t < .5 ? .5 * a.Easing.Bounce.In(2 * t) : .5 * a.Easing.Bounce.Out(2 * t - 1) + .5
                    }
                }
            }, a.Easing.Default = a.Easing.Linear.None, a.Easing.Power0 = a.Easing.Linear.None, a.Easing.Power1 = a.Easing.Quadratic.Out, a.Easing.Power2 = a.Easing.Cubic.Out, a.Easing.Power3 = a.Easing.Quartic.Out, a.Easing.Power4 = a.Easing.Quintic.Out, a.Time = function(t) {
                this.game = t, this.time = 0, this.prevTime = 0, this.now = 0, this.elapsed = 0, this.elapsedMS = 0, this.physicsElapsed = 1 / 60, this.physicsElapsedMS = 1 / 60 * 1e3, this.desiredFpsMult = 1 / 60, this._desiredFps = 60, this.suggestedFps = this.desiredFps, this.slowMotion = 1, this.advancedTiming = !1, this.frames = 0, this.fps = 0, this.fpsMin = 1e3, this.fpsMax = 0, this.msMin = 1e3, this.msMax = 0, this.pauseDuration = 0, this.timeToCall = 0, this.timeExpected = 0, this.events = new a.Timer(this.game, !1), this._frameCount = 0, this._elapsedAccumulator = 0, this._started = 0, this._timeLastSecond = 0, this._pauseStarted = 0, this._justResumed = !1, this._timers = []
            }, a.Time.prototype = {
                boot: function() {
                    this._started = Date.now(), this.time = Date.now(), this.events.start(), this.timeExpected = this.time
                },
                add: function(t) {
                    return this._timers.push(t), t
                },
                create: function(t) {
                    void 0 === t && (t = !0);
                    var e = new a.Timer(this.game, t);
                    return this._timers.push(e), e
                },
                removeAll: function() {
                    for (var t = 0; t < this._timers.length; t++) this._timers[t].destroy();
                    this._timers = [], this.events.removeAll()
                },
                refresh: function() {
                    var t = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - t
                },
                update: function(t) {
                    var e = this.time;
                    this.time = Date.now(), this.elapsedMS = this.time - e, this.prevTime = this.now, this.now = t, this.elapsed = this.now - this.prevTime, this.game.raf._isSetTimeOut && (this.timeToCall = Math.floor(Math.max(0, 1e3 / this._desiredFps - (this.timeExpected - t))), this.timeExpected = t + this.timeToCall), this.advancedTiming && this.updateAdvancedTiming(), this.game.paused || (this.events.update(this.time), this._timers.length && this.updateTimers())
                },
                updateTimers: function() {
                    for (var t = 0, e = this._timers.length; t < e;) this._timers[t].update(this.time) ? t++ : (this._timers.splice(t, 1), e--)
                },
                updateAdvancedTiming: function() {
                    this._frameCount++, this._elapsedAccumulator += this.elapsed, this._frameCount >= 2 * this._desiredFps && (this.suggestedFps = 5 * Math.floor(200 / (this._elapsedAccumulator / this._frameCount)), this._frameCount = 0, this._elapsedAccumulator = 0), this.msMin = Math.min(this.msMin, this.elapsed), this.msMax = Math.max(this.msMax, this.elapsed), this.frames++, this.now > this._timeLastSecond + 1e3 && (this.fps = Math.round(1e3 * this.frames / (this.now - this._timeLastSecond)), this.fpsMin = Math.min(this.fpsMin, this.fps), this.fpsMax = Math.max(this.fpsMax, this.fps), this._timeLastSecond = this.now, this.frames = 0)
                },
                gamePaused: function() {
                    this._pauseStarted = Date.now(), this.events.pause();
                    for (var t = this._timers.length; t--;) this._timers[t]._pause()
                },
                gameResumed: function() {
                    this.time = Date.now(), this.pauseDuration = this.time - this._pauseStarted, this.events.resume();
                    for (var t = this._timers.length; t--;) this._timers[t]._resume()
                },
                totalElapsedSeconds: function() {
                    return .001 * (this.time - this._started)
                },
                elapsedSince: function(t) {
                    return this.time - t
                },
                elapsedSecondsSince: function(t) {
                    return .001 * (this.time - t)
                },
                reset: function() {
                    this._started = this.time, this.removeAll()
                }
            }, Object.defineProperty(a.Time.prototype, "desiredFps", {
                get: function() {
                    return this._desiredFps
                },
                set: function(t) {
                    this._desiredFps = t, this.physicsElapsed = 1 / t, this.physicsElapsedMS = 1e3 * this.physicsElapsed, this.desiredFpsMult = 1 / t
                }
            }), a.Time.prototype.constructor = a.Time, a.Timer = function(t, e) {
                void 0 === e && (e = !0), this.game = t, this.running = !1, this.autoDestroy = e, this.expired = !1, this.elapsed = 0, this.events = [], this.onComplete = new a.Signal, this.nextTick = 0, this.timeCap = 1e3, this.paused = !1, this._codePaused = !1, this._started = 0, this._pauseStarted = 0, this._pauseTotal = 0, this._now = Date.now(), this._len = 0, this._marked = 0, this._i = 0, this._diff = 0, this._newTick = 0
            }, a.Timer.MINUTE = 6e4, a.Timer.SECOND = 1e3, a.Timer.HALF = 500, a.Timer.QUARTER = 250, a.Timer.prototype = {
                create: function(t, e, i, s, n, o) {
                    t = Math.round(t);
                    var r = t;
                    0 === this._now ? r += this.game.time.time : r += this._now;
                    var h = new a.TimerEvent(this, t, r, i, e, s, n, o);
                    return this.events.push(h), this.order(), this.expired = !1, h
                },
                add: function(t, e, i) {
                    return this.create(t, !1, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                repeat: function(t, e, i, s) {
                    return this.create(t, !1, e, i, s, Array.prototype.slice.call(arguments, 4))
                },
                loop: function(t, e, i) {
                    return this.create(t, !0, 0, e, i, Array.prototype.slice.call(arguments, 3))
                },
                start: function(t) {
                    if (!this.running) {
                        this._started = this.game.time.time + (t || 0), this.running = !0;
                        for (var e = 0; e < this.events.length; e++) this.events[e].tick = this.events[e].delay + this._started
                    }
                },
                stop: function(t) {
                    this.running = !1, void 0 === t && (t = !0), t && (this.events.length = 0)
                },
                remove: function(t) {
                    for (var e = 0; e < this.events.length; e++)
                        if (this.events[e] === t) return this.events[e].pendingDelete = !0, !0;
                    return !1
                },
                order: function() {
                    this.events.length > 0 && (this.events.sort(this.sortHandler), this.nextTick = this.events[0].tick)
                },
                sortHandler: function(t, e) {
                    return t.tick < e.tick ? -1 : t.tick > e.tick ? 1 : 0
                },
                clearPendingEvents: function() {
                    for (this._i = this.events.length; this._i--;) this.events[this._i].pendingDelete && this.events.splice(this._i, 1);
                    this._len = this.events.length, this._i = 0
                },
                update: function(t) {
                    if (this.paused) return !0;
                    if (this.elapsed = t - this._now, this._now = t, this.elapsed > this.timeCap && this.adjustEvents(t - this.elapsed), this._marked = 0, this.clearPendingEvents(), this.running && this._now >= this.nextTick && this._len > 0) {
                        for (; this._i < this._len && this.running && this._now >= this.events[this._i].tick && !this.events[this._i].pendingDelete;) this._newTick = this._now + this.events[this._i].delay - (this._now - this.events[this._i].tick), this._newTick < 0 && (this._newTick = this._now + this.events[this._i].delay), !0 === this.events[this._i].loop ? (this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : this.events[this._i].repeatCount > 0 ? (this.events[this._i].repeatCount--, this.events[this._i].tick = this._newTick, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)) : (this._marked++, this.events[this._i].pendingDelete = !0, this.events[this._i].callback.apply(this.events[this._i].callbackContext, this.events[this._i].args)), this._i++;
                        this.events.length > this._marked ? this.order() : (this.expired = !0, this.onComplete.dispatch(this))
                    }
                    return !this.expired || !this.autoDestroy
                },
                pause: function() {
                    this.running && (this._codePaused = !0, this.paused || (this._pauseStarted = this.game.time.time, this.paused = !0))
                },
                _pause: function() {
                    !this.paused && this.running && (this._pauseStarted = this.game.time.time, this.paused = !0)
                },
                adjustEvents: function(t) {
                    for (var e = 0; e < this.events.length; e++)
                        if (!this.events[e].pendingDelete) {
                            var i = this.events[e].tick - t;
                            i < 0 && (i = 0), this.events[e].tick = this._now + i
                        } var s = this.nextTick - t;
                    this.nextTick = s < 0 ? this._now : this._now + s
                },
                resume: function() {
                    if (this.paused) {
                        var t = this.game.time.time;
                        this._pauseTotal += t - this._now, this._now = t, this.adjustEvents(this._pauseStarted), this.paused = !1, this._codePaused = !1
                    }
                },
                _resume: function() {
                    this._codePaused || this.resume()
                },
                removeAll: function() {
                    this.onComplete.removeAll(), this.events.length = 0, this._len = 0, this._i = 0
                },
                destroy: function() {
                    this.onComplete.removeAll(), this.running = !1, this.events = [], this._len = 0, this._i = 0
                }
            }, Object.defineProperty(a.Timer.prototype, "next", {
                get: function() {
                    return this.nextTick
                }
            }), Object.defineProperty(a.Timer.prototype, "duration", {
                get: function() {
                    return this.running && this.nextTick > this._now ? this.nextTick - this._now : 0
                }
            }), Object.defineProperty(a.Timer.prototype, "length", {
                get: function() {
                    return this.events.length
                }
            }), Object.defineProperty(a.Timer.prototype, "ms", {
                get: function() {
                    return this.running ? this._now - this._started - this._pauseTotal : 0
                }
            }), Object.defineProperty(a.Timer.prototype, "seconds", {
                get: function() {
                    return this.running ? .001 * this.ms : 0
                }
            }), a.Timer.prototype.constructor = a.Timer, a.TimerEvent = function(t, e, i, s, n, a, o, r) {
                this.timer = t, this.delay = e, this.tick = i, this.repeatCount = s - 1, this.loop = n, this.callback = a, this.callbackContext = o, this.args = r, this.pendingDelete = !1
            }, a.TimerEvent.prototype.constructor = a.TimerEvent, a.AnimationManager = function(t) {
                this.sprite = t, this.game = t.game, this.currentFrame = null, this.currentAnim = null, this.updateIfVisible = !0, this.isLoaded = !1, this._frameData = null, this._anims = {}, this._outputFrames = []
            }, a.AnimationManager.prototype = {
                loadFrameData: function(t, e) {
                    if (void 0 === t) return !1;
                    if (this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(t);
                    return this._frameData = t, void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                },
                copyFrameData: function(t, e) {
                    if (this._frameData = t.clone(), this.isLoaded)
                        for (var i in this._anims) this._anims[i].updateFrameData(this._frameData);
                    return void 0 === e || null === e ? this.frame = 0 : "string" == typeof e ? this.frameName = e : this.frame = e, this.isLoaded = !0, !0
                },
                add: function(t, e, i, s, n) {
                    return e = e || [], i = i || 60, void 0 === s && (s = !1), void 0 === n && (n = !(!e || "number" != typeof e[0])), this._outputFrames = [], this._frameData.getFrameIndexes(e, n, this._outputFrames), this._anims[t] = new a.Animation(this.game, this.sprite, t, this._frameData, this._outputFrames, i, s), this.currentAnim = this._anims[t], this.sprite.tilingTexture && (this.sprite.refreshTexture = !0), this._anims[t]
                },
                validateFrames: function(t, e) {
                    void 0 === e && (e = !0);
                    for (var i = 0; i < t.length; i++)
                        if (!0 === e) {
                            if (t[i] > this._frameData.total) return !1
                        } else if (!1 === this._frameData.checkFrameName(t[i])) return !1;
                    return !0
                },
                play: function(t, e, i, s) {
                    if (this._anims[t]) return this.currentAnim === this._anims[t] ? !1 === this.currentAnim.isPlaying ? (this.currentAnim.paused = !1, this.currentAnim.play(e, i, s)) : this.currentAnim : (this.currentAnim && this.currentAnim.isPlaying && this.currentAnim.stop(), this.currentAnim = this._anims[t], this.currentAnim.paused = !1, this.currentFrame = this.currentAnim.currentFrame, this.currentAnim.play(e, i, s))
                },
                stop: function(t, e) {
                    void 0 === e && (e = !1), !this.currentAnim || "string" == typeof t && t !== this.currentAnim.name || this.currentAnim.stop(e)
                },
                update: function() {
                    return !(this.updateIfVisible && !this.sprite.visible) && (!(!this.currentAnim || !this.currentAnim.update()) && (this.currentFrame = this.currentAnim.currentFrame, !0))
                },
                next: function(t) {
                    this.currentAnim && (this.currentAnim.next(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                previous: function(t) {
                    this.currentAnim && (this.currentAnim.previous(t), this.currentFrame = this.currentAnim.currentFrame)
                },
                getAnimation: function(t) {
                    return "string" == typeof t && this._anims[t] ? this._anims[t] : null
                },
                refreshFrame: function() {},
                destroy: function() {
                    var t = null;
                    for (var t in this._anims) this._anims.hasOwnProperty(t) && this._anims[t].destroy();
                    this._anims = {}, this._outputFrames = [], this._frameData = null, this.currentAnim = null, this.currentFrame = null, this.sprite = null, this.game = null
                }
            }, a.AnimationManager.prototype.constructor = a.AnimationManager, Object.defineProperty(a.AnimationManager.prototype, "frameData", {
                get: function() {
                    return this._frameData
                }
            }), Object.defineProperty(a.AnimationManager.prototype, "frameTotal", {
                get: function() {
                    return this._frameData.total
                }
            }), Object.defineProperty(a.AnimationManager.prototype, "paused", {
                get: function() {
                    return this.currentAnim.isPaused
                },
                set: function(t) {
                    this.currentAnim.paused = t
                }
            }), Object.defineProperty(a.AnimationManager.prototype, "name", {
                get: function() {
                    if (this.currentAnim) return this.currentAnim.name
                }
            }), Object.defineProperty(a.AnimationManager.prototype, "frame", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.index
                },
                set: function(t) {
                    "number" == typeof t && this._frameData && null !== this._frameData.getFrame(t) && (this.currentFrame = this._frameData.getFrame(t), this.currentFrame && this.sprite.setFrame(this.currentFrame))
                }
            }), Object.defineProperty(a.AnimationManager.prototype, "frameName", {
                get: function() {
                    if (this.currentFrame) return this.currentFrame.name
                },
                set: function(t) {
                    "string" == typeof t && this._frameData && null !== this._frameData.getFrameByName(t) && (this.currentFrame = this._frameData.getFrameByName(t), this.currentFrame && (this._frameIndex = this.currentFrame.index, this.sprite.setFrame(this.currentFrame)))
                }
            }), a.Animation = function(t, e, i, s, n, o, r) {
                void 0 === r && (r = !1), this.game = t, this._parent = e, this._frameData = s, this.name = i, this._frames = [], this._frames = this._frames.concat(n), this.delay = 1e3 / o, this.loop = r, this.loopCount = 0, this.killOnComplete = !1, this.isFinished = !1, this.isPlaying = !1, this.isPaused = !1, this._pauseStartTime = 0, this._frameIndex = 0, this._frameDiff = 0, this._frameSkip = 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.onStart = new a.Signal, this.onUpdate = null, this.onComplete = new a.Signal, this.onLoop = new a.Signal, this.isReversed = !1, this.game.onPause.add(this.onPause, this), this.game.onResume.add(this.onResume, this)
            }, a.Animation.prototype = {
                play: function(t, e, i) {
                    return "number" == typeof t && (this.delay = 1e3 / t), "boolean" == typeof e && (this.loop = e), void 0 !== i && (this.killOnComplete = i), this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = this.isReversed ? this._frames.length - 1 : 0, this.updateCurrentFrame(!1, !0), this._parent.events.onAnimationStart$dispatch(this._parent, this), this.onStart.dispatch(this._parent, this), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this
                },
                restart: function() {
                    this.isPlaying = !0, this.isFinished = !1, this.paused = !1, this.loopCount = 0, this._timeLastFrame = this.game.time.time, this._timeNextFrame = this.game.time.time + this.delay, this._frameIndex = 0, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this._parent.setFrame(this.currentFrame), this._parent.animations.currentAnim = this, this._parent.animations.currentFrame = this.currentFrame, this.onStart.dispatch(this._parent, this)
                },
                reverse: function() {
                    return this.reversed = !this.reversed, this
                },
                reverseOnce: function() {
                    return this.onComplete.addOnce(this.reverse, this), this.reverse()
                },
                setFrame: function(t, e) {
                    var i;
                    if (void 0 === e && (e = !1), "string" == typeof t)
                        for (var s = 0; s < this._frames.length; s++) this._frameData.getFrame(this._frames[s])
                            .name === t && (i = s);
                    else if ("number" == typeof t)
                        if (e) i = t;
                        else
                            for (var s = 0; s < this._frames.length; s++) this._frames[s] === t && (i = s);
                    i && (this._frameIndex = i - 1, this._timeNextFrame = this.game.time.time, this.update())
                },
                stop: function(t, e) {
                    void 0 === t && (t = !1), void 0 === e && (e = !1), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, t && (this.currentFrame = this._frameData.getFrame(this._frames[0]), this._parent.setFrame(this.currentFrame)), e && (this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this))
                },
                onPause: function() {
                    this.isPlaying && (this._frameDiff = this._timeNextFrame - this.game.time.time)
                },
                onResume: function() {
                    this.isPlaying && (this._timeNextFrame = this.game.time.time + this._frameDiff)
                },
                update: function() {
                    return !this.isPaused && (!!(this.isPlaying && this.game.time.time >= this._timeNextFrame) && (this._frameSkip = 1, this._frameDiff = this.game.time.time - this._timeNextFrame, this._timeLastFrame = this.game.time.time, this._frameDiff > this.delay && (this._frameSkip = Math.floor(this._frameDiff / this.delay), this._frameDiff -= this._frameSkip * this.delay), this._timeNextFrame = this.game.time.time + (this.delay - this._frameDiff), this.isReversed ? this._frameIndex -= this._frameSkip : this._frameIndex += this._frameSkip, !this.isReversed && this._frameIndex >= this._frames.length || this.isReversed && this._frameIndex <= -1 ? this.loop ? (this._frameIndex = Math.abs(this._frameIndex) % this._frames.length, this.isReversed && (this._frameIndex = this._frames.length - 1 - this._frameIndex), this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && this._parent.setFrame(this.currentFrame), this.loopCount++, this._parent.events.onAnimationLoop$dispatch(this._parent, this), this.onLoop.dispatch(this._parent, this), !this.onUpdate || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)) : (this.complete(), !1) : this.updateCurrentFrame(!0)))
                },
                updateCurrentFrame: function(t, e) {
                    if (void 0 === e && (e = !1), !this._frameData) return !1;
                    var i = this.currentFrame.index;
                    return this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.currentFrame && (e || !e && i !== this.currentFrame.index) && this._parent.setFrame(this.currentFrame), !this.onUpdate || !t || (this.onUpdate.dispatch(this, this.currentFrame), !!this._frameData)
                },
                next: function(t) {
                    void 0 === t && (t = 1);
                    var e = this._frameIndex + t;
                    e >= this._frames.length && (this.loop ? e %= this._frames.length : e = this._frames.length - 1), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                },
                previous: function(t) {
                    void 0 === t && (t = 1);
                    var e = this._frameIndex - t;
                    e < 0 && (this.loop ? e = this._frames.length + e : e++), e !== this._frameIndex && (this._frameIndex = e, this.updateCurrentFrame(!0))
                },
                updateFrameData: function(t) {
                    this._frameData = t, this.currentFrame = this._frameData ? this._frameData.getFrame(this._frames[this._frameIndex % this._frames.length]) : null
                },
                destroy: function() {
                    this._frameData && (this.game.onPause.remove(this.onPause, this), this.game.onResume.remove(this.onResume, this), this.game = null, this._parent = null, this._frames = null, this._frameData = null, this.currentFrame = null, this.isPlaying = !1, this.onStart.dispose(), this.onLoop.dispose(), this.onComplete.dispose(), this.onUpdate && this.onUpdate.dispose())
                },
                complete: function() {
                    this._frameIndex = this._frames.length - 1, this.currentFrame = this._frameData.getFrame(this._frames[this._frameIndex]), this.isPlaying = !1, this.isFinished = !0, this.paused = !1, this._parent.events.onAnimationComplete$dispatch(this._parent, this), this.onComplete.dispatch(this._parent, this), this.killOnComplete && this._parent.kill()
                }
            }, a.Animation.prototype.constructor = a.Animation, Object.defineProperty(a.Animation.prototype, "paused", {
                get: function() {
                    return this.isPaused
                },
                set: function(t) {
                    this.isPaused = t, t ? this._pauseStartTime = this.game.time.time : this.isPlaying && (this._timeNextFrame = this.game.time.time + this.delay)
                }
            }), Object.defineProperty(a.Animation.prototype, "reversed", {
                get: function() {
                    return this.isReversed
                },
                set: function(t) {
                    this.isReversed = t
                }
            }), Object.defineProperty(a.Animation.prototype, "frameTotal", {
                get: function() {
                    return this._frames.length
                }
            }), Object.defineProperty(a.Animation.prototype, "frame", {
                get: function() {
                    return null !== this.currentFrame ? this.currentFrame.index : this._frameIndex
                },
                set: function(t) {
                    this.currentFrame = this._frameData.getFrame(this._frames[t]), null !== this.currentFrame && (this._frameIndex = t, this._parent.setFrame(this.currentFrame), this.onUpdate && this.onUpdate.dispatch(this, this.currentFrame))
                }
            }), Object.defineProperty(a.Animation.prototype, "speed", {
                get: function() {
                    return 1e3 / this.delay
                },
                set: function(t) {
                    t > 0 && (this.delay = 1e3 / t)
                }
            }), Object.defineProperty(a.Animation.prototype, "enableUpdate", {
                get: function() {
                    return null !== this.onUpdate
                },
                set: function(t) {
                    t && null === this.onUpdate ? this.onUpdate = new a.Signal : t || null === this.onUpdate || (this.onUpdate.dispose(), this.onUpdate = null)
                }
            }), a.Animation.generateFrameNames = function(t, e, i, s, n) {
                void 0 === s && (s = "");
                var o = [],
                    r = "";
                if (e < i)
                    for (var h = e; h <= i; h++) r = "number" == typeof n ? a.Utils.pad(h.toString(), n, "0", 1) : h.toString(), r = t + r + s, o.push(r);
                else
                    for (var h = e; h >= i; h--) r = "number" == typeof n ? a.Utils.pad(h.toString(), n, "0", 1) : h.toString(), r = t + r + s, o.push(r);
                return o
            }, a.Frame = function(t, e, i, s, n, o) {
                this.index = t, this.x = e, this.y = i, this.width = s, this.height = n, this.name = o, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(n / 2), this.distance = a.Math.distance(0, 0, s, n), this.rotated = !1, this.rotationDirection = "cw", this.trimmed = !1, this.sourceSizeW = s, this.sourceSizeH = n, this.spriteSourceSizeX = 0, this.spriteSourceSizeY = 0, this.spriteSourceSizeW = 0, this.spriteSourceSizeH = 0, this.right = this.x + this.width, this.bottom = this.y + this.height
            }, a.Frame.prototype = {
                resize: function(t, e) {
                    this.width = t, this.height = e, this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2), this.distance = a.Math.distance(0, 0, t, e), this.sourceSizeW = t, this.sourceSizeH = e, this.right = this.x + t, this.bottom = this.y + e
                },
                setTrim: function(t, e, i, s, n, a, o) {
                    this.trimmed = t, t && (this.sourceSizeW = e, this.sourceSizeH = i, this.centerX = Math.floor(e / 2), this.centerY = Math.floor(i / 2), this.spriteSourceSizeX = s, this.spriteSourceSizeY = n, this.spriteSourceSizeW = a, this.spriteSourceSizeH = o)
                },
                clone: function() {
                    var t = new a.Frame(this.index, this.x, this.y, this.width, this.height, this.name);
                    for (var e in this) this.hasOwnProperty(e) && (t[e] = this[e]);
                    return t
                },
                getRect: function(t) {
                    return void 0 === t ? t = new a.Rectangle(this.x, this.y, this.width, this.height) : t.setTo(this.x, this.y, this.width, this.height), t
                }
            }, a.Frame.prototype.constructor = a.Frame, a.FrameData = function() {
                this._frames = [], this._frameNames = []
            }, a.FrameData.prototype = {
                addFrame: function(t) {
                    return t.index = this._frames.length, this._frames.push(t), "" !== t.name && (this._frameNames[t.name] = t.index), t
                },
                getFrame: function(t) {
                    return t >= this._frames.length && (t = 0), this._frames[t]
                },
                getFrameByName: function(t) {
                    return "number" == typeof this._frameNames[t] ? this._frames[this._frameNames[t]] : null
                },
                checkFrameName: function(t) {
                    return null != this._frameNames[t]
                },
                clone: function() {
                    for (var t = new a.FrameData, e = 0; e < this._frames.length; e++) t._frames.push(this._frames[e].clone());
                    for (var i in this._frameNames) this._frameNames.hasOwnProperty(i) && t._frameNames.push(this._frameNames[i]);
                    return t
                },
                getFrameRange: function(t, e, i) {
                    void 0 === i && (i = []);
                    for (var s = t; s <= e; s++) i.push(this._frames[s]);
                    return i
                },
                getFrames: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s]);
                    else
                        for (var s = 0; s < t.length; s++) e ? i.push(this.getFrame(t[s])) : i.push(this.getFrameByName(t[s]));
                    return i
                },
                getFrameIndexes: function(t, e, i) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = []), void 0 === t || 0 === t.length)
                        for (var s = 0; s < this._frames.length; s++) i.push(this._frames[s].index);
                    else
                        for (var s = 0; s < t.length; s++) e && this._frames[t[s]] ? i.push(this._frames[t[s]].index) : this.getFrameByName(t[s]) && i.push(this.getFrameByName(t[s])
                            .index);
                    return i
                },
                destroy: function() {
                    this._frames = null, this._frameNames = null
                }
            }, a.FrameData.prototype.constructor = a.FrameData, Object.defineProperty(a.FrameData.prototype, "total", {
                get: function() {
                    return this._frames.length
                }
            }), a.AnimationParser = {
                spriteSheet: function(t, e, i, s, n, o, r) {
                    var h = e;
                    if ("string" == typeof e && (h = t.cache.getImage(e)), null === h) return null;
                    var l = h.width,
                        c = h.height;
                    i <= 0 && (i = Math.floor(-l / Math.min(-1, i))), s <= 0 && (s = Math.floor(-c / Math.min(-1, s)));
                    var u = Math.floor((l - o) / (i + r)),
                        d = Math.floor((c - o) / (s + r)),
                        p = u * d;
                    if (-1 !== n && (p = n), 0 === l || 0 === c || l < i || c < s || 0 === p) return null;
                    for (var f = new a.FrameData, g = o, y = o, m = 0; m < p; m++) f.addFrame(new a.Frame(m, g, y, i, s, "")), (g += i + r) + i > l && (g = o, y += s + r);
                    return f
                },
                JSONData: function(t, e) {
                    if (e.frames) {
                        for (var i = new a.FrameData, s = e.frames, n, o = 0; o < s.length; o++) n = i.addFrame(new a.Frame(o, s[o].frame.x, s[o].frame.y, s[o].frame.w, s[o].frame.h, s[o].filename)), s[o].trimmed && n.setTrim(s[o].trimmed, s[o].sourceSize.w, s[o].sourceSize.h, s[o].spriteSourceSize.x, s[o].spriteSourceSize.y, s[o].spriteSourceSize.w, s[o].spriteSourceSize.h);
                        return i
                    }
                },
                JSONDataPyxel: function(t, e) {
                    if (["layers", "tilewidth", "tileheight", "tileswide", "tileshigh"].forEach(function(t) {
                            e[t]
                        }), 1 === e.layers.length) {
                        for (var i = new a.FrameData, s = e.tileheight, n = e.tilewidth, o = e.layers[0].tiles, r, h = 0; h < o.length; h++) r = i.addFrame(new a.Frame(h, o[h].x, o[h].y, n, s, "frame_" + h)), r.setTrim(!1);
                        return i
                    }
                },
                JSONDataHash: function(t, e) {
                    if (e.frames) {
                        var i = new a.FrameData,
                            s = e.frames,
                            n, o = 0;
                        for (var r in s) n = i.addFrame(new a.Frame(o, s[r].frame.x, s[r].frame.y, s[r].frame.w, s[r].frame.h, r)), s[r].trimmed && n.setTrim(s[r].trimmed, s[r].sourceSize.w, s[r].sourceSize.h, s[r].spriteSourceSize.x, s[r].spriteSourceSize.y, s[r].spriteSourceSize.w, s[r].spriteSourceSize.h), o++;
                        return i
                    }
                },
                XMLData: function(t, e) {
                    if (e.getElementsByTagName("TextureAtlas")) {
                        for (var i = new a.FrameData, s = e.getElementsByTagName("SubTexture"), n, o, r, h, l, c, u, d, p, f, g, y = 0; y < s.length; y++) r = s[y].attributes, o = r.name.value, h = parseInt(r.x.value, 10), l = parseInt(r.y.value, 10), c = parseInt(r.width.value, 10), u = parseInt(r.height.value, 10), d = null, p = null, r.frameX && (d = Math.abs(parseInt(r.frameX.value, 10)), p = Math.abs(parseInt(r.frameY.value, 10)), f = parseInt(r.frameWidth.value, 10), g = parseInt(r.frameHeight.value, 10)), n = i.addFrame(new a.Frame(y, h, l, c, u, o)), null === d && null === p || n.setTrim(!0, c, u, d, p, f, g);
                        return i
                    }
                }
            }, a.Cache = function(t) {
                this.game = t, this.autoResolveURL = !1, this._cache = {
                    canvas: {},
                    image: {},
                    texture: {},
                    sound: {},
                    video: {},
                    text: {},
                    json: {},
                    xml: {},
                    physics: {},
                    tilemap: {},
                    binary: {},
                    bitmapData: {},
                    bitmapFont: {},
                    shader: {},
                    renderTexture: {}
                }, this._urlMap = {}, this._urlResolver = new Image, this._urlTemp = null, this.onSoundUnlock = new a.Signal, this._cacheMap = [], this._cacheMap[a.Cache.CANVAS] = this._cache.canvas, this._cacheMap[a.Cache.IMAGE] = this._cache.image, this._cacheMap[a.Cache.TEXTURE] = this._cache.texture, this._cacheMap[a.Cache.SOUND] = this._cache.sound, this._cacheMap[a.Cache.TEXT] = this._cache.text, this._cacheMap[a.Cache.PHYSICS] = this._cache.physics, this._cacheMap[a.Cache.TILEMAP] = this._cache.tilemap, this._cacheMap[a.Cache.BINARY] = this._cache.binary, this._cacheMap[a.Cache.BITMAPDATA] = this._cache.bitmapData, this._cacheMap[a.Cache.BITMAPFONT] = this._cache.bitmapFont, this._cacheMap[a.Cache.JSON] = this._cache.json, this._cacheMap[a.Cache.XML] = this._cache.xml, this._cacheMap[a.Cache.VIDEO] = this._cache.video, this._cacheMap[a.Cache.SHADER] = this._cache.shader, this._cacheMap[a.Cache.RENDER_TEXTURE] = this._cache.renderTexture, this.addDefaultImage(), this.addMissingImage()
            }, a.Cache.CANVAS = 1, a.Cache.IMAGE = 2, a.Cache.TEXTURE = 3, a.Cache.SOUND = 4, a.Cache.TEXT = 5, a.Cache.PHYSICS = 6, a.Cache.TILEMAP = 7, a.Cache.BINARY = 8, a.Cache.BITMAPDATA = 9, a.Cache.BITMAPFONT = 10, a.Cache.JSON = 11, a.Cache.XML = 12, a.Cache.VIDEO = 13, a.Cache.SHADER = 14, a.Cache.RENDER_TEXTURE = 15, a.Cache.DEFAULT = null, a.Cache.MISSING = null, a.Cache.prototype = {
                addCanvas: function(t, e, i) {
                    void 0 === i && (i = e.getContext("2d")), this._cache.canvas[t] = {
                        canvas: e,
                        context: i
                    }
                },
                addImage: function(t, e, i) {
                    this.checkImageKey(t) && this.removeImage(t);
                    var s = {
                        key: t,
                        url: e,
                        data: i,
                        base: new PIXI.BaseTexture(i),
                        frame: new a.Frame(0, 0, 0, i.width, i.height, t),
                        frameData: new a.FrameData
                    };
                    return s.frameData.addFrame(new a.Frame(0, 0, 0, i.width, i.height, e)), this._cache.image[t] = s, this._resolveURL(e, s), "__default" === t ? a.Cache.DEFAULT = new PIXI.Texture(s.base) : "__missing" === t && (a.Cache.MISSING = new PIXI.Texture(s.base)), s
                },
                addDefaultImage: function() {
                    var t = new Image;
                    t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgAQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==";
                    var e = this.addImage("__default", null, t);
                    e.base.skipRender = !0, a.Cache.DEFAULT = new PIXI.Texture(e.base)
                },
                addMissingImage: function() {
                    var t = new Image;
                    t.src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==";
                    var e = this.addImage("__missing", null, t);
                    a.Cache.MISSING = new PIXI.Texture(e.base)
                },
                addSound: function(t, e, i, s, n) {
                    void 0 === s && (s = !0, n = !1), void 0 === n && (s = !1, n = !0);
                    var a = !1;
                    n && (a = !0), this._cache.sound[t] = {
                        url: e,
                        data: i,
                        isDecoding: !1,
                        decoded: a,
                        webAudio: s,
                        audioTag: n,
                        locked: this.game.sound.touchLocked
                    }, this._resolveURL(e, this._cache.sound[t])
                },
                addText: function(t, e, i) {
                    this._cache.text[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.text[t])
                },
                addPhysicsData: function(t, e, i, s) {
                    this._cache.physics[t] = {
                        url: e,
                        data: i,
                        format: s
                    }, this._resolveURL(e, this._cache.physics[t])
                },
                addTilemap: function(t, e, i, s) {
                    this._cache.tilemap[t] = {
                        url: e,
                        data: i,
                        format: s
                    }, this._resolveURL(e, this._cache.tilemap[t])
                },
                addBinary: function(t, e) {
                    this._cache.binary[t] = e
                },
                addBitmapData: function(t, e, i) {
                    return e.key = t, void 0 === i && (i = new a.FrameData, i.addFrame(e.textureFrame)), this._cache.bitmapData[t] = {
                        data: e,
                        frameData: i
                    }, e
                },
                addBitmapFont: function(t, e, i, s, n, o, r) {
                    var h = {
                        url: e,
                        data: i,
                        font: null,
                        base: new PIXI.BaseTexture(i)
                    };
                    void 0 === o && (o = 0), void 0 === r && (r = 0), h.font = "json" === n ? a.LoaderParser.jsonBitmapFont(s, h.base, o, r) : a.LoaderParser.xmlBitmapFont(s, h.base, o, r), this._cache.bitmapFont[t] = h, this._resolveURL(e, h)
                },
                addJSON: function(t, e, i) {
                    this._cache.json[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.json[t])
                },
                addXML: function(t, e, i) {
                    this._cache.xml[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.xml[t])
                },
                addVideo: function(t, e, i, s) {
                    this._cache.video[t] = {
                        url: e,
                        data: i,
                        isBlob: s,
                        locked: !0
                    }, this._resolveURL(e, this._cache.video[t])
                },
                addShader: function(t, e, i) {
                    this._cache.shader[t] = {
                        url: e,
                        data: i
                    }, this._resolveURL(e, this._cache.shader[t])
                },
                addRenderTexture: function(t, e) {
                    this._cache.renderTexture[t] = {
                        texture: e,
                        frame: new a.Frame(0, 0, 0, e.width, e.height, "", "")
                    }
                },
                addSpriteSheet: function(t, e, i, s, n, o, r, h) {
                    void 0 === o && (o = -1), void 0 === r && (r = 0), void 0 === h && (h = 0);
                    var l = {
                        key: t,
                        url: e,
                        data: i,
                        frameWidth: s,
                        frameHeight: n,
                        margin: r,
                        spacing: h,
                        base: new PIXI.BaseTexture(i),
                        frameData: a.AnimationParser.spriteSheet(this.game, i, s, n, o, r, h)
                    };
                    this._cache.image[t] = l, this._resolveURL(e, l)
                },
                addTextureAtlas: function(t, e, i, s, n) {
                    var o = {
                        key: t,
                        url: e,
                        data: i,
                        base: new PIXI.BaseTexture(i)
                    };
                    n === a.Loader.TEXTURE_ATLAS_XML_STARLING ? o.frameData = a.AnimationParser.XMLData(this.game, s, t) : n === a.Loader.TEXTURE_ATLAS_JSON_PYXEL ? o.frameData = a.AnimationParser.JSONDataPyxel(this.game, s, t) : Array.isArray(s.frames) ? o.frameData = a.AnimationParser.JSONData(this.game, s, t) : o.frameData = a.AnimationParser.JSONDataHash(this.game, s, t), this._cache.image[t] = o, this._resolveURL(e, o)
                },
                reloadSound: function(t) {
                    var e = this,
                        i = this.getSound(t);
                    i && (i.data.src = i.url, i.data.addEventListener("canplaythrough", function() {
                        return e.reloadSoundComplete(t)
                    }, !1), i.data.load())
                },
                reloadSoundComplete: function(t) {
                    var e = this.getSound(t);
                    e && (e.locked = !1, this.onSoundUnlock.dispatch(t))
                },
                updateSound: function(t, e, i) {
                    var s = this.getSound(t);
                    s && (s[e] = i)
                },
                decodedSound: function(t, e) {
                    var i = this.getSound(t);
                    i.data = e, i.decoded = !0, i.isDecoding = !1
                },
                isSoundDecoded: function(t) {
                    var e = this.getItem(t, a.Cache.SOUND, "isSoundDecoded");
                    if (e) return e.decoded
                },
                isSoundReady: function(t) {
                    var e = this.getItem(t, a.Cache.SOUND, "isSoundDecoded");
                    if (e) return e.decoded && !this.game.sound.touchLocked
                },
                checkKey: function(t, e) {
                    return !!this._cacheMap[t][e]
                },
                checkURL: function(t) {
                    return !!this._urlMap[this._resolveURL(t)]
                },
                checkCanvasKey: function(t) {
                    return this.checkKey(a.Cache.CANVAS, t)
                },
                checkImageKey: function(t) {
                    return this.checkKey(a.Cache.IMAGE, t)
                },
                checkTextureKey: function(t) {
                    return this.checkKey(a.Cache.TEXTURE, t)
                },
                checkSoundKey: function(t) {
                    return this.checkKey(a.Cache.SOUND, t)
                },
                checkTextKey: function(t) {
                    return this.checkKey(a.Cache.TEXT, t)
                },
                checkPhysicsKey: function(t) {
                    return this.checkKey(a.Cache.PHYSICS, t)
                },
                checkTilemapKey: function(t) {
                    return this.checkKey(a.Cache.TILEMAP, t)
                },
                checkBinaryKey: function(t) {
                    return this.checkKey(a.Cache.BINARY, t)
                },
                checkBitmapDataKey: function(t) {
                    return this.checkKey(a.Cache.BITMAPDATA, t)
                },
                checkBitmapFontKey: function(t) {
                    return this.checkKey(a.Cache.BITMAPFONT, t)
                },
                checkJSONKey: function(t) {
                    return this.checkKey(a.Cache.JSON, t)
                },
                checkXMLKey: function(t) {
                    return this.checkKey(a.Cache.XML, t)
                },
                checkVideoKey: function(t) {
                    return this.checkKey(a.Cache.VIDEO, t)
                },
                checkShaderKey: function(t) {
                    return this.checkKey(a.Cache.SHADER, t)
                },
                checkRenderTextureKey: function(t) {
                    return this.checkKey(a.Cache.RENDER_TEXTURE, t)
                },
                getItem: function(t, e, i, s) {
                    return this.checkKey(e, t) ? void 0 === s ? this._cacheMap[e][t] : this._cacheMap[e][t][s] : null
                },
                getCanvas: function(t) {
                    return this.getItem(t, a.Cache.CANVAS, "getCanvas", "canvas")
                },
                getImage: function(t, e) {
                    void 0 !== t && null !== t || (t = "__default"), void 0 === e && (e = !1);
                    var i = this.getItem(t, a.Cache.IMAGE, "getImage");
                    return null === i && (i = this.getItem("__missing", a.Cache.IMAGE, "getImage")), e ? i : i.data
                },
                getTextureFrame: function(t) {
                    return this.getItem(t, a.Cache.TEXTURE, "getTextureFrame", "frame")
                },
                getSound: function(t) {
                    return this.getItem(t, a.Cache.SOUND, "getSound")
                },
                getSoundData: function(t) {
                    return this.getItem(t, a.Cache.SOUND, "getSoundData", "data")
                },
                getText: function(t) {
                    return this.getItem(t, a.Cache.TEXT, "getText", "data")
                },
                getPhysicsData: function(t, e, i) {
                    var s = this.getItem(t, a.Cache.PHYSICS, "getPhysicsData", "data");
                    if (null === s || void 0 === e || null === e) return s;
                    if (s[e]) {
                        var n = s[e];
                        if (!n || !i) return n;
                        for (var o in n)
                            if (o = n[o], o.fixtureKey === i) return o
                    }
                    return null
                },
                getTilemapData: function(t) {
                    return this.getItem(t, a.Cache.TILEMAP, "getTilemapData")
                },
                getBinary: function(t) {
                    return this.getItem(t, a.Cache.BINARY, "getBinary")
                },
                getBitmapData: function(t) {
                    return this.getItem(t, a.Cache.BITMAPDATA, "getBitmapData", "data")
                },
                getBitmapFont: function(t) {
                    return this.getItem(t, a.Cache.BITMAPFONT, "getBitmapFont")
                },
                getJSON: function(t, e) {
                    var i = this.getItem(t, a.Cache.JSON, "getJSON", "data");
                    return i ? e ? a.Utils.extend(!0, Array.isArray(i) ? [] : {}, i) : i : null
                },
                getXML: function(t) {
                    return this.getItem(t, a.Cache.XML, "getXML", "data")
                },
                getVideo: function(t) {
                    return this.getItem(t, a.Cache.VIDEO, "getVideo")
                },
                getShader: function(t) {
                    return this.getItem(t, a.Cache.SHADER, "getShader", "data")
                },
                getRenderTexture: function(t) {
                    return this.getItem(t, a.Cache.RENDER_TEXTURE, "getRenderTexture")
                },
                getBaseTexture: function(t, e) {
                    return void 0 === e && (e = a.Cache.IMAGE), this.getItem(t, e, "getBaseTexture", "base")
                },
                getFrame: function(t, e) {
                    return void 0 === e && (e = a.Cache.IMAGE), this.getItem(t, e, "getFrame", "frame")
                },
                getFrameCount: function(t, e) {
                    var i = this.getFrameData(t, e);
                    return i ? i.total : 0
                },
                getFrameData: function(t, e) {
                    return void 0 === e && (e = a.Cache.IMAGE), this.getItem(t, e, "getFrameData", "frameData")
                },
                hasFrameData: function(t, e) {
                    return void 0 === e && (e = a.Cache.IMAGE), null !== this.getItem(t, e, "", "frameData")
                },
                updateFrameData: function(t, e, i) {
                    void 0 === i && (i = a.Cache.IMAGE), this._cacheMap[i][t] && (this._cacheMap[i][t].frameData = e)
                },
                getFrameByIndex: function(t, e, i) {
                    var s = this.getFrameData(t, i);
                    return s ? s.getFrame(e) : null
                },
                getFrameByName: function(t, e, i) {
                    var s = this.getFrameData(t, i);
                    return s ? s.getFrameByName(e) : null
                },
                getURL: function(t) {
                    var t = this._resolveURL(t);
                    return t ? this._urlMap[t] : null
                },
                getKeys: function(t) {
                    void 0 === t && (t = a.Cache.IMAGE);
                    var e = [];
                    if (this._cacheMap[t])
                        for (var i in this._cacheMap[t]) "__default" !== i && "__missing" !== i && e.push(i);
                    return e
                },
                removeCanvas: function(t) {
                    delete this._cache.canvas[t]
                },
                removeImage: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = this.getImage(t, !0);
                    e && i.base && i.base.destroy(), delete this._cache.image[t]
                },
                removeSound: function(t) {
                    delete this._cache.sound[t]
                },
                removeText: function(t) {
                    delete this._cache.text[t]
                },
                removePhysics: function(t) {
                    delete this._cache.physics[t]
                },
                removeTilemap: function(t) {
                    delete this._cache.tilemap[t]
                },
                removeBinary: function(t) {
                    delete this._cache.binary[t]
                },
                removeBitmapData: function(t) {
                    delete this._cache.bitmapData[t]
                },
                removeBitmapFont: function(t) {
                    delete this._cache.bitmapFont[t]
                },
                removeJSON: function(t) {
                    delete this._cache.json[t]
                },
                removeXML: function(t) {
                    delete this._cache.xml[t]
                },
                removeVideo: function(t) {
                    delete this._cache.video[t]
                },
                removeShader: function(t) {
                    delete this._cache.shader[t]
                },
                removeRenderTexture: function(t) {
                    delete this._cache.renderTexture[t]
                },
                removeSpriteSheet: function(t) {
                    delete this._cache.spriteSheet[t]
                },
                removeTextureAtlas: function(t) {
                    delete this._cache.atlas[t]
                },
                clearGLTextures: function() {
                    for (var t in this._cache.image) this._cache.image[t].base._glTextures = []
                },
                _resolveURL: function(t, e) {
                    return this.autoResolveURL ? (this._urlResolver.src = this.game.load.baseURL + t, this._urlTemp = this._urlResolver.src, this._urlResolver.src = "", e && (this._urlMap[this._urlTemp] = e), this._urlTemp) : null
                },
                destroy: function() {
                    for (var t = 0; t < this._cacheMap.length; t++) {
                        var e = this._cacheMap[t];
                        for (var i in e) "__default" !== i && "__missing" !== i && (e[i].destroy && e[i].destroy(), delete e[i])
                    }
                    this._urlMap = null, this._urlResolver = null, this._urlTemp = null
                }
            }, a.Cache.prototype.constructor = a.Cache, a.Loader = function(t) {
                this.game = t, this.cache = t.cache, this.resetLocked = !1, this.isLoading = !1, this.hasLoaded = !1, this.preloadSprite = null, this.crossOrigin = !1, this.baseURL = "", this.path = "", this.headers = {
                    requestedWith: !1,
                    json: "application/json",
                    xml: "application/xml"
                }, this.onLoadStart = new a.Signal, this.onLoadComplete = new a.Signal, this.onPackComplete = new a.Signal, this.onFileStart = new a.Signal, this.onFileComplete = new a.Signal, this.onFileError = new a.Signal, this.useXDomainRequest = !1, this._warnedAboutXDomainRequest = !1, this.enableParallel = !0, this.maxParallelDownloads = 4, this._withSyncPointDepth = 0, this._fileList = [], this._flightQueue = [], this._processingHead = 0, this._fileLoadStarted = !1, this._totalPackCount = 0, this._totalFileCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0
            }, a.Loader.TEXTURE_ATLAS_JSON_ARRAY = 0, a.Loader.TEXTURE_ATLAS_JSON_HASH = 1, a.Loader.TEXTURE_ATLAS_XML_STARLING = 2, a.Loader.PHYSICS_LIME_CORONA_JSON = 3, a.Loader.PHYSICS_PHASER_JSON = 4, a.Loader.TEXTURE_ATLAS_JSON_PYXEL = 5, a.Loader.prototype = {
                setPreloadSprite: function(t, e) {
                    e = e || 0, this.preloadSprite = {
                        sprite: t,
                        direction: e,
                        width: t.width,
                        height: t.height,
                        rect: null
                    }, this.preloadSprite.rect = 0 === e ? new a.Rectangle(0, 0, 1, t.height) : new a.Rectangle(0, 0, t.width, 1), t.crop(this.preloadSprite.rect), t.visible = !0
                },
                resize: function() {
                    this.preloadSprite && this.preloadSprite.height !== this.preloadSprite.sprite.height && (this.preloadSprite.rect.height = this.preloadSprite.sprite.height)
                },
                checkKeyExists: function(t, e) {
                    return this.getAssetIndex(t, e) > -1
                },
                getAssetIndex: function(t, e) {
                    for (var i = -1, s = 0; s < this._fileList.length; s++) {
                        var n = this._fileList[s];
                        if (n.type === t && n.key === e && (i = s, !n.loaded && !n.loading)) break
                    }
                    return i
                },
                getAsset: function(t, e) {
                    var i = this.getAssetIndex(t, e);
                    return i > -1 && {
                        index: i,
                        file: this._fileList[i]
                    }
                },
                reset: function(t, e) {
                    void 0 === e && (e = !1), this.resetLocked || (t && (this.preloadSprite = null), this.isLoading = !1, this._processingHead = 0, this._fileList.length = 0, this._flightQueue.length = 0, this._fileLoadStarted = !1, this._totalFileCount = 0, this._totalPackCount = 0, this._loadedPackCount = 0, this._loadedFileCount = 0, e && (this.onLoadStart.removeAll(), this.onLoadComplete.removeAll(), this.onPackComplete.removeAll(), this.onFileStart.removeAll(), this.onFileComplete.removeAll(), this.onFileError.removeAll()))
                },
                addToFileList: function(t, e, i, s, n, a) {
                    if (void 0 === n && (n = !1), void 0 === e || "" === e) return this;
                    if (void 0 === i || null === i) {
                        if (!a) return this;
                        i = e + a
                    }
                    var o = {
                        type: t,
                        key: e,
                        path: this.path,
                        url: i,
                        syncPoint: this._withSyncPointDepth > 0,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1
                    };
                    if (s)
                        for (var r in s) o[r] = s[r];
                    var h = this.getAssetIndex(t, e);
                    if (n && h > -1) {
                        var l = this._fileList[h];
                        l.loading || l.loaded ? (this._fileList.push(o), this._totalFileCount++) : this._fileList[h] = o
                    } else -1 === h && (this._fileList.push(o), this._totalFileCount++);
                    return this
                },
                replaceInFileList: function(t, e, i, s) {
                    return this.addToFileList(t, e, i, s, !0)
                },
                pack: function(t, e, i, s) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), !e && !i) return this;
                    var n = {
                        type: "packfile",
                        key: t,
                        url: e,
                        path: this.path,
                        syncPoint: !0,
                        data: null,
                        loading: !1,
                        loaded: !1,
                        error: !1,
                        callbackContext: s
                    };
                    i && ("string" == typeof i && (i = JSON.parse(i)), n.data = i || {}, n.loaded = !0);
                    for (var a = 0; a < this._fileList.length + 1; a++) {
                        var o = this._fileList[a];
                        if (!o || !o.loaded && !o.loading && "packfile" !== o.type) {
                            this._fileList.splice(a, 0, n), this._totalPackCount++;
                            break
                        }
                    }
                    return this
                },
                image: function(t, e, i) {
                    return this.addToFileList("image", t, e, void 0, i, ".png")
                },
                images: function(t, e) {
                    if (Array.isArray(e))
                        for (var i = 0; i < t.length; i++) this.image(t[i], e[i]);
                    else
                        for (var i = 0; i < t.length; i++) this.image(t[i]);
                    return this
                },
                text: function(t, e, i) {
                    return this.addToFileList("text", t, e, void 0, i, ".txt")
                },
                json: function(t, e, i) {
                    return this.addToFileList("json", t, e, void 0, i, ".json")
                },
                shader: function(t, e, i) {
                    return this.addToFileList("shader", t, e, void 0, i, ".frag")
                },
                xml: function(t, e, i) {
                    return this.addToFileList("xml", t, e, void 0, i, ".xml")
                },
                script: function(t, e, i, s) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = this), this.addToFileList("script", t, e, {
                        syncPoint: !0,
                        callback: i,
                        callbackContext: s
                    }, !1, ".js")
                },
                binary: function(t, e, i, s) {
                    return void 0 === i && (i = !1), !1 !== i && void 0 === s && (s = i), this.addToFileList("binary", t, e, {
                        callback: i,
                        callbackContext: s
                    }, !1, ".bin")
                },
                spritesheet: function(t, e, i, s, n, a, o) {
                    return void 0 === n && (n = -1), void 0 === a && (a = 0), void 0 === o && (o = 0), this.addToFileList("spritesheet", t, e, {
                        frameWidth: i,
                        frameHeight: s,
                        frameMax: n,
                        margin: a,
                        spacing: o
                    }, !1, ".png")
                },
                audio: function(t, e, i) {
                    return this.game.sound.noAudio ? this : (void 0 === i && (i = !0), "string" == typeof e && (e = [e]), this.addToFileList("audio", t, e, {
                        buffer: null,
                        autoDecode: i
                    }))
                },
                audioSprite: function(t, e, i, s, n) {
                    return this.game.sound.noAudio ? this : (void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = !0), this.audio(t, e, n), i ? this.json(t + "-audioatlas", i) : s && ("string" == typeof s && (s = JSON.parse(s)), this.cache.addJSON(t + "-audioatlas", "", s)), this)
                },
                audiosprite: function(t, e, i, s, n) {
                    return this.audioSprite(t, e, i, s, n)
                },
                video: function(t, e, i, s) {
                    return void 0 === i && (i = this.game.device.firefox ? "loadeddata" : "canplaythrough"), void 0 === s && (s = !1), "string" == typeof e && (e = [e]), this.addToFileList("video", t, e, {
                        buffer: null,
                        asBlob: s,
                        loadEvent: i
                    })
                },
                tilemap: function(t, e, i, s) {
                    if (void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = a.Tilemap.CSV), e || i || (e = s === a.Tilemap.CSV ? t + ".csv" : t + ".json"), i) {
                        switch (s) {
                            case a.Tilemap.CSV:
                                break;
                            case a.Tilemap.TILED_JSON:
                                "string" == typeof i && (i = JSON.parse(i))
                        }
                        this.cache.addTilemap(t, null, i, s)
                    } else this.addToFileList("tilemap", t, e, {
                        format: s
                    });
                    return this
                },
                physics: function(t, e, i, s) {
                    return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = a.Physics.LIME_CORONA_JSON), e || i || (e = t + ".json"), i ? ("string" == typeof i && (i = JSON.parse(i)), this.cache.addPhysicsData(t, null, i, s)) : this.addToFileList("physics", t, e, {
                        format: s
                    }), this
                },
                bitmapFont: function(t, e, i, s, n, a) {
                    if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), null === i && null === s && (i = t + ".xml"), void 0 === n && (n = 0), void 0 === a && (a = 0), i) this.addToFileList("bitmapfont", t, e, {
                        atlasURL: i,
                        xSpacing: n,
                        ySpacing: a
                    });
                    else if ("string" == typeof s) {
                        var o, r;
                        try {
                            o = JSON.parse(s)
                        } catch (t) {
                            r = this.parseXml(s)
                        }
                        if (!r && !o) throw new Error("Phaser.Loader. Invalid Bitmap Font atlas given");
                        this.addToFileList("bitmapfont", t, e, {
                            atlasURL: null,
                            atlasData: o || r,
                            atlasType: o ? "json" : "xml",
                            xSpacing: n,
                            ySpacing: a
                        })
                    }
                    return this
                },
                atlasJSONArray: function(t, e, i, s) {
                    return this.atlas(t, e, i, s, a.Loader.TEXTURE_ATLAS_JSON_ARRAY)
                },
                atlasJSONHash: function(t, e, i, s) {
                    return this.atlas(t, e, i, s, a.Loader.TEXTURE_ATLAS_JSON_HASH)
                },
                atlasXML: function(t, e, i, s) {
                    return void 0 === i && (i = null), void 0 === s && (s = null), i || s || (i = t + ".xml"), this.atlas(t, e, i, s, a.Loader.TEXTURE_ATLAS_XML_STARLING)
                },
                atlas: function(t, e, i, s, n) {
                    if (void 0 !== e && null !== e || (e = t + ".png"), void 0 === i && (i = null), void 0 === s && (s = null), void 0 === n && (n = a.Loader.TEXTURE_ATLAS_JSON_ARRAY), i || s || (i = n === a.Loader.TEXTURE_ATLAS_XML_STARLING ? t + ".xml" : t + ".json"), i) this.addToFileList("textureatlas", t, e, {
                        atlasURL: i,
                        format: n
                    });
                    else {
                        switch (n) {
                            case a.Loader.TEXTURE_ATLAS_JSON_ARRAY:
                                "string" == typeof s && (s = JSON.parse(s));
                                break;
                            case a.Loader.TEXTURE_ATLAS_XML_STARLING:
                                if ("string" == typeof s) {
                                    var o = this.parseXml(s);
                                    if (!o) throw new Error("Phaser.Loader. Invalid Texture Atlas XML given");
                                    s = o
                                }
                        }
                        this.addToFileList("textureatlas", t, e, {
                            atlasURL: null,
                            atlasData: s,
                            format: n
                        })
                    }
                    return this
                },
                withSyncPoint: function(t, e) {
                    this._withSyncPointDepth++;
                    try {
                        t.call(e || this, this)
                    } finally {
                        this._withSyncPointDepth--
                    }
                    return this
                },
                addSyncPoint: function(t, e) {
                    var i = this.getAsset(t, e);
                    return i && (i.file.syncPoint = !0), this
                },
                removeFile: function(t, e) {
                    var i = this.getAsset(t, e);
                    i && (i.loaded || i.loading || this._fileList.splice(i.index, 1))
                },
                removeAll: function() {
                    this._fileList.length = 0, this._flightQueue.length = 0
                },
                start: function() {
                    this.isLoading || (this.hasLoaded = !1, this.isLoading = !0, this.updateProgress(), this.processLoadQueue())
                },
                processLoadQueue: function() {
                    if (!this.isLoading) return void this.finishedLoading(!0);
                    for (var t = 0; t < this._flightQueue.length; t++) {
                        var e = this._flightQueue[t];
                        (e.loaded || e.error) && (this._flightQueue.splice(t, 1), t--, e.loading = !1, e.requestUrl = null, e.requestObject = null, e.error && this.onFileError.dispatch(e.key, e), "packfile" !== e.type ? (this._loadedFileCount++, this.onFileComplete.dispatch(this.progress, e.key, !e.error, this._loadedFileCount, this._totalFileCount)) : "packfile" === e.type && e.error && (this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)))
                    }
                    for (var i = !1, s = this.enableParallel ? a.Math.clamp(this.maxParallelDownloads, 1, 12) : 1, t = this._processingHead; t < this._fileList.length; t++) {
                        var e = this._fileList[t];
                        if ("packfile" === e.type && !e.error && e.loaded && t === this._processingHead && (this.processPack(e), this._loadedPackCount++, this.onPackComplete.dispatch(e.key, !e.error, this._loadedPackCount, this._totalPackCount)), e.loaded || e.error ? t === this._processingHead && (this._processingHead = t + 1) : !e.loading && this._flightQueue.length < s && ("packfile" !== e.type || e.data ? i || (this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this._flightQueue.push(e), e.loading = !0, this.onFileStart.dispatch(this.progress, e.key, e.url), this.loadFile(e)) : (this._flightQueue.push(e), e.loading = !0, this.loadFile(e))), !e.loaded && e.syncPoint && (i = !0), this._flightQueue.length >= s || i && this._loadedPackCount === this._totalPackCount) break
                    }
                    if (this.updateProgress(), this._processingHead >= this._fileList.length) this.finishedLoading();
                    else if (!this._flightQueue.length) {
                        var n = this;
                        setTimeout(function() {
                            n.finishedLoading(!0)
                        }, 2e3)
                    }
                },
                finishedLoading: function(t) {
                    this.hasLoaded || (this.hasLoaded = !0, this.isLoading = !1, t || this._fileLoadStarted || (this._fileLoadStarted = !0, this.onLoadStart.dispatch()), this.onLoadComplete.dispatch(), this.game.state.loadComplete(), this.reset())
                },
                asyncComplete: function(t, e) {
                    void 0 === e && (e = ""), t.loaded = !0, t.error = !!e, e && (t.errorMessage = e), this.processLoadQueue()
                },
                processPack: function(t) {
                    var e = t.data[t.key];
                    if (e)
                        for (var i = 0; i < e.length; i++) {
                            var s = e[i];
                            switch (s.type) {
                                case "image":
                                    this.image(s.key, s.url, s.overwrite);
                                    break;
                                case "text":
                                    this.text(s.key, s.url, s.overwrite);
                                    break;
                                case "json":
                                    this.json(s.key, s.url, s.overwrite);
                                    break;
                                case "xml":
                                    this.xml(s.key, s.url, s.overwrite);
                                    break;
                                case "script":
                                    this.script(s.key, s.url, s.callback, t.callbackContext || this);
                                    break;
                                case "binary":
                                    this.binary(s.key, s.url, s.callback, t.callbackContext || this);
                                    break;
                                case "spritesheet":
                                    this.spritesheet(s.key, s.url, s.frameWidth, s.frameHeight, s.frameMax, s.margin, s.spacing);
                                    break;
                                case "video":
                                    this.video(s.key, s.urls);
                                    break;
                                case "audio":
                                    this.audio(s.key, s.urls, s.autoDecode);
                                    break;
                                case "audiosprite":
                                    this.audiosprite(s.key, s.urls, s.jsonURL, s.jsonData, s.autoDecode);
                                    break;
                                case "tilemap":
                                    this.tilemap(s.key, s.url, s.data, a.Tilemap[s.format]);
                                    break;
                                case "physics":
                                    this.physics(s.key, s.url, s.data, a.Loader[s.format]);
                                    break;
                                case "bitmapFont":
                                    this.bitmapFont(s.key, s.textureURL, s.atlasURL, s.atlasData, s.xSpacing, s.ySpacing);
                                    break;
                                case "atlasJSONArray":
                                    this.atlasJSONArray(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlasJSONHash":
                                    this.atlasJSONHash(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlasXML":
                                    this.atlasXML(s.key, s.textureURL, s.atlasURL, s.atlasData);
                                    break;
                                case "atlas":
                                    this.atlas(s.key, s.textureURL, s.atlasURL, s.atlasData, a.Loader[s.format]);
                                    break;
                                case "shader":
                                    this.shader(s.key, s.url, s.overwrite)
                            }
                        }
                },
                transformUrl: function(t, e) {
                    return !!t && (t.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t : this.baseURL + e.path + t)
                },
                loadFile: function(t) {
                    switch (t.type) {
                        case "packfile":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "image":
                        case "spritesheet":
                        case "textureatlas":
                        case "bitmapfont":
                            this.loadImageTag(t);
                            break;
                        case "audio":
                            t.url = this.getAudioURL(t.url), t.url ? this.game.sound.usingWebAudio ? this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete) : this.game.sound.usingAudioTag && this.loadAudioTag(t) : this.fileError(t, null, "No supported audio URL specified or device does not have audio playback support");
                            break;
                        case "video":
                            t.url = this.getVideoURL(t.url), t.url ? t.asBlob ? this.xhrLoad(t, this.transformUrl(t.url, t), "blob", this.fileComplete) : this.loadVideoTag(t) : this.fileError(t, null, "No supported video URL specified or device does not have video playback support");
                            break;
                        case "json":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete);
                            break;
                        case "xml":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.xmlLoadComplete);
                            break;
                        case "tilemap":
                            t.format === a.Tilemap.TILED_JSON ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.jsonLoadComplete) : t.format === a.Tilemap.CSV ? this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.csvLoadComplete) : this.asyncComplete(t, "invalid Tilemap format: " + t.format);
                            break;
                        case "text":
                        case "script":
                        case "shader":
                        case "physics":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "text", this.fileComplete);
                            break;
                        case "binary":
                            this.xhrLoad(t, this.transformUrl(t.url, t), "arraybuffer", this.fileComplete)
                    }
                },
                loadImageTag: function(t) {
                    var e = this;
                    t.data = new Image, t.data.name = t.key, this.crossOrigin && (t.data.crossOrigin = this.crossOrigin), t.data.onload = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileComplete(t))
                    }, t.data.onerror = function() {
                        t.data.onload && (t.data.onload = null, t.data.onerror = null, e.fileError(t))
                    }, t.data.src = this.transformUrl(t.url, t), t.data.complete && t.data.width && t.data.height && (t.data.onload = null, t.data.onerror = null, this.fileComplete(t))
                },
                loadVideoTag: function(t) {
                    var e = this;
                    t.data = document.createElement("video"), t.data.name = t.key, t.data.controls = !1, t.data.autoplay = !1;
                    var i = function() {
                        t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !0, a.GAMES[e.game.id].load.fileComplete(t)
                    };
                    t.data.onerror = function() {
                        t.data.removeEventListener(t.loadEvent, i, !1), t.data.onerror = null, t.data.canplay = !1, e.fileError(t)
                    }, t.data.addEventListener(t.loadEvent, i, !1), t.data.src = this.transformUrl(t.url, t), t.data.load()
                },
                loadAudioTag: function(t) {
                    var e = this;
                    if (this.game.sound.touchLocked) t.data = new Audio, t.data.name = t.key, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), this.fileComplete(t);
                    else {
                        t.data = new Audio, t.data.name = t.key;
                        var i = function() {
                            t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileComplete(t)
                        };
                        t.data.onerror = function() {
                            t.data.removeEventListener("canplaythrough", i, !1), t.data.onerror = null, e.fileError(t)
                        }, t.data.preload = "auto", t.data.src = this.transformUrl(t.url, t), t.data.addEventListener("canplaythrough", i, !1), t.data.load()
                    }
                },
                xhrLoad: function(t, e, i, s, n) {
                    if (this.useXDomainRequest && window.XDomainRequest) return void this.xhrLoadWithXDR(t, e, i, s, n);
                    var a = new XMLHttpRequest;
                    a.open("GET", e, !0), a.responseType = i, !1 !== this.headers.requestedWith && a.setRequestHeader("X-Requested-With", this.headers.requestedWith), this.headers[t.type] && a.setRequestHeader("Accept", this.headers[t.type]), n = n || this.fileError;
                    var o = this;
                    a.onload = function() {
                        try {
                            return 4 === a.readyState && a.status >= 400 && a.status <= 599 ? n.call(o, t, a) : s.call(o, t, a)
                        } catch (e) {
                            o.hasLoaded ? window.console : o.asyncComplete(t, e.message || "Exception")
                        }
                    }, a.onerror = function() {
                        try {
                            return n.call(o, t, a)
                        } catch (e) {
                            o.hasLoaded ? window.console : o.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = a, t.requestUrl = e, a.send()
                },
                xhrLoadWithXDR: function(t, e, i, s, n) {
                    this._warnedAboutXDomainRequest || this.game.device.ie && !(this.game.device.ieVersion >= 10) || (this._warnedAboutXDomainRequest = !0);
                    var a = new window.XDomainRequest;
                    a.open("GET", e, !0), a.responseType = i, a.timeout = 3e3, n = n || this.fileError;
                    var o = this;
                    a.onerror = function() {
                        try {
                            return n.call(o, t, a)
                        } catch (e) {
                            o.asyncComplete(t, e.message || "Exception")
                        }
                    }, a.ontimeout = function() {
                        try {
                            return n.call(o, t, a)
                        } catch (e) {
                            o.asyncComplete(t, e.message || "Exception")
                        }
                    }, a.onprogress = function() {}, a.onload = function() {
                        try {
                            return 4 === a.readyState && a.status >= 400 && a.status <= 599 ? n.call(o, t, a) : s.call(o, t, a)
                        } catch (e) {
                            o.asyncComplete(t, e.message || "Exception")
                        }
                    }, t.requestObject = a, t.requestUrl = e, setTimeout(function() {
                        a.send()
                    }, 0)
                },
                getVideoURL: function(t) {
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e],
                            s;
                        if (i.uri) {
                            if (s = i.type, i = i.uri, this.game.device.canPlayVideo(s)) return i
                        } else {
                            if (0 === i.indexOf("blob:") || 0 === i.indexOf("data:")) return i;
                            i.indexOf("?") >= 0 && (i = i.substr(0, i.indexOf("?")));
                            if (s = i.substr((Math.max(0, i.lastIndexOf(".")) || 1 / 0) + 1)
                                .toLowerCase(), this.game.device.canPlayVideo(s)) return t[e]
                        }
                    }
                    return null
                },
                getAudioURL: function(t) {
                    if (this.game.sound.noAudio) return null;
                    for (var e = 0; e < t.length; e++) {
                        var i = t[e],
                            s;
                        if (i.uri) {
                            if (s = i.type, i = i.uri, this.game.device.canPlayAudio(s)) return i
                        } else {
                            if (0 === i.indexOf("blob:") || 0 === i.indexOf("data:")) return i;
                            i.indexOf("?") >= 0 && (i = i.substr(0, i.indexOf("?")));
                            if (s = i.substr((Math.max(0, i.lastIndexOf(".")) || 1 / 0) + 1)
                                .toLowerCase(), this.game.device.canPlayAudio(s)) return t[e]
                        }
                    }
                    return null
                },
                fileError: function(t, e, i) {
                    var s = t.requestUrl || this.transformUrl(t.url, t),
                        n = "error loading asset from URL " + s;
                    !i && e && (i = e.status), i && (n = n + " (" + i + ")"), this.asyncComplete(t, n)
                },
                fileComplete: function(t, e) {
                    var i = !0;
                    switch (t.type) {
                        case "packfile":
                            var s = JSON.parse(e.responseText);
                            t.data = s || {};
                            break;
                        case "image":
                            this.cache.addImage(t.key, t.url, t.data);
                            break;
                        case "spritesheet":
                            this.cache.addSpriteSheet(t.key, t.url, t.data, t.frameWidth, t.frameHeight, t.frameMax, t.margin, t.spacing);
                            break;
                        case "textureatlas":
                            if (null == t.atlasURL) this.cache.addTextureAtlas(t.key, t.url, t.data, t.atlasData, t.format);
                            else if (i = !1, t.format === a.Loader.TEXTURE_ATLAS_JSON_ARRAY || t.format === a.Loader.TEXTURE_ATLAS_JSON_HASH || t.format === a.Loader.TEXTURE_ATLAS_JSON_PYXEL) this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.jsonLoadComplete);
                            else {
                                if (t.format !== a.Loader.TEXTURE_ATLAS_XML_STARLING) throw new Error("Phaser.Loader. Invalid Texture Atlas format: " + t.format);
                                this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", this.xmlLoadComplete)
                            }
                            break;
                        case "bitmapfont":
                            t.atlasURL ? (i = !1, this.xhrLoad(t, this.transformUrl(t.atlasURL, t), "text", function(t, e) {
                                var i;
                                try {
                                    i = JSON.parse(e.responseText)
                                } catch (t) {}
                                i ? (t.atlasType = "json", this.jsonLoadComplete(t, e)) : (t.atlasType = "xml", this.xmlLoadComplete(t, e))
                            })) : this.cache.addBitmapFont(t.key, t.url, t.data, t.atlasData, t.atlasType, t.xSpacing, t.ySpacing);
                            break;
                        case "video":
                            if (t.asBlob) try {
                                t.data = e.response
                            } catch (e) {
                                throw new Error("Phaser.Loader. Unable to parse video file as Blob: " + t.key)
                            }
                            this.cache.addVideo(t.key, t.url, t.data, t.asBlob);
                            break;
                        case "audio":
                            this.game.sound.usingWebAudio ? (t.data = e.response, this.cache.addSound(t.key, t.url, t.data, !0, !1), t.autoDecode && this.game.sound.decode(t.key)) : this.cache.addSound(t.key, t.url, t.data, !1, !0);
                            break;
                        case "text":
                            t.data = e.responseText, this.cache.addText(t.key, t.url, t.data);
                            break;
                        case "shader":
                            t.data = e.responseText, this.cache.addShader(t.key, t.url, t.data);
                            break;
                        case "physics":
                            var s = JSON.parse(e.responseText);
                            this.cache.addPhysicsData(t.key, t.url, s, t.format);
                            break;
                        case "script":
                            t.data = document.createElement("script"), t.data.language = "javascript", t.data.type = "text/javascript", t.data.defer = !1, t.data.text = e.responseText, document.head.appendChild(t.data), t.callback && (t.data = t.callback.call(t.callbackContext, t.key, e.responseText));
                            break;
                        case "binary":
                            t.callback ? t.data = t.callback.call(t.callbackContext, t.key, e.response) : t.data = e.response, this.cache.addBinary(t.key, t.data)
                    }
                    i && this.asyncComplete(t)
                },
                jsonLoadComplete: function(t, e) {
                    var i = JSON.parse(e.responseText);
                    "tilemap" === t.type ? this.cache.addTilemap(t.key, t.url, i, t.format) : "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, i, t.atlasType, t.xSpacing, t.ySpacing) : "json" === t.type ? this.cache.addJSON(t.key, t.url, i) : this.cache.addTextureAtlas(t.key, t.url, t.data, i, t.format), this.asyncComplete(t)
                },
                csvLoadComplete: function(t, e) {
                    var i = e.responseText;
                    this.cache.addTilemap(t.key, t.url, i, t.format), this.asyncComplete(t)
                },
                xmlLoadComplete: function(t, e) {
                    var i = e.responseText,
                        s = this.parseXml(i);
                    if (!s) {
                        var n = e.responseType || e.contentType;
                        return void this.asyncComplete(t, "invalid XML")
                    }
                    "bitmapfont" === t.type ? this.cache.addBitmapFont(t.key, t.url, t.data, s, t.atlasType, t.xSpacing, t.ySpacing) : "textureatlas" === t.type ? this.cache.addTextureAtlas(t.key, t.url, t.data, s, t.format) : "xml" === t.type && this.cache.addXML(t.key, t.url, s), this.asyncComplete(t)
                },
                parseXml: function(t) {
                    var e;
                    try {
                        if (window.DOMParser) {
                            var i = new DOMParser;
                            e = i.parseFromString(t, "text/xml")
                        } else e = new ActiveXObject("Microsoft.XMLDOM"), e.async = "false", e.loadXML(t)
                    } catch (t) {
                        e = null
                    }
                    return e && e.documentElement && !e.getElementsByTagName("parsererror")
                        .length ? e : null
                },
                updateProgress: function() {
                    this.preloadSprite && (0 === this.preloadSprite.direction ? this.preloadSprite.rect.width = Math.floor(this.preloadSprite.width / 100 * this.progress) : this.preloadSprite.rect.height = Math.floor(this.preloadSprite.height / 100 * this.progress), this.preloadSprite.sprite ? this.preloadSprite.sprite.updateCrop() : this.preloadSprite = null)
                },
                totalLoadedFiles: function() {
                    return this._loadedFileCount
                },
                totalQueuedFiles: function() {
                    return this._totalFileCount - this._loadedFileCount
                },
                totalLoadedPacks: function() {
                    return this._totalPackCount
                },
                totalQueuedPacks: function() {
                    return this._totalPackCount - this._loadedPackCount
                }
            }, Object.defineProperty(a.Loader.prototype, "progressFloat", {
                get: function() {
                    var t = this._loadedFileCount / this._totalFileCount * 100;
                    return a.Math.clamp(t || 0, 0, 100)
                }
            }), Object.defineProperty(a.Loader.prototype, "progress", {
                get: function() {
                    return Math.round(this.progressFloat)
                }
            }), a.Loader.prototype.constructor = a.Loader, a.LoaderParser = {
                bitmapFont: function(t, e, i, s) {
                    return this.xmlBitmapFont(t, e, i, s)
                },
                xmlBitmapFont: function(t, e, i, s) {
                    var n = {},
                        a = t.getElementsByTagName("info")[0],
                        o = t.getElementsByTagName("common")[0];
                    n.font = a.getAttribute("face"), n.size = parseInt(a.getAttribute("size"), 10), n.lineHeight = parseInt(o.getAttribute("lineHeight"), 10) + s, n.chars = {};
                    for (var r = t.getElementsByTagName("char"), h = 0; h < r.length; h++) {
                        var l = parseInt(r[h].getAttribute("id"), 10);
                        n.chars[l] = {
                            x: parseInt(r[h].getAttribute("x"), 10),
                            y: parseInt(r[h].getAttribute("y"), 10),
                            width: parseInt(r[h].getAttribute("width"), 10),
                            height: parseInt(r[h].getAttribute("height"), 10),
                            xOffset: parseInt(r[h].getAttribute("xoffset"), 10),
                            yOffset: parseInt(r[h].getAttribute("yoffset"), 10),
                            xAdvance: parseInt(r[h].getAttribute("xadvance"), 10) + i,
                            kerning: {}
                        }
                    }
                    var c = t.getElementsByTagName("kerning");
                    for (h = 0; h < c.length; h++) {
                        var u = parseInt(c[h].getAttribute("first"), 10),
                            d = parseInt(c[h].getAttribute("second"), 10),
                            p = parseInt(c[h].getAttribute("amount"), 10);
                        n.chars[d].kerning[u] = p
                    }
                    return this.finalizeBitmapFont(e, n)
                },
                jsonBitmapFont: function(t, e, i, s) {
                    var n = {
                        font: t.font.info._face,
                        size: parseInt(t.font.info._size, 10),
                        lineHeight: parseInt(t.font.common._lineHeight, 10) + s,
                        chars: {}
                    };
                    return t.font.chars.char.forEach(function t(e) {
                        var s = parseInt(e._id, 10);
                        n.chars[s] = {
                            x: parseInt(e._x, 10),
                            y: parseInt(e._y, 10),
                            width: parseInt(e._width, 10),
                            height: parseInt(e._height, 10),
                            xOffset: parseInt(e._xoffset, 10),
                            yOffset: parseInt(e._yoffset, 10),
                            xAdvance: parseInt(e._xadvance, 10) + i,
                            kerning: {}
                        }
                    }), t.font.kernings && t.font.kernings.kerning && t.font.kernings.kerning.forEach(function t(e) {
                        n.chars[e._second].kerning[e._first] = parseInt(e._amount, 10)
                    }), this.finalizeBitmapFont(e, n)
                },
                finalizeBitmapFont: function(t, e) {
                    return Object.keys(e.chars)
                        .forEach(function i(s) {
                            var n = e.chars[s];
                            n.texture = new PIXI.Texture(t, new a.Rectangle(n.x, n.y, n.width, n.height))
                        }), e
                }
            }, a.AudioSprite = function(t, e) {
                this.game = t, this.key = e, this.config = this.game.cache.getJSON(e + "-audioatlas"), this.autoplayKey = null, this.autoplay = !1, this.sounds = {};
                for (var i in this.config.spritemap) {
                    var s = this.config.spritemap[i],
                        n = this.game.add.sound(this.key);
                    n.addMarker(i, s.start, s.end - s.start, null, s.loop), this.sounds[i] = n
                }
                this.config.autoplay && (this.autoplayKey = this.config.autoplay, this.play(this.autoplayKey), this.autoplay = this.sounds[this.autoplayKey])
            }, a.AudioSprite.prototype = {
                play: function(t, e) {
                    return void 0 === e && (e = 1), this.sounds[t].play(t, null, e)
                },
                stop: function(t) {
                    if (t) this.sounds[t].stop();
                    else
                        for (var e in this.sounds) this.sounds[e].stop()
                },
                get: function(t) {
                    return this.sounds[t]
                }
            }, a.AudioSprite.prototype.constructor = a.AudioSprite, a.Sound = function(t, e, i, s, n) {
                void 0 === i && (i = 1), void 0 === s && (s = !1), void 0 === n && (n = t.sound.connectToMaster), this.game = t, this.name = e, this.key = e, this.loop = s, this.markers = {}, this.context = null, this.autoplay = !1, this.totalDuration = 0, this.startTime = 0, this.currentTime = 0, this.duration = 0, this.durationMS = 0, this.position = 0, this.stopTime = 0, this.paused = !1, this.pausedPosition = 0, this.pausedTime = 0, this.isPlaying = !1, this.currentMarker = "", this.fadeTween = null, this.pendingPlayback = !1, this.override = !1, this.allowMultiple = !1, this.usingWebAudio = this.game.sound.usingWebAudio, this.usingAudioTag = this.game.sound.usingAudioTag, this.externalNode = null, this.masterGainNode = null, this.gainNode = null, this._sound = null, this.usingWebAudio ? (this.context = this.game.sound.context, this.masterGainNode = this.game.sound.masterGain, void 0 === this.context.createGain ? this.gainNode = this.context.createGainNode() : this.gainNode = this.context.createGain(), this.gainNode.gain.value = i * this.game.sound.volume, n && this.gainNode.connect(this.masterGainNode)) : this.usingAudioTag && (this.game.cache.getSound(e) && this.game.cache.isSoundReady(e) ? (this._sound = this.game.cache.getSoundData(e), this.totalDuration = 0, this._sound.duration && (this.totalDuration = this._sound.duration)) : this.game.cache.onSoundUnlock.add(this.soundHasUnlocked, this)), this.onDecoded = new a.Signal, this.onPlay = new a.Signal, this.onPause = new a.Signal, this.onResume = new a.Signal, this.onLoop = new a.Signal, this.onStop = new a.Signal, this.onMute = new a.Signal, this.onMarkerComplete = new a.Signal, this.onFadeComplete = new a.Signal, this._volume = i, this._buffer = null, this._muted = !1, this._tempMarker = 0, this._tempPosition = 0, this._tempVolume = 0, this._tempPause = 0, this._muteVolume = 0, this._tempLoop = 0, this._paused = !1, this._onDecodedEventDispatched = !1
            }, a.Sound.prototype = {
                soundHasUnlocked: function(t) {
                    t === this.key && (this._sound = this.game.cache.getSoundData(this.key), this.totalDuration = this._sound.duration)
                },
                addMarker: function(t, e, i, s, n) {
                    void 0 !== i && null !== i || (i = 1), void 0 !== s && null !== s || (s = 1), void 0 === n && (n = !1), this.markers[t] = {
                        name: t,
                        start: e,
                        stop: e + i,
                        volume: s,
                        duration: i,
                        durationMS: 1e3 * i,
                        loop: n
                    }
                },
                removeMarker: function(t) {
                    delete this.markers[t]
                },
                onEndedHandler: function() {
                    this._sound.onended = null, this.isPlaying = !1, this.currentTime = this.durationMS, this.stop()
                },
                update: function() {
                    if (!this.game.cache.checkSoundKey(this.key)) return void this.destroy();
                    this.isDecoded && !this._onDecodedEventDispatched && (this.onDecoded.dispatch(this), this._onDecodedEventDispatched = !0), this.pendingPlayback && this.game.cache.isSoundReady(this.key) && (this.pendingPlayback = !1, this.play(this._tempMarker, this._tempPosition, this._tempVolume, this._tempLoop)), this.isPlaying && (this.currentTime = this.game.time.time - this.startTime, this.currentTime >= this.durationMS && (this.usingWebAudio ? this.loop ? (this.onLoop.dispatch(this), this.isPlaying = !1, "" === this.currentMarker ? (this.currentTime = 0, this.startTime = this.game.time.time, this.isPlaying = !0) : (this.onMarkerComplete.dispatch(this.currentMarker, this), this.play(this.currentMarker, 0, this.volume, !0, !0))) : "" !== this.currentMarker && this.stop() : this.loop ? (this.onLoop.dispatch(this), "" === this.currentMarker && (this.currentTime = 0, this.startTime = this.game.time.time), this.isPlaying = !1, this.play(this.currentMarker, 0, this.volume, !0, !0)) : this.stop()))
                },
                loopFull: function(t) {
                    return this.play(null, 0, t, !0)
                },
                play: function(t, e, i, s, n) {
                    if (void 0 !== t && !1 !== t && null !== t || (t = ""), void 0 === n && (n = !0), this.isPlaying && !this.allowMultiple && !n && !this.override) return this;
                    if (this._sound && this.isPlaying && !this.allowMultiple && (this.override || n)) {
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                        this.isPlaying = !1
                    }
                    if ("" === t && Object.keys(this.markers)
                        .length > 0) return this;
                    if ("" !== t) {
                        if (!this.markers[t]) return this;
                        this.currentMarker = t, this.position = this.markers[t].start, this.volume = this.markers[t].volume, this.loop = this.markers[t].loop, this.duration = this.markers[t].duration, this.durationMS = this.markers[t].durationMS, void 0 !== i && (this.volume = i), void 0 !== s && (this.loop = s), this._tempMarker = t, this._tempPosition = this.position, this._tempVolume = this.volume, this._tempLoop = this.loop
                    } else e = e || 0, void 0 === i && (i = this._volume), void 0 === s && (s = this.loop), this.position = Math.max(0, e), this.volume = i, this.loop = s, this.duration = 0, this.durationMS = 0, this._tempMarker = t, this._tempPosition = e, this._tempVolume = i, this._tempLoop = s;
                    return this.usingWebAudio ? this.game.cache.isSoundDecoded(this.key) ? (this._sound = this.context.createBufferSource(), this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this._buffer = this.game.cache.getSoundData(this.key), this._sound.buffer = this._buffer, this.loop && "" === t && (this._sound.loop = !0), this.loop || "" !== t || (this._sound.onended = this.onEndedHandler.bind(this)), this.totalDuration = this._sound.buffer.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = Math.ceil(1e3 * this.totalDuration)), void 0 === this._sound.start ? this._sound.noteGrainOn(0, this.position, this.duration) : this.loop && "" === t ? this._sound.start(0, 0) : this._sound.start(0, this.position, this.duration), this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : (this.pendingPlayback = !0, this.game.cache.getSound(this.key) && !1 === this.game.cache.getSound(this.key)
                            .isDecoding && this.game.sound.decode(this.key, this)) : this.game.cache.getSound(this.key) && this.game.cache.getSound(this.key)
                        .locked ? (this.game.cache.reloadSound(this.key), this.pendingPlayback = !0) : this._sound && (this.game.device.cocoonJS || 4 === this._sound.readyState) ? (this._sound.play(), this.totalDuration = this._sound.duration, 0 === this.duration && (this.duration = this.totalDuration, this.durationMS = 1e3 * this.totalDuration), this._sound.currentTime = this.position, this._sound.muted = this._muted, this._muted || this.game.sound.mute ? this._sound.volume = 0 : this._sound.volume = this._volume, this.isPlaying = !0, this.startTime = this.game.time.time, this.currentTime = 0, this.stopTime = this.startTime + this.durationMS, this.onPlay.dispatch(this)) : this.pendingPlayback = !0, this
                },
                restart: function(t, e, i, s) {
                    t = t || "", e = e || 0, i = i || 1, void 0 === s && (s = !1), this.play(t, e, i, s, !0)
                },
                pause: function() {
                    this.isPlaying && this._sound && (this.paused = !0, this.pausedPosition = this.currentTime, this.pausedTime = this.game.time.time, this._tempPause = this._sound.currentTime, this.onPause.dispatch(this), this.stop())
                },
                resume: function() {
                    if (this.paused && this._sound) {
                        if (this.usingWebAudio) {
                            var t = Math.max(0, this.position + this.pausedPosition / 1e3);
                            this._sound = this.context.createBufferSource(), this._sound.buffer = this._buffer, this.externalNode ? this._sound.connect(this.externalNode) : this._sound.connect(this.gainNode), this.loop && (this._sound.loop = !0), this.loop || "" !== this.currentMarker || (this._sound.onended = this.onEndedHandler.bind(this));
                            var e = this.duration - this.pausedPosition / 1e3;
                            void 0 === this._sound.start ? this._sound.noteGrainOn(0, t, e) : this.loop && this.game.device.chrome ? 42 === this.game.device.chromeVersion ? this._sound.start(0) : this._sound.start(0, t) : this._sound.start(0, t, e)
                        } else this._sound.currentTime = this._tempPause, this._sound.play();
                        this.isPlaying = !0, this.paused = !1, this.startTime += this.game.time.time - this.pausedTime, this.onResume.dispatch(this)
                    }
                },
                stop: function() {
                    if (this.isPlaying && this._sound)
                        if (this.usingWebAudio) {
                            if (void 0 === this._sound.stop) this._sound.noteOff(0);
                            else try {
                                this._sound.stop(0)
                            } catch (t) {}
                            this.externalNode ? this._sound.disconnect(this.externalNode) : this.gainNode && this._sound.disconnect(this.gainNode)
                        } else this.usingAudioTag && (this._sound.pause(), this._sound.currentTime = 0);
                    if (this.pendingPlayback = !1, this.isPlaying = !1, !this.paused) {
                        var t = this.currentMarker;
                        "" !== this.currentMarker && this.onMarkerComplete.dispatch(this.currentMarker, this), this.currentMarker = "", null !== this.fadeTween && this.fadeTween.stop(), this.onStop.dispatch(this, t)
                    }
                },
                fadeIn: function(t, e, i) {
                    void 0 === e && (e = !1), void 0 === i && (i = this.currentMarker), this.paused || (this.play(i, 0, 0, e), this.fadeTo(t, 1))
                },
                fadeOut: function(t) {
                    this.fadeTo(t, 0)
                },
                fadeTo: function(t, e) {
                    this.isPlaying && !this.paused && e !== this.volume && (void 0 === t && (t = 1e3), void 0 !== e && (this.fadeTween = this.game.add.tween(this)
                        .to({
                            volume: e
                        }, t, a.Easing.Linear.None, !0), this.fadeTween.onComplete.add(this.fadeComplete, this)))
                },
                fadeComplete: function() {
                    this.onFadeComplete.dispatch(this, this.volume), 0 === this.volume && this.stop()
                },
                updateGlobalVolume: function(t) {
                    this.usingAudioTag && this._sound && (this._sound.volume = t * this._volume)
                },
                destroy: function(t) {
                    void 0 === t && (t = !0), this.stop(), t ? this.game.sound.remove(this) : (this.markers = {}, this.context = null, this._buffer = null, this.externalNode = null, this.onDecoded.dispose(), this.onPlay.dispose(), this.onPause.dispose(), this.onResume.dispose(), this.onLoop.dispose(), this.onStop.dispose(), this.onMute.dispose(), this.onMarkerComplete.dispose())
                }
            }, a.Sound.prototype.constructor = a.Sound, Object.defineProperty(a.Sound.prototype, "isDecoding", {
                get: function() {
                    return this.game.cache.getSound(this.key)
                        .isDecoding
                }
            }), Object.defineProperty(a.Sound.prototype, "isDecoded", {
                get: function() {
                    return this.game.cache.isSoundDecoded(this.key)
                }
            }), Object.defineProperty(a.Sound.prototype, "mute", {
                get: function() {
                    return this._muted || this.game.sound.mute
                },
                set: function(t) {
                    (t = t || !1) !== this._muted && (t ? (this._muted = !0, this._muteVolume = this._tempVolume, this.usingWebAudio ? this.gainNode.gain.value = 0 : this.usingAudioTag && this._sound && (this._sound.volume = 0)) : (this._muted = !1, this.usingWebAudio ? this.gainNode.gain.value = this._muteVolume : this.usingAudioTag && this._sound && (this._sound.volume = this._muteVolume)), this.onMute.dispatch(this))
                }
            }), Object.defineProperty(a.Sound.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    if (this.game.device.firefox && this.usingAudioTag && (t = this.game.math.clamp(t, 0, 1)), this._muted) return void(this._muteVolume = t);
                    this._tempVolume = t, this._volume = t, this.usingWebAudio ? this.gainNode.gain.value = t : this.usingAudioTag && this._sound && (this._sound.volume = t)
                }
            }), a.SoundManager = function(t) {
                this.game = t, this.onSoundDecode = new a.Signal, this.onVolumeChange = new a.Signal, this.onMute = new a.Signal, this.onUnMute = new a.Signal, this.context = null, this.usingWebAudio = !1, this.usingAudioTag = !1, this.noAudio = !1, this.connectToMaster = !0, this.touchLocked = !1, this.channels = 32, this.muteOnPause = !0, this._codeMuted = !1, this._muted = !1, this._unlockSource = null, this._volume = 1, this._sounds = [], this._watchList = new a.ArraySet, this._watching = !1, this._watchCallback = null, this._watchContext = null
            }, a.SoundManager.prototype = {
                boot: function() {
                    if (this.game.device.iOS && !1 === this.game.device.webAudio && (this.channels = 1), window.PhaserGlobal) {
                        if (!0 === window.PhaserGlobal.disableAudio) return this.noAudio = !0, void(this.touchLocked = !1);
                        if (!0 === window.PhaserGlobal.disableWebAudio) return this.usingAudioTag = !0, void(this.touchLocked = !1)
                    }
                    if (window.PhaserGlobal && window.PhaserGlobal.audioContext) this.context = window.PhaserGlobal.audioContext;
                    else if (window.AudioContext) try {
                        this.context = new window.AudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    } else if (window.webkitAudioContext) try {
                        this.context = new window.webkitAudioContext
                    } catch (t) {
                        this.context = null, this.usingWebAudio = !1, this.touchLocked = !1
                    }
                    if (null === this.context) {
                        if (void 0 === window.Audio) return void(this.noAudio = !0);
                        this.usingAudioTag = !0
                    } else this.usingWebAudio = !0, void 0 === this.context.createGain ? this.masterGain = this.context.createGainNode() : this.masterGain = this.context.createGain(), this.masterGain.gain.value = 1, this.masterGain.connect(this.context.destination);
                    this.noAudio || !this.game.device.cocoonJS && (this.game.device.android || this.game.device.iOS || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock) && this.setTouchLock()
                },
                setTouchLock: function() {
                    this.noAudio || window.PhaserGlobal && !0 === window.PhaserGlobal.disableAudio || (this.game.device.iOSVersion > 8 || this.game.device.chromeVersion >= 55 ? this.game.input.touch.addTouchLockCallback(this.unlock, this, !0) : this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0)
                },
                unlock: function() {
                    if (this.noAudio || !this.touchLocked || null !== this._unlockSource) return !0;
                    if (this.usingAudioTag) this.touchLocked = !1, this._unlockSource = null;
                    else if (this.usingWebAudio) {
                        var t = this.context.createBuffer(1, 1, 22050);
                        this._unlockSource = this.context.createBufferSource(), this._unlockSource.buffer = t, this._unlockSource.connect(this.context.destination), void 0 === this._unlockSource.start ? this._unlockSource.noteOn(0) : this._unlockSource.start(0), "suspended" === this._unlockSource.context.state && this._unlockSource.context.resume()
                    }
                    return !0
                },
                stopAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].stop()
                },
                pauseAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].pause()
                },
                resumeAll: function() {
                    if (!this.noAudio)
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].resume()
                },
                decode: function(t, e) {
                    e = e || null;
                    var i = this.game.cache.getSoundData(t);
                    if (i && !1 === this.game.cache.isSoundDecoded(t)) {
                        this.game.cache.updateSound(t, "isDecoding", !0);
                        var s = this;
                        try {
                            this.context.decodeAudioData(i, function(i) {
                                i && (s.game.cache.decodedSound(t, i), s.onSoundDecode.dispatch(t, e))
                            })
                        } catch (t) {}
                    }
                },
                setDecodedCallback: function(t, e, i) {
                    "string" == typeof t && (t = [t]), this._watchList.reset();
                    for (var s = 0; s < t.length; s++) t[s] instanceof a.Sound ? this.game.cache.isSoundDecoded(t[s].key) || this._watchList.add(t[s].key) : this.game.cache.isSoundDecoded(t[s]) || this._watchList.add(t[s]);
                    0 === this._watchList.total ? (this._watching = !1, e.call(i)) : (this._watching = !0, this._watchCallback = e, this._watchContext = i)
                },
                update: function() {
                    if (!this.noAudio) {
                        !this.touchLocked || null === this._unlockSource || this._unlockSource.playbackState !== this._unlockSource.PLAYING_STATE && this._unlockSource.playbackState !== this._unlockSource.FINISHED_STATE || (this.touchLocked = !1, this._unlockSource = null);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].update();
                        if (this._watching) {
                            for (var e = this._watchList.first; e;) this.game.cache.isSoundDecoded(e) && this._watchList.remove(e), e = this._watchList.next;
                            0 === this._watchList.total && (this._watching = !1, this._watchCallback.call(this._watchContext))
                        }
                    }
                },
                add: function(t, e, i, s) {
                    void 0 === e && (e = 1), void 0 === i && (i = !1), void 0 === s && (s = this.connectToMaster);
                    var n = new a.Sound(this.game, t, e, i, s);
                    return this._sounds.push(n), n
                },
                addSprite: function(t) {
                    return new a.AudioSprite(this.game, t)
                },
                remove: function(t) {
                    for (var e = this._sounds.length; e--;)
                        if (this._sounds[e] === t) return this._sounds[e].destroy(!1), this._sounds.splice(e, 1), !0;
                    return !1
                },
                removeByKey: function(t) {
                    for (var e = this._sounds.length, i = 0; e--;) this._sounds[e].key === t && (this._sounds[e].destroy(!1), this._sounds.splice(e, 1), i++);
                    return i
                },
                play: function(t, e, i) {
                    if (!this.noAudio) {
                        var s = this.add(t, e, i);
                        return s.play(), s
                    }
                },
                setMute: function() {
                    if (!this._muted) {
                        this._muted = !0, this.usingWebAudio && (this._muteVolume = this.masterGain.gain.value, this.masterGain.gain.value = 0);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !0);
                        this.onMute.dispatch()
                    }
                },
                unsetMute: function() {
                    if (this._muted && !this._codeMuted) {
                        this._muted = !1, this.usingWebAudio && (this.masterGain.gain.value = this._muteVolume);
                        for (var t = 0; t < this._sounds.length; t++) this._sounds[t].usingAudioTag && (this._sounds[t].mute = !1);
                        this.onUnMute.dispatch()
                    }
                },
                destroy: function() {
                    this.stopAll();
                    for (var t = 0; t < this._sounds.length; t++) this._sounds[t] && this._sounds[t].destroy();
                    this._sounds = [], this.onSoundDecode.dispose(), this.context && (window.PhaserGlobal ? window.PhaserGlobal.audioContext = this.context : this.context.close && this.context.close())
                }
            }, a.SoundManager.prototype.constructor = a.SoundManager, Object.defineProperty(a.SoundManager.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    if (t = t || !1) {
                        if (this._muted) return;
                        this._codeMuted = !0, this.setMute()
                    } else {
                        if (!this._muted) return;
                        this._codeMuted = !1, this.unsetMute()
                    }
                }
            }), Object.defineProperty(a.SoundManager.prototype, "volume", {
                get: function() {
                    return this._volume
                },
                set: function(t) {
                    if (t < 0 ? t = 0 : t > 1 && (t = 1), this._volume !== t) {
                        if (this._volume = t, this.usingWebAudio) this.masterGain.gain.value = t;
                        else
                            for (var e = 0; e < this._sounds.length; e++) this._sounds[e].usingAudioTag && this._sounds[e].updateGlobalVolume(t);
                        this.onVolumeChange.dispatch(t)
                    }
                }
            }), a.ScaleManager = function(t, e, i) {
                this.game = t, this.dom = a.DOM, this.grid = null, this.width = 0, this.height = 0, this.minWidth = null, this.maxWidth = null, this.minHeight = null, this.maxHeight = null, this.offset = new a.Point, this.forceLandscape = !1, this.forcePortrait = !1, this.incorrectOrientation = !1, this._pageAlignHorizontally = !1, this._pageAlignVertically = !1, this.onOrientationChange = new a.Signal, this.enterIncorrectOrientation = new a.Signal, this.leaveIncorrectOrientation = new a.Signal, this.hasPhaserSetFullScreen = !1, this.fullScreenTarget = null, this._createdFullScreenTarget = null, this.onFullScreenInit = new a.Signal, this.onFullScreenChange = new a.Signal, this.onFullScreenError = new a.Signal, this.screenOrientation = this.dom.getScreenOrientation(), this.scaleFactor = new a.Point(1, 1), this.scaleFactorInversed = new a.Point(1, 1), this.margin = {
                    left: 0,
                    top: 0,
                    right: 0,
                    bottom: 0,
                    x: 0,
                    y: 0
                }, this.bounds = new a.Rectangle, this.aspectRatio = 0, this.sourceAspectRatio = 0, this.event = null, this.windowConstraints = {
                    right: "layout",
                    bottom: ""
                }, this.compatibility = {
                    supportsFullScreen: !1,
                    orientationFallback: null,
                    noMargins: !1,
                    scrollTo: null,
                    forceMinimumDocumentHeight: !1,
                    canExpandParent: !0,
                    clickTrampoline: ""
                }, this._scaleMode = a.ScaleManager.NO_SCALE, this._fullScreenScaleMode = a.ScaleManager.NO_SCALE, this.parentIsWindow = !1, this.parentNode = null, this.parentScaleFactor = new a.Point(1, 1), this.trackParentInterval = 2e3, this.onSizeChange = new a.Signal, this.onResize = null, this.onResizeContext = null, this._pendingScaleMode = null, this._fullScreenRestore = null, this._gameSize = new a.Rectangle, this._userScaleFactor = new a.Point(1, 1), this._userScaleTrim = new a.Point(0, 0), this._lastUpdate = 0, this._updateThrottle = 0, this._updateThrottleReset = 100, this._parentBounds = new a.Rectangle, this._tempBounds = new a.Rectangle, this._lastReportedCanvasSize = new a.Rectangle, this._lastReportedGameSize = new a.Rectangle, this._booted = !1, t.config && this.parseConfig(t.config), this.setupScale(e, i)
            }, a.ScaleManager.EXACT_FIT = 0, a.ScaleManager.NO_SCALE = 1, a.ScaleManager.SHOW_ALL = 2, a.ScaleManager.RESIZE = 3, a.ScaleManager.USER_SCALE = 4, a.ScaleManager.prototype = {
                boot: function() {
                    var t = this.compatibility;
                    t.supportsFullScreen = this.game.device.fullscreen && !this.game.device.cocoonJS, this.game.device.iPad || this.game.device.webApp || this.game.device.desktop || (this.game.device.android && !this.game.device.chrome ? t.scrollTo = new a.Point(0, 1) : t.scrollTo = new a.Point(0, 0)), this.game.device.desktop ? (t.orientationFallback = "screen", t.clickTrampoline = "when-not-mouse") : (t.orientationFallback = "", t.clickTrampoline = "");
                    var e = this;
                    this._orientationChange = function(t) {
                        return e.orientationChange(t)
                    }, this._windowResize = function(t) {
                        return e.windowResize(t)
                    }, window.addEventListener("orientationchange", this._orientationChange, !1), window.addEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (this._fullScreenChange = function(t) {
                        return e.fullScreenChange(t)
                    }, this._fullScreenError = function(t) {
                        return e.fullScreenError(t)
                    }, document.addEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.addEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.addEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.addEventListener("fullscreenchange", this._fullScreenChange, !1), document.addEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.addEventListener("mozfullscreenerror", this._fullScreenError, !1), document.addEventListener("MSFullscreenError", this._fullScreenError, !1), document.addEventListener("fullscreenerror", this._fullScreenError, !1)), this.game.onResume.add(this._gameResumed, this), this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.setGameSize(this.game.width, this.game.height), this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), a.FlexGrid && (this.grid = new a.FlexGrid(this, this.width, this.height)), this._booted = !0, null !== this._pendingScaleMode && (this.scaleMode = this._pendingScaleMode, this._pendingScaleMode = null)
                },
                parseConfig: function(t) {
                    void 0 !== t.scaleMode && (this._booted ? this.scaleMode = t.scaleMode : this._pendingScaleMode = t.scaleMode), void 0 !== t.fullScreenScaleMode && (this.fullScreenScaleMode = t.fullScreenScaleMode), t.fullScreenTarget && (this.fullScreenTarget = t.fullScreenTarget)
                },
                setupScale: function(t, e) {
                    var i, s = new a.Rectangle;
                    "" !== this.game.parent && ("string" == typeof this.game.parent ? i = document.getElementById(this.game.parent) : this.game.parent && 1 === this.game.parent.nodeType && (i = this.game.parent)), i ? (this.parentNode = i, this.parentIsWindow = !1, this.getParentBounds(this._parentBounds), s.width = this._parentBounds.width, s.height = this._parentBounds.height, this.offset.set(this._parentBounds.x, this._parentBounds.y)) : (this.parentNode = null, this.parentIsWindow = !0, s.width = this.dom.visualBounds.width, s.height = this.dom.visualBounds.height, this.offset.set(0, 0));
                    var n = 0,
                        o = 0;
                    "number" == typeof t ? n = t : (this.parentScaleFactor.x = parseInt(t, 10) / 100, n = s.width * this.parentScaleFactor.x), "number" == typeof e ? o = e : (this.parentScaleFactor.y = parseInt(e, 10) / 100, o = s.height * this.parentScaleFactor.y), n = Math.floor(n), o = Math.floor(o), this._gameSize.setTo(0, 0, n, o), this.updateDimensions(n, o, !1)
                },
                _gameResumed: function() {
                    this.queueUpdate(!0)
                },
                setGameSize: function(t, e) {
                    this._gameSize.setTo(0, 0, t, e), this.currentScaleMode !== a.ScaleManager.RESIZE && this.updateDimensions(t, e, !0), this.queueUpdate(!0)
                },
                setUserScale: function(t, e, i, s) {
                    this._userScaleFactor.setTo(t, e), this._userScaleTrim.setTo(0 | i, 0 | s), this.queueUpdate(!0)
                },
                setResizeCallback: function(t, e) {
                    this.onResize = t, this.onResizeContext = e
                },
                signalSizeChange: function() {
                    if (!a.Rectangle.sameDimensions(this, this._lastReportedCanvasSize) || !a.Rectangle.sameDimensions(this.game, this._lastReportedGameSize)) {
                        var t = this.width,
                            e = this.height;
                        this._lastReportedCanvasSize.setTo(0, 0, t, e), this._lastReportedGameSize.setTo(0, 0, this.game.width, this.game.height), this.grid && this.grid.onResize(t, e), this.onSizeChange.dispatch(this, t, e), this.currentScaleMode === a.ScaleManager.RESIZE && (this.game.state.resize(t, e), this.game.load.resize(t, e))
                    }
                },
                setMinMax: function(t, e, i, s) {
                    this.minWidth = t, this.minHeight = e, void 0 !== i && (this.maxWidth = i), void 0 !== s && (this.maxHeight = s)
                },
                preUpdate: function() {
                    if (!(this.game.time.time < this._lastUpdate + this._updateThrottle)) {
                        var t = this._updateThrottle;
                        this._updateThrottleReset = t >= 400 ? 0 : 100, this.dom.getOffset(this.game.canvas, this.offset);
                        var e = this._parentBounds.width,
                            i = this._parentBounds.height,
                            s = this.getParentBounds(this._parentBounds),
                            n = s.width !== e || s.height !== i,
                            o = this.updateOrientationState();
                        (n || o) && (this.onResize && this.onResize.call(this.onResizeContext, this, s), this.updateLayout(), this.signalSizeChange());
                        var r = 2 * this._updateThrottle;
                        this._updateThrottle < t && (r = Math.min(t, this._updateThrottleReset)), this._updateThrottle = a.Math.clamp(r, 25, this.trackParentInterval), this._lastUpdate = this.game.time.time
                    }
                },
                pauseUpdate: function() {
                    this.preUpdate(), this._updateThrottle = this.trackParentInterval
                },
                updateDimensions: function(t, e, i) {
                    this.width = t * this.parentScaleFactor.x, this.height = e * this.parentScaleFactor.y, this.game.width = this.width, this.game.height = this.height, this.sourceAspectRatio = this.width / this.height, this.updateScalingAndBounds(), i && (this.game.renderer.resize(this.width, this.height), this.game.camera.setSize(this.width, this.height), this.game.world.resize(this.width, this.height))
                },
                updateScalingAndBounds: function() {
                    this.scaleFactor.x = this.game.width / this.width, this.scaleFactor.y = this.game.height / this.height, this.scaleFactorInversed.x = this.width / this.game.width, this.scaleFactorInversed.y = this.height / this.game.height, this.aspectRatio = this.width / this.height, this.game.canvas && this.dom.getOffset(this.game.canvas, this.offset), this.bounds.setTo(this.offset.x, this.offset.y, this.width, this.height), this.game.input && this.game.input.scale && this.game.input.scale.setTo(this.scaleFactor.x, this.scaleFactor.y)
                },
                forceOrientation: function(t, e) {
                    void 0 === e && (e = !1), this.forceLandscape = t, this.forcePortrait = e, this.queueUpdate(!0)
                },
                classifyOrientation: function(t) {
                    return "portrait-primary" === t || "portrait-secondary" === t ? "portrait" : "landscape-primary" === t || "landscape-secondary" === t ? "landscape" : null
                },
                updateOrientationState: function() {
                    var t = this.screenOrientation,
                        e = this.incorrectOrientation;
                    this.screenOrientation = this.dom.getScreenOrientation(this.compatibility.orientationFallback), this.incorrectOrientation = this.forceLandscape && !this.isLandscape || this.forcePortrait && !this.isPortrait;
                    var i = t !== this.screenOrientation,
                        s = e !== this.incorrectOrientation;
                    return s && (this.incorrectOrientation ? this.enterIncorrectOrientation.dispatch() : this.leaveIncorrectOrientation.dispatch()), (i || s) && this.onOrientationChange.dispatch(this, t, e), i || s
                },
                orientationChange: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                windowResize: function(t) {
                    this.event = t, this.queueUpdate(!0)
                },
                scrollTop: function() {
                    var t = this.compatibility.scrollTo;
                    t && window.scrollTo(t.x, t.y)
                },
                refresh: function() {
                    this.scrollTop(), this.queueUpdate(!0)
                },
                updateLayout: function() {
                    var t = this.currentScaleMode;
                    if (t === a.ScaleManager.RESIZE) return void this.reflowGame();
                    if (this.scrollTop(), this.compatibility.forceMinimumDocumentHeight && (document.documentElement.style.minHeight = window.innerHeight + "px"), this.incorrectOrientation ? this.setMaximum() : t === a.ScaleManager.EXACT_FIT ? this.setExactFit() : t === a.ScaleManager.SHOW_ALL ? !this.isFullScreen && this.boundingParent && this.compatibility.canExpandParent ? (this.setShowAll(!0), this.resetCanvas(), this.setShowAll()) : this.setShowAll() : t === a.ScaleManager.NO_SCALE ? (this.width = this.game.width, this.height = this.game.height) : t === a.ScaleManager.USER_SCALE && (this.width = this.game.width * this._userScaleFactor.x - this._userScaleTrim.x, this.height = this.game.height * this._userScaleFactor.y - this._userScaleTrim.y), !this.compatibility.canExpandParent && (t === a.ScaleManager.SHOW_ALL || t === a.ScaleManager.USER_SCALE)) {
                        var e = this.getParentBounds(this._tempBounds);
                        this.width = Math.min(this.width, e.width), this.height = Math.min(this.height, e.height)
                    }
                    this.width = 0 | this.width, this.height = 0 | this.height, this.reflowCanvas()
                },
                getParentBounds: function(t) {
                    var e = t || new a.Rectangle,
                        i = this.boundingParent,
                        s = this.dom.visualBounds,
                        n = this.dom.layoutBounds;
                    if (i) {
                        var o = i.getBoundingClientRect(),
                            r = i.offsetParent ? i.offsetParent.getBoundingClientRect() : i.getBoundingClientRect();
                        e.setTo(o.left - r.left, o.top - r.top, o.width, o.height);
                        var h = this.windowConstraints;
                        if (h.right) {
                            var l = "layout" === h.right ? n : s;
                            e.right = Math.min(e.right, l.width)
                        }
                        if (h.bottom) {
                            var l = "layout" === h.bottom ? n : s;
                            e.bottom = Math.min(e.bottom, l.height)
                        }
                    } else e.setTo(0, 0, s.width, s.height);
                    return e.setTo(Math.round(e.x), Math.round(e.y), Math.round(e.width), Math.round(e.height)), e
                },
                alignCanvas: function(t, e) {
                    var i = this.getParentBounds(this._tempBounds),
                        s = this.game.canvas,
                        n = this.margin;
                    if (t) {
                        n.left = n.right = 0;
                        var a = s.getBoundingClientRect();
                        if (this.width < i.width && !this.incorrectOrientation) {
                            var o = a.left - i.x,
                                r = i.width / 2 - this.width / 2;
                            r = Math.max(r, 0);
                            var h = r - o;
                            n.left = Math.round(h)
                        }
                        s.style.marginLeft = n.left + "px", 0 !== n.left && (n.right = -(i.width - a.width - n.left), s.style.marginRight = n.right + "px")
                    }
                    if (e) {
                        n.top = n.bottom = 0;
                        var a = s.getBoundingClientRect();
                        if (this.height < i.height && !this.incorrectOrientation) {
                            var o = a.top - i.y,
                                r = i.height / 2 - this.height / 2;
                            r = Math.max(r, 0);
                            var h = r - o;
                            n.top = Math.round(h)
                        }
                        s.style.marginTop = n.top + "px", 0 !== n.top && (n.bottom = -(i.height - a.height - n.top), s.style.marginBottom = n.bottom + "px")
                    }
                    n.x = n.left, n.y = n.top
                },
                reflowGame: function() {
                    this.resetCanvas("", "");
                    var t = this.getParentBounds(this._tempBounds);
                    this.updateDimensions(t.width, t.height, !0)
                },
                reflowCanvas: function() {
                    this.incorrectOrientation || (this.width = a.Math.clamp(this.width, this.minWidth || 0, this.maxWidth || this.width), this.height = a.Math.clamp(this.height, this.minHeight || 0, this.maxHeight || this.height)), this.resetCanvas(), this.compatibility.noMargins || (this.isFullScreen && this._createdFullScreenTarget ? this.alignCanvas(!0, !0) : this.alignCanvas(this.pageAlignHorizontally, this.pageAlignVertically)), this.updateScalingAndBounds()
                },
                resetCanvas: function(t, e) {
                    void 0 === t && (t = this.width + "px"), void 0 === e && (e = this.height + "px");
                    var i = this.game.canvas;
                    this.compatibility.noMargins || (i.style.marginLeft = "", i.style.marginTop = "", i.style.marginRight = "", i.style.marginBottom = ""), i.style.width = t, i.style.height = e
                },
                queueUpdate: function(t) {
                    t && (this._parentBounds.width = 0, this._parentBounds.height = 0), this._updateThrottle = this._updateThrottleReset
                },
                reset: function(t) {
                    t && this.grid && this.grid.reset()
                },
                setMaximum: function() {
                    this.width = this.dom.visualBounds.width, this.height = this.dom.visualBounds.height
                },
                setShowAll: function(t) {
                    var e = this.getParentBounds(this._tempBounds),
                        i = e.width,
                        s = e.height,
                        n;
                    n = t ? Math.max(s / this.game.height, i / this.game.width) : Math.min(s / this.game.height, i / this.game.width), this.width = Math.round(this.game.width * n), this.height = Math.round(this.game.height * n)
                },
                setExactFit: function() {
                    var t = this.getParentBounds(this._tempBounds);
                    this.width = t.width, this.height = t.height, this.isFullScreen || (this.maxWidth && (this.width = Math.min(this.width, this.maxWidth)), this.maxHeight && (this.height = Math.min(this.height, this.maxHeight)))
                },
                createFullScreenTarget: function() {
                    var t = document.createElement("div");
                    return t.style.margin = "0", t.style.padding = "0", t.style.background = "#000", t
                },
                startFullScreen: function(t, e) {
                    if (this.isFullScreen) return !1;
                    if (!this.compatibility.supportsFullScreen) {
                        var i = this;
                        return void setTimeout(function() {
                            i.fullScreenError()
                        }, 10)
                    }
                    if ("when-not-mouse" === this.compatibility.clickTrampoline) {
                        var s = this.game.input;
                        if (s.activePointer && s.activePointer !== s.mousePointer && (e || !1 !== e)) return void s.activePointer.addClickTrampoline("startFullScreen", this.startFullScreen, this, [t, !1])
                    }
                    void 0 !== t && this.game.renderType === a.CANVAS && (this.game.stage.smoothed = t);
                    var n = this.fullScreenTarget;
                    n || (this.cleanupCreatedTarget(), this._createdFullScreenTarget = this.createFullScreenTarget(), n = this._createdFullScreenTarget);
                    var o = {
                        targetElement: n
                    };
                    if (this.hasPhaserSetFullScreen = !0, this.onFullScreenInit.dispatch(this, o), this._createdFullScreenTarget) {
                        var r = this.game.canvas;
                        r.parentNode.insertBefore(n, r), n.appendChild(r)
                    }
                    return this.game.device.fullscreenKeyboard ? n[this.game.device.requestFullscreen](Element.ALLOW_KEYBOARD_INPUT) : n[this.game.device.requestFullscreen](), !0
                },
                stopFullScreen: function() {
                    return !(!this.isFullScreen || !this.compatibility.supportsFullScreen) && (this.hasPhaserSetFullScreen = !1, document[this.game.device.cancelFullscreen](), !0)
                },
                cleanupCreatedTarget: function() {
                    var t = this._createdFullScreenTarget;
                    if (t && t.parentNode) {
                        var e = t.parentNode;
                        e.insertBefore(this.game.canvas, t), e.removeChild(t)
                    }
                    this._createdFullScreenTarget = null
                },
                prepScreenMode: function(t) {
                    var e = !!this._createdFullScreenTarget,
                        i = this._createdFullScreenTarget || this.fullScreenTarget;
                    t ? (e || this.fullScreenScaleMode === a.ScaleManager.EXACT_FIT) && i !== this.game.canvas && (this._fullScreenRestore = {
                        targetWidth: i.style.width,
                        targetHeight: i.style.height
                    }, i.style.width = "100%", i.style.height = "100%") : (this._fullScreenRestore && (i.style.width = this._fullScreenRestore.targetWidth, i.style.height = this._fullScreenRestore.targetHeight, this._fullScreenRestore = null), this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.resetCanvas())
                },
                fullScreenChange: function(t) {
                    this.event = t, this.isFullScreen ? (this.prepScreenMode(!0), this.updateLayout(), this.queueUpdate(!0)) : (this.prepScreenMode(!1), this.cleanupCreatedTarget(), this.updateLayout(), this.queueUpdate(!0)), this.onFullScreenChange.dispatch(this, this.width, this.height)
                },
                fullScreenError: function(t) {
                    this.event = t, this.cleanupCreatedTarget(), this.onFullScreenError.dispatch(this)
                },
                scaleSprite: function(t, e, i, s) {
                    if (void 0 === e && (e = this.width), void 0 === i && (i = this.height), void 0 === s && (s = !1), !t || !t.scale) return t;
                    if (t.scale.x = 1, t.scale.y = 1, t.width <= 0 || t.height <= 0 || e <= 0 || i <= 0) return t;
                    var n = e,
                        a = t.height * e / t.width,
                        o = t.width * i / t.height,
                        r = i,
                        h = o > e;
                    return h = h ? s : !s, h ? (t.width = Math.floor(n), t.height = Math.floor(a)) : (t.width = Math.floor(o), t.height = Math.floor(r)), t
                },
                destroy: function() {
                    this.game.onResume.remove(this._gameResumed, this), window.removeEventListener("orientationchange", this._orientationChange, !1), window.removeEventListener("resize", this._windowResize, !1), this.compatibility.supportsFullScreen && (document.removeEventListener("webkitfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("mozfullscreenchange", this._fullScreenChange, !1), document.removeEventListener("MSFullscreenChange", this._fullScreenChange, !1), document.removeEventListener("fullscreenchange", this._fullScreenChange, !1), document.removeEventListener("webkitfullscreenerror", this._fullScreenError, !1), document.removeEventListener("mozfullscreenerror", this._fullScreenError, !1), document.removeEventListener("MSFullscreenError", this._fullScreenError, !1), document.removeEventListener("fullscreenerror", this._fullScreenError, !1))
                }
            }, a.ScaleManager.prototype.constructor = a.ScaleManager, Object.defineProperty(a.ScaleManager.prototype, "boundingParent", {
                get: function() {
                    return this.parentIsWindow || this.isFullScreen && this.hasPhaserSetFullScreen && !this._createdFullScreenTarget ? null : this.game.canvas && this.game.canvas.parentNode || null
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "scaleMode", {
                get: function() {
                    return this._scaleMode
                },
                set: function(t) {
                    return t !== this._scaleMode && (this.isFullScreen || (this.updateDimensions(this._gameSize.width, this._gameSize.height, !0), this.queueUpdate(!0)), this._scaleMode = t), this._scaleMode
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "fullScreenScaleMode", {
                get: function() {
                    return this._fullScreenScaleMode
                },
                set: function(t) {
                    return t !== this._fullScreenScaleMode && (this.isFullScreen ? (this.prepScreenMode(!1), this._fullScreenScaleMode = t, this.prepScreenMode(!0), this.queueUpdate(!0)) : this._fullScreenScaleMode = t), this._fullScreenScaleMode
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "currentScaleMode", {
                get: function() {
                    return this.isFullScreen ? this._fullScreenScaleMode : this._scaleMode
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "pageAlignHorizontally", {
                get: function() {
                    return this._pageAlignHorizontally
                },
                set: function(t) {
                    t !== this._pageAlignHorizontally && (this._pageAlignHorizontally = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "pageAlignVertically", {
                get: function() {
                    return this._pageAlignVertically
                },
                set: function(t) {
                    t !== this._pageAlignVertically && (this._pageAlignVertically = t, this.queueUpdate(!0))
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "isFullScreen", {
                get: function() {
                    return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement)
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "isPortrait", {
                get: function() {
                    return "portrait" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "isLandscape", {
                get: function() {
                    return "landscape" === this.classifyOrientation(this.screenOrientation)
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "isGamePortrait", {
                get: function() {
                    return this.height > this.width
                }
            }), Object.defineProperty(a.ScaleManager.prototype, "isGameLandscape", {
                get: function() {
                    return this.width > this.height
                }
            }), a.Utils.Debug = function(t) {
                this.game = t, this.sprite = null, this.bmd = null, this.canvas = null, this.context = null, this.font = "14px Courier", this.columnWidth = 100, this.lineHeight = 16, this.renderShadow = !0, this.currentX = 0, this.currentY = 0, this.currentAlpha = 1, this.dirty = !1
            }, a.Utils.Debug.prototype = {
                boot: function() {
                    this.game.renderType === a.CANVAS ? this.context = this.game.context : (this.bmd = new a.BitmapData(this.game, "__DEBUG", this.game.width, this.game.height, !0), this.sprite = this.game.make.image(0, 0, this.bmd), this.game.stage.addChild(this.sprite), this.game.scale.onSizeChange.add(this.resize, this), this.canvas = PIXI.CanvasPool.create(this, this.game.width, this.game.height), this.context = this.canvas.getContext("2d"))
                },
                resize: function(t, e, i) {
                    this.bmd.resize(e, i), this.canvas.width = e, this.canvas.height = i
                },
                preUpdate: function() {
                    this.dirty && this.sprite && (this.bmd.clear(), this.bmd.draw(this.canvas, 0, 0), this.context.clearRect(0, 0, this.game.width, this.game.height), this.dirty = !1)
                },
                reset: function() {
                    this.context && this.context.clearRect(0, 0, this.game.width, this.game.height), this.sprite && this.bmd.clear()
                },
                start: function(t, e, i, s) {
                    "number" != typeof t && (t = 0), "number" != typeof e && (e = 0), i = i || "rgb(255,255,255)", void 0 === s && (s = 0), this.currentX = t, this.currentY = e, this.currentColor = i, this.columnWidth = s, this.dirty = !0, this.context.save(), this.context.setTransform(1, 0, 0, 1, 0, 0), this.context.strokeStyle = i, this.context.fillStyle = i, this.context.font = this.font, this.context.globalAlpha = this.currentAlpha
                },
                stop: function() {
                    this.context.restore()
                },
                line: function() {
                    for (var t = this.currentX, e = 0; e < arguments.length; e++) this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(arguments[e], t + 1, this.currentY + 1), this.context.fillStyle = this.currentColor), this.context.fillText(arguments[e], t, this.currentY), t += this.columnWidth;
                    this.currentY += this.lineHeight
                },
                soundInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sound: " + t.key + " Locked: " + t.game.sound.touchLocked), this.line("Is Ready?: " + this.game.cache.isSoundReady(t.key) + " Pending Playback: " + t.pendingPlayback), this.line("Decoded: " + t.isDecoded + " Decoding: " + t.isDecoding), this.line("Total Duration: " + t.totalDuration + " Playing: " + t.isPlaying), this.line("Time: " + t.currentTime), this.line("Volume: " + t.volume + " Muted: " + t.mute), this.line("WebAudio: " + t.usingWebAudio + " Audio: " + t.usingAudioTag), "" !== t.currentMarker && (this.line("Marker: " + t.currentMarker + " Duration: " + t.duration + " (ms: " + t.durationMS + ")"), this.line("Start: " + t.markers[t.currentMarker].start + " Stop: " + t.markers[t.currentMarker].stop), this.line("Position: " + t.position)), this.stop()
                },
                cameraInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Camera (" + t.width + " x " + t.height + ")"), this.line("X: " + t.x + " Y: " + t.y), t.bounds && this.line("Bounds x: " + t.bounds.x + " Y: " + t.bounds.y + " w: " + t.bounds.width + " h: " + t.bounds.height), this.line("View x: " + t.view.x + " Y: " + t.view.y + " w: " + t.view.width + " h: " + t.view.height), this.line("Total in view: " + t.totalInView), this.stop()
                },
                timer: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Timer (running: " + t.running + " expired: " + t.expired + ")"), this.line("Next Tick: " + t.next + " Duration: " + t.duration), this.line("Paused: " + t.paused + " Length: " + t.length), this.stop()
                },
                pointer: function(t, e, i, s, n) {
                    null != t && (void 0 === e && (e = !1), i = i || "rgba(0,255,0,0.5)", s = s || "rgba(255,0,0,0.5)", !0 === e && !0 === t.isUp || (this.start(t.x, t.y - 100, n), this.context.beginPath(), this.context.arc(t.x, t.y, t.circle.radius, 0, 2 * Math.PI), t.active ? this.context.fillStyle = i : this.context.fillStyle = s, this.context.fill(), this.context.closePath(), this.context.beginPath(), this.context.moveTo(t.positionDown.x, t.positionDown.y), this.context.lineTo(t.position.x, t.position.y), this.context.lineWidth = 2, this.context.stroke(), this.context.closePath(), this.line("ID: " + t.id + " Active: " + t.active), this.line("World X: " + t.worldX + " World Y: " + t.worldY), this.line("Screen X: " + t.x + " Screen Y: " + t.y + " In: " + t.withinGame), this.line("Duration: " + t.duration + " ms"), this.line("is Down: " + t.isDown + " is Up: " + t.isUp), this.stop()))
                },
                spriteInputInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sprite Input: (" + t.width + " x " + t.height + ")"), this.line("x: " + t.input.pointerX()
                        .toFixed(1) + " y: " + t.input.pointerY()
                        .toFixed(1)), this.line("over: " + t.input.pointerOver() + " duration: " + t.input.overDuration()
                        .toFixed(0)), this.line("down: " + t.input.pointerDown() + " duration: " + t.input.downDuration()
                        .toFixed(0)), this.line("just over: " + t.input.justOver() + " just out: " + t.input.justOut()), this.stop()
                },
                key: function(t, e, i, s) {
                    this.start(e, i, s, 150), this.line("Key:", t.keyCode, "isDown:", t.isDown), this.line("justDown:", t.justDown, "justUp:", t.justUp), this.line("Time Down:", t.timeDown.toFixed(0), "duration:", t.duration.toFixed(0)), this.stop()
                },
                inputInfo: function(t, e, i) {
                    this.start(t, e, i), this.line("Input"), this.line("X: " + this.game.input.x + " Y: " + this.game.input.y), this.line("World X: " + this.game.input.worldX + " World Y: " + this.game.input.worldY), this.line("Scale X: " + this.game.input.scale.x.toFixed(1) + " Scale Y: " + this.game.input.scale.x.toFixed(1)), this.line("Screen X: " + this.game.input.activePointer.screenX + " Screen Y: " + this.game.input.activePointer.screenY), this.stop()
                },
                spriteBounds: function(t, e, i) {
                    var s = t.getBounds();
                    s.x += this.game.camera.x, s.y += this.game.camera.y, this.rectangle(s, e, i)
                },
                ropeSegments: function(t, e, i) {
                    var s = this;
                    t.segments.forEach(function(t) {
                        s.rectangle(t, e, i)
                    }, this)
                },
                spriteInfo: function(t, e, i, s) {
                    this.start(e, i, s), this.line("Sprite:  (" + t.width + " x " + t.height + ") anchor: " + t.anchor.x + " x " + t.anchor.y), this.line("x: " + t.x.toFixed(1) + " y: " + t.y.toFixed(1)), this.line("angle: " + t.angle.toFixed(1) + " rotation: " + t.rotation.toFixed(1)), this.line("visible: " + t.visible + " in camera: " + t.inCamera), this.line("bounds x: " + t._bounds.x.toFixed(1) + " y: " + t._bounds.y.toFixed(1) + " w: " + t._bounds.width.toFixed(1) + " h: " + t._bounds.height.toFixed(1)), this.stop()
                },
                spriteCoords: function(t, e, i, s) {
                    this.start(e, i, s, 100), t.name && this.line(t.name), this.line("x:", t.x.toFixed(2), "y:", t.y.toFixed(2)), this.line("pos x:", t.position.x.toFixed(2), "pos y:", t.position.y.toFixed(2)), this.line("world x:", t.world.x.toFixed(2), "world y:", t.world.y.toFixed(2)), this.stop()
                },
                lineInfo: function(t, e, i, s) {
                    this.start(e, i, s, 80), this.line("start.x:", t.start.x.toFixed(2), "start.y:", t.start.y.toFixed(2)), this.line("end.x:", t.end.x.toFixed(2), "end.y:", t.end.y.toFixed(2)), this.line("length:", t.length.toFixed(2), "angle:", t.angle), this.stop()
                },
                pixel: function(t, e, i, s) {
                    s = s || 2, this.start(), this.context.fillStyle = i, this.context.fillRect(t, e, s, s), this.stop()
                },
                geom: function(t, e, i, s) {
                    void 0 === i && (i = !0), void 0 === s && (s = 0), e = e || "rgba(0,255,0,0.4)", this.start(), this.context.fillStyle = e, this.context.strokeStyle = e, t instanceof a.Rectangle || 1 === s ? i ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height) : t instanceof a.Circle || 2 === s ? (this.context.beginPath(), this.context.arc(t.x - this.game.camera.x, t.y - this.game.camera.y, t.radius, 0, 2 * Math.PI, !1), this.context.closePath(), i ? this.context.fill() : this.context.stroke()) : t instanceof a.Point || 3 === s ? this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, 4, 4) : (t instanceof a.Line || 4 === s) && (this.context.lineWidth = 1, this.context.beginPath(), this.context.moveTo(t.start.x + .5 - this.game.camera.x, t.start.y + .5 - this.game.camera.y), this.context.lineTo(t.end.x + .5 - this.game.camera.x, t.end.y + .5 - this.game.camera.y), this.context.closePath(), this.context.stroke()), this.stop()
                },
                rectangle: function(t, e, i) {
                    void 0 === i && (i = !0), e = e || "rgba(0, 255, 0, 0.4)", this.start(), i ? (this.context.fillStyle = e, this.context.fillRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)) : (this.context.strokeStyle = e, this.context.strokeRect(t.x - this.game.camera.x, t.y - this.game.camera.y, t.width, t.height)), this.stop()
                },
                text: function(t, e, i, s, n) {
                    s = s || "rgb(255,255,255)", n = n || "16px Courier", this.start(), this.context.font = n, this.renderShadow && (this.context.fillStyle = "rgb(0,0,0)", this.context.fillText(t, e + 1, i + 1)), this.context.fillStyle = s, this.context.fillText(t, e, i), this.stop()
                },
                quadTree: function(t, e) {
                    e = e || "rgba(255,0,0,0.3)", this.start();
                    var i = t.bounds;
                    if (0 === t.nodes.length) {
                        this.context.strokeStyle = e, this.context.strokeRect(i.x, i.y, i.width, i.height), this.text("size: " + t.objects.length, i.x + 4, i.y + 16, "rgb(0,200,0)", "12px Courier"), this.context.strokeStyle = "rgb(0,255,0)";
                        for (var s = 0; s < t.objects.length; s++) this.context.strokeRect(t.objects[s].x, t.objects[s].y, t.objects[s].width, t.objects[s].height)
                    } else
                        for (var s = 0; s < t.nodes.length; s++) this.quadTree(t.nodes[s]);
                    this.stop()
                },
                body: function(t, e, i) {
                    t.body && (this.start(), t.body.type === a.Physics.ARCADE ? a.Physics.Arcade.Body.render(this.context, t.body, e, i) : t.body.type === a.Physics.NINJA ? a.Physics.Ninja.Body.render(this.context, t.body, e, i) : t.body.type === a.Physics.BOX2D && a.Physics.Box2D.renderBody(this.context, t.body, e), this.stop())
                },
                bodyInfo: function(t, e, i, s) {
                    t.body && (this.start(e, i, s, 210), t.body.type === a.Physics.ARCADE ? a.Physics.Arcade.Body.renderBodyInfo(this, t.body) : t.body.type === a.Physics.BOX2D && this.game.physics.box2d.renderBodyInfo(this, t.body), this.stop())
                },
                box2dWorld: function() {
                    this.start(), this.context.translate(-this.game.camera.view.x, -this.game.camera.view.y, 0), this.game.physics.box2d.renderDebugDraw(this.context), this.stop()
                },
                box2dBody: function(t, e) {
                    this.start(), a.Physics.Box2D.renderBody(this.context, t, e), this.stop()
                },
                displayList: function(t) {
                    if (void 0 === t && (t = this.game.world), t.hasOwnProperty("renderOrderID"), t.children && t.children.length > 0)
                        for (var e = 0; e < t.children.length; e++) this.game.debug.displayList(t.children[e])
                },
                destroy: function() {
                    PIXI.CanvasPool.remove(this)
                }
            }, a.Utils.Debug.prototype.constructor = a.Utils.Debug, a.DOM = {
                getOffset: function(t, e) {
                    e = e || new a.Point;
                    var i = t.getBoundingClientRect(),
                        s = a.DOM.scrollY,
                        n = a.DOM.scrollX,
                        o = document.documentElement.clientTop,
                        r = document.documentElement.clientLeft;
                    return e.x = i.left + n - r, e.y = i.top + s - o, e
                },
                getBounds: function(t, e) {
                    return void 0 === e && (e = 0), !(!(t = t && !t.nodeType ? t[0] : t) || 1 !== t.nodeType) && this.calibrate(t.getBoundingClientRect(), e)
                },
                calibrate: function(t, e) {
                    e = +e || 0;
                    var i = {
                        width: 0,
                        height: 0,
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    };
                    return i.width = (i.right = t.right + e) - (i.left = t.left - e), i.height = (i.bottom = t.bottom + e) - (i.top = t.top - e), i
                },
                getAspectRatio: function(t) {
                    t = null == t ? this.visualBounds : 1 === t.nodeType ? this.getBounds(t) : t;
                    var e = t.width,
                        i = t.height;
                    return "function" == typeof e && (e = e.call(t)), "function" == typeof i && (i = i.call(t)), e / i
                },
                inLayoutViewport: function(t, e) {
                    var i = this.getBounds(t, e);
                    return !!i && i.bottom >= 0 && i.right >= 0 && i.top <= this.layoutBounds.width && i.left <= this.layoutBounds.height
                },
                getScreenOrientation: function(t) {
                    var e = window.screen,
                        i = e.orientation || e.mozOrientation || e.msOrientation;
                    if (i && "string" == typeof i.type) return i.type;
                    if ("string" == typeof i) return i;
                    var s = "portrait-primary",
                        n = "landscape-primary";
                    if ("screen" === t) return e.height > e.width ? s : n;
                    if ("viewport" === t) return this.visualBounds.height > this.visualBounds.width ? s : n;
                    if ("window.orientation" === t && "number" == typeof window.orientation) return 0 === window.orientation || 180 === window.orientation ? s : n;
                    if (window.matchMedia) {
                        if (window.matchMedia("(orientation: portrait)")
                            .matches) return s;
                        if (window.matchMedia("(orientation: landscape)")
                            .matches) return n
                    }
                    return this.visualBounds.height > this.visualBounds.width ? s : n
                },
                visualBounds: new a.Rectangle,
                layoutBounds: new a.Rectangle,
                documentBounds: new a.Rectangle
            }, a.Device.whenReady(function(t) {
                var e = window && "pageXOffset" in window ? function() {
                        return window.pageXOffset
                    } : function() {
                        return document.documentElement.scrollLeft
                    },
                    i = window && "pageYOffset" in window ? function() {
                        return window.pageYOffset
                    } : function() {
                        return document.documentElement.scrollTop
                    };
                if (Object.defineProperty(a.DOM, "scrollX", {
                        get: e
                    }), Object.defineProperty(a.DOM, "scrollY", {
                        get: i
                    }), Object.defineProperty(a.DOM.visualBounds, "x", {
                        get: e
                    }), Object.defineProperty(a.DOM.visualBounds, "y", {
                        get: i
                    }), Object.defineProperty(a.DOM.layoutBounds, "x", {
                        value: 0
                    }), Object.defineProperty(a.DOM.layoutBounds, "y", {
                        value: 0
                    }), t.desktop && document.documentElement.clientWidth <= window.innerWidth && document.documentElement.clientHeight <= window.innerHeight) {
                    var s = function() {
                            return Math.max(window.innerWidth, document.documentElement.clientWidth)
                        },
                        n = function() {
                            return Math.max(window.innerHeight, document.documentElement.clientHeight)
                        };
                    Object.defineProperty(a.DOM.visualBounds, "width", {
                        get: s
                    }), Object.defineProperty(a.DOM.visualBounds, "height", {
                        get: n
                    }), Object.defineProperty(a.DOM.layoutBounds, "width", {
                        get: s
                    }), Object.defineProperty(a.DOM.layoutBounds, "height", {
                        get: n
                    })
                } else Object.defineProperty(a.DOM.visualBounds, "width", {
                    get: function() {
                        return window.innerWidth
                    }
                }), Object.defineProperty(a.DOM.visualBounds, "height", {
                    get: function() {
                        return window.innerHeight
                    }
                }), Object.defineProperty(a.DOM.layoutBounds, "width", {
                    get: function() {
                        var t = document.documentElement.clientWidth,
                            e = window.innerWidth;
                        return t < e ? e : t
                    }
                }), Object.defineProperty(a.DOM.layoutBounds, "height", {
                    get: function() {
                        var t = document.documentElement.clientHeight,
                            e = window.innerHeight;
                        return t < e ? e : t
                    }
                });
                Object.defineProperty(a.DOM.documentBounds, "x", {
                    value: 0
                }), Object.defineProperty(a.DOM.documentBounds, "y", {
                    value: 0
                }), Object.defineProperty(a.DOM.documentBounds, "width", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientWidth, t.offsetWidth, t.scrollWidth)
                    }
                }), Object.defineProperty(a.DOM.documentBounds, "height", {
                    get: function() {
                        var t = document.documentElement;
                        return Math.max(t.clientHeight, t.offsetHeight, t.scrollHeight)
                    }
                })
            }, null, !0), a.ArraySet = function(t) {
                this.position = 0, this.list = t || []
            }, a.ArraySet.prototype = {
                add: function(t) {
                    return this.exists(t) || this.list.push(t), t
                },
                getIndex: function(t) {
                    return this.list.indexOf(t)
                },
                getByKey: function(t, e) {
                    for (var i = this.list.length; i--;)
                        if (this.list[i][t] === e) return this.list[i];
                    return null
                },
                exists: function(t) {
                    return this.list.indexOf(t) > -1
                },
                reset: function() {
                    this.list.length = 0
                },
                remove: function(t) {
                    var e = this.list.indexOf(t);
                    if (e > -1) return this.list.splice(e, 1), t
                },
                setAll: function(t, e) {
                    for (var i = this.list.length; i--;) this.list[i] && (this.list[i][t] = e)
                },
                callAll: function(t) {
                    for (var e = Array.prototype.slice.call(arguments, 1), i = this.list.length; i--;) this.list[i] && this.list[i][t] && this.list[i][t].apply(this.list[i], e)
                },
                removeAll: function(t) {
                    void 0 === t && (t = !1);
                    for (var e = this.list.length; e--;)
                        if (this.list[e]) {
                            var i = this.remove(this.list[e]);
                            t && i.destroy()
                        } this.position = 0, this.list = []
                }
            }, Object.defineProperty(a.ArraySet.prototype, "total", {
                get: function() {
                    return this.list.length
                }
            }), Object.defineProperty(a.ArraySet.prototype, "first", {
                get: function() {
                    return this.position = 0, this.list.length > 0 ? this.list[0] : null
                }
            }), Object.defineProperty(a.ArraySet.prototype, "next", {
                get: function() {
                    return this.position < this.list.length ? (this.position++, this.list[this.position]) : null
                }
            }), a.ArraySet.prototype.constructor = a.ArraySet, a.ArrayUtils = {
                getRandomItem: function(t, e, i) {
                    if (null === t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    var s = e + Math.floor(Math.random() * i);
                    return void 0 === t[s] ? null : t[s]
                },
                removeRandomItem: function(t, e, i) {
                    if (null == t) return null;
                    void 0 === e && (e = 0), void 0 === i && (i = t.length);
                    var s = e + Math.floor(Math.random() * i);
                    if (s < t.length) {
                        var n = t.splice(s, 1);
                        return void 0 === n[0] ? null : n[0]
                    }
                    return null
                },
                shuffle: function(t) {
                    for (var e = t.length - 1; e > 0; e--) {
                        var i = Math.floor(Math.random() * (e + 1)),
                            s = t[e];
                        t[e] = t[i], t[i] = s
                    }
                    return t
                },
                transposeMatrix: function(t) {
                    for (var e = t.length, i = t[0].length, s = new Array(i), n = 0; n < i; n++) {
                        s[n] = new Array(e);
                        for (var a = e - 1; a > -1; a--) s[n][a] = t[a][n]
                    }
                    return s
                },
                rotateMatrix: function(t, e) {
                    if ("string" != typeof e && (e = (e % 360 + 360) % 360), 90 === e || -270 === e || "rotateLeft" === e) t = a.ArrayUtils.transposeMatrix(t), t = t.reverse();
                    else if (-90 === e || 270 === e || "rotateRight" === e) t = t.reverse(), t = a.ArrayUtils.transposeMatrix(t);
                    else if (180 === Math.abs(e) || "rotate180" === e) {
                        for (var i = 0; i < t.length; i++) t[i].reverse();
                        t = t.reverse()
                    }
                    return t
                },
                findClosest: function(t, e) {
                    if (!e.length) return NaN;
                    if (1 === e.length || t < e[0]) return e[0];
                    for (var i = 1; e[i] < t;) i++;
                    var s = e[i - 1],
                        n = i < e.length ? e[i] : Number.POSITIVE_INFINITY;
                    return n - t <= t - s ? n : s
                },
                rotateRight: function(t) {
                    var e = t.pop();
                    return t.unshift(e), e
                },
                rotateLeft: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                rotate: function(t) {
                    var e = t.shift();
                    return t.push(e), e
                },
                numberArray: function(t, e) {
                    for (var i = [], s = t; s <= e; s++) i.push(s);
                    return i
                },
                numberArrayStep: function(t, e, i) {
                    void 0 !== t && null !== t || (t = 0), void 0 !== e && null !== e || (e = t, t = 0), void 0 === i && (i = 1);
                    for (var s = [], n = Math.max(a.Math.roundAwayFromZero((e - t) / (i || 1)), 0), o = 0; o < n; o++) s.push(t), t += i;
                    return s
                }
            }, a.LinkedList = function() {
                this.next = null, this.prev = null, this.first = null, this.last = null, this.total = 0
            }, a.LinkedList.prototype = {
                add: function(t) {
                    return 0 === this.total && null === this.first && null === this.last ? (this.first = t, this.last = t, this.next = t, t.prev = this, this.total++, t) : (this.last.next = t, t.prev = this.last, this.last = t, this.total++, t)
                },
                reset: function() {
                    this.first = null, this.last = null, this.next = null, this.prev = null, this.total = 0
                },
                remove: function(t) {
                    if (1 === this.total) return this.reset(), void(t.next = t.prev = null);
                    t === this.first ? this.first = this.first.next : t === this.last && (this.last = this.last.prev), t.prev && (t.prev.next = t.next), t.next && (t.next.prev = t.prev), t.next = t.prev = null, null === this.first && (this.last = null), this.total--
                },
                callAll: function(t) {
                    if (this.first && this.last) {
                        var e = this.first;
                        do {
                            e && e[t] && e[t].call(e), e = e.next
                        } while (e !== this.last.next)
                    }
                }
            }, a.LinkedList.prototype.constructor = a.LinkedList, a.Create = function(t) {
                this.game = t, this.bmd = null, this.canvas = null, this.ctx = null, this.palettes = [{
                    0: "#000",
                    1: "#9D9D9D",
                    2: "#FFF",
                    3: "#BE2633",
                    4: "#E06F8B",
                    5: "#493C2B",
                    6: "#A46422",
                    7: "#EB8931",
                    8: "#F7E26B",
                    9: "#2F484E",
                    A: "#44891A",
                    B: "#A3CE27",
                    C: "#1B2632",
                    D: "#005784",
                    E: "#31A2F2",
                    F: "#B2DCEF"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#f5f4eb"
                }, {
                    0: "#000",
                    1: "#2234d1",
                    2: "#0c7e45",
                    3: "#44aacc",
                    4: "#8a3622",
                    5: "#5c2e78",
                    6: "#aa5c3d",
                    7: "#b5b5b5",
                    8: "#5e606e",
                    9: "#4c81fb",
                    A: "#6cd947",
                    B: "#7be2f9",
                    C: "#eb8a60",
                    D: "#e23d69",
                    E: "#ffd93f",
                    F: "#fff"
                }, {
                    0: "#000",
                    1: "#fff",
                    2: "#8b4131",
                    3: "#7bbdc5",
                    4: "#8b41ac",
                    5: "#6aac41",
                    6: "#3931a4",
                    7: "#d5de73",
                    8: "#945a20",
                    9: "#5a4100",
                    A: "#bd736a",
                    B: "#525252",
                    C: "#838383",
                    D: "#acee8b",
                    E: "#7b73de",
                    F: "#acacac"
                }, {
                    0: "#000",
                    1: "#191028",
                    2: "#46af45",
                    3: "#a1d685",
                    4: "#453e78",
                    5: "#7664fe",
                    6: "#833129",
                    7: "#9ec2e8",
                    8: "#dc534b",
                    9: "#e18d79",
                    A: "#d6b97b",
                    B: "#e9d8a1",
                    C: "#216c4b",
                    D: "#d365c8",
                    E: "#afaab9",
                    F: "#fff"
                }]
            }, a.Create.PALETTE_ARNE = 0, a.Create.PALETTE_JMP = 1, a.Create.PALETTE_CGA = 2, a.Create.PALETTE_C64 = 3, a.Create.PALETTE_JAPANESE_MACHINE = 4, a.Create.prototype = {
                texture: function(t, e, i, s, n) {
                    void 0 === i && (i = 8), void 0 === s && (s = i), void 0 === n && (n = 0);
                    var a = e[0].length * i,
                        o = e.length * s;
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(a, o), this.bmd.clear();
                    for (var r = 0; r < e.length; r++)
                        for (var h = e[r], l = 0; l < h.length; l++) {
                            var c = h[l];
                            "." !== c && " " !== c && (this.ctx.fillStyle = this.palettes[n][c], this.ctx.fillRect(l * i, r * s, i, s))
                        }
                    return this.bmd.generateTexture(t)
                },
                grid: function(t, e, i, s, n, a) {
                    null === this.bmd && (this.bmd = this.game.make.bitmapData(), this.canvas = this.bmd.canvas, this.ctx = this.bmd.context), this.bmd.resize(e, i), this.ctx.fillStyle = a;
                    for (var o = 0; o < i; o += n) this.ctx.fillRect(0, o, e, 1);
                    for (var r = 0; r < e; r += s) this.ctx.fillRect(r, 0, 1, i);
                    return this.bmd.generateTexture(t)
                }
            }, a.Create.prototype.constructor = a.Create, a.FlexGrid = function(t, e, i) {
                this.game = t.game, this.manager = t, this.width = e, this.height = i, this.boundsCustom = new a.Rectangle(0, 0, e, i), this.boundsFluid = new a.Rectangle(0, 0, e, i), this.boundsFull = new a.Rectangle(0, 0, e, i), this.boundsNone = new a.Rectangle(0, 0, e, i), this.positionCustom = new a.Point(0, 0), this.positionFluid = new a.Point(0, 0), this.positionFull = new a.Point(0, 0), this.positionNone = new a.Point(0, 0), this.scaleCustom = new a.Point(1, 1), this.scaleFluid = new a.Point(1, 1), this.scaleFluidInversed = new a.Point(1, 1), this.scaleFull = new a.Point(1, 1), this.scaleNone = new a.Point(1, 1), this.customWidth = 0, this.customHeight = 0, this.customOffsetX = 0, this.customOffsetY = 0, this.ratioH = e / i, this.ratioV = i / e, this.multiplier = 0, this.layers = []
            }, a.FlexGrid.prototype = {
                setSize: function(t, e) {
                    this.width = t, this.height = e, this.ratioH = t / e, this.ratioV = e / t, this.scaleNone = new a.Point(1, 1), this.boundsNone.width = this.width, this.boundsNone.height = this.height, this.refresh()
                },
                createCustomLayer: function(t, e, i, s) {
                    void 0 === s && (s = !0), this.customWidth = t, this.customHeight = e, this.boundsCustom.width = t, this.boundsCustom.height = e;
                    var n = new a.FlexLayer(this, this.positionCustom, this.boundsCustom, this.scaleCustom);
                    return s && this.game.world.add(n), this.layers.push(n), void 0 !== i && null !== typeof i && n.addMultiple(i), n
                },
                createFluidLayer: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = new a.FlexLayer(this, this.positionFluid, this.boundsFluid, this.scaleFluid);
                    return e && this.game.world.add(i), this.layers.push(i), void 0 !== t && null !== typeof t && i.addMultiple(t), i
                },
                createFullLayer: function(t) {
                    var e = new a.FlexLayer(this, this.positionFull, this.boundsFull, this.scaleFluid);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                createFixedLayer: function(t) {
                    var e = new a.FlexLayer(this, this.positionNone, this.boundsNone, this.scaleNone);
                    return this.game.world.add(e), this.layers.push(e), void 0 !== t && e.addMultiple(t), e
                },
                reset: function() {
                    for (var t = this.layers.length; t--;) this.layers[t].persist || (this.layers[t].position = null, this.layers[t].scale = null, this.layers.slice(t, 1))
                },
                onResize: function(t, e) {
                    this.ratioH = t / e, this.ratioV = e / t, this.refresh(t, e)
                },
                refresh: function() {
                    this.multiplier = Math.min(this.manager.height / this.height, this.manager.width / this.width), this.boundsFluid.width = Math.round(this.width * this.multiplier), this.boundsFluid.height = Math.round(this.height * this.multiplier), this.scaleFluid.set(this.boundsFluid.width / this.width, this.boundsFluid.height / this.height), this.scaleFluidInversed.set(this.width / this.boundsFluid.width, this.height / this.boundsFluid.height), this.scaleFull.set(this.boundsFull.width / this.width, this.boundsFull.height / this.height), this.boundsFull.width = Math.round(this.manager.width * this.scaleFluidInversed.x), this.boundsFull.height = Math.round(this.manager.height * this.scaleFluidInversed.y), this.boundsFluid.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.boundsNone.centerOn(this.manager.bounds.centerX, this.manager.bounds.centerY), this.positionFluid.set(this.boundsFluid.x, this.boundsFluid.y), this.positionNone.set(this.boundsNone.x, this.boundsNone.y)
                },
                fitSprite: function(t) {
                    this.manager.scaleSprite(t), t.x = this.manager.bounds.centerX, t.y = this.manager.bounds.centerY
                },
                debug: function() {
                    this.game.debug.text(this.boundsFluid.width + " x " + this.boundsFluid.height, this.boundsFluid.x + 4, this.boundsFluid.y + 16), this.game.debug.geom(this.boundsFluid, "rgba(255,0,0,0.9", !1)
                }
            }, a.FlexGrid.prototype.constructor = a.FlexGrid, a.FlexLayer = function(t, e, i, s) {
                a.Group.call(this, t.game, null, "__flexLayer" + t.game.rnd.uuid(), !1), this.manager = t.manager, this.grid = t, this.persist = !1, this.position = e, this.bounds = i, this.scale = s, this.topLeft = i.topLeft, this.topMiddle = new a.Point(i.halfWidth, 0), this.topRight = i.topRight, this.bottomLeft = i.bottomLeft, this.bottomMiddle = new a.Point(i.halfWidth, i.bottom), this.bottomRight = i.bottomRight
            }, a.FlexLayer.prototype = Object.create(a.Group.prototype), a.FlexLayer.prototype.constructor = a.FlexLayer, a.FlexLayer.prototype.resize = function() {}, a.FlexLayer.prototype.debug = function() {
                this.game.debug.text(this.bounds.width + " x " + this.bounds.height, this.bounds.x + 4, this.bounds.y + 16), this.game.debug.geom(this.bounds, "rgba(0,0,255,0.9", !1), this.game.debug.geom(this.topLeft, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topMiddle, "rgba(255,255,255,0.9"), this.game.debug.geom(this.topRight, "rgba(255,255,255,0.9")
            }, a.Color = {
                packPixel: function(t, e, i, s) {
                    return a.Device.LITTLE_ENDIAN ? (s << 24 | i << 16 | e << 8 | t) >>> 0 : (t << 24 | e << 16 | i << 8 | s) >>> 0
                },
                unpackPixel: function(t, e, i, s) {
                    return void 0 !== e && null !== e || (e = a.Color.createColor()), void 0 !== i && null !== i || (i = !1), void 0 !== s && null !== s || (s = !1), a.Device.LITTLE_ENDIAN ? (e.a = (4278190080 & t) >>> 24, e.b = (16711680 & t) >>> 16, e.g = (65280 & t) >>> 8, e.r = 255 & t) : (e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t), e.color = t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a / 255 + ")", i && a.Color.RGBtoHSL(e.r, e.g, e.b, e), s && a.Color.RGBtoHSV(e.r, e.g, e.b, e), e
                },
                fromRGBA: function(t, e) {
                    return e || (e = a.Color.createColor()), e.r = (4278190080 & t) >>> 24, e.g = (16711680 & t) >>> 16, e.b = (65280 & t) >>> 8, e.a = 255 & t, e.rgba = "rgba(" + e.r + "," + e.g + "," + e.b + "," + e.a + ")", e
                },
                toRGBA: function(t, e, i, s) {
                    return t << 24 | e << 16 | i << 8 | s
                },
                toABGR: function(t, e, i, s) {
                    return (s << 24 | i << 16 | e << 8 | t) >>> 0
                },
                RGBtoHSL: function(t, e, i, s) {
                    s || (s = a.Color.createColor(t, e, i, 1)), t /= 255, e /= 255, i /= 255;
                    var n = Math.min(t, e, i),
                        o = Math.max(t, e, i);
                    if (s.h = 0, s.s = 0, s.l = (o + n) / 2, o !== n) {
                        var r = o - n;
                        s.s = s.l > .5 ? r / (2 - o - n) : r / (o + n), o === t ? s.h = (e - i) / r + (e < i ? 6 : 0) : o === e ? s.h = (i - t) / r + 2 : o === i && (s.h = (t - e) / r + 4), s.h /= 6
                    }
                    return s
                },
                HSLtoRGB: function(t, e, i, s) {
                    if (s ? (s.r = i, s.g = i, s.b = i) : s = a.Color.createColor(i, i, i), 0 !== e) {
                        var n = i < .5 ? i * (1 + e) : i + e - i * e,
                            o = 2 * i - n;
                        s.r = a.Color.hueToColor(o, n, t + 1 / 3), s.g = a.Color.hueToColor(o, n, t), s.b = a.Color.hueToColor(o, n, t - 1 / 3)
                    }
                    return s.r = Math.floor(255 * s.r | 0), s.g = Math.floor(255 * s.g | 0), s.b = Math.floor(255 * s.b | 0), a.Color.updateColor(s), s
                },
                RGBtoHSV: function(t, e, i, s) {
                    s || (s = a.Color.createColor(t, e, i, 255)), t /= 255, e /= 255, i /= 255;
                    var n = Math.min(t, e, i),
                        o = Math.max(t, e, i),
                        r = o - n;
                    return s.h = 0, s.s = 0 === o ? 0 : r / o, s.v = o, o !== n && (o === t ? s.h = (e - i) / r + (e < i ? 6 : 0) : o === e ? s.h = (i - t) / r + 2 : o === i && (s.h = (t - e) / r + 4), s.h /= 6), s
                },
                HSVtoRGB: function(t, e, i, s) {
                    void 0 === s && (s = a.Color.createColor(0, 0, 0, 1, t, e, 0, i));
                    var n, o, r, h = Math.floor(6 * t),
                        l = 6 * t - h,
                        c = i * (1 - e),
                        u = i * (1 - l * e),
                        d = i * (1 - (1 - l) * e);
                    switch (h % 6) {
                        case 0:
                            n = i, o = d, r = c;
                            break;
                        case 1:
                            n = u, o = i, r = c;
                            break;
                        case 2:
                            n = c, o = i, r = d;
                            break;
                        case 3:
                            n = c, o = u, r = i;
                            break;
                        case 4:
                            n = d, o = c, r = i;
                            break;
                        case 5:
                            n = i, o = c, r = u
                    }
                    return s.r = Math.floor(255 * n), s.g = Math.floor(255 * o), s.b = Math.floor(255 * r), a.Color.updateColor(s), s
                },
                hueToColor: function(t, e, i) {
                    return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < .5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t
                },
                createColor: function(t, e, i, s, n, o, r, h) {
                    var l = {
                        r: t || 0,
                        g: e || 0,
                        b: i || 0,
                        a: s || 1,
                        h: n || 0,
                        s: o || 0,
                        l: r || 0,
                        v: h || 0,
                        color: 0,
                        color32: 0,
                        rgba: ""
                    };
                    return a.Color.updateColor(l)
                },
                updateColor: function(t) {
                    return t.rgba = "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + t.a.toString() + ")", t.color = a.Color.getColor(t.r, t.g, t.b), t.color32 = a.Color.getColor32(255 * t.a, t.r, t.g, t.b), t
                },
                getColor32: function(t, e, i, s) {
                    return t << 24 | e << 16 | i << 8 | s
                },
                getColor: function(t, e, i) {
                    return t << 16 | e << 8 | i
                },
                RGBtoString: function(t, e, i, s, n) {
                    return void 0 === s && (s = 255), void 0 === n && (n = "#"), "#" === n ? "#" + ((1 << 24) + (t << 16) + (e << 8) + i)
                        .toString(16)
                        .slice(1) : "0x" + a.Color.componentToHex(s) + a.Color.componentToHex(t) + a.Color.componentToHex(e) + a.Color.componentToHex(i)
                },
                hexToRGB: function(t) {
                    var e = a.Color.hexToColor(t);
                    if (e) return a.Color.getColor32(e.a, e.r, e.g, e.b)
                },
                hexToColor: function(t, e) {
                    t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, function(t, e, i, s) {
                        return e + e + i + i + s + s
                    });
                    var i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t);
                    if (i) {
                        var s = parseInt(i[1], 16),
                            n = parseInt(i[2], 16),
                            o = parseInt(i[3], 16);
                        e ? (e.r = s, e.g = n, e.b = o) : e = a.Color.createColor(s, n, o)
                    }
                    return e
                },
                webToColor: function(t, e) {
                    e || (e = a.Color.createColor());
                    var i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t);
                    return i && (e.r = parseInt(i[1], 10), e.g = parseInt(i[2], 10), e.b = parseInt(i[3], 10), e.a = void 0 !== i[4] ? parseFloat(i[4]) : 1, a.Color.updateColor(e)), e
                },
                valueToColor: function(t, e) {
                    if (e || (e = a.Color.createColor()), "string" == typeof t) return 0 === t.indexOf("rgb") ? a.Color.webToColor(t, e) : (e.a = 1, a.Color.hexToColor(t, e));
                    if ("number" == typeof t) {
                        var i = a.Color.getRGB(t);
                        return e.r = i.r, e.g = i.g, e.b = i.b, e.a = i.a / 255, e
                    }
                    return e
                },
                componentToHex: function(t) {
                    var e = t.toString(16);
                    return 1 === e.length ? "0" + e : e
                },
                HSVColorWheel: function(t, e) {
                    void 0 === t && (t = 1), void 0 === e && (e = 1);
                    for (var i = [], s = 0; s <= 359; s++) i.push(a.Color.HSVtoRGB(s / 359, t, e));
                    return i
                },
                HSLColorWheel: function(t, e) {
                    void 0 === t && (t = .5), void 0 === e && (e = .5);
                    for (var i = [], s = 0; s <= 359; s++) i.push(a.Color.HSLtoRGB(s / 359, t, e));
                    return i
                },
                interpolateColor: function(t, e, i, s, n) {
                    void 0 === n && (n = 255);
                    var o = a.Color.getRGB(t),
                        r = a.Color.getRGB(e),
                        h = (r.red - o.red) * s / i + o.red,
                        l = (r.green - o.green) * s / i + o.green,
                        c = (r.blue - o.blue) * s / i + o.blue;
                    return a.Color.getColor32(n, h, l, c)
                },
                interpolateColorWithRGB: function(t, e, i, s, n, o) {
                    var r = a.Color.getRGB(t),
                        h = (e - r.red) * o / n + r.red,
                        l = (i - r.green) * o / n + r.green,
                        c = (s - r.blue) * o / n + r.blue;
                    return a.Color.getColor(h, l, c)
                },
                interpolateRGB: function(t, e, i, s, n, o, r, h) {
                    var l = (s - t) * h / r + t,
                        c = (n - e) * h / r + e,
                        u = (o - i) * h / r + i;
                    return a.Color.getColor(l, c, u)
                },
                getRandomColor: function(t, e, i) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 255), void 0 === i && (i = 255), e > 255 || t > e) return a.Color.getColor(255, 255, 255);
                    var s = t + Math.round(Math.random() * (e - t)),
                        n = t + Math.round(Math.random() * (e - t)),
                        o = t + Math.round(Math.random() * (e - t));
                    return a.Color.getColor32(i, s, n, o)
                },
                getRGB: function(t) {
                    return t > 16777215 ? {
                        alpha: t >>> 24,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: t >>> 24,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    } : {
                        alpha: 255,
                        red: t >> 16 & 255,
                        green: t >> 8 & 255,
                        blue: 255 & t,
                        a: 255,
                        r: t >> 16 & 255,
                        g: t >> 8 & 255,
                        b: 255 & t
                    }
                },
                getWebRGB: function(t) {
                    if ("object" == typeof t) return "rgba(" + t.r.toString() + "," + t.g.toString() + "," + t.b.toString() + "," + (t.a / 255)
                        .toString() + ")";
                    var e = a.Color.getRGB(t);
                    return "rgba(" + e.r.toString() + "," + e.g.toString() + "," + e.b.toString() + "," + (e.a / 255)
                        .toString() + ")"
                },
                getAlpha: function(t) {
                    return t >>> 24
                },
                getAlphaFloat: function(t) {
                    return (t >>> 24) / 255
                },
                getRed: function(t) {
                    return t >> 16 & 255
                },
                getGreen: function(t) {
                    return t >> 8 & 255
                },
                getBlue: function(t) {
                    return 255 & t
                },
                blendNormal: function(t) {
                    return t
                },
                blendLighten: function(t, e) {
                    return e > t ? e : t
                },
                blendDarken: function(t, e) {
                    return e > t ? t : e
                },
                blendMultiply: function(t, e) {
                    return t * e / 255
                },
                blendAverage: function(t, e) {
                    return (t + e) / 2
                },
                blendAdd: function(t, e) {
                    return Math.min(255, t + e)
                },
                blendSubtract: function(t, e) {
                    return Math.max(0, t + e - 255)
                },
                blendDifference: function(t, e) {
                    return Math.abs(t - e)
                },
                blendNegation: function(t, e) {
                    return 255 - Math.abs(255 - t - e)
                },
                blendScreen: function(t, e) {
                    return 255 - ((255 - t) * (255 - e) >> 8)
                },
                blendExclusion: function(t, e) {
                    return t + e - 2 * t * e / 255
                },
                blendOverlay: function(t, e) {
                    return e < 128 ? 2 * t * e / 255 : 255 - 2 * (255 - t) * (255 - e) / 255
                },
                blendSoftLight: function(t, e) {
                    return e < 128 ? 2 * (64 + (t >> 1)) * (e / 255) : 255 - 2 * (255 - (64 + (t >> 1))) * (255 - e) / 255
                },
                blendHardLight: function(t, e) {
                    return a.Color.blendOverlay(e, t)
                },
                blendColorDodge: function(t, e) {
                    return 255 === e ? e : Math.min(255, (t << 8) / (255 - e))
                },
                blendColorBurn: function(t, e) {
                    return 0 === e ? e : Math.max(0, 255 - (255 - t << 8) / e)
                },
                blendLinearDodge: function(t, e) {
                    return a.Color.blendAdd(t, e)
                },
                blendLinearBurn: function(t, e) {
                    return a.Color.blendSubtract(t, e)
                },
                blendLinearLight: function(t, e) {
                    return e < 128 ? a.Color.blendLinearBurn(t, 2 * e) : a.Color.blendLinearDodge(t, 2 * (e - 128))
                },
                blendVividLight: function(t, e) {
                    return e < 128 ? a.Color.blendColorBurn(t, 2 * e) : a.Color.blendColorDodge(t, 2 * (e - 128))
                },
                blendPinLight: function(t, e) {
                    return e < 128 ? a.Color.blendDarken(t, 2 * e) : a.Color.blendLighten(t, 2 * (e - 128))
                },
                blendHardMix: function(t, e) {
                    return a.Color.blendVividLight(t, e) < 128 ? 0 : 255
                },
                blendReflect: function(t, e) {
                    return 255 === e ? e : Math.min(255, t * t / (255 - e))
                },
                blendGlow: function(t, e) {
                    return a.Color.blendReflect(e, t)
                },
                blendPhoenix: function(t, e) {
                    return Math.min(t, e) - Math.max(t, e) + 255
                }
            }, a.Physics = function(t, e) {
                e = e || {}, this.game = t, this.config = e, this.arcade = null, this.p2 = null, this.ninja = null, this.box2d = null, this.chipmunk = null, this.matter = null, this.parseConfig()
            }, a.Physics.ARCADE = 0, a.Physics.P2JS = 1, a.Physics.NINJA = 2, a.Physics.BOX2D = 3, a.Physics.CHIPMUNK = 4, a.Physics.MATTERJS = 5, a.Physics.prototype = {
                parseConfig: function() {
                    this.config.hasOwnProperty("arcade") && !0 !== this.config.arcade || !a.Physics.hasOwnProperty("Arcade") || (this.arcade = new a.Physics.Arcade(this.game)), this.config.hasOwnProperty("ninja") && !0 === this.config.ninja && a.Physics.hasOwnProperty("Ninja") && (this.ninja = new a.Physics.Ninja(this.game)), this.config.hasOwnProperty("p2") && !0 === this.config.p2 && a.Physics.hasOwnProperty("P2") && (this.p2 = new a.Physics.P2(this.game, this.config)), this.config.hasOwnProperty("box2d") && !0 === this.config.box2d && a.Physics.hasOwnProperty("BOX2D") && (this.box2d = new a.Physics.BOX2D(this.game, this.config)), this.config.hasOwnProperty("matter") && !0 === this.config.matter && a.Physics.hasOwnProperty("Matter") && (this.matter = new a.Physics.Matter(this.game, this.config))
                },
                startSystem: function(t) {
                    t === a.Physics.ARCADE ? this.arcade = new a.Physics.Arcade(this.game) : t === a.Physics.P2JS ? null === this.p2 ? this.p2 = new a.Physics.P2(this.game, this.config) : this.p2.reset() : t === a.Physics.NINJA ? this.ninja = new a.Physics.Ninja(this.game) : t === a.Physics.BOX2D ? null === this.box2d ? this.box2d = new a.Physics.Box2D(this.game, this.config) : this.box2d.reset() : t === a.Physics.MATTERJS && (null === this.matter ? this.matter = new a.Physics.Matter(this.game, this.config) : this.matter.reset())
                },
                enable: function(t, e, i) {
                    void 0 === e && (e = a.Physics.ARCADE), void 0 === i && (i = !1), e === a.Physics.ARCADE ? this.arcade.enable(t) : e === a.Physics.P2JS && this.p2 ? this.p2.enable(t, i) : e === a.Physics.NINJA && this.ninja ? this.ninja.enableAABB(t) : e === a.Physics.BOX2D && this.box2d ? this.box2d.enable(t) : e === a.Physics.MATTERJS && this.matter && this.matter.enable(t)
                },
                preUpdate: function() {
                    this.p2 && this.p2.preUpdate(), this.box2d && this.box2d.preUpdate(), this.matter && this.matter.preUpdate()
                },
                update: function() {
                    this.p2 && this.p2.update(), this.box2d && this.box2d.update(), this.matter && this.matter.update()
                },
                setBoundsToWorld: function() {
                    this.arcade && this.arcade.setBoundsToWorld(), this.ninja && this.ninja.setBoundsToWorld(), this.p2 && this.p2.setBoundsToWorld(), this.box2d && this.box2d.setBoundsToWorld(), this.matter && this.matter.setBoundsToWorld()
                },
                clear: function() {
                    this.p2 && this.p2.clear(), this.box2d && this.box2d.clear(), this.matter && this.matter.clear()
                },
                reset: function() {
                    this.p2 && this.p2.reset(), this.box2d && this.box2d.reset(), this.matter && this.matter.reset()
                },
                destroy: function() {
                    this.p2 && this.p2.destroy(), this.box2d && this.box2d.destroy(), this.matter && this.matter.destroy(), this.arcade = null, this.ninja = null, this.p2 = null, this.box2d = null, this.matter = null
                }
            }, a.Physics.prototype.constructor = a.Physics, a.Physics.Arcade = function(t) {
                this.game = t, this.gravity = new a.Point, this.bounds = new a.Rectangle(0, 0, t.world.width, t.world.height), this.checkCollision = {
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.maxObjects = 10, this.maxLevels = 4, this.OVERLAP_BIAS = 4, this.forceX = !1, this.sortDirection = a.Physics.Arcade.LEFT_RIGHT, this.skipQuadTree = !0, this.isPaused = !1, this.quadTree = new a.QuadTree(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this._total = 0, this.setBoundsToWorld()
            }, a.Physics.Arcade.prototype.constructor = a.Physics.Arcade, a.Physics.Arcade.SORT_NONE = 0, a.Physics.Arcade.LEFT_RIGHT = 1, a.Physics.Arcade.RIGHT_LEFT = 2, a.Physics.Arcade.TOP_BOTTOM = 3, a.Physics.Arcade.BOTTOM_TOP = 4, a.Physics.Arcade.prototype = {
                setBounds: function(t, e, i, s) {
                    this.bounds.setTo(t, e, i, s)
                },
                setBoundsToWorld: function() {
                    this.bounds.copyFrom(this.game.world.bounds)
                },
                enable: function(t, e) {
                    void 0 === e && (e = !0);
                    var i = 1;
                    if (Array.isArray(t))
                        for (i = t.length; i--;) t[i] instanceof a.Group ? this.enable(t[i].children, e) : (this.enableBody(t[i]), e && t[i].hasOwnProperty("children") && t[i].children.length > 0 && this.enable(t[i], !0));
                    else t instanceof a.Group ? this.enable(t.children, e) : (this.enableBody(t), e && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, !0))
                },
                enableBody: function(t) {
                    t.hasOwnProperty("body") && null === t.body && (t.body = new a.Physics.Arcade.Body(t), t.parent && t.parent instanceof a.Group && t.parent.addToHash(t))
                },
                updateMotion: function(t) {
                    var e = this.computeVelocity(0, t, t.angularVelocity, t.angularAcceleration, t.angularDrag, t.maxAngular) - t.angularVelocity;
                    t.angularVelocity += e, t.rotation += t.angularVelocity * this.game.time.physicsElapsed, t.velocity.x = this.computeVelocity(1, t, t.velocity.x, t.acceleration.x, t.drag.x, t.maxVelocity.x), t.velocity.y = this.computeVelocity(2, t, t.velocity.y, t.acceleration.y, t.drag.y, t.maxVelocity.y)
                },
                computeVelocity: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = 1e4), 1 === t && e.allowGravity ? i += (this.gravity.x + e.gravity.x) * this.game.time.physicsElapsed : 2 === t && e.allowGravity && (i += (this.gravity.y + e.gravity.y) * this.game.time.physicsElapsed), s ? i += s * this.game.time.physicsElapsed : n && (n *= this.game.time.physicsElapsed, i - n > 0 ? i -= n : i + n < 0 ? i += n : i = 0), i > a ? i = a : i < -a && (i = -a), i
                },
                overlap: function(t, e, i, s, n) {
                    if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < e.length; a++) this.collideHandler(t, e[a], i, s, n, !0);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (var a = 0; a < t.length; a++) this.collideHandler(t[a], e, i, s, n, !0);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < t.length; a++)
                            for (var o = 0; o < e.length; o++) this.collideHandler(t[a], e[o], i, s, n, !0);
                    else this.collideHandler(t, e, i, s, n, !0);
                    return this._total > 0
                },
                collide: function(t, e, i, s, n) {
                    if (i = i || null, s = s || null, n = n || i, this._total = 0, !Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < e.length; a++) this.collideHandler(t, e[a], i, s, n, !1);
                    else if (Array.isArray(t) && !Array.isArray(e))
                        for (var a = 0; a < t.length; a++) this.collideHandler(t[a], e, i, s, n, !1);
                    else if (Array.isArray(t) && Array.isArray(e))
                        for (var a = 0; a < t.length; a++)
                            for (var o = 0; o < e.length; o++) this.collideHandler(t[a], e[o], i, s, n, !1);
                    else this.collideHandler(t, e, i, s, n, !1);
                    return this._total > 0
                },
                sortLeftRight: function(t, e) {
                    return t.body && e.body ? t.body.x - e.body.x : 0
                },
                sortRightLeft: function(t, e) {
                    return t.body && e.body ? e.body.x - t.body.x : 0
                },
                sortTopBottom: function(t, e) {
                    return t.body && e.body ? t.body.y - e.body.y : 0
                },
                sortBottomTop: function(t, e) {
                    return t.body && e.body ? e.body.y - t.body.y : 0
                },
                sort: function(t, e) {
                    null !== t.physicsSortDirection ? e = t.physicsSortDirection : void 0 === e && (e = this.sortDirection), e === a.Physics.Arcade.LEFT_RIGHT ? t.hash.sort(this.sortLeftRight) : e === a.Physics.Arcade.RIGHT_LEFT ? t.hash.sort(this.sortRightLeft) : e === a.Physics.Arcade.TOP_BOTTOM ? t.hash.sort(this.sortTopBottom) : e === a.Physics.Arcade.BOTTOM_TOP && t.hash.sort(this.sortBottomTop)
                },
                collideHandler: function(t, e, i, s, n, o) {
                    if (void 0 === e && t.physicsType === a.GROUP) return this.sort(t), void this.collideGroupVsSelf(t, i, s, n, o);
                    t && e && t.exists && e.exists && (this.sortDirection !== a.Physics.Arcade.SORT_NONE && (t.physicsType === a.GROUP && this.sort(t), e.physicsType === a.GROUP && this.sort(e)), t.physicsType === a.SPRITE ? e.physicsType === a.SPRITE ? this.collideSpriteVsSprite(t, e, i, s, n, o) : e.physicsType === a.GROUP ? this.collideSpriteVsGroup(t, e, i, s, n, o) : e.physicsType === a.TILEMAPLAYER && this.collideSpriteVsTilemapLayer(t, e, i, s, n, o) : t.physicsType === a.GROUP ? e.physicsType === a.SPRITE ? this.collideSpriteVsGroup(e, t, i, s, n, o) : e.physicsType === a.GROUP ? this.collideGroupVsGroup(t, e, i, s, n, o) : e.physicsType === a.TILEMAPLAYER && this.collideGroupVsTilemapLayer(t, e, i, s, n, o) : t.physicsType === a.TILEMAPLAYER && (e.physicsType === a.SPRITE ? this.collideSpriteVsTilemapLayer(e, t, i, s, n, o) : e.physicsType === a.GROUP && this.collideGroupVsTilemapLayer(e, t, i, s, n, o)))
                },
                collideSpriteVsSprite: function(t, e, i, s, n, a) {
                    return !(!t.body || !e.body) && (this.separate(t.body, e.body, s, n, a) && (i && i.call(n, t, e), this._total++), !0)
                },
                collideSpriteVsGroup: function(t, e, i, s, n, o) {
                    if (0 !== e.length && t.body)
                        if (this.skipQuadTree || t.body.skipQuadTree)
                            for (var r = {}, h = 0; h < e.hash.length; h++) {
                                var l = e.hash[h];
                                if (l && l.exists && l.body) {
                                    if (r = l.body.getBounds(r), this.sortDirection === a.Physics.Arcade.LEFT_RIGHT) {
                                        if (t.body.right < r.x) break;
                                        if (r.right < t.body.x) continue
                                    } else if (this.sortDirection === a.Physics.Arcade.RIGHT_LEFT) {
                                        if (t.body.x > r.right) break;
                                        if (r.x > t.body.right) continue
                                    } else if (this.sortDirection === a.Physics.Arcade.TOP_BOTTOM) {
                                        if (t.body.bottom < r.y) break;
                                        if (r.bottom < t.body.y) continue
                                    } else if (this.sortDirection === a.Physics.Arcade.BOTTOM_TOP) {
                                        if (t.body.y > r.bottom) break;
                                        if (r.y > t.body.bottom) continue
                                    }
                                    this.collideSpriteVsSprite(t, l, i, s, n, o)
                                }
                            } else {
                                this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(e);
                                for (var c = this.quadTree.retrieve(t), h = 0; h < c.length; h++) this.separate(t.body, c[h], s, n, o) && (i && i.call(n, t, c[h].sprite), this._total++)
                            }
                },
                collideGroupVsSelf: function(t, e, i, s, n) {
                    if (0 !== t.length)
                        for (var o = 0; o < t.hash.length; o++) {
                            var r = {},
                                h = t.hash[o];
                            if (h && h.exists && h.body) {
                                r = h.body.getBounds(r);
                                for (var l = o + 1; l < t.hash.length; l++) {
                                    var c = {},
                                        u = t.hash[l];
                                    if (u && u.exists && u.body) {
                                        if (c = u.body.getBounds(c), this.sortDirection === a.Physics.Arcade.LEFT_RIGHT) {
                                            if (r.right < c.x) break;
                                            if (c.right < r.x) continue
                                        } else if (this.sortDirection === a.Physics.Arcade.RIGHT_LEFT) {
                                            if (r.x > c.right) continue;
                                            if (c.x > r.right) break
                                        } else if (this.sortDirection === a.Physics.Arcade.TOP_BOTTOM) {
                                            if (r.bottom < c.y) continue;
                                            if (c.bottom < r.y) break
                                        } else if (this.sortDirection === a.Physics.Arcade.BOTTOM_TOP) {
                                            if (r.y > c.bottom) continue;
                                            if (c.y > h.body.bottom) break
                                        }
                                        this.collideSpriteVsSprite(h, u, e, i, s, n)
                                    }
                                }
                            }
                        }
                },
                collideGroupVsGroup: function(t, e, i, s, n, o) {
                    if (0 !== t.length && 0 !== e.length)
                        for (var r = 0; r < t.children.length; r++) t.children[r].exists && (t.children[r].physicsType === a.GROUP ? this.collideGroupVsGroup(t.children[r], e, i, s, n, o) : this.collideSpriteVsGroup(t.children[r], e, i, s, n, o))
                },
                separate: function(t, e, i, s, n) {
                    if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1;
                    if (i && !1 === i.call(s, t.sprite, e.sprite)) return !1;
                    if (t.isCircle && e.isCircle) return this.separateCircle(t, e, n);
                    if (t.isCircle !== e.isCircle) {
                        var a = t.isCircle ? e : t,
                            o = t.isCircle ? t : e,
                            r = {
                                x: a.x,
                                y: a.y,
                                right: a.right,
                                bottom: a.bottom
                            },
                            h = {
                                x: o.x + o.radius,
                                y: o.y + o.radius
                            };
                        if ((h.y < r.y || h.y > r.bottom) && (h.x < r.x || h.x > r.right)) return this.separateCircle(t, e, n)
                    }
                    var l = !1,
                        c = !1;
                    this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = this.separateX(t, e, n), this.intersects(t, e) && (c = this.separateY(t, e, n))) : (c = this.separateY(t, e, n), this.intersects(t, e) && (l = this.separateX(t, e, n)));
                    var u = l || c;
                    return u && (n ? (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)) : (t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite))), u
                },
                intersects: function(t, e) {
                    return t !== e && (t.isCircle ? e.isCircle ? a.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y) <= t.radius + e.radius : this.circleBodyIntersects(t, e) : e.isCircle ? this.circleBodyIntersects(e, t) : !(t.right <= e.position.x) && (!(t.bottom <= e.position.y) && (!(t.position.x >= e.right) && !(t.position.y >= e.bottom))))
                },
                circleBodyIntersects: function(t, e) {
                    var i = a.Math.clamp(t.center.x, e.left, e.right),
                        s = a.Math.clamp(t.center.y, e.top, e.bottom);
                    return (t.center.x - i) * (t.center.x - i) + (t.center.y - s) * (t.center.y - s) <= t.radius * t.radius
                },
                separateCircle: function(t, e, i) {
                    this.getOverlapX(t, e), this.getOverlapY(t, e);
                    var s = e.center.x - t.center.x,
                        n = e.center.y - t.center.y,
                        o = Math.atan2(n, s),
                        r = 0;
                    if (t.isCircle !== e.isCircle) {
                        var h = {
                                x: e.isCircle ? t.position.x : e.position.x,
                                y: e.isCircle ? t.position.y : e.position.y,
                                right: e.isCircle ? t.right : e.right,
                                bottom: e.isCircle ? t.bottom : e.bottom
                            },
                            l = {
                                x: t.isCircle ? t.position.x + t.radius : e.position.x + e.radius,
                                y: t.isCircle ? t.position.y + t.radius : e.position.y + e.radius,
                                radius: t.isCircle ? t.radius : e.radius
                            };
                        l.y < h.y ? l.x < h.x ? r = a.Math.distance(l.x, l.y, h.x, h.y) - l.radius : l.x > h.right && (r = a.Math.distance(l.x, l.y, h.right, h.y) - l.radius) : l.y > h.bottom && (l.x < h.x ? r = a.Math.distance(l.x, l.y, h.x, h.bottom) - l.radius : l.x > h.right && (r = a.Math.distance(l.x, l.y, h.right, h.bottom) - l.radius)), r *= -1
                    } else r = t.radius + e.radius - a.Math.distance(t.center.x, t.center.y, e.center.x, e.center.y);
                    if (i || 0 === r || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== r && (t.onOverlap && t.onOverlap.dispatch(t.sprite, e.sprite), e.onOverlap && e.onOverlap.dispatch(e.sprite, t.sprite)), 0 !== r;
                    var c = {
                            x: t.velocity.x * Math.cos(o) + t.velocity.y * Math.sin(o),
                            y: t.velocity.x * Math.sin(o) - t.velocity.y * Math.cos(o)
                        },
                        u = {
                            x: e.velocity.x * Math.cos(o) + e.velocity.y * Math.sin(o),
                            y: e.velocity.x * Math.sin(o) - e.velocity.y * Math.cos(o)
                        },
                        d = ((t.mass - e.mass) * c.x + 2 * e.mass * u.x) / (t.mass + e.mass),
                        p = (2 * t.mass * c.x + (e.mass - t.mass) * u.x) / (t.mass + e.mass);
                    return t.immovable || (t.velocity.x = (d * Math.cos(o) - c.y * Math.sin(o)) * t.bounce.x, t.velocity.y = (c.y * Math.cos(o) + d * Math.sin(o)) * t.bounce.y), e.immovable || (e.velocity.x = (p * Math.cos(o) - u.y * Math.sin(o)) * e.bounce.x, e.velocity.y = (u.y * Math.cos(o) + p * Math.sin(o)) * e.bounce.y), Math.abs(o) < Math.PI / 2 ? t.velocity.x > 0 && !t.immovable && e.velocity.x > t.velocity.x ? t.velocity.x *= -1 : e.velocity.x < 0 && !e.immovable && t.velocity.x < e.velocity.x ? e.velocity.x *= -1 : t.velocity.y > 0 && !t.immovable && e.velocity.y > t.velocity.y ? t.velocity.y *= -1 : e.velocity.y < 0 && !e.immovable && t.velocity.y < e.velocity.y && (e.velocity.y *= -1) : Math.abs(o) > Math.PI / 2 && (t.velocity.x < 0 && !t.immovable && e.velocity.x < t.velocity.x ? t.velocity.x *= -1 : e.velocity.x > 0 && !e.immovable && t.velocity.x > e.velocity.x ? e.velocity.x *= -1 : t.velocity.y < 0 && !t.immovable && e.velocity.y < t.velocity.y ? t.velocity.y *= -1 : e.velocity.y > 0 && !e.immovable && t.velocity.x > e.velocity.y && (e.velocity.y *= -1)), t.immovable || (t.x += t.velocity.x * this.game.time.physicsElapsed - r * Math.cos(o), t.y += t.velocity.y * this.game.time.physicsElapsed - r * Math.sin(o)), e.immovable || (e.x += e.velocity.x * this.game.time.physicsElapsed + r * Math.cos(o), e.y += e.velocity.y * this.game.time.physicsElapsed + r * Math.sin(o)), t.onCollide && t.onCollide.dispatch(t.sprite, e.sprite), e.onCollide && e.onCollide.dispatch(e.sprite, t.sprite), !0
                },
                getOverlapX: function(t, e, i) {
                    var s = 0,
                        n = t.deltaAbsX() + e.deltaAbsX() + this.OVERLAP_BIAS;
                    return 0 === t.deltaX() && 0 === e.deltaX() ? (t.embedded = !0, e.embedded = !0) : t.deltaX() > e.deltaX() ? (s = t.right - e.x, s > n && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? s = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0)) : t.deltaX() < e.deltaX() && (s = t.x - e.width - e.x, -s > n && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? s = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0)), t.overlapX = s, e.overlapX = s, s
                },
                getOverlapY: function(t, e, i) {
                    var s = 0,
                        n = t.deltaAbsY() + e.deltaAbsY() + this.OVERLAP_BIAS;
                    return 0 === t.deltaY() && 0 === e.deltaY() ? (t.embedded = !0, e.embedded = !0) : t.deltaY() > e.deltaY() ? (s = t.bottom - e.y, s > n && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? s = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0)) : t.deltaY() < e.deltaY() && (s = t.y - e.bottom, -s > n && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? s = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0)), t.overlapY = s, e.overlapY = s, s
                },
                separateX: function(t, e, i) {
                    var s = this.getOverlapX(t, e, i);
                    if (i || 0 === s || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return 0 !== s || t.embedded && e.embedded;
                    var n = t.velocity.x,
                        a = e.velocity.x;
                    if (t.immovable || e.immovable) t.immovable ? (e.x += s, e.velocity.x = n - a * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= s, t.velocity.x = a - n * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y));
                    else {
                        s *= .5, t.x -= s, e.x += s;
                        var o = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1),
                            r = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                            h = .5 * (o + r);
                        o -= h, r -= h, t.velocity.x = h + o * t.bounce.x, e.velocity.x = h + r * e.bounce.x
                    }
                    return !0
                },
                separateY: function(t, e, i) {
                    var s = this.getOverlapY(t, e, i);
                    if (i || 0 === s || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return 0 !== s || t.embedded && e.embedded;
                    var n = t.velocity.y,
                        a = e.velocity.y;
                    if (t.immovable || e.immovable) t.immovable ? (e.y += s, e.velocity.y = n - a * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= s, t.velocity.y = a - n * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x));
                    else {
                        s *= .5, t.y -= s, e.y += s;
                        var o = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1),
                            r = Math.sqrt(n * n * t.mass / e.mass) * (n > 0 ? 1 : -1),
                            h = .5 * (o + r);
                        o -= h, r -= h, t.velocity.y = h + o * t.bounce.y, e.velocity.y = h + r * e.bounce.y
                    }
                    return !0
                },
                getObjectsUnderPointer: function(t, e, i, s) {
                    if (0 !== e.length && t.exists) return this.getObjectsAtLocation(t.x, t.y, e, i, s, t)
                },
                getObjectsAtLocation: function(t, e, i, s, n, o) {
                    this.quadTree.clear(), this.quadTree.reset(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, this.maxObjects, this.maxLevels), this.quadTree.populate(i);
                    for (var r = new a.Rectangle(t, e, 1, 1), h = [], l = this.quadTree.retrieve(r), c = 0; c < l.length; c++) l[c].hitTest(t, e) && (s && s.call(n, o, l[c].sprite), h.push(l[c].sprite));
                    return h
                },
                moveToObject: function(t, e, i, s) {
                    void 0 === i && (i = 60), void 0 === s && (s = 0);
                    var n = Math.atan2(e.y - t.y, e.x - t.x);
                    return s > 0 && (i = this.distanceBetween(t, e) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * i, t.body.velocity.y = Math.sin(n) * i, n
                },
                moveToPointer: function(t, e, i, s) {
                    void 0 === e && (e = 60), i = i || this.game.input.activePointer, void 0 === s && (s = 0);
                    var n = this.angleToPointer(t, i);
                    return s > 0 && (e = this.distanceToPointer(t, i) / (s / 1e3)), t.body.velocity.x = Math.cos(n) * e, t.body.velocity.y = Math.sin(n) * e, n
                },
                moveToXY: function(t, e, i, s, n) {
                    void 0 === s && (s = 60), void 0 === n && (n = 0);
                    var a = Math.atan2(i - t.y, e - t.x);
                    return n > 0 && (s = this.distanceToXY(t, e, i) / (n / 1e3)), t.body.velocity.x = Math.cos(a) * s, t.body.velocity.y = Math.sin(a) * s, a
                },
                velocityFromAngle: function(t, e, i) {
                    return void 0 === e && (e = 60), i = i || new a.Point, i.setTo(Math.cos(this.game.math.degToRad(t)) * e, Math.sin(this.game.math.degToRad(t)) * e)
                },
                velocityFromRotation: function(t, e, i) {
                    return void 0 === e && (e = 60), i = i || new a.Point, i.setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerationFromRotation: function(t, e, i) {
                    return void 0 === e && (e = 60), i = i || new a.Point, i.setTo(Math.cos(t) * e, Math.sin(t) * e)
                },
                accelerateToObject: function(t, e, i, s, n) {
                    void 0 === i && (i = 60), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                    var a = this.angleBetween(t, e);
                    return t.body.acceleration.setTo(Math.cos(a) * i, Math.sin(a) * i), t.body.maxVelocity.setTo(s, n), a
                },
                accelerateToPointer: function(t, e, i, s, n) {
                    void 0 === i && (i = 60), void 0 === e && (e = this.game.input.activePointer), void 0 === s && (s = 1e3), void 0 === n && (n = 1e3);
                    var a = this.angleToPointer(t, e);
                    return t.body.acceleration.setTo(Math.cos(a) * i, Math.sin(a) * i), t.body.maxVelocity.setTo(s, n), a
                },
                accelerateToXY: function(t, e, i, s, n, a) {
                    void 0 === s && (s = 60), void 0 === n && (n = 1e3), void 0 === a && (a = 1e3);
                    var o = this.angleToXY(t, e, i);
                    return t.body.acceleration.setTo(Math.cos(o) * s, Math.sin(o) * s), t.body.maxVelocity.setTo(n, a), o
                },
                distanceBetween: function(t, e, i) {
                    void 0 === i && (i = !1);
                    var s = i ? t.world.x - e.world.x : t.x - e.x,
                        n = i ? t.world.y - e.world.y : t.y - e.y;
                    return Math.sqrt(s * s + n * n)
                },
                distanceToXY: function(t, e, i, s) {
                    void 0 === s && (s = !1);
                    var n = s ? t.world.x - e : t.x - e,
                        a = s ? t.world.y - i : t.y - i;
                    return Math.sqrt(n * n + a * a)
                },
                distanceToPointer: function(t, e, i) {
                    void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1);
                    var s = i ? t.world.x - e.worldX : t.x - e.worldX,
                        n = i ? t.world.y - e.worldY : t.y - e.worldY;
                    return Math.sqrt(s * s + n * n)
                },
                angleBetween: function(t, e, i) {
                    return void 0 === i && (i = !1), i ? Math.atan2(e.world.y - t.world.y, e.world.x - t.world.x) : Math.atan2(e.y - t.y, e.x - t.x)
                },
                angleBetweenCenters: function(t, e) {
                    var i = e.centerX - t.centerX,
                        s = e.centerY - t.centerY;
                    return Math.atan2(s, i)
                },
                angleToXY: function(t, e, i, s) {
                    return void 0 === s && (s = !1), s ? Math.atan2(i - t.world.y, e - t.world.x) : Math.atan2(i - t.y, e - t.x)
                },
                angleToPointer: function(t, e, i) {
                    return void 0 === e && (e = this.game.input.activePointer), void 0 === i && (i = !1), i ? Math.atan2(e.worldY - t.world.y, e.worldX - t.world.x) : Math.atan2(e.worldY - t.y, e.worldX - t.x)
                },
                worldAngleToPointer: function(t, e) {
                    return this.angleToPointer(t, e, !0)
                }
            }, a.Physics.Arcade.Body = function(t) {
                this.sprite = t, this.game = t.game, this.type = a.Physics.ARCADE, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a.Point, this.position = new a.Point(t.x, t.y), this.prev = new a.Point(this.position.x, this.position.y), this.allowRotation = !0, this.rotation = t.angle, this.preRotation = t.angle, this.width = t.width, this.height = t.height, this.sourceWidth = t.width, this.sourceHeight = t.height, t.texture && (this.sourceWidth = t.texture.frame.width, this.sourceHeight = t.texture.frame.height), this.halfWidth = Math.abs(t.width / 2), this.halfHeight = Math.abs(t.height / 2), this.center = new a.Point(t.x + this.halfWidth, t.y + this.halfHeight), this.velocity = new a.Point, this.newVelocity = new a.Point, this.deltaMax = new a.Point, this.acceleration = new a.Point, this.drag = new a.Point, this.allowGravity = !0, this.gravity = new a.Point, this.bounce = new a.Point, this.worldBounce = null, this.onWorldBounds = null, this.onCollide = null, this.onOverlap = null, this.maxVelocity = new a.Point(1e4, 1e4), this.friction = new a.Point(1, 0), this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = a.NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
                    none: !1,
                    any: !0,
                    up: !0,
                    down: !0,
                    left: !0,
                    right: !0
                }, this.touching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.wasTouching = {
                    none: !0,
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.blocked = {
                    up: !1,
                    down: !1,
                    left: !1,
                    right: !1
                }, this.tilePadding = new a.Point, this.dirty = !1, this.skipQuadTree = !1, this.syncBounds = !1, this.isMoving = !1, this.stopVelocityOnCollide = !0, this.moveTimer = 0, this.moveDistance = 0, this.moveDuration = 0, this.moveTarget = null, this.moveEnd = null, this.onMoveComplete = new a.Signal, this.movementCallback = null, this.movementCallbackContext = null, this._reset = !0, this._sx = t.scale.x, this._sy = t.scale.y, this._dx = 0, this._dy = 0
            }, a.Physics.Arcade.Body.prototype = {
                updateBounds: function() {
                    if (this.syncBounds) {
                        var t = this.sprite.getBounds();
                        t.ceilAll(), t.width === this.width && t.height === this.height || (this.width = t.width, this.height = t.height, this._reset = !0)
                    } else {
                        var e = Math.abs(this.sprite.scale.x),
                            i = Math.abs(this.sprite.scale.y);
                        e === this._sx && i === this._sy || (this.width = this.sourceWidth * e, this.height = this.sourceHeight * i, this._sx = e, this._sy = i, this._reset = !0)
                    }
                    this._reset && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight))
                },
                preUpdate: function() {
                    this.enable && !this.game.physics.arcade.isPaused && (this.dirty = !0, this.wasTouching.none = this.touching.none, this.wasTouching.up = this.touching.up, this.wasTouching.down = this.touching.down, this.wasTouching.left = this.touching.left, this.wasTouching.right = this.touching.right, this.touching.none = !0, this.touching.up = !1, this.touching.down = !1, this.touching.left = !1, this.touching.right = !1, this.blocked.up = !1, this.blocked.down = !1, this.blocked.left = !1, this.blocked.right = !1, this.embedded = !1, this.updateBounds(), this.position.x = this.sprite.world.x - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = this.sprite.world.y - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.rotation = this.sprite.angle, this.preRotation = this.rotation, (this._reset || this.sprite.fresh) && (this.prev.x = this.position.x, this.prev.y = this.position.y), this.moves && (this.game.physics.arcade.updateMotion(this), this.newVelocity.set(this.velocity.x * this.game.time.physicsElapsed, this.velocity.y * this.game.time.physicsElapsed), this.position.x += this.newVelocity.x, this.position.y += this.newVelocity.y, this.position.x === this.prev.x && this.position.y === this.prev.y || (this.angle = Math.atan2(this.velocity.y, this.velocity.x)), this.speed = Math.sqrt(this.velocity.x * this.velocity.x + this.velocity.y * this.velocity.y), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.onWorldBounds.dispatch(this.sprite, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right)), this._dx = this.deltaX(), this._dy = this.deltaY(), this._reset = !1)
                },
                updateMovement: function() {
                    var t = 0,
                        e = 0 !== this.overlapX || 0 !== this.overlapY;
                    if (this.moveDuration > 0 ? (this.moveTimer += this.game.time.elapsedMS, t = this.moveTimer / this.moveDuration) : (this.moveTarget.end.set(this.position.x, this.position.y), t = this.moveTarget.length / this.moveDistance), this.movementCallback) var i = this.movementCallback.call(this.movementCallbackContext, this, this.velocity, t);
                    return !(e || t >= 1 || void 0 !== i && !0 !== i) || (this.stopMovement(t >= 1 || this.stopVelocityOnCollide && e), !1)
                },
                stopMovement: function(t) {
                    this.isMoving && (this.isMoving = !1, t && this.velocity.set(0), this.onMoveComplete.dispatch(this.sprite, 0 !== this.overlapX || 0 !== this.overlapY))
                },
                postUpdate: function() {
                    this.enable && this.dirty && (this.isMoving && this.updateMovement(), this.dirty = !1, this.deltaX() < 0 ? this.facing = a.LEFT : this.deltaX() > 0 && (this.facing = a.RIGHT), this.deltaY() < 0 ? this.facing = a.UP : this.deltaY() > 0 && (this.facing = a.DOWN), this.moves && (this._dx = this.deltaX(), this._dy = this.deltaY(), 0 !== this.deltaMax.x && 0 !== this._dx && (this._dx < 0 && this._dx < -this.deltaMax.x ? this._dx = -this.deltaMax.x : this._dx > 0 && this._dx > this.deltaMax.x && (this._dx = this.deltaMax.x)), 0 !== this.deltaMax.y && 0 !== this._dy && (this._dy < 0 && this._dy < -this.deltaMax.y ? this._dy = -this.deltaMax.y : this._dy > 0 && this._dy > this.deltaMax.y && (this._dy = this.deltaMax.y)), this.sprite.position.x += this._dx, this.sprite.position.y += this._dy, this._reset = !0), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.allowRotation && (this.sprite.angle += this.deltaZ()), this.prev.x = this.position.x, this.prev.y = this.position.y)
                },
                checkWorldBounds: function() {
                    var t = this.position,
                        e = this.game.physics.arcade.bounds,
                        i = this.game.physics.arcade.checkCollision,
                        s = this.worldBounce ? -this.worldBounce.x : -this.bounce.x,
                        n = this.worldBounce ? -this.worldBounce.y : -this.bounce.y;
                    if (this.isCircle) {
                        var a = {
                            x: this.center.x - this.radius,
                            y: this.center.y - this.radius,
                            right: this.center.x + this.radius,
                            bottom: this.center.y + this.radius
                        };
                        a.x < e.x && i.left ? (t.x = e.x - this.halfWidth + this.radius, this.velocity.x *= s, this.blocked.left = !0) : a.right > e.right && i.right && (t.x = e.right - this.halfWidth - this.radius, this.velocity.x *= s, this.blocked.right = !0), a.y < e.y && i.up ? (t.y = e.y - this.halfHeight + this.radius, this.velocity.y *= n, this.blocked.up = !0) : a.bottom > e.bottom && i.down && (t.y = e.bottom - this.halfHeight - this.radius, this.velocity.y *= n, this.blocked.down = !0)
                    } else t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= s, this.blocked.left = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= s, this.blocked.right = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= n, this.blocked.up = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= n, this.blocked.down = !0);
                    return this.blocked.up || this.blocked.down || this.blocked.left || this.blocked.right
                },
                moveFrom: function(t, e, i) {
                    if (void 0 === e && (e = this.speed), 0 === e) return !1;
                    var s;
                    return void 0 === i ? (s = this.angle, i = this.game.math.radToDeg(s)) : s = this.game.math.degToRad(i), this.moveTimer = 0, this.moveDuration = t, 0 === i || 180 === i ? this.velocity.set(Math.cos(s) * e, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(s) * e) : this.velocity.set(Math.cos(s) * e, Math.sin(s) * e), this.isMoving = !0, !0
                },
                moveTo: function(t, e, i) {
                    var s = e / (t / 1e3);
                    if (0 === s) return !1;
                    var n;
                    return void 0 === i ? (n = this.angle, i = this.game.math.radToDeg(n)) : n = this.game.math.degToRad(i), e = Math.abs(e), this.moveDuration = 0, this.moveDistance = e, null === this.moveTarget && (this.moveTarget = new a.Line, this.moveEnd = new a.Point), this.moveTarget.fromAngle(this.x, this.y, n, e), this.moveEnd.set(this.moveTarget.end.x, this.moveTarget.end.y), this.moveTarget.setTo(this.x, this.y, this.x, this.y), 0 === i || 180 === i ? this.velocity.set(Math.cos(n) * s, 0) : 90 === i || 270 === i ? this.velocity.set(0, Math.sin(n) * s) : this.velocity.set(Math.cos(n) * s, Math.sin(n) * s), this.isMoving = !0, !0
                },
                setSize: function(t, e, i, s) {
                    void 0 === i && (i = this.offset.x), void 0 === s && (s = this.offset.y), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(i, s), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.isCircle = !1, this.radius = 0
                },
                setCircle: function(t, e, i) {
                    void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.setTo(e, i), this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)) : this.isCircle = !1
                },
                reset: function(t, e) {
                    this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this.position.x = t - this.sprite.anchor.x * this.sprite.width + this.sprite.scale.x * this.offset.x, this.position.x -= this.sprite.scale.x < 0 ? this.width : 0, this.position.y = e - this.sprite.anchor.y * this.sprite.height + this.sprite.scale.y * this.offset.y, this.position.y -= this.sprite.scale.y < 0 ? this.height : 0, this.prev.x = this.position.x, this.prev.y = this.position.y, this.rotation = this.sprite.angle, this.preRotation = this.rotation, this._sx = this.sprite.scale.x, this._sy = this.sprite.scale.y, this.center.setTo(this.position.x + this.halfWidth, this.position.y + this.halfHeight)
                },
                getBounds: function(t) {
                    return this.isCircle ? (t.x = this.center.x - this.radius, t.y = this.center.y - this.radius, t.right = this.center.x + this.radius, t.bottom = this.center.y + this.radius) : (t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom), t
                },
                hitTest: function(t, e) {
                    return this.isCircle ? a.Circle.contains(this, t, e) : a.Rectangle.contains(this, t, e)
                },
                onFloor: function() {
                    return this.blocked.down
                },
                onCeiling: function() {
                    return this.blocked.up
                },
                onWall: function() {
                    return this.blocked.left || this.blocked.right
                },
                deltaAbsX: function() {
                    return this.deltaX() > 0 ? this.deltaX() : -this.deltaX()
                },
                deltaAbsY: function() {
                    return this.deltaY() > 0 ? this.deltaY() : -this.deltaY()
                },
                deltaX: function() {
                    return this.position.x - this.prev.x
                },
                deltaY: function() {
                    return this.position.y - this.prev.y
                },
                deltaZ: function() {
                    return this.rotation - this.preRotation
                },
                destroy: function() {
                    this.sprite.parent && this.sprite.parent instanceof a.Group && this.sprite.parent.removeFromHash(this.sprite), this.sprite.body = null, this.sprite = null
                }
            }, Object.defineProperty(a.Physics.Arcade.Body.prototype, "left", {
                get: function() {
                    return this.position.x
                }
            }), Object.defineProperty(a.Physics.Arcade.Body.prototype, "right", {
                get: function() {
                    return this.position.x + this.width
                }
            }), Object.defineProperty(a.Physics.Arcade.Body.prototype, "top", {
                get: function() {
                    return this.position.y
                }
            }), Object.defineProperty(a.Physics.Arcade.Body.prototype, "bottom", {
                get: function() {
                    return this.position.y + this.height
                }
            }), Object.defineProperty(a.Physics.Arcade.Body.prototype, "x", {
                get: function() {
                    return this.position.x
                },
                set: function(t) {
                    this.position.x = t
                }
            }), Object.defineProperty(a.Physics.Arcade.Body.prototype, "y", {
                get: function() {
                    return this.position.y
                },
                set: function(t) {
                    this.position.y = t
                }
            }), a.Physics.Arcade.Body.render = function(t, e, i, s) {
                void 0 === s && (s = !0), i = i || "rgba(0,255,0,0.4)", t.fillStyle = i, t.strokeStyle = i, e.isCircle ? (t.beginPath(), t.arc(e.center.x - e.game.camera.x, e.center.y - e.game.camera.y, e.radius, 0, 2 * Math.PI), s ? t.fill() : t.stroke()) : s ? t.fillRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height) : t.strokeRect(e.position.x - e.game.camera.x, e.position.y - e.game.camera.y, e.width, e.height)
            }, a.Physics.Arcade.Body.renderBodyInfo = function(t, e) {
                t.line("x: " + e.x.toFixed(2), "y: " + e.y.toFixed(2), "width: " + e.width, "height: " + e.height), t.line("velocity x: " + e.velocity.x.toFixed(2), "y: " + e.velocity.y.toFixed(2), "deltaX: " + e._dx.toFixed(2), "deltaY: " + e._dy.toFixed(2)), t.line("acceleration x: " + e.acceleration.x.toFixed(2), "y: " + e.acceleration.y.toFixed(2), "speed: " + e.speed.toFixed(2), "angle: " + e.angle.toFixed(2)), t.line("gravity x: " + e.gravity.x, "y: " + e.gravity.y, "bounce x: " + e.bounce.x.toFixed(2), "y: " + e.bounce.y.toFixed(2)), t.line("touching left: " + e.touching.left, "right: " + e.touching.right, "up: " + e.touching.up, "down: " + e.touching.down), t.line("blocked left: " + e.blocked.left, "right: " + e.blocked.right, "up: " + e.blocked.up, "down: " + e.blocked.down)
            }, a.Physics.Arcade.Body.prototype.constructor = a.Physics.Arcade.Body, a.Physics.Arcade.TilemapCollision = function() {}, a.Physics.Arcade.TilemapCollision.prototype = {
                TILE_BIAS: 16,
                collideSpriteVsTilemapLayer: function(t, e, i, s, n, a) {
                    if (t.body) {
                        var o = e.getTiles(t.body.position.x - t.body.tilePadding.x, t.body.position.y - t.body.tilePadding.y, t.body.width + t.body.tilePadding.x, t.body.height + t.body.tilePadding.y, !1, !1);
                        if (0 !== o.length)
                            for (var r = 0; r < o.length; r++) s ? s.call(n, t, o[r]) && this.separateTile(r, t.body, o[r], e, a) && (this._total++, i && i.call(n, t, o[r])) : this.separateTile(r, t.body, o[r], e, a) && (this._total++, i && i.call(n, t, o[r]))
                    }
                },
                collideGroupVsTilemapLayer: function(t, e, i, s, n, a) {
                    if (0 !== t.length)
                        for (var o = 0; o < t.children.length; o++) t.children[o].exists && this.collideSpriteVsTilemapLayer(t.children[o], e, i, s, n, a)
                },
                separateTile: function(t, e, i, s, n) {
                    if (!e.enable) return !1;
                    var a = s.fixedToCamera ? 0 : s.position.x,
                        o = s.fixedToCamera ? 0 : s.position.y;
                    if (!i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !1;
                    if (n) return !0;
                    if (i.collisionCallback && !i.collisionCallback.call(i.collisionCallbackContext, e.sprite, i)) return !1;
                    if (void 0 !== i.layer.callbacks && i.layer.callbacks[i.index] && !i.layer.callbacks[i.index].callback.call(i.layer.callbacks[i.index].callbackContext, e.sprite, i)) return !1;
                    if (!(i.faceLeft || i.faceRight || i.faceTop || i.faceBottom)) return !1;
                    var r = 0,
                        h = 0,
                        l = 0,
                        c = 1;
                    if (e.deltaAbsX() > e.deltaAbsY() ? l = -1 : e.deltaAbsX() < e.deltaAbsY() && (c = -1), 0 !== e.deltaX() && 0 !== e.deltaY() && (i.faceLeft || i.faceRight) && (i.faceTop || i.faceBottom) && (l = Math.min(Math.abs(e.position.x - a - i.right), Math.abs(e.right - a - i.left)), c = Math.min(Math.abs(e.position.y - o - i.bottom), Math.abs(e.bottom - o - i.top))), l < c) {
                        if ((i.faceLeft || i.faceRight) && 0 !== (r = this.tileCheckX(e, i, s)) && !i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !0;
                        (i.faceTop || i.faceBottom) && (h = this.tileCheckY(e, i, s))
                    } else {
                        if ((i.faceTop || i.faceBottom) && 0 !== (h = this.tileCheckY(e, i, s)) && !i.intersects(e.position.x - a, e.position.y - o, e.right - a, e.bottom - o)) return !0;
                        (i.faceLeft || i.faceRight) && (r = this.tileCheckX(e, i, s))
                    }
                    return 0 !== r || 0 !== h
                },
                tileCheckX: function(t, e, i) {
                    var s = 0,
                        n = i.fixedToCamera ? 0 : i.position.x;
                    return t.deltaX() < 0 && !t.blocked.left && e.collideRight && t.checkCollision.left ? e.faceRight && t.x - n < e.right && (s = t.x - n - e.right) < -this.TILE_BIAS && (s = 0) : t.deltaX() > 0 && !t.blocked.right && e.collideLeft && t.checkCollision.right && e.faceLeft && t.right - n > e.left && (s = t.right - n - e.left) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateX ? t.overlapX = s : this.processTileSeparationX(t, s)), s
                },
                tileCheckY: function(t, e, i) {
                    var s = 0,
                        n = i.fixedToCamera ? 0 : i.position.y;
                    return t.deltaY() < 0 && !t.blocked.up && e.collideDown && t.checkCollision.up ? e.faceBottom && t.y - n < e.bottom && (s = t.y - n - e.bottom) < -this.TILE_BIAS && (s = 0) : t.deltaY() > 0 && !t.blocked.down && e.collideUp && t.checkCollision.down && e.faceTop && t.bottom - n > e.top && (s = t.bottom - n - e.top) > this.TILE_BIAS && (s = 0), 0 !== s && (t.customSeparateY ? t.overlapY = s : this.processTileSeparationY(t, s)), s
                },
                processTileSeparationX: function(t, e) {
                    e < 0 ? t.blocked.left = !0 : e > 0 && (t.blocked.right = !0), t.position.x -= e, 0 === t.bounce.x ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x
                },
                processTileSeparationY: function(t, e) {
                    e < 0 ? t.blocked.up = !0 : e > 0 && (t.blocked.down = !0), t.position.y -= e, 0 === t.bounce.y ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y
                }
            }, a.Utils.mixinPrototype(a.Physics.Arcade.prototype, a.Physics.Arcade.TilemapCollision.prototype), p2.Body.prototype.parent = null, p2.Spring.prototype.parent = null, a.Physics.P2 = function(t, e) {
                this.game = t, void 0 === e ? e = {
                    gravity: [0, 0],
                    broadphase: new p2.SAPBroadphase
                } : (e.hasOwnProperty("gravity") || (e.gravity = [0, 0]), e.hasOwnProperty("broadphase") || (e.broadphase = new p2.SAPBroadphase)), this.config = e, this.world = new p2.World(this.config), this.frameRate = 1 / 60, this.useElapsedTime = !1, this.paused = !1, this.materials = [], this.gravity = new a.Physics.P2.InversePointProxy(this, this.world.gravity), this.walls = {
                    left: null,
                    right: null,
                    top: null,
                    bottom: null
                }, this.onBodyAdded = new a.Signal, this.onBodyRemoved = new a.Signal, this.onSpringAdded = new a.Signal, this.onSpringRemoved = new a.Signal, this.onConstraintAdded = new a.Signal, this.onConstraintRemoved = new a.Signal, this.onContactMaterialAdded = new a.Signal, this.onContactMaterialRemoved = new a.Signal, this.postBroadphaseCallback = null, this.callbackContext = null, this.onBeginContact = new a.Signal, this.onEndContact = new a.Signal, e.hasOwnProperty("mpx") && e.hasOwnProperty("pxm") && e.hasOwnProperty("mpxi") && e.hasOwnProperty("pxmi") && (this.mpx = e.mpx, this.mpxi = e.mpxi, this.pxm = e.pxm, this.pxmi = e.pxmi), this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.collisionGroups = [], this.nothingCollisionGroup = new a.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new a.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new a.Physics.P2.CollisionGroup(2147483648), this.boundsCollidesWith = [], this._toRemove = [], this._collisionGroupID = 2, this._boundsLeft = !0, this._boundsRight = !0, this._boundsTop = !0, this._boundsBottom = !0, this._boundsOwnGroup = !1, this.setBoundsToWorld(!0, !0, !0, !0, !1)
            }, a.Physics.P2.prototype = {
                removeBodyNextStep: function(t) {
                    this._toRemove.push(t)
                },
                preUpdate: function() {
                    for (var t = this._toRemove.length; t--;) this.removeBody(this._toRemove[t]);
                    this._toRemove.length = 0
                },
                enable: function(t, e, i) {
                    void 0 === e && (e = !1), void 0 === i && (i = !0);
                    var s = 1;
                    if (Array.isArray(t))
                        for (s = t.length; s--;) t[s] instanceof a.Group ? this.enable(t[s].children, e, i) : (this.enableBody(t[s], e), i && t[s].hasOwnProperty("children") && t[s].children.length > 0 && this.enable(t[s], e, !0));
                    else t instanceof a.Group ? this.enable(t.children, e, i) : (this.enableBody(t, e), i && t.hasOwnProperty("children") && t.children.length > 0 && this.enable(t.children, e, !0))
                },
                enableBody: function(t, e) {
                    t.hasOwnProperty("body") && null === t.body && (t.body = new a.Physics.P2.Body(this.game, t, t.x, t.y, 1), t.body.debug = e, void 0 !== t.anchor && t.anchor.set(.5))
                },
                setImpactEvents: function(t) {
                    t ? this.world.on("impact", this.impactHandler, this) : this.world.off("impact", this.impactHandler, this)
                },
                setPostBroadphaseCallback: function(t, e) {
                    this.postBroadphaseCallback = t, this.callbackContext = e, null !== t ? this.world.on("postBroadphase", this.postBroadphaseHandler, this) : this.world.off("postBroadphase", this.postBroadphaseHandler, this)
                },
                postBroadphaseHandler: function(t) {
                    if (this.postBroadphaseCallback && 0 !== t.pairs.length)
                        for (var e = t.pairs.length - 2; e >= 0; e -= 2) t.pairs[e].parent && t.pairs[e + 1].parent && !this.postBroadphaseCallback.call(this.callbackContext, t.pairs[e].parent, t.pairs[e + 1].parent) && t.pairs.splice(e, 2)
                },
                impactHandler: function(t) {
                    if (t.bodyA.parent && t.bodyB.parent) {
                        var e = t.bodyA.parent,
                            i = t.bodyB.parent;
                        e._bodyCallbacks[t.bodyB.id] && e._bodyCallbacks[t.bodyB.id].call(e._bodyCallbackContext[t.bodyB.id], e, i, t.shapeA, t.shapeB), i._bodyCallbacks[t.bodyA.id] && i._bodyCallbacks[t.bodyA.id].call(i._bodyCallbackContext[t.bodyA.id], i, e, t.shapeB, t.shapeA), e._groupCallbacks[t.shapeB.collisionGroup] && e._groupCallbacks[t.shapeB.collisionGroup].call(e._groupCallbackContext[t.shapeB.collisionGroup], e, i, t.shapeA, t.shapeB), i._groupCallbacks[t.shapeA.collisionGroup] && i._groupCallbacks[t.shapeA.collisionGroup].call(i._groupCallbackContext[t.shapeA.collisionGroup], i, e, t.shapeB, t.shapeA)
                    }
                },
                beginContactHandler: function(t) {
                    t.bodyA && t.bodyB && (this.onBeginContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyA.parent && t.bodyA.parent.onBeginContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB, t.contactEquations), t.bodyB.parent && t.bodyB.parent.onBeginContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA, t.contactEquations))
                },
                endContactHandler: function(t) {
                    t.bodyA && t.bodyB && (this.onEndContact.dispatch(t.bodyA, t.bodyB, t.shapeA, t.shapeB), t.bodyA.parent && t.bodyA.parent.onEndContact.dispatch(t.bodyB.parent, t.bodyB, t.shapeA, t.shapeB), t.bodyB.parent && t.bodyB.parent.onEndContact.dispatch(t.bodyA.parent, t.bodyA, t.shapeB, t.shapeA))
                },
                setBoundsToWorld: function(t, e, i, s, n) {
                    this.setBounds(this.game.world.bounds.x, this.game.world.bounds.y, this.game.world.bounds.width, this.game.world.bounds.height, t, e, i, s, n)
                },
                setWorldMaterial: function(t, e, i, s, n) {
                    void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === s && (s = !0), void 0 === n && (n = !0), e && this.walls.left && (this.walls.left.shapes[0].material = t), i && this.walls.right && (this.walls.right.shapes[0].material = t), s && this.walls.top && (this.walls.top.shapes[0].material = t), n && this.walls.bottom && (this.walls.bottom.shapes[0].material = t)
                },
                updateBoundsCollisionGroup: function(t) {
                    void 0 === t && (t = !0);
                    var e = t ? this.boundsCollisionGroup.mask : this.everythingCollisionGroup.mask;
                    this.walls.left && (this.walls.left.shapes[0].collisionGroup = e), this.walls.right && (this.walls.right.shapes[0].collisionGroup = e), this.walls.top && (this.walls.top.shapes[0].collisionGroup = e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionGroup = e), this._boundsOwnGroup = t
                },
                setBounds: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === n && (n = this._boundsLeft), void 0 === a && (a = this._boundsRight), void 0 === o && (o = this._boundsTop), void 0 === r && (r = this._boundsBottom), void 0 === h && (h = this._boundsOwnGroup), this.setupWall(n, "left", t, e, 1.5707963267948966, h), this.setupWall(a, "right", t + i, e, -1.5707963267948966, h), this.setupWall(o, "top", t, e, -3.141592653589793, h), this.setupWall(r, "bottom", t, e + s, 0, h), this._boundsLeft = n, this._boundsRight = a, this._boundsTop = o, this._boundsBottom = r, this._boundsOwnGroup = h
                },
                setupWall: function(t, e, i, s, n, a) {
                    t ? (this.walls[e] ? this.walls[e].position = [this.pxmi(i), this.pxmi(s)] : (this.walls[e] = new p2.Body({
                        mass: 0,
                        position: [this.pxmi(i), this.pxmi(s)],
                        angle: n
                    }), this.walls[e].addShape(new p2.Plane), this.world.addBody(this.walls[e])), a && (this.walls[e].shapes[0].collisionGroup = this.boundsCollisionGroup.mask)) : this.walls[e] && (this.world.removeBody(this.walls[e]), this.walls[e] = null)
                },
                pause: function() {
                    this.paused = !0
                },
                resume: function() {
                    this.paused = !1
                },
                update: function() {
                    this.paused || (this.useElapsedTime ? this.world.step(this.game.time.physicsElapsed) : this.world.step(this.frameRate))
                },
                reset: function() {
                    this.world.on("beginContact", this.beginContactHandler, this), this.world.on("endContact", this.endContactHandler, this), this.nothingCollisionGroup = new a.Physics.P2.CollisionGroup(1), this.boundsCollisionGroup = new a.Physics.P2.CollisionGroup(2), this.everythingCollisionGroup = new a.Physics.P2.CollisionGroup(2147483648), this._collisionGroupID = 2, this.setBoundsToWorld(!0, !0, !0, !0, !1)
                },
                clear: function() {
                    this.world.time = 0, this.world.fixedStepTime = 0, this.world.solver && this.world.solver.equations.length && this.world.solver.removeAllEquations();
                    for (var t = this.world.constraints, e = t.length - 1; e >= 0; e--) this.world.removeConstraint(t[e]);
                    for (var i = this.world.bodies, e = i.length - 1; e >= 0; e--) this.world.removeBody(i[e]);
                    for (var s = this.world.springs, e = s.length - 1; e >= 0; e--) this.world.removeSpring(s[e]);
                    for (var n = this.world.contactMaterials, e = n.length - 1; e >= 0; e--) this.world.removeContactMaterial(n[e]);
                    this.world.off("beginContact", this.beginContactHandler, this), this.world.off("endContact", this.endContactHandler, this), this.postBroadphaseCallback = null, this.callbackContext = null, this.impactCallback = null, this.collisionGroups = [], this._toRemove = [], this.boundsCollidesWith = [], this.walls = {
                        left: null,
                        right: null,
                        top: null,
                        bottom: null
                    }
                },
                destroy: function() {
                    this.clear(), this.game = null
                },
                addBody: function(t) {
                    return !t.data.world && (this.world.addBody(t.data), this.onBodyAdded.dispatch(t), !0)
                },
                removeBody: function(t) {
                    return t.data.world === this.world && (this.world.removeBody(t.data), this.onBodyRemoved.dispatch(t)), t
                },
                addSpring: function(t) {
                    return t instanceof a.Physics.P2.Spring || t instanceof a.Physics.P2.RotationalSpring ? this.world.addSpring(t.data) : this.world.addSpring(t), this.onSpringAdded.dispatch(t), t
                },
                removeSpring: function(t) {
                    return t instanceof a.Physics.P2.Spring || t instanceof a.Physics.P2.RotationalSpring ? this.world.removeSpring(t.data) : this.world.removeSpring(t), this.onSpringRemoved.dispatch(t), t
                },
                createDistanceConstraint: function(t, e, i, s, n, o) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new a.Physics.P2.DistanceConstraint(this, t, e, i, s, n, o))
                },
                createGearConstraint: function(t, e, i, s) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new a.Physics.P2.GearConstraint(this, t, e, i, s))
                },
                createRevoluteConstraint: function(t, e, i, s, n, o) {
                    if (t = this.getBody(t), i = this.getBody(i), t && i) return this.addConstraint(new a.Physics.P2.RevoluteConstraint(this, t, e, i, s, n, o))
                },
                createLockConstraint: function(t, e, i, s, n) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new a.Physics.P2.LockConstraint(this, t, e, i, s, n))
                },
                createPrismaticConstraint: function(t, e, i, s, n, o, r) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addConstraint(new a.Physics.P2.PrismaticConstraint(this, t, e, i, s, n, o, r))
                },
                addConstraint: function(t) {
                    return this.world.addConstraint(t), this.onConstraintAdded.dispatch(t), t
                },
                removeConstraint: function(t) {
                    return this.world.removeConstraint(t), this.onConstraintRemoved.dispatch(t), t
                },
                addContactMaterial: function(t) {
                    return this.world.addContactMaterial(t), this.onContactMaterialAdded.dispatch(t), t
                },
                removeContactMaterial: function(t) {
                    return this.world.removeContactMaterial(t), this.onContactMaterialRemoved.dispatch(t), t
                },
                getContactMaterial: function(t, e) {
                    return this.world.getContactMaterial(t, e)
                },
                setMaterial: function(t, e) {
                    for (var i = e.length; i--;) e[i].setMaterial(t)
                },
                createMaterial: function(t, e) {
                    t = t || "";
                    var i = new a.Physics.P2.Material(t);
                    return this.materials.push(i), void 0 !== e && e.setMaterial(i), i
                },
                createContactMaterial: function(t, e, i) {
                    void 0 === t && (t = this.createMaterial()), void 0 === e && (e = this.createMaterial());
                    var s = new a.Physics.P2.ContactMaterial(t, e, i);
                    return this.addContactMaterial(s)
                },
                getBodies: function() {
                    for (var t = [], e = this.world.bodies.length; e--;) t.push(this.world.bodies[e].parent);
                    return t
                },
                getBody: function(t) {
                    return t instanceof p2.Body ? t : t instanceof a.Physics.P2.Body ? t.data : t.body && t.body.type === a.Physics.P2JS ? t.body.data : null
                },
                getSprings: function() {
                    for (var t = [], e = this.world.springs.length; e--;) t.push(this.world.springs[e].parent);
                    return t
                },
                getConstraints: function() {
                    for (var t = [], e = this.world.constraints.length; e--;) t.push(this.world.constraints[e]);
                    return t
                },
                hitTest: function(t, e, i, s) {
                    void 0 === e && (e = this.world.bodies), void 0 === i && (i = 5), void 0 === s && (s = !1);
                    for (var n = [this.pxmi(t.x), this.pxmi(t.y)], o = [], r = e.length; r--;) e[r] instanceof a.Physics.P2.Body && (!s || e[r].data.type !== p2.Body.STATIC) ? o.push(e[r].data) : e[r] instanceof p2.Body && e[r].parent && (!s || e[r].type !== p2.Body.STATIC) ? o.push(e[r]) : e[r] instanceof a.Sprite && e[r].hasOwnProperty("body") && (!s || e[r].body.data.type !== p2.Body.STATIC) && o.push(e[r].body.data);
                    return this.world.hitTest(n, o, i)
                },
                toJSON: function() {
                    return this.world.toJSON()
                },
                createCollisionGroup: function(t) {
                    var e = Math.pow(2, this._collisionGroupID);
                    this.walls.left && (this.walls.left.shapes[0].collisionMask = this.walls.left.shapes[0].collisionMask | e), this.walls.right && (this.walls.right.shapes[0].collisionMask = this.walls.right.shapes[0].collisionMask | e), this.walls.top && (this.walls.top.shapes[0].collisionMask = this.walls.top.shapes[0].collisionMask | e), this.walls.bottom && (this.walls.bottom.shapes[0].collisionMask = this.walls.bottom.shapes[0].collisionMask | e), this._collisionGroupID++;
                    var i = new a.Physics.P2.CollisionGroup(e);
                    return this.collisionGroups.push(i), t && this.setCollisionGroup(t, i), i
                },
                setCollisionGroup: function(t, e) {
                    if (t instanceof a.Group)
                        for (var i = 0; i < t.total; i++) t.children[i].body && t.children[i].body.type === a.Physics.P2JS && t.children[i].body.setCollisionGroup(e);
                    else t.body.setCollisionGroup(e)
                },
                createSpring: function(t, e, i, s, n, o, r, h, l) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new a.Physics.P2.Spring(this, t, e, i, s, n, o, r, h, l))
                },
                createRotationalSpring: function(t, e, i, s, n) {
                    if (t = this.getBody(t), e = this.getBody(e), t && e) return this.addSpring(new a.Physics.P2.RotationalSpring(this, t, e, i, s, n))
                },
                createBody: function(t, e, i, s, n, o) {
                    void 0 === s && (s = !1);
                    var r = new a.Physics.P2.Body(this.game, null, t, e, i);
                    if (o) {
                        if (!r.addPolygon(n, o)) return !1
                    }
                    return s && this.world.addBody(r.data), r
                },
                createParticle: function(t, e, i, s, n, o) {
                    void 0 === s && (s = !1);
                    var r = new a.Physics.P2.Body(this.game, null, t, e, i);
                    if (o) {
                        if (!r.addPolygon(n, o)) return !1
                    }
                    return s && this.world.addBody(r.data), r
                },
                convertCollisionObjects: function(t, e, i) {
                    void 0 === i && (i = !0);
                    for (var s = [], n = 0, a = t.collision[e].length; n < a; n++) {
                        var o = t.collision[e][n],
                            r = this.createBody(o.x, o.y, 0, i, {}, o.polyline);
                        r && s.push(r)
                    }
                    return s
                },
                clearTilemapLayerBodies: function(t, e) {
                    e = t.getLayer(e);
                    for (var i = t.layers[e].bodies.length; i--;) t.layers[e].bodies[i].destroy();
                    t.layers[e].bodies.length = 0
                },
                convertTilemap: function(t, e, i, s) {
                    e = t.getLayer(e), void 0 === i && (i = !0), void 0 === s && (s = !0), this.clearTilemapLayerBodies(t, e);
                    for (var n = 0, a = 0, o = 0, r = 0, h = t.layers[e].height; r < h; r++) {
                        n = 0;
                        for (var l = 0, c = t.layers[e].width; l < c; l++) {
                            var u = t.layers[e].data[r][l];
                            if (u && u.index > -1 && u.collides)
                                if (s) {
                                    var d = t.getTileRight(e, l, r);
                                    if (0 === n && (a = u.x * u.width, o = u.y * u.height, n = u.width), d && d.collides) n += u.width;
                                    else {
                                        var p = this.createBody(a, o, 0, !1);
                                        p.addRectangle(n, u.height, n / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p), n = 0
                                    }
                                } else {
                                    var p = this.createBody(u.x * u.width, u.y * u.height, 0, !1);
                                    p.addRectangle(u.width, u.height, u.width / 2, u.height / 2, 0), i && this.addBody(p), t.layers[e].bodies.push(p)
                                }
                        }
                    }
                    return t.layers[e].bodies
                },
                mpx: function(t) {
                    return t *= 20
                },
                pxm: function(t) {
                    return .05 * t
                },
                mpxi: function(t) {
                    return t *= -20
                },
                pxmi: function(t) {
                    return -.05 * t
                }
            }, Object.defineProperty(a.Physics.P2.prototype, "friction", {
                get: function() {
                    return this.world.defaultContactMaterial.friction
                },
                set: function(t) {
                    this.world.defaultContactMaterial.friction = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "restitution", {
                get: function() {
                    return this.world.defaultContactMaterial.restitution
                },
                set: function(t) {
                    this.world.defaultContactMaterial.restitution = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "contactMaterial", {
                get: function() {
                    return this.world.defaultContactMaterial
                },
                set: function(t) {
                    this.world.defaultContactMaterial = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "applySpringForces", {
                get: function() {
                    return this.world.applySpringForces
                },
                set: function(t) {
                    this.world.applySpringForces = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "applyDamping", {
                get: function() {
                    return this.world.applyDamping
                },
                set: function(t) {
                    this.world.applyDamping = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "applyGravity", {
                get: function() {
                    return this.world.applyGravity
                },
                set: function(t) {
                    this.world.applyGravity = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "solveConstraints", {
                get: function() {
                    return this.world.solveConstraints
                },
                set: function(t) {
                    this.world.solveConstraints = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "time", {
                get: function() {
                    return this.world.time
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "emitImpactEvent", {
                get: function() {
                    return this.world.emitImpactEvent
                },
                set: function(t) {
                    this.world.emitImpactEvent = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "sleepMode", {
                get: function() {
                    return this.world.sleepMode
                },
                set: function(t) {
                    this.world.sleepMode = t
                }
            }), Object.defineProperty(a.Physics.P2.prototype, "total", {
                get: function() {
                    return this.world.bodies.length
                }
            }), a.Physics.P2.FixtureList = function(t) {
                Array.isArray(t) || (t = [t]), this.rawList = t, this.init(), this.parse(this.rawList)
            }, a.Physics.P2.FixtureList.prototype = {
                init: function() {
                    this.namedFixtures = {}, this.groupedFixtures = [], this.allFixtures = []
                },
                setCategory: function(t, e) {
                    var i = function(e) {
                        e.collisionGroup = t
                    };
                    this.getFixtures(e)
                        .forEach(i)
                },
                setMask: function(t, e) {
                    var i = function(e) {
                        e.collisionMask = t
                    };
                    this.getFixtures(e)
                        .forEach(i)
                },
                setSensor: function(t, e) {
                    var i = function(e) {
                        e.sensor = t
                    };
                    this.getFixtures(e)
                        .forEach(i)
                },
                setMaterial: function(t, e) {
                    var i = function(e) {
                        e.material = t
                    };
                    this.getFixtures(e)
                        .forEach(i)
                },
                getFixtures: function(t) {
                    var e = [];
                    if (t) {
                        t instanceof Array || (t = [t]);
                        var i = this;
                        return t.forEach(function(t) {
                            i.namedFixtures[t] && e.push(i.namedFixtures[t])
                        }), this.flatten(e)
                    }
                    return this.allFixtures
                },
                getFixtureByKey: function(t) {
                    return this.namedFixtures[t]
                },
                getGroup: function(t) {
                    return this.groupedFixtures[t]
                },
                parse: function() {
                    var t, e, i, s;
                    i = this.rawList, s = [];
                    for (t in i) e = i[t], isNaN(t - 0) ? this.namedFixtures[t] = this.flatten(e) : (this.groupedFixtures[t] = this.groupedFixtures[t] || [], this.groupedFixtures[t] = this.groupedFixtures[t].concat(e)), s.push(this.allFixtures = this.flatten(this.groupedFixtures))
                },
                flatten: function(t) {
                    var e, i;
                    return e = [], i = arguments.callee, t.forEach(function(t) {
                        return Array.prototype.push.apply(e, Array.isArray(t) ? i(t) : [t])
                    }), e
                }
            }, a.Physics.P2.PointProxy = function(t, e) {
                this.world = t, this.destination = e
            }, a.Physics.P2.PointProxy.prototype.constructor = a.Physics.P2.PointProxy, Object.defineProperty(a.Physics.P2.PointProxy.prototype, "x", {
                get: function() {
                    return this.world.mpx(this.destination[0])
                },
                set: function(t) {
                    this.destination[0] = this.world.pxm(t)
                }
            }), Object.defineProperty(a.Physics.P2.PointProxy.prototype, "y", {
                get: function() {
                    return this.world.mpx(this.destination[1])
                },
                set: function(t) {
                    this.destination[1] = this.world.pxm(t)
                }
            }), Object.defineProperty(a.Physics.P2.PointProxy.prototype, "mx", {
                get: function() {
                    return this.destination[0]
                },
                set: function(t) {
                    this.destination[0] = t
                }
            }), Object.defineProperty(a.Physics.P2.PointProxy.prototype, "my", {
                get: function() {
                    return this.destination[1]
                },
                set: function(t) {
                    this.destination[1] = t
                }
            }), a.Physics.P2.InversePointProxy = function(t, e) {
                this.world = t, this.destination = e
            }, a.Physics.P2.InversePointProxy.prototype.constructor = a.Physics.P2.InversePointProxy, Object.defineProperty(a.Physics.P2.InversePointProxy.prototype, "x", {
                get: function() {
                    return this.world.mpxi(this.destination[0])
                },
                set: function(t) {
                    this.destination[0] = this.world.pxmi(t)
                }
            }), Object.defineProperty(a.Physics.P2.InversePointProxy.prototype, "y", {
                get: function() {
                    return this.world.mpxi(this.destination[1])
                },
                set: function(t) {
                    this.destination[1] = this.world.pxmi(t)
                }
            }), Object.defineProperty(a.Physics.P2.InversePointProxy.prototype, "mx", {
                get: function() {
                    return this.destination[0]
                },
                set: function(t) {
                    this.destination[0] = -t
                }
            }), Object.defineProperty(a.Physics.P2.InversePointProxy.prototype, "my", {
                get: function() {
                    return this.destination[1]
                },
                set: function(t) {
                    this.destination[1] = -t
                }
            }), a.Physics.P2.Body = function(t, e, i, s, n) {
                e = e || null, i = i || 0, s = s || 0, void 0 === n && (n = 1), this.game = t, this.world = t.physics.p2, this.sprite = e, this.type = a.Physics.P2JS, this.offset = new a.Point, this.data = new p2.Body({
                    position: [this.world.pxmi(i), this.world.pxmi(s)],
                    mass: n
                }), this.data.parent = this, this.velocity = new a.Physics.P2.InversePointProxy(this.world, this.data.velocity), this.force = new a.Physics.P2.InversePointProxy(this.world, this.data.force), this.gravity = new a.Point, this.onBeginContact = new a.Signal, this.onEndContact = new a.Signal, this.collidesWith = [], this.removeNextStep = !1, this.debugBody = null, this.dirty = !1, this._collideWorldBounds = !0, this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this._reset = !1, e && (this.setRectangleFromSprite(e), e.exists && this.game.physics.p2.addBody(this))
            }, a.Physics.P2.Body.prototype = {
                createBodyCallback: function(t, e, i) {
                    var s = -1;
                    t.id ? s = t.id : t.body && (s = t.body.id), s > -1 && (null === e ? (delete this._bodyCallbacks[s], delete this._bodyCallbackContext[s]) : (this._bodyCallbacks[s] = e, this._bodyCallbackContext[s] = i))
                },
                createGroupCallback: function(t, e, i) {
                    null === e ? (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]) : (this._groupCallbacks[t.mask] = e, this._groupCallbackContext[t.mask] = i)
                },
                getCollisionMask: function() {
                    var t = 0;
                    this._collideWorldBounds && (t = this.game.physics.p2.boundsCollisionGroup.mask);
                    for (var e = 0; e < this.collidesWith.length; e++) t |= this.collidesWith[e].mask;
                    return t
                },
                updateCollisionMask: function(t) {
                    var e = this.getCollisionMask();
                    if (void 0 === t)
                        for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].collisionMask = e;
                    else t.collisionMask = e
                },
                setCollisionGroup: function(t, e) {
                    var i = this.getCollisionMask();
                    if (void 0 === e)
                        for (var s = this.data.shapes.length - 1; s >= 0; s--) this.data.shapes[s].collisionGroup = t.mask, this.data.shapes[s].collisionMask = i;
                    else e.collisionGroup = t.mask, e.collisionMask = i
                },
                clearCollision: function(t, e, i) {
                    if (void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i)
                        for (var s = this.data.shapes.length - 1; s >= 0; s--) t && (this.data.shapes[s].collisionGroup = null), e && (this.data.shapes[s].collisionMask = null);
                    else t && (i.collisionGroup = null), e && (i.collisionMask = null);
                    t && (this.collidesWith.length = 0)
                },
                removeCollisionGroup: function(t, e, i) {
                    void 0 === e && (e = !0);
                    var s;
                    if (Array.isArray(t))
                        for (var n = 0; n < t.length; n++)(s = this.collidesWith.indexOf(t[n])) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                    else(s = this.collidesWith.indexOf(t)) > -1 && (this.collidesWith.splice(s, 1), e && (delete this._groupCallbacks[t.mask], delete this._groupCallbackContext[t.mask]));
                    var a = this.getCollisionMask();
                    if (void 0 === i)
                        for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionMask = a;
                    else i.collisionMask = a
                },
                collides: function(t, e, i, s) {
                    if (Array.isArray(t))
                        for (var n = 0; n < t.length; n++) - 1 === this.collidesWith.indexOf(t[n]) && (this.collidesWith.push(t[n]), e && this.createGroupCallback(t[n], e, i));
                    else -1 === this.collidesWith.indexOf(t) && (this.collidesWith.push(t), e && this.createGroupCallback(t, e, i));
                    var a = this.getCollisionMask();
                    if (void 0 === s)
                        for (var n = this.data.shapes.length - 1; n >= 0; n--) this.data.shapes[n].collisionMask = a;
                    else s.collisionMask = a
                },
                adjustCenterOfMass: function() {
                    this.data.adjustCenterOfMass(), this.shapeChanged()
                },
                getVelocityAtPoint: function(t, e) {
                    return this.data.getVelocityAtPoint(t, e)
                },
                applyDamping: function(t) {
                    this.data.applyDamping(t)
                },
                applyImpulse: function(t, e, i) {
                    this.data.applyImpulse(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                applyImpulseLocal: function(t, e, i) {
                    this.data.applyImpulseLocal(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                applyForce: function(t, e, i) {
                    this.data.applyForce(t, [this.world.pxmi(e), this.world.pxmi(i)])
                },
                setZeroForce: function() {
                    this.data.setZeroForce()
                },
                setZeroRotation: function() {
                    this.data.angularVelocity = 0
                },
                setZeroVelocity: function() {
                    this.data.velocity[0] = 0, this.data.velocity[1] = 0
                },
                setZeroDamping: function() {
                    this.data.damping = 0, this.data.angularDamping = 0
                },
                toLocalFrame: function(t, e) {
                    return this.data.toLocalFrame(t, e)
                },
                toWorldFrame: function(t, e) {
                    return this.data.toWorldFrame(t, e)
                },
                rotateLeft: function(t) {
                    this.data.angularVelocity = this.world.pxm(-t)
                },
                rotateRight: function(t) {
                    this.data.angularVelocity = this.world.pxm(t)
                },
                moveForward: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle + Math.PI / 2;
                    this.data.velocity[0] = e * Math.cos(i), this.data.velocity[1] = e * Math.sin(i)
                },
                moveBackward: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle + Math.PI / 2;
                    this.data.velocity[0] = -e * Math.cos(i), this.data.velocity[1] = -e * Math.sin(i)
                },
                thrust: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle + Math.PI / 2;
                    this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
                },
                thrustLeft: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle;
                    this.data.force[0] += e * Math.cos(i), this.data.force[1] += e * Math.sin(i)
                },
                thrustRight: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle;
                    this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
                },
                reverse: function(t) {
                    var e = this.world.pxmi(-t),
                        i = this.data.angle + Math.PI / 2;
                    this.data.force[0] -= e * Math.cos(i), this.data.force[1] -= e * Math.sin(i)
                },
                moveLeft: function(t) {
                    this.data.velocity[0] = this.world.pxmi(-t)
                },
                moveRight: function(t) {
                    this.data.velocity[0] = this.world.pxmi(t)
                },
                moveUp: function(t) {
                    this.data.velocity[1] = this.world.pxmi(-t)
                },
                moveDown: function(t) {
                    this.data.velocity[1] = this.world.pxmi(t)
                },
                preUpdate: function() {
                    this.dirty = !0, this.removeNextStep && (this.removeFromWorld(), this.removeNextStep = !1)
                },
                postUpdate: function() {
                    this.sprite.x = this.world.mpxi(this.data.position[0]) + this.offset.x, this.sprite.y = this.world.mpxi(this.data.position[1]) + this.offset.y, this.fixedRotation || (this.sprite.rotation = this.data.angle), this.debugBody && this.debugBody.updateSpriteTransform(), this.dirty = !1
                },
                reset: function(t, e, i, s) {
                    void 0 === i && (i = !1), void 0 === s && (s = !1), this.setZeroForce(), this.setZeroVelocity(), this.setZeroRotation(), i && this.setZeroDamping(), s && (this.mass = 1), this.x = t, this.y = e
                },
                addToWorld: function() {
                    if (this.game.physics.p2._toRemove)
                        for (var t = 0; t < this.game.physics.p2._toRemove.length; t++) this.game.physics.p2._toRemove[t] === this && this.game.physics.p2._toRemove.splice(t, 1);
                    this.data.world !== this.game.physics.p2.world && this.game.physics.p2.addBody(this)
                },
                removeFromWorld: function() {
                    this.data.world === this.game.physics.p2.world && this.game.physics.p2.removeBodyNextStep(this)
                },
                destroy: function() {
                    this.removeFromWorld(), this.clearShapes(), this._bodyCallbacks = {}, this._bodyCallbackContext = {}, this._groupCallbacks = {}, this._groupCallbackContext = {}, this.debugBody && this.debugBody.destroy(!0, !0), this.debugBody = null, this.sprite && (this.sprite.body = null, this.sprite = null)
                },
                clearShapes: function() {
                    for (var t = this.data.shapes.length; t--;) this.data.removeShape(this.data.shapes[t]);
                    this.shapeChanged()
                },
                addShape: function(t, e, i, s) {
                    return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = 0), this.data.addShape(t, [this.world.pxmi(e), this.world.pxmi(i)], s), this.shapeChanged(), t
                },
                addCircle: function(t, e, i, s) {
                    var n = new p2.Circle({
                        radius: this.world.pxm(t)
                    });
                    return this.addShape(n, e, i, s)
                },
                addRectangle: function(t, e, i, s, n) {
                    var a = new p2.Box({
                        width: this.world.pxm(t),
                        height: this.world.pxm(e)
                    });
                    return this.addShape(a, i, s, n)
                },
                addPlane: function(t, e, i) {
                    var s = new p2.Plane;
                    return this.addShape(s, t, e, i)
                },
                addParticle: function(t, e, i) {
                    var s = new p2.Particle;
                    return this.addShape(s, t, e, i)
                },
                addLine: function(t, e, i, s) {
                    var n = new p2.Line({
                        length: this.world.pxm(t)
                    });
                    return this.addShape(n, e, i, s)
                },
                addCapsule: function(t, e, i, s, n) {
                    var a = new p2.Capsule({
                        length: this.world.pxm(t),
                        radius: this.world.pxm(e)
                    });
                    return this.addShape(a, i, s, n)
                },
                addPolygon: function(t, e) {
                    t = t || {}, Array.isArray(e) || (e = Array.prototype.slice.call(arguments, 1));
                    var i = [];
                    if (1 === e.length && Array.isArray(e[0])) i = e[0].slice(0);
                    else if (Array.isArray(e[0])) i = e.slice();
                    else if ("number" == typeof e[0])
                        for (var s = 0, n = e.length; s < n; s += 2) i.push([e[s], e[s + 1]]);
                    var a = i.length - 1;
                    i[a][0] === i[0][0] && i[a][1] === i[0][1] && i.pop();
                    for (var o = 0; o < i.length; o++) i[o][0] = this.world.pxmi(i[o][0]), i[o][1] = this.world.pxmi(i[o][1]);
                    var r = this.data.fromPolygon(i, t);
                    return this.shapeChanged(), r
                },
                removeShape: function(t) {
                    var e = this.data.removeShape(t);
                    return this.shapeChanged(), e
                },
                setCircle: function(t, e, i, s) {
                    return this.clearShapes(), this.addCircle(t, e, i, s)
                },
                setRectangle: function(t, e, i, s, n) {
                    return void 0 === t && (t = 16), void 0 === e && (e = 16), this.clearShapes(), this.addRectangle(t, e, i, s, n)
                },
                setRectangleFromSprite: function(t) {
                    return void 0 === t && (t = this.sprite), this.clearShapes(), this.addRectangle(t.width, t.height, 0, 0, t.rotation)
                },
                setMaterial: function(t, e) {
                    if (void 0 === e)
                        for (var i = this.data.shapes.length - 1; i >= 0; i--) this.data.shapes[i].material = t;
                    else e.material = t
                },
                shapeChanged: function() {
                    this.debugBody && this.debugBody.draw()
                },
                addPhaserPolygon: function(t, e) {
                    for (var i = this.game.cache.getPhysicsData(t, e), s = [], n = 0; n < i.length; n++) {
                        var a = i[n],
                            o = this.addFixture(a);
                        s[a.filter.group] = s[a.filter.group] || [], s[a.filter.group] = s[a.filter.group].concat(o), a.fixtureKey && (s[a.fixtureKey] = o)
                    }
                    return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), s
                },
                addFixture: function(t) {
                    var e = [];
                    if (t.circle) {
                        var i = new p2.Circle({
                            radius: this.world.pxm(t.circle.radius)
                        });
                        i.collisionGroup = t.filter.categoryBits, i.collisionMask = t.filter.maskBits, i.sensor = t.isSensor;
                        var s = p2.vec2.create();
                        s[0] = this.world.pxmi(t.circle.position[0] - this.sprite.width / 2), s[1] = this.world.pxmi(t.circle.position[1] - this.sprite.height / 2), this.data.addShape(i, s), e.push(i)
                    } else
                        for (var n = t.polygons, a = p2.vec2.create(), o = 0; o < n.length; o++) {
                            for (var r = n[o], h = [], l = 0; l < r.length; l += 2) h.push([this.world.pxmi(r[l]), this.world.pxmi(r[l + 1])]);
                            for (var i = new p2.Convex({
                                    vertices: h
                                }), c = 0; c !== i.vertices.length; c++) {
                                var u = i.vertices[c];
                                p2.vec2.sub(u, u, i.centerOfMass)
                            }
                            p2.vec2.scale(a, i.centerOfMass, 1), a[0] -= this.world.pxmi(this.sprite.width / 2), a[1] -= this.world.pxmi(this.sprite.height / 2), i.updateTriangles(), i.updateCenterOfMass(), i.updateBoundingRadius(), i.collisionGroup = t.filter.categoryBits, i.collisionMask = t.filter.maskBits, i.sensor = t.isSensor, this.data.addShape(i, a), e.push(i)
                        }
                    return e
                },
                loadPolygon: function(t, e) {
                    if (null === t) var i = e;
                    else var i = this.game.cache.getPhysicsData(t, e);
                    for (var s = p2.vec2.create(), n = 0; n < i.length; n++) {
                        for (var a = [], o = 0; o < i[n].shape.length; o += 2) a.push([this.world.pxmi(i[n].shape[o]), this.world.pxmi(i[n].shape[o + 1])]);
                        for (var r = new p2.Convex({
                                vertices: a
                            }), h = 0; h !== r.vertices.length; h++) {
                            var l = r.vertices[h];
                            p2.vec2.sub(l, l, r.centerOfMass)
                        }
                        p2.vec2.scale(s, r.centerOfMass, 1), s[0] -= this.world.pxmi(this.sprite.width / 2), s[1] -= this.world.pxmi(this.sprite.height / 2), r.updateTriangles(), r.updateCenterOfMass(), r.updateBoundingRadius(), this.data.addShape(r, s)
                    }
                    return this.data.aabbNeedsUpdate = !0, this.shapeChanged(), !0
                }
            }, a.Physics.P2.Body.prototype.constructor = a.Physics.P2.Body, a.Physics.P2.Body.DYNAMIC = 1, a.Physics.P2.Body.STATIC = 2, a.Physics.P2.Body.KINEMATIC = 4, Object.defineProperty(a.Physics.P2.Body.prototype, "static", {
                get: function() {
                    return this.data.type === a.Physics.P2.Body.STATIC
                },
                set: function(t) {
                    t && this.data.type !== a.Physics.P2.Body.STATIC ? (this.data.type = a.Physics.P2.Body.STATIC, this.mass = 0) : t || this.data.type !== a.Physics.P2.Body.STATIC || (this.data.type = a.Physics.P2.Body.DYNAMIC, this.mass = 1)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "dynamic", {
                get: function() {
                    return this.data.type === a.Physics.P2.Body.DYNAMIC
                },
                set: function(t) {
                    t && this.data.type !== a.Physics.P2.Body.DYNAMIC ? (this.data.type = a.Physics.P2.Body.DYNAMIC, this.mass = 1) : t || this.data.type !== a.Physics.P2.Body.DYNAMIC || (this.data.type = a.Physics.P2.Body.STATIC, this.mass = 0)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "kinematic", {
                get: function() {
                    return this.data.type === a.Physics.P2.Body.KINEMATIC
                },
                set: function(t) {
                    t && this.data.type !== a.Physics.P2.Body.KINEMATIC ? (this.data.type = a.Physics.P2.Body.KINEMATIC, this.mass = 4) : t || this.data.type !== a.Physics.P2.Body.KINEMATIC || (this.data.type = a.Physics.P2.Body.STATIC, this.mass = 0)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "allowSleep", {
                get: function() {
                    return this.data.allowSleep
                },
                set: function(t) {
                    t !== this.data.allowSleep && (this.data.allowSleep = t)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "angle", {
                get: function() {
                    return a.Math.wrapAngle(a.Math.radToDeg(this.data.angle))
                },
                set: function(t) {
                    this.data.angle = a.Math.degToRad(a.Math.wrapAngle(t))
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "angularDamping", {
                get: function() {
                    return this.data.angularDamping
                },
                set: function(t) {
                    this.data.angularDamping = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "angularForce", {
                get: function() {
                    return this.data.angularForce
                },
                set: function(t) {
                    this.data.angularForce = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "angularVelocity", {
                get: function() {
                    return this.data.angularVelocity
                },
                set: function(t) {
                    this.data.angularVelocity = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "damping", {
                get: function() {
                    return this.data.damping
                },
                set: function(t) {
                    this.data.damping = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "fixedRotation", {
                get: function() {
                    return this.data.fixedRotation
                },
                set: function(t) {
                    t !== this.data.fixedRotation && (this.data.fixedRotation = t)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "inertia", {
                get: function() {
                    return this.data.inertia
                },
                set: function(t) {
                    this.data.inertia = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "mass", {
                get: function() {
                    return this.data.mass
                },
                set: function(t) {
                    t !== this.data.mass && (this.data.mass = t, this.data.updateMassProperties())
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "motionState", {
                get: function() {
                    return this.data.type
                },
                set: function(t) {
                    t !== this.data.type && (this.data.type = t)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "rotation", {
                get: function() {
                    return this.data.angle
                },
                set: function(t) {
                    this.data.angle = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "sleepSpeedLimit", {
                get: function() {
                    return this.data.sleepSpeedLimit
                },
                set: function(t) {
                    this.data.sleepSpeedLimit = t
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "x", {
                get: function() {
                    return this.world.mpxi(this.data.position[0])
                },
                set: function(t) {
                    this.data.position[0] = this.world.pxmi(t)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "y", {
                get: function() {
                    return this.world.mpxi(this.data.position[1])
                },
                set: function(t) {
                    this.data.position[1] = this.world.pxmi(t)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "id", {
                get: function() {
                    return this.data.id
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "debug", {
                get: function() {
                    return null !== this.debugBody
                },
                set: function(t) {
                    t && !this.debugBody ? this.debugBody = new a.Physics.P2.BodyDebug(this.game, this.data) : !t && this.debugBody && (this.debugBody.destroy(), this.debugBody = null)
                }
            }), Object.defineProperty(a.Physics.P2.Body.prototype, "collideWorldBounds", {
                get: function() {
                    return this._collideWorldBounds
                },
                set: function(t) {
                    t && !this._collideWorldBounds ? (this._collideWorldBounds = !0, this.updateCollisionMask()) : !t && this._collideWorldBounds && (this._collideWorldBounds = !1, this.updateCollisionMask())
                }
            }), a.Physics.P2.BodyDebug = function(t, e, i) {
                a.Group.call(this, t);
                var s = {
                    pixelsPerLengthUnit: t.physics.p2.mpx(1),
                    debugPolygons: !1,
                    lineWidth: 1,
                    alpha: .5
                };
                this.settings = a.Utils.extend(s, i), this.ppu = this.settings.pixelsPerLengthUnit, this.ppu = -1 * this.ppu, this.body = e, this.canvas = new a.Graphics(t), this.canvas.alpha = this.settings.alpha, this.add(this.canvas), this.draw(), this.updateSpriteTransform()
            }, a.Physics.P2.BodyDebug.prototype = Object.create(a.Group.prototype), a.Physics.P2.BodyDebug.prototype.constructor = a.Physics.P2.BodyDebug, a.Utils.extend(a.Physics.P2.BodyDebug.prototype, {
                updateSpriteTransform: function() {
                    this.position.x = this.body.position[0] * this.ppu, this.position.y = this.body.position[1] * this.ppu, this.rotation = this.body.angle
                },
                draw: function() {
                    var t, e, i, s, n, a, o, r, h, l, c, u, d, p, f;
                    if (r = this.body, l = this.canvas, l.clear(), i = parseInt(this.randomPastelHex(), 16), a = 16711680, o = this.lineWidth, r instanceof p2.Body && r.shapes.length) {
                        var g = r.shapes.length;
                        for (s = 0; s !== g;) {
                            if (e = r.shapes[s], h = e.position || 0, t = e.angle || 0, e instanceof p2.Circle) this.drawCircle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.radius * this.ppu, i, o);
                            else if (e instanceof p2.Capsule) this.drawCapsule(l, h[0] * this.ppu, h[1] * this.ppu, t, e.length * this.ppu, e.radius * this.ppu, a, i, o);
                            else if (e instanceof p2.Plane) this.drawPlane(l, h[0] * this.ppu, -h[1] * this.ppu, i, a, 5 * o, 10 * o, 10 * o, 100 * this.ppu, t);
                            else if (e instanceof p2.Line) this.drawLine(l, e.length * this.ppu, a, o);
                            else if (e instanceof p2.Box) this.drawRectangle(l, h[0] * this.ppu, h[1] * this.ppu, t, e.width * this.ppu, e.height * this.ppu, a, i, o);
                            else if (e instanceof p2.Convex) {
                                for (u = [], d = p2.vec2.create(), n = p = 0, f = e.vertices.length; 0 <= f ? p < f : p > f; n = 0 <= f ? ++p : --p) c = e.vertices[n], p2.vec2.rotate(d, c, t), u.push([(d[0] + h[0]) * this.ppu, -(d[1] + h[1]) * this.ppu]);
                                this.drawConvex(l, u, e.triangles, a, i, o, this.settings.debugPolygons, [h[0] * this.ppu, -h[1] * this.ppu])
                            }
                            s++
                        }
                    }
                },
                drawRectangle: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1), t.beginFill(r), t.drawRect(e - n / 2, i - a / 2, n, a)
                },
                drawCircle: function(t, e, i, s, n, a, o) {
                    void 0 === o && (o = 1), void 0 === a && (a = 16777215), t.lineStyle(o, 0, 1), t.beginFill(a, 1), t.drawCircle(e, i, 2 * -n), t.endFill(), t.moveTo(e, i), t.lineTo(e + n * Math.cos(-s), i + n * Math.sin(-s))
                },
                drawLine: function(t, e, i, s) {
                    void 0 === s && (s = 1), void 0 === i && (i = 0), t.lineStyle(5 * s, i, 1), t.moveTo(-e / 2, 0), t.lineTo(e / 2, 0)
                },
                drawConvex: function(t, e, i, s, n, a, o, r) {
                    var h, l, c, u, d, p, f, g, y, m, v;
                    if (void 0 === a && (a = 1), void 0 === s && (s = 0), o) {
                        for (h = [16711680, 65280, 255], l = 0; l !== e.length + 1;) u = e[l % e.length], d = e[(l + 1) % e.length], f = u[0], m = u[1], g = d[0], v = d[1], t.lineStyle(a, h[l % h.length], 1), t.moveTo(f, -m), t.lineTo(g, -v), t.drawCircle(f, -m, 2 * a), l++;
                        return t.lineStyle(a, 0, 1), t.drawCircle(r[0], r[1], 2 * a)
                    }
                    for (t.lineStyle(a, s, 1), t.beginFill(n), l = 0; l !== e.length;) c = e[l], p = c[0], y = c[1], 0 === l ? t.moveTo(p, -y) : t.lineTo(p, -y), l++;
                    if (t.endFill(), e.length > 2) return t.moveTo(e[e.length - 1][0], -e[e.length - 1][1]), t.lineTo(e[0][0], -e[0][1])
                },
                drawPath: function(t, e, i, s, n) {
                    var a, o, r, h, l, c, u, d, p, f, g, y, m;
                    for (void 0 === n && (n = 1), void 0 === i && (i = 0), t.lineStyle(n, i, 1), "number" == typeof s && t.beginFill(s), r = null, h = null, o = 0; o < e.length;) g = e[o], y = g[0], m = g[1], y === r && m === h || (0 === o ? t.moveTo(y, m) : (l = r, c = h, u = y, d = m, p = e[(o + 1) % e.length][0], f = e[(o + 1) % e.length][1], 0 !== (a = (u - l) * (f - c) - (p - l) * (d - c)) && t.lineTo(y, m)), r = y, h = m), o++;
                    "number" == typeof s && t.endFill(), e.length > 2 && "number" == typeof s && (t.moveTo(e[e.length - 1][0], e[e.length - 1][1]), t.lineTo(e[0][0], e[0][1]))
                },
                drawPlane: function(t, e, i, s, n, a, o, r, h, l) {
                    var c, u, d;
                    void 0 === a && (a = 1), void 0 === s && (s = 16777215), t.lineStyle(a, n, 11), t.beginFill(s), c = h, t.moveTo(e, -i), u = e + Math.cos(l) * this.game.width, d = i + Math.sin(l) * this.game.height, t.lineTo(u, -d), t.moveTo(e, -i), u = e + Math.cos(l) * -this.game.width, d = i + Math.sin(l) * -this.game.height, t.lineTo(u, -d)
                },
                drawCapsule: function(t, e, i, s, n, a, o, r, h) {
                    void 0 === h && (h = 1), void 0 === o && (o = 0), t.lineStyle(h, o, 1);
                    var l = Math.cos(s),
                        c = Math.sin(s);
                    t.beginFill(r, 1), t.drawCircle(-n / 2 * l + e, -n / 2 * c + i, 2 * -a), t.drawCircle(n / 2 * l + e, n / 2 * c + i, 2 * -a), t.endFill(), t.lineStyle(h, o, 0), t.beginFill(r, 1), t.moveTo(-n / 2 * l + a * c + e, -n / 2 * c + a * l + i), t.lineTo(n / 2 * l + a * c + e, n / 2 * c + a * l + i), t.lineTo(n / 2 * l - a * c + e, n / 2 * c - a * l + i), t.lineTo(-n / 2 * l - a * c + e, -n / 2 * c - a * l + i), t.endFill(), t.lineStyle(h, o, 1), t.moveTo(-n / 2 * l + a * c + e, -n / 2 * c + a * l + i), t.lineTo(n / 2 * l + a * c + e, n / 2 * c + a * l + i), t.moveTo(-n / 2 * l - a * c + e, -n / 2 * c - a * l + i), t.lineTo(n / 2 * l - a * c + e, n / 2 * c - a * l + i)
                },
                randomPastelHex: function() {
                    var t, e, i, s;
                    return i = [255, 255, 255], s = Math.floor(256 * Math.random()), e = Math.floor(256 * Math.random()), t = Math.floor(256 * Math.random()), s = Math.floor((s + 3 * i[0]) / 4), e = Math.floor((e + 3 * i[1]) / 4), t = Math.floor((t + 3 * i[2]) / 4), this.rgbToHex(s, e, t)
                },
                rgbToHex: function(t, e, i) {
                    return this.componentToHex(t) + this.componentToHex(e) + this.componentToHex(i)
                },
                componentToHex: function(t) {
                    var e;
                    return e = t.toString(16), 2 === e.length ? e : e + "0"
                }
            }), a.Physics.P2.Spring = function(t, e, i, s, n, a, o, r, h, l) {
                this.game = t.game, this.world = t, void 0 === s && (s = 1), void 0 === n && (n = 100), void 0 === a && (a = 1), s = t.pxm(s);
                var c = {
                    restLength: s,
                    stiffness: n,
                    damping: a
                };
                void 0 !== o && null !== o && (c.worldAnchorA = [t.pxm(o[0]), t.pxm(o[1])]), void 0 !== r && null !== r && (c.worldAnchorB = [t.pxm(r[0]), t.pxm(r[1])]), void 0 !== h && null !== h && (c.localAnchorA = [t.pxm(h[0]), t.pxm(h[1])]), void 0 !== l && null !== l && (c.localAnchorB = [t.pxm(l[0]), t.pxm(l[1])]), this.data = new p2.LinearSpring(e, i, c), this.data.parent = this
            }, a.Physics.P2.Spring.prototype.constructor = a.Physics.P2.Spring, a.Physics.P2.RotationalSpring = function(t, e, i, s, n, a) {
                this.game = t.game, this.world = t, void 0 === s && (s = null), void 0 === n && (n = 100), void 0 === a && (a = 1), s && (s = t.pxm(s));
                var o = {
                    restAngle: s,
                    stiffness: n,
                    damping: a
                };
                this.data = new p2.RotationalSpring(e, i, o), this.data.parent = this
            }, a.Physics.P2.Spring.prototype.constructor = a.Physics.P2.Spring, a.Physics.P2.Material = function(t) {
                this.name = t, p2.Material.call(this)
            }, a.Physics.P2.Material.prototype = Object.create(p2.Material.prototype), a.Physics.P2.Material.prototype.constructor = a.Physics.P2.Material, a.Physics.P2.ContactMaterial = function(t, e, i) {
                p2.ContactMaterial.call(this, t, e, i)
            }, a.Physics.P2.ContactMaterial.prototype = Object.create(p2.ContactMaterial.prototype), a.Physics.P2.ContactMaterial.prototype.constructor = a.Physics.P2.ContactMaterial, a.Physics.P2.CollisionGroup = function(t) {
                this.mask = t
            }, a.Physics.P2.DistanceConstraint = function(t, e, i, s, n, a, o) {
                void 0 === s && (s = 100), void 0 === n && (n = [0, 0]), void 0 === a && (a = [0, 0]), void 0 === o && (o = Number.MAX_VALUE), this.game = t.game, this.world = t, s = t.pxm(s), n = [t.pxmi(n[0]), t.pxmi(n[1])], a = [t.pxmi(a[0]), t.pxmi(a[1])];
                var r = {
                    distance: s,
                    localAnchorA: n,
                    localAnchorB: a,
                    maxForce: o
                };
                p2.DistanceConstraint.call(this, e, i, r)
            }, a.Physics.P2.DistanceConstraint.prototype = Object.create(p2.DistanceConstraint.prototype), a.Physics.P2.DistanceConstraint.prototype.constructor = a.Physics.P2.DistanceConstraint, a.Physics.P2.GearConstraint = function(t, e, i, s, n) {
                void 0 === s && (s = 0), void 0 === n && (n = 1), this.game = t.game, this.world = t;
                var a = {
                    angle: s,
                    ratio: n
                };
                p2.GearConstraint.call(this, e, i, a)
            }, a.Physics.P2.GearConstraint.prototype = Object.create(p2.GearConstraint.prototype), a.Physics.P2.GearConstraint.prototype.constructor = a.Physics.P2.GearConstraint, a.Physics.P2.LockConstraint = function(t, e, i, s, n, a) {
                void 0 === s && (s = [0, 0]), void 0 === n && (n = 0), void 0 === a && (a = Number.MAX_VALUE), this.game = t.game, this.world = t, s = [t.pxm(s[0]), t.pxm(s[1])];
                var o = {
                    localOffsetB: s,
                    localAngleB: n,
                    maxForce: a
                };
                p2.LockConstraint.call(this, e, i, o)
            }, a.Physics.P2.LockConstraint.prototype = Object.create(p2.LockConstraint.prototype), a.Physics.P2.LockConstraint.prototype.constructor = a.Physics.P2.LockConstraint, a.Physics.P2.PrismaticConstraint = function(t, e, i, s, n, a, o, r) {
                void 0 === s && (s = !0), void 0 === n && (n = [0, 0]), void 0 === a && (a = [0, 0]), void 0 === o && (o = [0, 0]), void 0 === r && (r = Number.MAX_VALUE), this.game = t.game, this.world = t, n = [t.pxmi(n[0]), t.pxmi(n[1])], a = [t.pxmi(a[0]), t.pxmi(a[1])];
                var h = {
                    localAnchorA: n,
                    localAnchorB: a,
                    localAxisA: o,
                    maxForce: r,
                    disableRotationalLock: !s
                };
                p2.PrismaticConstraint.call(this, e, i, h)
            }, a.Physics.P2.PrismaticConstraint.prototype = Object.create(p2.PrismaticConstraint.prototype), a.Physics.P2.PrismaticConstraint.prototype.constructor = a.Physics.P2.PrismaticConstraint, a.Physics.P2.RevoluteConstraint = function(t, e, i, s, n, a, o) {
                void 0 === a && (a = Number.MAX_VALUE), void 0 === o && (o = null), this.game = t.game, this.world = t, i = [t.pxmi(i[0]), t.pxmi(i[1])], n = [t.pxmi(n[0]), t.pxmi(n[1])], o && (o = [t.pxmi(o[0]), t.pxmi(o[1])]);
                var r = {
                    worldPivot: o,
                    localPivotA: i,
                    localPivotB: n,
                    maxForce: a
                };
                p2.RevoluteConstraint.call(this, e, s, r)
            }, a.Physics.P2.RevoluteConstraint.prototype = Object.create(p2.RevoluteConstraint.prototype), a.Physics.P2.RevoluteConstraint.prototype.constructor = a.Physics.P2.RevoluteConstraint, a.ImageCollection = function(t, e, i, s, n, a, o) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === a && (a = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | s, this.imageMargin = 0 | n, this.imageSpacing = 0 | a, this.properties = o || {}, this.images = [], this.total = 0
            }, a.ImageCollection.prototype = {
                containsImageIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                addImage: function(t, e) {
                    this.images.push({
                        gid: t,
                        image: e
                    }), this.total++
                }
            }, a.ImageCollection.prototype.constructor = a.ImageCollection, a.Tile = function(t, e, i, s, n, a) {
                this.layer = t, this.index = e, this.x = i, this.y = s, this.rotation = 0, this.flipped = !1, this.worldX = i * n, this.worldY = s * a, this.width = n, this.height = a, this.centerX = Math.abs(n / 2), this.centerY = Math.abs(a / 2), this.alpha = 1, this.properties = {}, this.scanned = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.collisionCallback = null, this.collisionCallbackContext = this
            }, a.Tile.prototype = {
                containsPoint: function(t, e) {
                    return !(t < this.worldX || e < this.worldY || t > this.right || e > this.bottom)
                },
                intersects: function(t, e, i, s) {
                    return !(i <= this.worldX) && (!(s <= this.worldY) && (!(t >= this.worldX + this.width) && !(e >= this.worldY + this.height)))
                },
                setCollisionCallback: function(t, e) {
                    this.collisionCallback = t, this.collisionCallbackContext = e
                },
                destroy: function() {
                    this.collisionCallback = null, this.collisionCallbackContext = null, this.properties = null
                },
                setCollision: function(t, e, i, s) {
                    this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = s, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = s
                },
                resetCollision: function() {
                    this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1
                },
                isInteresting: function(t, e) {
                    return t && e ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.faceTop || this.faceBottom || this.faceLeft || this.faceRight || this.collisionCallback : t ? this.collideLeft || this.collideRight || this.collideUp || this.collideDown : !!e && (this.faceTop || this.faceBottom || this.faceLeft || this.faceRight)
                },
                copy: function(t) {
                    this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext
                }
            }, a.Tile.prototype.constructor = a.Tile, Object.defineProperty(a.Tile.prototype, "collides", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown
                }
            }), Object.defineProperty(a.Tile.prototype, "canCollide", {
                get: function() {
                    return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback
                }
            }), Object.defineProperty(a.Tile.prototype, "left", {
                get: function() {
                    return this.worldX
                }
            }), Object.defineProperty(a.Tile.prototype, "right", {
                get: function() {
                    return this.worldX + this.width
                }
            }), Object.defineProperty(a.Tile.prototype, "top", {
                get: function() {
                    return this.worldY
                }
            }), Object.defineProperty(a.Tile.prototype, "bottom", {
                get: function() {
                    return this.worldY + this.height
                }
            }), a.Tilemap = function(t, e, i, s, n, o) {
                this.game = t, this.key = e;
                var r = a.TilemapParser.parse(this.game, e, i, s, n, o);
                null !== r && (this.width = r.width, this.height = r.height, this.tileWidth = r.tileWidth, this.tileHeight = r.tileHeight, this.orientation = r.orientation, this.format = r.format, this.version = r.version, this.properties = r.properties, this.widthInPixels = r.widthInPixels, this.heightInPixels = r.heightInPixels, this.layers = r.layers, this.tilesets = r.tilesets, this.imagecollections = r.imagecollections, this.tiles = r.tiles, this.objects = r.objects, this.collideIndexes = [], this.collision = r.collision, this.images = r.images, this.enableDebug = !1, this.currentLayer = 0, this.debugMap = [], this._results = [], this._tempA = 0, this._tempB = 0)
            }, a.Tilemap.CSV = 0, a.Tilemap.TILED_JSON = 1, a.Tilemap.NORTH = 0, a.Tilemap.EAST = 1, a.Tilemap.SOUTH = 2, a.Tilemap.WEST = 3, a.Tilemap.prototype = {
                create: function(t, e, i, s, n, a) {
                    return void 0 === a && (a = this.game.world), this.width = e, this.height = i, this.setTileSize(s, n), this.layers.length = 0, this.createBlankLayer(t, e, i, s, n, a)
                },
                setTileSize: function(t, e) {
                    this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e
                },
                addTilesetImage: function(t, e, i, s, n, o, r) {
                    if (void 0 === t) return null;
                    void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === r && (r = 0), 0 === i && (i = 32), 0 === s && (s = 32);
                    var h = null;
                    if (void 0 !== e && null !== e || (e = t), e instanceof a.BitmapData) h = e.canvas;
                    else {
                        if (!this.game.cache.checkImageKey(e)) return null;
                        h = this.game.cache.getImage(e)
                    }
                    var l = this.getTilesetIndex(t);
                    if (null === l && this.format === a.Tilemap.TILED_JSON) return null;
                    if (this.tilesets[l]) return this.tilesets[l].setImage(h), this.tilesets[l];
                    var c = new a.Tileset(t, r, i, s, n, o, {});
                    c.setImage(h), this.tilesets.push(c);
                    for (var u = this.tilesets.length - 1, d = n, p = n, f = 0, g = 0, y = 0, m = r; m < r + c.total && (this.tiles[m] = [d, p, u], d += i + o, ++f !== c.total) && (++g !== c.columns || (d = n, p += s + o, g = 0, ++y !== c.rows)); m++);
                    return c
                },
                createFromObjects: function(t, e, i, s, n, o, r, h, l) {
                    if (void 0 === n && (n = !0), void 0 === o && (o = !1), void 0 === r && (r = this.game.world), void 0 === h && (h = a.Sprite), void 0 === l && (l = !0), this.objects[t])
                        for (var c = 0; c < this.objects[t].length; c++) {
                            var u = !1,
                                d = this.objects[t][c];
                            if (void 0 !== d.gid && "number" == typeof e && d.gid === e ? u = !0 : void 0 !== d.id && "number" == typeof e && d.id === e ? u = !0 : void 0 !== d.name && "string" == typeof e && d.name === e && (u = !0), u) {
                                var p = new h(this.game, parseFloat(d.x, 10), parseFloat(d.y, 10), i, s);
                                p.name = d.name, p.visible = d.visible, p.autoCull = o, p.exists = n, d.width && (p.width = d.width), d.height && (p.height = d.height), d.rotation && (p.angle = d.rotation), l && (p.y -= p.height), r.add(p);
                                for (var f in d.properties) r.set(p, f, d.properties[f], !1, !1, 0, !0)
                            }
                        }
                },
                createFromTiles: function(t, e, i, s, n, o) {
                    "number" == typeof t && (t = [t]), void 0 === e || null === e ? e = [] : "number" == typeof e && (e = [e]), s = this.getLayer(s), void 0 === n && (n = this.game.world), void 0 === o && (o = {}), void 0 === o.customClass && (o.customClass = a.Sprite), void 0 === o.adjustY && (o.adjustY = !0);
                    var r = this.layers[s].width,
                        h = this.layers[s].height;
                    if (this.copy(0, 0, r, h, s), this._results.length < 2) return 0;
                    for (var l = 0, c, u = 1, d = this._results.length; u < d; u++)
                        if (-1 !== t.indexOf(this._results[u].index)) {
                            c = new o.customClass(this.game, this._results[u].worldX, this._results[u].worldY, i);
                            for (var p in o) c[p] = o[p];
                            n.add(c), l++
                        } if (1 === e.length)
                        for (u = 0; u < t.length; u++) this.replace(t[u], e[0], 0, 0, r, h, s);
                    else if (e.length > 1)
                        for (u = 0; u < t.length; u++) this.replace(t[u], e[u], 0, 0, r, h, s);
                    return l
                },
                createLayer: function(t, e, i, s) {
                    void 0 === e && (e = this.game.width), void 0 === i && (i = this.game.height), void 0 === s && (s = this.game.world);
                    var n = t;
                    if ("string" == typeof t && (n = this.getLayerIndex(t)), !(null === n || n > this.layers.length)) {
                        void 0 === e || e <= 0 ? e = Math.min(this.game.width, this.layers[n].widthInPixels) : e > this.game.width && (e = this.game.width), void 0 === i || i <= 0 ? i = Math.min(this.game.height, this.layers[n].heightInPixels) : i > this.game.height && (i = this.game.height), this.enableDebug;
                        var o = s.add(new a.TilemapLayer(this.game, this, n, e, i));
                        return this.enableDebug, o
                    }
                },
                createBlankLayer: function(t, e, i, s, n, o) {
                    if (void 0 === o && (o = this.game.world), null === this.getLayerIndex(t)) {
                        for (var r = {
                                name: t,
                                x: 0,
                                y: 0,
                                width: e,
                                height: i,
                                widthInPixels: e * s,
                                heightInPixels: i * n,
                                alpha: 1,
                                visible: !0,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: [],
                                data: null
                            }, h, l = [], c = 0; c < i; c++) {
                            h = [];
                            for (var u = 0; u < e; u++) h.push(new a.Tile(r, -1, u, c, s, n));
                            l.push(h)
                        }
                        r.data = l, this.layers.push(r), this.currentLayer = this.layers.length - 1;
                        var d = r.widthInPixels,
                            p = r.heightInPixels;
                        d > this.game.width && (d = this.game.width), p > this.game.height && (p = this.game.height);
                        var l = new a.TilemapLayer(this.game, this, this.layers.length - 1, d, p);
                        return l.name = t, o.add(l)
                    }
                },
                getIndex: function(t, e) {
                    for (var i = 0; i < t.length; i++)
                        if (t[i].name === e) return i;
                    return null
                },
                getLayerIndex: function(t) {
                    return this.getIndex(this.layers, t)
                },
                getTilesetIndex: function(t) {
                    return this.getIndex(this.tilesets, t)
                },
                getImageIndex: function(t) {
                    return this.getIndex(this.images, t)
                },
                setTileIndexCallback: function(t, e, i, s) {
                    if (s = this.getLayer(s), "number" == typeof t) this.layers[s].callbacks[t] = {
                        callback: e,
                        callbackContext: i
                    };
                    else
                        for (var n = 0, a = t.length; n < a; n++) this.layers[s].callbacks[t[n]] = {
                            callback: e,
                            callbackContext: i
                        }
                },
                setTileLocationCallback: function(t, e, i, s, n, a, o) {
                    if (o = this.getLayer(o), this.copy(t, e, i, s, o), !(this._results.length < 2))
                        for (var r = 1; r < this._results.length; r++) this._results[r].setCollisionCallback(n, a)
                },
                setCollision: function(t, e, i, s) {
                    if (void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i), "number" == typeof t) return this.setCollisionByIndex(t, e, i, !0);
                    if (Array.isArray(t)) {
                        for (var n = 0; n < t.length; n++) this.setCollisionByIndex(t[n], e, i, !1);
                        s && this.calculateFaces(i)
                    }
                },
                setCollisionBetween: function(t, e, i, s, n) {
                    if (void 0 === i && (i = !0), void 0 === n && (n = !0), s = this.getLayer(s), !(t > e)) {
                        for (var a = t; a <= e; a++) this.setCollisionByIndex(a, i, s, !1);
                        n && this.calculateFaces(s)
                    }
                },
                setCollisionByExclusion: function(t, e, i, s) {
                    void 0 === e && (e = !0), void 0 === s && (s = !0), i = this.getLayer(i);
                    for (var n = 0, a = this.tiles.length; n < a; n++) - 1 === t.indexOf(n) && this.setCollisionByIndex(n, e, i, !1);
                    s && this.calculateFaces(i)
                },
                setCollisionByIndex: function(t, e, i, s) {
                    if (void 0 === e && (e = !0), void 0 === i && (i = this.currentLayer), void 0 === s && (s = !0), e) this.collideIndexes.push(t);
                    else {
                        var n = this.collideIndexes.indexOf(t);
                        n > -1 && this.collideIndexes.splice(n, 1)
                    }
                    for (var a = 0; a < this.layers[i].height; a++)
                        for (var o = 0; o < this.layers[i].width; o++) {
                            var r = this.layers[i].data[a][o];
                            r && r.index === t && (e ? r.setCollision(!0, !0, !0, !0) : r.resetCollision(), r.faceTop = e, r.faceBottom = e, r.faceLeft = e, r.faceRight = e)
                        }
                    return s && this.calculateFaces(i), i
                },
                getLayer: function(t) {
                    return void 0 === t ? t = this.currentLayer : "string" == typeof t ? t = this.getLayerIndex(t) : t instanceof a.TilemapLayer && (t = t.index), t
                },
                setPreventRecalculate: function(t) {
                    if (!0 === t && !0 !== this.preventingRecalculate && (this.preventingRecalculate = !0, this.needToRecalculate = {}), !1 === t && !0 === this.preventingRecalculate) {
                        this.preventingRecalculate = !1;
                        for (var e in this.needToRecalculate) this.calculateFaces(e);
                        this.needToRecalculate = !1
                    }
                },
                calculateFaces: function(t) {
                    if (this.preventingRecalculate) return void(this.needToRecalculate[t] = !0);
                    for (var e = null, i = null, s = null, n = null, a = 0, o = this.layers[t].height; a < o; a++)
                        for (var r = 0, h = this.layers[t].width; r < h; r++) {
                            var l = this.layers[t].data[a][r];
                            l && (e = this.getTileAbove(t, r, a), i = this.getTileBelow(t, r, a), s = this.getTileLeft(t, r, a), n = this.getTileRight(t, r, a), l.collides && (l.faceTop = !0, l.faceBottom = !0, l.faceLeft = !0, l.faceRight = !0), e && e.collides && (l.faceTop = !1), i && i.collides && (l.faceBottom = !1), s && s.collides && (l.faceLeft = !1), n && n.collides && (l.faceRight = !1))
                        }
                },
                getTileAbove: function(t, e, i) {
                    return i > 0 ? this.layers[t].data[i - 1][e] : null
                },
                getTileBelow: function(t, e, i) {
                    return i < this.layers[t].height - 1 ? this.layers[t].data[i + 1][e] : null
                },
                getTileLeft: function(t, e, i) {
                    return e > 0 ? this.layers[t].data[i][e - 1] : null
                },
                getTileRight: function(t, e, i) {
                    return e < this.layers[t].width - 1 ? this.layers[t].data[i][e + 1] : null
                },
                setLayer: function(t) {
                    t = this.getLayer(t), this.layers[t] && (this.currentLayer = t)
                },
                hasTile: function(t, e, i) {
                    return i = this.getLayer(i), void 0 !== this.layers[i].data[e] && void 0 !== this.layers[i].data[e][t] && this.layers[i].data[e][t].index > -1
                },
                removeTile: function(t, e, i) {
                    if (i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height && this.hasTile(t, e, i)) {
                        var s = this.layers[i].data[e][t];
                        return this.layers[i].data[e][t] = new a.Tile(this.layers[i], -1, t, e, this.tileWidth, this.tileHeight), this.layers[i].dirty = !0, this.calculateFaces(i), s
                    }
                },
                removeTileWorldXY: function(t, e, i, s, n) {
                    return n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.removeTile(t, e, n)
                },
                putTile: function(t, e, i, s) {
                    if (null === t) return this.removeTile(e, i, s);
                    if (s = this.getLayer(s), e >= 0 && e < this.layers[s].width && i >= 0 && i < this.layers[s].height) {
                        var n;
                        return t instanceof a.Tile ? (n = t.index, this.hasTile(e, i, s) ? this.layers[s].data[i][e].copy(t) : this.layers[s].data[i][e] = new a.Tile(s, n, e, i, t.width, t.height)) : (n = t, this.hasTile(e, i, s) ? this.layers[s].data[i][e].index = n : this.layers[s].data[i][e] = new a.Tile(this.layers[s], n, e, i, this.tileWidth, this.tileHeight)), this.collideIndexes.indexOf(n) > -1 ? this.layers[s].data[i][e].setCollision(!0, !0, !0, !0) : this.layers[s].data[i][e].resetCollision(), this.layers[s].dirty = !0, this.calculateFaces(s), this.layers[s].data[i][e]
                    }
                    return null
                },
                putTileWorldXY: function(t, e, i, s, n, a) {
                    return a = this.getLayer(a), e = this.game.math.snapToFloor(e, s) / s, i = this.game.math.snapToFloor(i, n) / n, this.putTile(t, e, i, a)
                },
                searchTileIndex: function(t, e, i, s) {
                    void 0 === e && (e = 0), void 0 === i && (i = !1), s = this.getLayer(s);
                    var n = 0;
                    if (i) {
                        for (var a = this.layers[s].height - 1; a >= 0; a--)
                            for (var o = this.layers[s].width - 1; o >= 0; o--)
                                if (this.layers[s].data[a][o].index === t) {
                                    if (n === e) return this.layers[s].data[a][o];
                                    n++
                                }
                    } else
                        for (var a = 0; a < this.layers[s].height; a++)
                            for (var o = 0; o < this.layers[s].width; o++)
                                if (this.layers[s].data[a][o].index === t) {
                                    if (n === e) return this.layers[s].data[a][o];
                                    n++
                                } return null
                },
                getTile: function(t, e, i, s) {
                    return void 0 === s && (s = !1), i = this.getLayer(i), t >= 0 && t < this.layers[i].width && e >= 0 && e < this.layers[i].height ? -1 === this.layers[i].data[e][t].index ? s ? this.layers[i].data[e][t] : null : this.layers[i].data[e][t] : null
                },
                getTileWorldXY: function(t, e, i, s, n, a) {
                    return void 0 === i && (i = this.tileWidth), void 0 === s && (s = this.tileHeight), n = this.getLayer(n), t = this.game.math.snapToFloor(t, i) / i, e = this.game.math.snapToFloor(e, s) / s, this.getTile(t, e, n, a)
                },
                copy: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), !this.layers[n]) return void(this._results.length = 0);
                    void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.layers[n].width), void 0 === s && (s = this.layers[n].height), t < 0 && (t = 0), e < 0 && (e = 0), i > this.layers[n].width && (i = this.layers[n].width), s > this.layers[n].height && (s = this.layers[n].height), this._results.length = 0, this._results.push({
                        x: t,
                        y: e,
                        width: i,
                        height: s,
                        layer: n
                    });
                    for (var a = e; a < e + s; a++)
                        for (var o = t; o < t + i; o++) this._results.push(this.layers[n].data[a][o]);
                    return this._results
                },
                paste: function(t, e, i, s) {
                    if (void 0 === t && (t = 0), void 0 === e && (e = 0), s = this.getLayer(s), i && !(i.length < 2)) {
                        for (var n = t - i[1].x, a = e - i[1].y, o = 1; o < i.length; o++) this.layers[s].data[a + i[o].y][n + i[o].x].copy(i[o]);
                        this.layers[s].dirty = !0, this.calculateFaces(s)
                    }
                },
                swap: function(t, e, i, s, n, a, o) {
                    o = this.getLayer(o), this.copy(i, s, n, a, o), this._results.length < 2 || (this._tempA = t, this._tempB = e, this._results.forEach(this.swapHandler, this), this.paste(i, s, this._results, o))
                },
                swapHandler: function(t) {
                    t.index === this._tempA ? t.index = this._tempB : t.index === this._tempB && (t.index = this._tempA)
                },
                forEach: function(t, e, i, s, n, a, o) {
                    o = this.getLayer(o), this.copy(i, s, n, a, o), this._results.length < 2 || (this._results.forEach(t, e), this.paste(i, s, this._results, o))
                },
                replace: function(t, e, i, s, n, a, o) {
                    if (o = this.getLayer(o), this.copy(i, s, n, a, o), !(this._results.length < 2)) {
                        for (var r = 1; r < this._results.length; r++) this._results[r].index === t && (this._results[r].index = e);
                        this.paste(i, s, this._results, o)
                    }
                },
                random: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                        for (var a = [], o = 1; o < this._results.length; o++)
                            if (this._results[o].index) {
                                var r = this._results[o].index; - 1 === a.indexOf(r) && a.push(r)
                            } for (var h = 1; h < this._results.length; h++) this._results[h].index = this.game.rnd.pick(a);
                        this.paste(t, e, this._results, n)
                    }
                },
                shuffle: function(t, e, i, s, n) {
                    if (n = this.getLayer(n), this.copy(t, e, i, s, n), !(this._results.length < 2)) {
                        for (var o = [], r = 1; r < this._results.length; r++) this._results[r].index && o.push(this._results[r].index);
                        a.ArrayUtils.shuffle(o);
                        for (var h = 1; h < this._results.length; h++) this._results[h].index = o[h - 1];
                        this.paste(t, e, this._results, n)
                    }
                },
                fill: function(t, e, i, s, n, a) {
                    if (a = this.getLayer(a), this.copy(e, i, s, n, a), !(this._results.length < 2)) {
                        for (var o = 1; o < this._results.length; o++) this._results[o].index = t;
                        this.paste(e, i, this._results, a)
                    }
                },
                removeAllLayers: function() {
                    this.layers.length = 0, this.currentLayer = 0
                },
                dump: function() {
                    for (var t = "", e = [""], i = 0; i < this.layers[this.currentLayer].height; i++) {
                        for (var s = 0; s < this.layers[this.currentLayer].width; s++) t += "%c  ", this.layers[this.currentLayer].data[i][s] > 1 ? this.debugMap[this.layers[this.currentLayer].data[i][s]] ? e.push("background: " + this.debugMap[this.layers[this.currentLayer].data[i][s]]) : e.push("background: #ffffff") : e.push("background: rgb(0, 0, 0)");
                        t += "\n"
                    }
                    e[0] = t
                },
                destroy: function() {
                    this.removeAllLayers(), this.data = [], this.game = null
                }
            }, a.Tilemap.prototype.constructor = a.Tilemap, Object.defineProperty(a.Tilemap.prototype, "layer", {
                get: function() {
                    return this.layers[this.currentLayer]
                },
                set: function(t) {
                    t !== this.currentLayer && this.setLayer(t)
                }
            }), a.TilemapLayer = function(t, e, i, s, n) {
                s |= 0, n |= 0, a.Sprite.call(this, t, 0, 0), this.map = e, this.index = i, this.layer = e.layers[i], this.canvas = PIXI.CanvasPool.create(this, s, n), this.context = this.canvas.getContext("2d"), this.setTexture(new PIXI.Texture(new PIXI.BaseTexture(this.canvas))), this.type = a.TILEMAPLAYER, this.physicsType = a.TILEMAPLAYER, this.renderSettings = {
                    enableScrollDelta: !1,
                    overdrawRatio: .2,
                    copyCanvas: null
                }, this.debug = !1, this.exists = !0, this.debugSettings = {
                    missingImageFill: "rgb(255,255,255)",
                    debuggedTileOverfill: "rgba(0,255,0,0.4)",
                    forceFullRedraw: !0,
                    debugAlpha: .5,
                    facingEdgeStroke: "rgba(0,255,0,1)",
                    collidingTileOverfill: "rgba(0,255,0,0.2)"
                }, this.scrollFactorX = 1, this.scrollFactorY = 1, this.dirty = !0, this.rayStepRate = 4, this._wrap = !1, this._mc = {
                    scrollX: 0,
                    scrollY: 0,
                    renderWidth: 0,
                    renderHeight: 0,
                    tileWidth: e.tileWidth,
                    tileHeight: e.tileHeight,
                    cw: e.tileWidth,
                    ch: e.tileHeight,
                    tilesets: []
                }, this._scrollX = 0, this._scrollY = 0, this._results = [], t.device.canvasBitBltShift || (this.renderSettings.copyCanvas = a.TilemapLayer.ensureSharedCopyCanvas()), this.fixedToCamera = !0
            }, a.TilemapLayer.prototype = Object.create(a.Sprite.prototype), a.TilemapLayer.prototype.constructor = a.TilemapLayer, a.TilemapLayer.prototype.preUpdateCore = a.Component.Core.preUpdate, a.TilemapLayer.sharedCopyCanvas = null, a.TilemapLayer.ensureSharedCopyCanvas = function() {
                return this.sharedCopyCanvas || (this.sharedCopyCanvas = PIXI.CanvasPool.create(this, 2, 2)), this.sharedCopyCanvas
            }, a.TilemapLayer.prototype.preUpdate = function() {
                return this.preUpdateCore()
            }, a.TilemapLayer.prototype.postUpdate = function() {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y
            }, a.TilemapLayer.prototype._renderCanvas = function(t) {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderCanvas.call(this, t)
            }, a.TilemapLayer.prototype._renderWebGL = function(t) {
                this.fixedToCamera && (this.position.x = (this.game.camera.view.x + this.cameraOffset.x) / this.game.camera.scale.x, this.position.y = (this.game.camera.view.y + this.cameraOffset.y) / this.game.camera.scale.y), this._scrollX = this.game.camera.view.x * this.scrollFactorX / this.scale.x, this._scrollY = this.game.camera.view.y * this.scrollFactorY / this.scale.y, this.render(), PIXI.Sprite.prototype._renderWebGL.call(this, t)
            }, a.TilemapLayer.prototype.destroy = function() {
                PIXI.CanvasPool.remove(this), a.Component.Destroy.prototype.destroy.call(this)
            }, a.TilemapLayer.prototype.resize = function(t, e) {
                this.canvas.width = t, this.canvas.height = e, this.texture.frame.resize(t, e), this.texture.width = t, this.texture.height = e, this.texture.crop.width = t, this.texture.crop.height = e, this.texture.baseTexture.width = t, this.texture.baseTexture.height = e, this.texture.baseTexture.dirty(), this.texture.requiresUpdate = !0, this.texture._updateUvs(), this.dirty = !0
            }, a.TilemapLayer.prototype.resizeWorld = function() {
                this.game.world.setBounds(0, 0, this.layer.widthInPixels * this.scale.x, this.layer.heightInPixels * this.scale.y)
            }, a.TilemapLayer.prototype._fixX = function(t) {
                return 1 === this.scrollFactorX || 0 === this.scrollFactorX && 0 === this.position.x ? t : 0 === this.scrollFactorX && 0 !== this.position.x ? t - this.position.x : this._scrollX + (t - this._scrollX / this.scrollFactorX)
            }, a.TilemapLayer.prototype._unfixX = function(t) {
                return 1 === this.scrollFactorX ? t : this._scrollX / this.scrollFactorX + (t - this._scrollX)
            }, a.TilemapLayer.prototype._fixY = function(t) {
                return 1 === this.scrollFactorY || 0 === this.scrollFactorY && 0 === this.position.y ? t : 0 === this.scrollFactorY && 0 !== this.position.y ? t - this.position.y : this._scrollY + (t - this._scrollY / this.scrollFactorY)
            }, a.TilemapLayer.prototype._unfixY = function(t) {
                return 1 === this.scrollFactorY ? t : this._scrollY / this.scrollFactorY + (t - this._scrollY)
            }, a.TilemapLayer.prototype.getTileX = function(t) {
                return Math.floor(this._fixX(t) / this._mc.tileWidth)
            }, a.TilemapLayer.prototype.getTileY = function(t) {
                return Math.floor(this._fixY(t) / this._mc.tileHeight)
            }, a.TilemapLayer.prototype.getTileXY = function(t, e, i) {
                return i.x = this.getTileX(t), i.y = this.getTileY(e), i
            }, a.TilemapLayer.prototype.getRayCastTiles = function(t, e, i, s) {
                e || (e = this.rayStepRate), void 0 === i && (i = !1), void 0 === s && (s = !1);
                var n = this.getTiles(t.x, t.y, t.width, t.height, i, s);
                if (0 === n.length) return [];
                for (var a = t.coordinatesOnLine(e), o = [], r = 0; r < n.length; r++)
                    for (var h = 0; h < a.length; h++) {
                        var l = n[r],
                            c = a[h];
                        if (l.containsPoint(c[0], c[1])) {
                            o.push(l);
                            break
                        }
                    }
                return o
            }, a.TilemapLayer.prototype.getTiles = function(t, e, i, s, n, a) {
                void 0 === n && (n = !1), void 0 === a && (a = !1);
                var o = !(n || a);
                t = this._fixX(t), e = this._fixY(e);
                for (var r = Math.floor(t / (this._mc.cw * this.scale.x)), h = Math.floor(e / (this._mc.ch * this.scale.y)), l = Math.ceil((t + i) / (this._mc.cw * this.scale.x)) - r, c = Math.ceil((e + s) / (this._mc.ch * this.scale.y)) - h; this._results.length;) this._results.pop();
                for (var u = h; u < h + c; u++)
                    for (var d = r; d < r + l; d++) {
                        var p = this.layer.data[u];
                        p && p[d] && (o || p[d].isInteresting(n, a)) && this._results.push(p[d])
                    }
                return this._results.slice()
            }, a.TilemapLayer.prototype.resolveTileset = function(t) {
                var e = this._mc.tilesets;
                if (t < 2e3)
                    for (; e.length < t;) e.push(void 0);
                var i = this.map.tiles[t] && this.map.tiles[t][2];
                if (null !== i) {
                    var s = this.map.tilesets[i];
                    if (s && s.containsTileIndex(t)) return e[t] = s
                }
                return e[t] = null
            }, a.TilemapLayer.prototype.resetTilesetCache = function() {
                for (var t = this._mc.tilesets; t.length;) t.pop()
            }, a.TilemapLayer.prototype.setScale = function(t, e) {
                t = t || 1, e = e || t;
                for (var i = 0; i < this.layer.data.length; i++)
                    for (var s = this.layer.data[i], n = 0; n < s.length; n++) {
                        var a = s[n];
                        a.width = this.map.tileWidth * t, a.height = this.map.tileHeight * e, a.worldX = a.x * a.width, a.worldY = a.y * a.height
                    }
                this.scale.setTo(t, e)
            }, a.TilemapLayer.prototype.shiftCanvas = function(t, e, i) {
                var s = t.canvas,
                    n = s.width - Math.abs(e),
                    a = s.height - Math.abs(i),
                    o = 0,
                    r = 0,
                    h = e,
                    l = i;
                e < 0 && (o = -e, h = 0), i < 0 && (r = -i, l = 0);
                var c = this.renderSettings.copyCanvas;
                if (c) {
                    (c.width < n || c.height < a) && (c.width = n, c.height = a);
                    var u = c.getContext("2d");
                    u.clearRect(0, 0, n, a), u.drawImage(s, o, r, n, a, 0, 0, n, a), t.clearRect(h, l, n, a), t.drawImage(c, 0, 0, n, a, h, l, n, a)
                } else t.save(), t.globalCompositeOperation = "copy", t.drawImage(s, o, r, n, a, h, l, n, a), t.restore()
            }, a.TilemapLayer.prototype.renderRegion = function(t, e, i, s, n, a) {
                var o = this.context,
                    r = this.layer.width,
                    h = this.layer.height,
                    l = this._mc.tileWidth,
                    c = this._mc.tileHeight,
                    u = this._mc.tilesets,
                    d = NaN;
                this._wrap || (i <= n && (i = Math.max(0, i), n = Math.min(r - 1, n)), s <= a && (s = Math.max(0, s), a = Math.min(h - 1, a)));
                var p = i * l - t,
                    f = s * c - e,
                    g = (i + (1 << 20) * r) % r,
                    y = (s + (1 << 20) * h) % h,
                    m, v, b, x, _, w;
                for (x = y, w = a - s, v = f; w >= 0; x++, w--, v += c) {
                    x >= h && (x -= h);
                    var C = this.layer.data[x];
                    for (b = g, _ = n - i, m = p; _ >= 0; b++, _--, m += l) {
                        b >= r && (b -= r);
                        var P = C[b];
                        if (P && !(P.index < 0)) {
                            var T = P.index,
                                S = u[T];
                            void 0 === S && (S = this.resolveTileset(T)), P.alpha === d || this.debug || (o.globalAlpha = P.alpha, d = P.alpha), S ? P.rotation || P.flipped ? (o.save(), o.translate(m + P.centerX, v + P.centerY), o.rotate(P.rotation), P.flipped && o.scale(-1, 1), S.draw(o, -P.centerX, -P.centerY, T), o.restore()) : S.draw(o, m, v, T) : this.debugSettings.missingImageFill && (o.fillStyle = this.debugSettings.missingImageFill, o.fillRect(m, v, l, c)), P.debug && this.debugSettings.debuggedTileOverfill && (o.fillStyle = this.debugSettings.debuggedTileOverfill, o.fillRect(m, v, l, c))
                        }
                    }
                }
            }, a.TilemapLayer.prototype.renderDeltaScroll = function(t, e) {
                var i = this._mc.scrollX,
                    s = this._mc.scrollY,
                    n = this.canvas.width,
                    a = this.canvas.height,
                    o = this._mc.tileWidth,
                    r = this._mc.tileHeight,
                    h = 0,
                    l = -o,
                    c = 0,
                    u = -r;
                if (t < 0 ? (h = n + t, l = n - 1) : t > 0 && (l = t), e < 0 ? (c = a + e, u = a - 1) : e > 0 && (u = e), this.shiftCanvas(this.context, t, e), h = Math.floor((h + i) / o), l = Math.floor((l + i) / o), c = Math.floor((c + s) / r), u = Math.floor((u + s) / r), h <= l) {
                    this.context.clearRect(h * o - i, 0, (l - h + 1) * o, a);
                    var d = Math.floor((0 + s) / r),
                        p = Math.floor((a - 1 + s) / r);
                    this.renderRegion(i, s, h, d, l, p)
                }
                if (c <= u) {
                    this.context.clearRect(0, c * r - s, n, (u - c + 1) * r);
                    var f = Math.floor((0 + i) / o),
                        g = Math.floor((n - 1 + i) / o);
                    this.renderRegion(i, s, f, c, g, u)
                }
            }, a.TilemapLayer.prototype.renderFull = function() {
                var t = this._mc.scrollX,
                    e = this._mc.scrollY,
                    i = this.canvas.width,
                    s = this.canvas.height,
                    n = this._mc.tileWidth,
                    a = this._mc.tileHeight,
                    o = Math.floor(t / n),
                    r = Math.floor((i - 1 + t) / n),
                    h = Math.floor(e / a),
                    l = Math.floor((s - 1 + e) / a);
                this.context.clearRect(0, 0, i, s), this.renderRegion(t, e, o, h, r, l)
            }, a.TilemapLayer.prototype.render = function() {
                var t = !1;
                if (this.visible) {
                    (this.dirty || this.layer.dirty) && (this.layer.dirty = !1, t = !0);
                    var e = this.canvas.width,
                        i = this.canvas.height,
                        s = 0 | this._scrollX,
                        n = 0 | this._scrollY,
                        a = this._mc,
                        o = a.scrollX - s,
                        r = a.scrollY - n;
                    if (t || 0 !== o || 0 !== r || a.renderWidth !== e || a.renderHeight !== i) return this.context.save(), a.scrollX = s, a.scrollY = n, a.renderWidth === e && a.renderHeight === i || (a.renderWidth = e, a.renderHeight = i), this.debug && (this.context.globalAlpha = this.debugSettings.debugAlpha, this.debugSettings.forceFullRedraw && (t = !0)), !t && this.renderSettings.enableScrollDelta && Math.abs(o) + Math.abs(r) < Math.min(e, i) ? this.renderDeltaScroll(o, r) : this.renderFull(), this.debug && (this.context.globalAlpha = 1, this.renderDebug()), this.texture.baseTexture.dirty(), this.dirty = !1, this.context.restore(), !0
                }
            }, a.TilemapLayer.prototype.renderDebug = function() {
                var t = this._mc.scrollX,
                    e = this._mc.scrollY,
                    i = this.context,
                    s = this.canvas.width,
                    n = this.canvas.height,
                    a = this.layer.width,
                    o = this.layer.height,
                    r = this._mc.tileWidth,
                    h = this._mc.tileHeight,
                    l = Math.floor(t / r),
                    c = Math.floor((s - 1 + t) / r),
                    u = Math.floor(e / h),
                    d = Math.floor((n - 1 + e) / h),
                    p = l * r - t,
                    f = u * h - e,
                    g = (l + (1 << 20) * a) % a,
                    y = (u + (1 << 20) * o) % o,
                    m, v, b, x, _, w;
                for (i.strokeStyle = this.debugSettings.facingEdgeStroke, x = y, w = d - u, v = f; w >= 0; x++, w--, v += h) {
                    x >= o && (x -= o);
                    var C = this.layer.data[x];
                    for (b = g, _ = c - l, m = p; _ >= 0; b++, _--, m += r) {
                        b >= a && (b -= a);
                        var P = C[b];
                        !P || P.index < 0 || !P.collides || (this.debugSettings.collidingTileOverfill && (i.fillStyle = this.debugSettings.collidingTileOverfill, i.fillRect(m, v, this._mc.cw, this._mc.ch)), this.debugSettings.facingEdgeStroke && (i.beginPath(), P.faceTop && (i.moveTo(m, v), i.lineTo(m + this._mc.cw, v)), P.faceBottom && (i.moveTo(m, v + this._mc.ch), i.lineTo(m + this._mc.cw, v + this._mc.ch)), P.faceLeft && (i.moveTo(m, v), i.lineTo(m, v + this._mc.ch)), P.faceRight && (i.moveTo(m + this._mc.cw, v), i.lineTo(m + this._mc.cw, v + this._mc.ch)), i.closePath(), i.stroke()))
                    }
                }
            }, Object.defineProperty(a.TilemapLayer.prototype, "wrap", {
                get: function() {
                    return this._wrap
                },
                set: function(t) {
                    this._wrap = t, this.dirty = !0
                }
            }), Object.defineProperty(a.TilemapLayer.prototype, "scrollX", {
                get: function() {
                    return this._scrollX
                },
                set: function(t) {
                    this._scrollX = t
                }
            }), Object.defineProperty(a.TilemapLayer.prototype, "scrollY", {
                get: function() {
                    return this._scrollY
                },
                set: function(t) {
                    this._scrollY = t
                }
            }), Object.defineProperty(a.TilemapLayer.prototype, "collisionWidth", {
                get: function() {
                    return this._mc.cw
                },
                set: function(t) {
                    this._mc.cw = 0 | t, this.dirty = !0
                }
            }), Object.defineProperty(a.TilemapLayer.prototype, "collisionHeight", {
                get: function() {
                    return this._mc.ch
                },
                set: function(t) {
                    this._mc.ch = 0 | t, this.dirty = !0
                }
            }), a.TilemapParser = {
                INSERT_NULL: !1,
                parse: function(t, e, i, s, n, o) {
                    if (void 0 === i && (i = 32), void 0 === s && (s = 32), void 0 === n && (n = 10), void 0 === o && (o = 10), void 0 === e) return this.getEmptyData();
                    if (null === e) return this.getEmptyData(i, s, n, o);
                    var r = t.cache.getTilemapData(e);
                    if (r) {
                        if (r.format === a.Tilemap.CSV) return this.parseCSV(e, r.data, i, s);
                        if (!r.format || r.format === a.Tilemap.TILED_JSON) return this.parseTiledJSON(r.data)
                    }
                },
                parseCSV: function(t, e, i, s) {
                    var n = this.getEmptyData();
                    e = e.trim();
                    for (var o = [], r = e.split("\n"), h = r.length, l = 0, c = 0; c < r.length; c++) {
                        o[c] = [];
                        for (var u = r[c].split(","), d = 0; d < u.length; d++) o[c][d] = new a.Tile(n.layers[0], parseInt(u[d], 10), d, c, i, s);
                        0 === l && (l = u.length)
                    }
                    return n.format = a.Tilemap.CSV, n.name = t, n.width = l, n.height = h, n.tileWidth = i, n.tileHeight = s, n.widthInPixels = l * i, n.heightInPixels = h * s, n.layers[0].width = l, n.layers[0].height = h, n.layers[0].widthInPixels = n.widthInPixels, n.layers[0].heightInPixels = n.heightInPixels, n.layers[0].data = o, n
                },
                getEmptyData: function(t, e, i, s) {
                    return {
                        width: void 0 !== i && null !== i ? i : 0,
                        height: void 0 !== s && null !== s ? s : 0,
                        tileWidth: void 0 !== t && null !== t ? t : 0,
                        tileHeight: void 0 !== e && null !== e ? e : 0,
                        orientation: "orthogonal",
                        version: "1",
                        properties: {},
                        widthInPixels: 0,
                        heightInPixels: 0,
                        layers: [{
                            name: "layer",
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0,
                            widthInPixels: 0,
                            heightInPixels: 0,
                            alpha: 1,
                            visible: !0,
                            properties: {},
                            indexes: [],
                            callbacks: [],
                            bodies: [],
                            data: []
                        }],
                        images: [],
                        objects: {},
                        collision: {},
                        tilesets: [],
                        tiles: []
                    }
                },
                parseTiledJSON: function(t) {
                    function e(t, e) {
                        var i = {};
                        for (var s in e) {
                            var n = e[s];
                            void 0 !== t[n] && (i[n] = t[n])
                        }
                        return i
                    }
                    if ("orthogonal" !== t.orientation) return null;
                    for (var i = {
                            width: t.width,
                            height: t.height,
                            tileWidth: t.tilewidth,
                            tileHeight: t.tileheight,
                            orientation: t.orientation,
                            format: a.Tilemap.TILED_JSON,
                            version: t.version,
                            properties: t.properties,
                            widthInPixels: t.width * t.tilewidth,
                            heightInPixels: t.height * t.tileheight
                        }, s = [], n = 0; n < t.layers.length; n++)
                        if ("tilelayer" === t.layers[n].type) {
                            var o = t.layers[n];
                            if (!o.compression && o.encoding && "base64" === o.encoding) {
                                for (var r = window.atob(o.data), h = r.length, l = new Array(h), c = 0; c < h; c += 4) l[c / 4] = (r.charCodeAt(c) | r.charCodeAt(c + 1) << 8 | r.charCodeAt(c + 2) << 16 | r.charCodeAt(c + 3) << 24) >>> 0;
                                o.data = l, delete o.encoding
                            } else if (o.compression) continue;
                            var u = {
                                name: o.name,
                                x: o.x,
                                y: o.y,
                                width: o.width,
                                height: o.height,
                                widthInPixels: o.width * t.tilewidth,
                                heightInPixels: o.height * t.tileheight,
                                alpha: o.opacity,
                                visible: o.visible,
                                properties: {},
                                indexes: [],
                                callbacks: [],
                                bodies: []
                            };
                            o.properties && (u.properties = o.properties);
                            for (var d = 0, p = [], f = [], g, y, m, v, b = 0, h = o.data.length; b < h; b++) {
                                if (g = 0, y = !1, v = o.data[b], m = 0, v > 536870912) switch (v > 2147483648 && (v -= 2147483648, m += 4), v > 1073741824 && (v -= 1073741824, m += 2), v > 536870912 && (v -= 536870912, m += 1), m) {
                                    case 5:
                                        g = Math.PI / 2;
                                        break;
                                    case 6:
                                        g = Math.PI;
                                        break;
                                    case 3:
                                        g = 3 * Math.PI / 2;
                                        break;
                                    case 4:
                                        g = 0, y = !0;
                                        break;
                                    case 7:
                                        g = Math.PI / 2, y = !0;
                                        break;
                                    case 2:
                                        g = Math.PI, y = !0;
                                        break;
                                    case 1:
                                        g = 3 * Math.PI / 2, y = !0
                                }
                                if (v > 0) {
                                    var x = new a.Tile(u, v, d, f.length, t.tilewidth, t.tileheight);
                                    x.rotation = g, x.flipped = y, 0 !== m && (x.flippedVal = m), p.push(x)
                                } else a.TilemapParser.INSERT_NULL ? p.push(null) : p.push(new a.Tile(u, -1, d, f.length, t.tilewidth, t.tileheight));
                                d++, d === o.width && (f.push(p), d = 0, p = [])
                            }
                            u.data = f, s.push(u)
                        } i.layers = s;
                    for (var _ = [], n = 0; n < t.layers.length; n++)
                        if ("imagelayer" === t.layers[n].type) {
                            var w = t.layers[n],
                                C = {
                                    name: w.name,
                                    image: w.image,
                                    x: w.x,
                                    y: w.y,
                                    alpha: w.opacity,
                                    visible: w.visible,
                                    properties: {}
                                };
                            w.properties && (C.properties = w.properties), _.push(C)
                        } i.images = _;
                    for (var P = [], T = [], S = null, n = 0; n < t.tilesets.length; n++) {
                        var A = t.tilesets[n];
                        if (A.image) {
                            var E = new a.Tileset(A.name, A.firstgid, A.tilewidth, A.tileheight, A.margin, A.spacing, A.properties);
                            A.tileproperties && (E.tileProperties = A.tileproperties), E.updateTileData(A.imagewidth, A.imageheight), P.push(E)
                        } else {
                            var I = new a.ImageCollection(A.name, A.firstgid, A.tilewidth, A.tileheight, A.margin, A.spacing, A.properties);
                            for (var M in A.tiles) {
                                var C = A.tiles[M].image,
                                    v = A.firstgid + parseInt(M, 10);
                                I.addImage(v, C)
                            }
                            T.push(I)
                        }
                        S && (S.lastgid = A.firstgid - 1), S = A
                    }
                    i.tilesets = P, i.imagecollections = T;
                    for (var O = {}, B = {}, n = 0; n < t.layers.length; n++)
                        if ("objectgroup" === t.layers[n].type) {
                            var R = t.layers[n];
                            O[R.name] = [], B[R.name] = [];
                            for (var k = 0, h = R.objects.length; k < h; k++)
                                if (R.objects[k].gid) {
                                    var D = {
                                        gid: R.objects[k].gid,
                                        name: R.objects[k].name,
                                        type: R.objects[k].hasOwnProperty("type") ? R.objects[k].type : "",
                                        x: R.objects[k].x,
                                        y: R.objects[k].y,
                                        visible: R.objects[k].visible,
                                        properties: R.objects[k].properties
                                    };
                                    R.objects[k].rotation && (D.rotation = R.objects[k].rotation), O[R.name].push(D)
                                } else if (R.objects[k].polyline) {
                                var D = {
                                    name: R.objects[k].name,
                                    type: R.objects[k].type,
                                    x: R.objects[k].x,
                                    y: R.objects[k].y,
                                    width: R.objects[k].width,
                                    height: R.objects[k].height,
                                    visible: R.objects[k].visible,
                                    properties: R.objects[k].properties
                                };
                                R.objects[k].rotation && (D.rotation = R.objects[k].rotation), D.polyline = [];
                                for (var L = 0; L < R.objects[k].polyline.length; L++) D.polyline.push([R.objects[k].polyline[L].x, R.objects[k].polyline[L].y]);
                                B[R.name].push(D), O[R.name].push(D)
                            } else if (R.objects[k].polygon) {
                                var D = e(R.objects[k], ["name", "type", "x", "y", "visible", "rotation", "properties"]);
                                D.polygon = [];
                                for (var L = 0; L < R.objects[k].polygon.length; L++) D.polygon.push([R.objects[k].polygon[L].x, R.objects[k].polygon[L].y]);
                                O[R.name].push(D)
                            } else if (R.objects[k].ellipse) {
                                var D = e(R.objects[k], ["name", "type", "ellipse", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                                O[R.name].push(D)
                            } else {
                                var D = e(R.objects[k], ["name", "type", "x", "y", "width", "height", "visible", "rotation", "properties"]);
                                D.rectangle = !0, O[R.name].push(D)
                            }
                        } i.objects = O, i.collision = B, i.tiles = [];
                    for (var n = 0; n < i.tilesets.length; n++)
                        for (var A = i.tilesets[n], d = A.tileMargin, F = A.tileMargin, G = 0, U = 0, N = 0, b = A.firstgid; b < A.firstgid + A.total && (i.tiles[b] = [d, F, n], d += A.tileWidth + A.tileSpacing, ++G !== A.total) && (++U !== A.columns || (d = A.tileMargin, F += A.tileHeight + A.tileSpacing, U = 0, ++N !== A.rows)); b++);
                    for (var u, x, j, A, n = 0; n < i.layers.length; n++) {
                        u = i.layers[n], A = null;
                        for (var c = 0; c < u.data.length; c++) {
                            p = u.data[c];
                            for (var W = 0; W < p.length; W++) null === (x = p[W]) || x.index < 0 || (j = i.tiles[x.index][2], A = i.tilesets[j], A.tileProperties && A.tileProperties[x.index - A.firstgid] && (x.properties = a.Utils.mixin(A.tileProperties[x.index - A.firstgid], x.properties)))
                        }
                    }
                    return i
                }
            }, a.Tileset = function(t, e, i, s, n, a, o) {
                (void 0 === i || i <= 0) && (i = 32), (void 0 === s || s <= 0) && (s = 32), void 0 === n && (n = 0), void 0 === a && (a = 0), this.name = t, this.firstgid = 0 | e, this.tileWidth = 0 | i, this.tileHeight = 0 | s, this.tileMargin = 0 | n, this.tileSpacing = 0 | a, this.properties = o || {}, this.image = null, this.rows = 0, this.columns = 0, this.total = 0, this.drawCoords = []
            }, a.Tileset.prototype = {
                draw: function(t, e, i, s) {
                    var n = s - this.firstgid << 1;
                    n >= 0 && n + 1 < this.drawCoords.length && t.drawImage(this.image, this.drawCoords[n], this.drawCoords[n + 1], this.tileWidth, this.tileHeight, e, i, this.tileWidth, this.tileHeight)
                },
                containsTileIndex: function(t) {
                    return t >= this.firstgid && t < this.firstgid + this.total
                },
                setImage: function(t) {
                    this.image = t, this.updateTileData(t.width, t.height)
                },
                setSpacing: function(t, e) {
                    this.tileMargin = 0 | t, this.tileSpacing = 0 | e, this.image && this.updateTileData(this.image.width, this.image.height)
                },
                updateTileData: function(t, e) {
                    var i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing),
                        s = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing);
                    i = Math.floor(i), s = Math.floor(s), this.rows && this.rows !== i || this.columns && this.columns, this.rows = i, this.columns = s, this.total = i * s, this.drawCoords.length = 0;
                    for (var n = this.tileMargin, a = this.tileMargin, o = 0; o < this.rows; o++) {
                        for (var r = 0; r < this.columns; r++) this.drawCoords.push(n), this.drawCoords.push(a), n += this.tileWidth + this.tileSpacing;
                        n = this.tileMargin, a += this.tileHeight + this.tileSpacing
                    }
                }
            }, a.Tileset.prototype.constructor = a.Tileset, a.Particle = function(t, e, i, s, n) {
                a.Sprite.call(this, t, e, i, s, n), this.autoScale = !1, this.scaleData = null, this._s = 0, this.autoAlpha = !1, this.alphaData = null, this._a = 0
            }, a.Particle.prototype = Object.create(a.Sprite.prototype), a.Particle.prototype.constructor = a.Particle, a.Particle.prototype.update = function() {
                this.autoScale && (this._s--, this._s ? this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y) : this.autoScale = !1), this.autoAlpha && (this._a--, this._a ? this.alpha = this.alphaData[this._a].v : this.autoAlpha = !1)
            }, a.Particle.prototype.onEmit = function() {}, a.Particle.prototype.setAlphaData = function(t) {
                this.alphaData = t, this._a = t.length - 1, this.alpha = this.alphaData[this._a].v, this.autoAlpha = !0
            }, a.Particle.prototype.setScaleData = function(t) {
                this.scaleData = t, this._s = t.length - 1, this.scale.set(this.scaleData[this._s].x, this.scaleData[this._s].y), this.autoScale = !0
            }, a.Particle.prototype.reset = function(t, e, i) {
                return a.Component.Reset.prototype.reset.call(this, t, e, i), this.alpha = 1, this.scale.set(1), this.autoScale = !1, this.autoAlpha = !1, this
            }, a.Particles = function(t) {
                this.game = t, this.emitters = {}, this.ID = 0
            }, a.Particles.prototype = {
                add: function(t) {
                    return this.emitters[t.name] = t, t
                },
                remove: function(t) {
                    delete this.emitters[t.name]
                },
                update: function() {
                    for (var t in this.emitters) this.emitters[t].exists && this.emitters[t].update()
                }
            }, a.Particles.prototype.constructor = a.Particles, a.Particles.Arcade = {}, a.Particles.Arcade.Emitter = function(t, e, i, s) {
                this.maxParticles = s || 50, a.Group.call(this, t), this.name = "emitter" + this.game.particles.ID++, this.type = a.EMITTER, this.physicsType = a.GROUP, this.area = new a.Rectangle(e, i, 1, 1), this.minParticleSpeed = new a.Point(-100, -100), this.maxParticleSpeed = new a.Point(100, 100), this.minParticleScale = 1, this.maxParticleScale = 1, this.scaleData = null, this.minRotation = -360, this.maxRotation = 360, this.minParticleAlpha = 1, this.maxParticleAlpha = 1, this.alphaData = null, this.gravity = 100, this.particleClass = a.Particle, this.particleDrag = new a.Point, this.angularDrag = 0, this.frequency = 100, this.lifespan = 2e3, this.bounce = new a.Point, this.on = !1, this.particleAnchor = new a.Point(.5, .5), this.blendMode = a.blendModes.NORMAL, this.emitX = e, this.emitY = i, this.autoScale = !1, this.autoAlpha = !1, this.particleBringToTop = !1, this.particleSendToBack = !1, this._minParticleScale = new a.Point(1, 1), this._maxParticleScale = new a.Point(1, 1), this._quantity = 0, this._timer = 0, this._counter = 0, this._flowQuantity = 0, this._flowTotal = 0, this._explode = !0, this._frames = null
            }, a.Particles.Arcade.Emitter.prototype = Object.create(a.Group.prototype), a.Particles.Arcade.Emitter.prototype.constructor = a.Particles.Arcade.Emitter, a.Particles.Arcade.Emitter.prototype.update = function() {
                if (this.on && this.game.time.time >= this._timer)
                    if (this._timer = this.game.time.time + this.frequency * this.game.time.slowMotion, 0 !== this._flowTotal)
                        if (this._flowQuantity > 0) {
                            for (var t = 0; t < this._flowQuantity; t++)
                                if (this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal)) {
                                    this.on = !1;
                                    break
                                }
                        } else this.emitParticle() && (this._counter++, -1 !== this._flowTotal && this._counter >= this._flowTotal && (this.on = !1));
                else this.emitParticle() && (this._counter++, this._quantity > 0 && this._counter >= this._quantity && (this.on = !1));
                for (var t = this.children.length; t--;) this.children[t].exists && this.children[t].update()
            }, a.Particles.Arcade.Emitter.prototype.makeParticles = function(t, e, i, s, n) {
                void 0 === e && (e = 0), void 0 === i && (i = this.maxParticles), void 0 === s && (s = !1), void 0 === n && (n = !1);
                var a, o = 0,
                    r = t,
                    h = e;
                for (this._frames = e, i > this.maxParticles && (this.maxParticles = i); o < i;) Array.isArray(t) && (r = this.game.rnd.pick(t)), Array.isArray(e) && (h = this.game.rnd.pick(e)), a = new this.particleClass(this.game, 0, 0, r, h), this.game.physics.arcade.enable(a, !1), s ? (a.body.checkCollision.any = !0, a.body.checkCollision.none = !1) : a.body.checkCollision.none = !0, a.body.collideWorldBounds = n, a.body.skipQuadTree = !0, a.exists = !1, a.visible = !1, a.anchor.copyFrom(this.particleAnchor), this.add(a), o++;
                return this
            }, a.Particles.Arcade.Emitter.prototype.kill = function() {
                return this.on = !1, this.alive = !1, this.exists = !1, this
            }, a.Particles.Arcade.Emitter.prototype.revive = function() {
                return this.alive = !0, this.exists = !0, this
            }, a.Particles.Arcade.Emitter.prototype.explode = function(t, e) {
                return this._flowTotal = 0, this.start(!0, t, 0, e, !1), this
            }, a.Particles.Arcade.Emitter.prototype.flow = function(t, e, i, s, n) {
                return void 0 !== i && 0 !== i || (i = 1), void 0 === s && (s = -1), void 0 === n && (n = !0), i > this.maxParticles && (i = this.maxParticles), this._counter = 0, this._flowQuantity = i, this._flowTotal = s, n ? (this.start(!0, t, e, i), this._counter += i, this.on = !0, this._timer = this.game.time.time + e * this.game.time.slowMotion) : this.start(!1, t, e, i), this
            }, a.Particles.Arcade.Emitter.prototype.start = function(t, e, i, s, n) {
                if (void 0 === t && (t = !0), void 0 === e && (e = 0), void 0 !== i && null !== i || (i = 250), void 0 === s && (s = 0), void 0 === n && (n = !1), s > this.maxParticles && (s = this.maxParticles), this.revive(), this.visible = !0, this.lifespan = e, this.frequency = i, t || n)
                    for (var a = 0; a < s; a++) this.emitParticle();
                else this.on = !0, this._quantity = s, this._counter = 0, this._timer = this.game.time.time + i * this.game.time.slowMotion;
                return this
            }, a.Particles.Arcade.Emitter.prototype.emitParticle = function(t, e, i, s) {
                void 0 === t && (t = null), void 0 === e && (e = null);
                var n = this.getFirstExists(!1);
                if (null === n) return !1;
                var a = this.game.rnd;
                void 0 !== i && void 0 !== s ? n.loadTexture(i, s) : void 0 !== i && n.loadTexture(i);
                var o = this.emitX,
                    r = this.emitY;
                null !== t ? o = t : this.width > 1 && (o = a.between(this.left, this.right)), null !== e ? r = e : this.height > 1 && (r = a.between(this.top, this.bottom)), n.reset(o, r), n.angle = 0, n.lifespan = this.lifespan, this.particleBringToTop ? this.bringToTop(n) : this.particleSendToBack && this.sendToBack(n), this.autoScale ? n.setScaleData(this.scaleData) : 1 !== this.minParticleScale || 1 !== this.maxParticleScale ? n.scale.set(a.realInRange(this.minParticleScale, this.maxParticleScale)) : this._minParticleScale.x === this._maxParticleScale.x && this._minParticleScale.y === this._maxParticleScale.y || n.scale.set(a.realInRange(this._minParticleScale.x, this._maxParticleScale.x), a.realInRange(this._minParticleScale.y, this._maxParticleScale.y)), void 0 === s && (Array.isArray(this._frames) ? n.frame = this.game.rnd.pick(this._frames) : n.frame = this._frames), this.autoAlpha ? n.setAlphaData(this.alphaData) : n.alpha = a.realInRange(this.minParticleAlpha, this.maxParticleAlpha), n.blendMode = this.blendMode;
                var h = n.body;
                return h.updateBounds(), h.bounce.copyFrom(this.bounce), h.drag.copyFrom(this.particleDrag), h.velocity.x = a.between(this.minParticleSpeed.x, this.maxParticleSpeed.x), h.velocity.y = a.between(this.minParticleSpeed.y, this.maxParticleSpeed.y), h.angularVelocity = a.between(this.minRotation, this.maxRotation), h.gravity.y = this.gravity, h.angularDrag = this.angularDrag, n.onEmit(), !0
            }, a.Particles.Arcade.Emitter.prototype.destroy = function() {
                this.game.particles.remove(this), a.Group.prototype.destroy.call(this, !0, !1)
            }, a.Particles.Arcade.Emitter.prototype.setSize = function(t, e) {
                return this.area.width = t, this.area.height = e, this
            }, a.Particles.Arcade.Emitter.prototype.setXSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.x = t, this.maxParticleSpeed.x = e, this
            }, a.Particles.Arcade.Emitter.prototype.setYSpeed = function(t, e) {
                return t = t || 0, e = e || 0, this.minParticleSpeed.y = t, this.maxParticleSpeed.y = e, this
            }, a.Particles.Arcade.Emitter.prototype.setRotation = function(t, e) {
                return t = t || 0, e = e || 0, this.minRotation = t, this.maxRotation = e, this
            }, a.Particles.Arcade.Emitter.prototype.setAlpha = function(t, e, i, s, n) {
                if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === s && (s = a.Easing.Linear.None), void 0 === n && (n = !1), this.minParticleAlpha = t, this.maxParticleAlpha = e, this.autoAlpha = !1, i > 0 && t !== e) {
                    var o = {
                            v: t
                        },
                        r = this.game.make.tween(o)
                        .to({
                            v: e
                        }, i, s);
                    r.yoyo(n), this.alphaData = r.generateData(60), this.alphaData.reverse(), this.autoAlpha = !0
                }
                return this
            }, a.Particles.Arcade.Emitter.prototype.setScale = function(t, e, i, s, n, o, r) {
                if (void 0 === t && (t = 1), void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === s && (s = 1), void 0 === n && (n = 0), void 0 === o && (o = a.Easing.Linear.None), void 0 === r && (r = !1), this.minParticleScale = 1, this.maxParticleScale = 1, this._minParticleScale.set(t, i), this._maxParticleScale.set(e, s), this.autoScale = !1, n > 0 && (t !== e || i !== s)) {
                    var h = {
                            x: t,
                            y: i
                        },
                        l = this.game.make.tween(h)
                        .to({
                            x: e,
                            y: s
                        }, n, o);
                    l.yoyo(r), this.scaleData = l.generateData(60), this.scaleData.reverse(), this.autoScale = !0
                }
                return this
            }, a.Particles.Arcade.Emitter.prototype.at = function(t) {
                return t.center ? (this.emitX = t.center.x, this.emitY = t.center.y) : (this.emitX = t.world.x + t.anchor.x * t.width, this.emitY = t.world.y + t.anchor.y * t.height), this
            }, Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "width", {
                get: function() {
                    return this.area.width
                },
                set: function(t) {
                    this.area.width = t
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "height", {
                get: function() {
                    return this.area.height
                },
                set: function(t) {
                    this.area.height = t
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "x", {
                get: function() {
                    return this.emitX
                },
                set: function(t) {
                    this.emitX = t
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "y", {
                get: function() {
                    return this.emitY
                },
                set: function(t) {
                    this.emitY = t
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "left", {
                get: function() {
                    return Math.floor(this.x - this.area.width / 2)
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "right", {
                get: function() {
                    return Math.floor(this.x + this.area.width / 2)
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "top", {
                get: function() {
                    return Math.floor(this.y - this.area.height / 2)
                }
            }), Object.defineProperty(a.Particles.Arcade.Emitter.prototype, "bottom", {
                get: function() {
                    return Math.floor(this.y + this.area.height / 2)
                }
            }), a.Weapon = function(t, e) {
                a.Plugin.call(this, t, e), this.bullets = null, this.autoExpandBulletsGroup = !1, this.autofire = !1, this.shots = 0, this.fireLimit = 0, this.fireRate = 100, this.fireRateVariance = 0, this.fireFrom = new a.Rectangle(0, 0, 1, 1), this.fireAngle = a.ANGLE_UP, this.bulletInheritSpriteSpeed = !1, this.bulletAnimation = "", this.bulletFrameRandom = !1, this.bulletFrameCycle = !1, this.bulletWorldWrap = !1, this.bulletWorldWrapPadding = 0, this.bulletAngleOffset = 0, this.bulletAngleVariance = 0, this.bulletSpeed = 200, this.bulletSpeedVariance = 0, this.bulletLifespan = 0, this.bulletKillDistance = 0, this.bulletGravity = new a.Point(0, 0), this.bulletRotateToVelocity = !1, this.bulletKey = "", this.bulletFrame = "", this._bulletClass = a.Bullet, this._bulletCollideWorldBounds = !1, this._bulletKillType = a.Weapon.KILL_WORLD_BOUNDS, this._data = {
                    customBody: !1,
                    width: 0,
                    height: 0,
                    offsetX: 0,
                    offsetY: 0
                }, this.bounds = new a.Rectangle, this.bulletBounds = t.world.bounds, this.bulletFrames = [], this.bulletFrameIndex = 0, this.anims = {}, this.onFire = new a.Signal, this.onKill = new a.Signal, this.onFireLimit = new a.Signal, this.trackedSprite = null, this.trackedPointer = null, this.trackRotation = !1, this.trackOffset = new a.Point, this._nextFire = 0, this._rotatedPoint = new a.Point
            }, a.Weapon.prototype = Object.create(a.Plugin.prototype), a.Weapon.prototype.constructor = a.Weapon, a.Weapon.KILL_NEVER = 0, a.Weapon.KILL_LIFESPAN = 1, a.Weapon.KILL_DISTANCE = 2, a.Weapon.KILL_WEAPON_BOUNDS = 3, a.Weapon.KILL_CAMERA_BOUNDS = 4, a.Weapon.KILL_WORLD_BOUNDS = 5, a.Weapon.KILL_STATIC_BOUNDS = 6, a.Weapon.prototype.createBullets = function(t, e, i, s) {
                return void 0 === t && (t = 1), void 0 === s && (s = this.game.world), this.bullets || (this.bullets = this.game.add.physicsGroup(a.Physics.ARCADE, s), this.bullets.classType = this._bulletClass), 0 !== t && (-1 === t && (this.autoExpandBulletsGroup = !0, t = 1), this.bullets.createMultiple(t, e, i), this.bullets.setAll("data.bulletManager", this), this.bulletKey = e, this.bulletFrame = i), this
            }, a.Weapon.prototype.forEach = function(t, e) {
                return this.bullets.forEachExists(t, e, arguments), this
            }, a.Weapon.prototype.pauseAll = function() {
                return this.bullets.setAll("body.enable", !1), this
            }, a.Weapon.prototype.resumeAll = function() {
                return this.bullets.setAll("body.enable", !0), this
            }, a.Weapon.prototype.killAll = function() {
                return this.bullets.callAllExists("kill", !0), this.bullets.setAll("body.enable", !0), this
            }, a.Weapon.prototype.resetShots = function(t) {
                return this.shots = 0, void 0 !== t && (this.fireLimit = t), this
            }, a.Weapon.prototype.destroy = function() {
                this.parent.remove(this, !1), this.bullets.destroy(), this.game = null, this.parent = null, this.active = !1, this.visible = !1
            }, a.Weapon.prototype.update = function() {
                this._bulletKillType === a.Weapon.KILL_WEAPON_BOUNDS && (this.trackedSprite ? (this.trackedSprite.updateTransform(), this.bounds.centerOn(this.trackedSprite.worldPosition.x, this.trackedSprite.worldPosition.y)) : this.trackedPointer && this.bounds.centerOn(this.trackedPointer.worldX, this.trackedPointer.worldY)), this.autofire && this.fire()
            }, a.Weapon.prototype.trackSprite = function(t, e, i, s) {
                return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === s && (s = !1), this.trackedPointer = null, this.trackedSprite = t, this.trackRotation = s, this.trackOffset.set(e, i), this
            }, a.Weapon.prototype.trackPointer = function(t, e, i) {
                return void 0 === t && (t = this.game.input.activePointer), void 0 === e && (e = 0), void 0 === i && (i = 0), this.trackedPointer = t, this.trackedSprite = null, this.trackRotation = !1, this.trackOffset.set(e, i), this
            }, a.Weapon.prototype.fire = function(t, e, i) {
                if (this.game.time.now < this._nextFire || this.fireLimit > 0 && this.shots === this.fireLimit) return !1;
                var s = this.bulletSpeed;
                0 !== this.bulletSpeedVariance && (s += a.Math.between(-this.bulletSpeedVariance, this.bulletSpeedVariance)), t ? this.fireFrom.width > 1 ? this.fireFrom.centerOn(t.x, t.y) : (this.fireFrom.x = t.x, this.fireFrom.y = t.y) : this.trackedSprite ? (this.trackRotation ? (this._rotatedPoint.set(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y), this._rotatedPoint.rotate(this.trackedSprite.world.x, this.trackedSprite.world.y, this.trackedSprite.rotation), this.fireFrom.width > 1 ? this.fireFrom.centerOn(this._rotatedPoint.x, this._rotatedPoint.y) : (this.fireFrom.x = this._rotatedPoint.x, this.fireFrom.y = this._rotatedPoint.y)) : this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedSprite.world.x + this.trackOffset.x, this.trackedSprite.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedSprite.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedSprite.world.y + this.trackOffset.y), this.bulletInheritSpriteSpeed && (s += this.trackedSprite.body.speed)) : this.trackedPointer && (this.fireFrom.width > 1 ? this.fireFrom.centerOn(this.trackedPointer.world.x + this.trackOffset.x, this.trackedPointer.world.y + this.trackOffset.y) : (this.fireFrom.x = this.trackedPointer.world.x + this.trackOffset.x, this.fireFrom.y = this.trackedPointer.world.y + this.trackOffset.y));
                var n = this.fireFrom.width > 1 ? this.fireFrom.randomX : this.fireFrom.x,
                    o = this.fireFrom.height > 1 ? this.fireFrom.randomY : this.fireFrom.y,
                    r = this.trackRotation ? this.trackedSprite.angle : this.fireAngle;
                void 0 !== e && void 0 !== i && (r = this.game.math.radToDeg(Math.atan2(i - o, e - n))), 0 !== this.bulletAngleVariance && (r += a.Math.between(-this.bulletAngleVariance, this.bulletAngleVariance));
                var h = 0,
                    l = 0;
                0 === r || 180 === r ? h = Math.cos(this.game.math.degToRad(r)) * s : 90 === r || 270 === r ? l = Math.sin(this.game.math.degToRad(r)) * s : (h = Math.cos(this.game.math.degToRad(r)) * s, l = Math.sin(this.game.math.degToRad(r)) * s);
                var c = null;
                if (this.autoExpandBulletsGroup ? (c = this.bullets.getFirstExists(!1, !0, n, o, this.bulletKey, this.bulletFrame), c.data.bulletManager = this) : c = this.bullets.getFirstExists(!1), c) {
                    if (c.reset(n, o), c.data.fromX = n, c.data.fromY = o, c.data.killType = this.bulletKillType, c.data.killDistance = this.bulletKillDistance, c.data.rotateToVelocity = this.bulletRotateToVelocity, this.bulletKillType === a.Weapon.KILL_LIFESPAN && (c.lifespan = this.bulletLifespan), c.angle = r + this.bulletAngleOffset, "" !== this.bulletAnimation) {
                        if (null === c.animations.getAnimation(this.bulletAnimation)) {
                            var u = this.anims[this.bulletAnimation];
                            c.animations.add(u.name, u.frames, u.frameRate, u.loop, u.useNumericIndex)
                        }
                        c.animations.play(this.bulletAnimation)
                    } else this.bulletFrameCycle ? (c.frame = this.bulletFrames[this.bulletFrameIndex], ++this.bulletFrameIndex >= this.bulletFrames.length && (this.bulletFrameIndex = 0)) : this.bulletFrameRandom && (c.frame = this.bulletFrames[Math.floor(Math.random() * this.bulletFrames.length)]);
                    if (c.data.bodyDirty && (this._data.customBody && c.body.setSize(this._data.width, this._data.height, this._data.offsetX, this._data.offsetY), c.body.collideWorldBounds = this.bulletCollideWorldBounds, c.data.bodyDirty = !1), c.body.velocity.set(h, l), c.body.gravity.set(this.bulletGravity.x, this.bulletGravity.y), 0 !== this.bulletSpeedVariance) {
                        var d = this.fireRate;
                        d += a.Math.between(-this.fireRateVariance, this.fireRateVariance), d < 0 && (d = 0), this._nextFire = this.game.time.now + d
                    } else this._nextFire = this.game.time.now + this.fireRate;
                    this.shots++, this.onFire.dispatch(c, this, s), this.fireLimit > 0 && this.shots === this.fireLimit && this.onFireLimit.dispatch(this, this.fireLimit)
                }
                return c
            }, a.Weapon.prototype.fireAtPointer = function(t) {
                return void 0 === t && (t = this.game.input.activePointer), this.fire(null, t.worldX, t.worldY)
            }, a.Weapon.prototype.fireAtSprite = function(t) {
                return this.fire(null, t.world.x, t.world.y)
            }, a.Weapon.prototype.fireAtXY = function(t, e) {
                return this.fire(null, t, e)
            }, a.Weapon.prototype.setBulletBodyOffset = function(t, e, i, s) {
                return void 0 === i && (i = 0), void 0 === s && (s = 0), this._data.customBody = !0, this._data.width = t, this._data.height = e, this._data.offsetX = i, this._data.offsetY = s, this.bullets.callAll("body.setSize", "body", t, e, i, s), this.bullets.setAll("data.bodyDirty", !1), this
            }, a.Weapon.prototype.setBulletFrames = function(t, e, i, s) {
                return void 0 === i && (i = !0), void 0 === s && (s = !1), this.bulletFrames = a.ArrayUtils.numberArray(t, e), this.bulletFrameIndex = 0, this.bulletFrameCycle = i, this.bulletFrameRandom = s, this
            }, a.Weapon.prototype.addBulletAnimation = function(t, e, i, s, n) {
                return this.anims[t] = {
                    name: t,
                    frames: e,
                    frameRate: i,
                    loop: s,
                    useNumericIndex: n
                }, this.bullets.callAll("animations.add", "animations", t, e, i, s, n), this.bulletAnimation = t, this
            }, a.Weapon.prototype.debug = function(t, e, i) {
                void 0 === t && (t = 16), void 0 === e && (e = 32), void 0 === i && (i = !1), this.game.debug.text("Weapon Plugin", t, e), this.game.debug.text("Bullets Alive: " + this.bullets.total + " - Total: " + this.bullets.length, t, e + 24), i && this.bullets.forEachExists(this.game.debug.body, this.game.debug, "rgba(255, 0, 255, 0.8)")
            }, Object.defineProperty(a.Weapon.prototype, "bulletClass", {
                get: function() {
                    return this._bulletClass
                },
                set: function(t) {
                    this._bulletClass = t, this.bullets.classType = this._bulletClass
                }
            }), Object.defineProperty(a.Weapon.prototype, "bulletKillType", {
                get: function() {
                    return this._bulletKillType
                },
                set: function(t) {
                    switch (t) {
                        case a.Weapon.KILL_STATIC_BOUNDS:
                        case a.Weapon.KILL_WEAPON_BOUNDS:
                            this.bulletBounds = this.bounds;
                            break;
                        case a.Weapon.KILL_CAMERA_BOUNDS:
                            this.bulletBounds = this.game.camera.view;
                            break;
                        case a.Weapon.KILL_WORLD_BOUNDS:
                            this.bulletBounds = this.game.world.bounds
                    }
                    this._bulletKillType = t
                }
            }), Object.defineProperty(a.Weapon.prototype, "bulletCollideWorldBounds", {
                get: function() {
                    return this._bulletCollideWorldBounds
                },
                set: function(t) {
                    this._bulletCollideWorldBounds = t, this.bullets.setAll("body.collideWorldBounds", t), this.bullets.setAll("data.bodyDirty", !1)
                }
            }), Object.defineProperty(a.Weapon.prototype, "x", {
                get: function() {
                    return this.fireFrom.x
                },
                set: function(t) {
                    this.fireFrom.x = t
                }
            }), Object.defineProperty(a.Weapon.prototype, "y", {
                get: function() {
                    return this.fireFrom.y
                },
                set: function(t) {
                    this.fireFrom.y = t
                }
            }), a.Bullet = function(t, e, i, s, n) {
                a.Sprite.call(this, t, e, i, s, n), this.anchor.set(.5), this.data = {
                    bulletManager: null,
                    fromX: 0,
                    fromY: 0,
                    bodyDirty: !0,
                    rotateToVelocity: !1,
                    killType: 0,
                    killDistance: 0
                }
            }, a.Bullet.prototype = Object.create(a.Sprite.prototype), a.Bullet.prototype.constructor = a.Bullet, a.Bullet.prototype.kill = function() {
                return this.alive = !1, this.exists = !1, this.visible = !1, this.data.bulletManager.onKill.dispatch(this), this
            }, a.Bullet.prototype.update = function() {
                this.exists && (this.data.killType > a.Weapon.KILL_LIFESPAN && (this.data.killType === a.Weapon.KILL_DISTANCE ? this.game.physics.arcade.distanceToXY(this, this.data.fromX, this.data.fromY, !0) > this.data.killDistance && this.kill() : this.data.bulletManager.bulletBounds.intersects(this) || this.kill()), this.data.rotateToVelocity && (this.rotation = Math.atan2(this.body.velocity.y, this.body.velocity.x)), this.data.bulletManager.bulletWorldWrap && this.game.world.wrap(this, this.data.bulletManager.bulletWorldWrapPadding))
            }, a.Video = function(t, e, i) {
                if (void 0 === e && (e = null), void 0 === i && (i = null), this.game = t, this.key = e, this.width = 0, this.height = 0, this.type = a.VIDEO, this.disableTextureUpload = !1, this.touchLocked = !1, this.onPlay = new a.Signal, this.onChangeSource = new a.Signal, this.onComplete = new a.Signal, this.onAccess = new a.Signal, this.onError = new a.Signal, this.onTimeout = new a.Signal, this.timeout = 15e3, this._timeOutID = null, this.video = null, this.videoStream = null, this.isStreaming = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._codeMuted = !1, this._muted = !1, this._codePaused = !1, this._paused = !1, this._pending = !1, this._autoplay = !1, this._endCallback = null, this._playCallback = null, e && this.game.cache.checkVideoKey(e)) {
                    var s = this.game.cache.getVideo(e);
                    s.isBlob ? this.createVideoFromBlob(s.data) : this.video = s.data, this.width = this.video.videoWidth, this.height = this.video.videoHeight
                } else i && this.createVideoFromURL(i, !1);
                this.video && !i ? (this.baseTexture = new PIXI.BaseTexture(this.video), this.baseTexture.forceLoaded(this.width, this.height)) : (this.baseTexture = new PIXI.BaseTexture(a.Cache.DEFAULT.baseTexture.source), this.baseTexture.forceLoaded(this.width, this.height)), this.texture = new PIXI.Texture(this.baseTexture), this.textureFrame = new a.Frame(0, 0, 0, this.width, this.height, "video"), this.texture.setFrame(this.textureFrame), this.texture.valid = !1, null !== e && this.video && (this.texture.valid = this.video.canplay), this.snapshot = null, a.BitmapData && (this.snapshot = new a.BitmapData(this.game, "", this.width, this.height)), !this.game.device.cocoonJS && (this.game.device.iOS || this.game.device.android) || window.PhaserGlobal && window.PhaserGlobal.fakeiOSTouchLock ? this.setTouchLock() : s && (s.locked = !1)
            }, a.Video.prototype = {
                connectToMediaStream: function(t, e) {
                    return t && e && (this.video = t, this.videoStream = e, this.isStreaming = !0, this.baseTexture.source = this.video, this.updateTexture(null, this.video.videoWidth, this.video.videoHeight), this.onAccess.dispatch(this)), this
                },
                startMediaStream: function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = null), void 0 === i && (i = null), !this.game.device.getUserMedia) return this.onError.dispatch(this, "No getUserMedia"), !1;
                    null !== this.videoStream && (this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.stop()), this.removeVideoElement(), this.video = document.createElement("video"), this.video.setAttribute("autoplay", "autoplay"), null !== e && (this.video.width = e), null !== i && (this.video.height = i), this._timeOutID = window.setTimeout(this.getUserMediaTimeout.bind(this), this.timeout);
                    try {
                        navigator.getUserMedia({
                            audio: t,
                            video: !0
                        }, this.getUserMediaSuccess.bind(this), this.getUserMediaError.bind(this))
                    } catch (t) {
                        this.getUserMediaError(t)
                    }
                    return this
                },
                getUserMediaTimeout: function() {
                    clearTimeout(this._timeOutID), this.onTimeout.dispatch(this)
                },
                getUserMediaError: function(t) {
                    clearTimeout(this._timeOutID), this.onError.dispatch(this, t)
                },
                getUserMediaSuccess: function(t) {
                    clearTimeout(this._timeOutID), this.videoStream = t, void 0 !== this.video.mozSrcObject ? this.video.mozSrcObject = t : this.video.src = window.URL && window.URL.createObjectURL(t) || t;
                    var e = this;
                    this.video.onloadeddata = function() {
                        function t() {
                            if (i > 0)
                                if (e.video.videoWidth > 0) {
                                    var s = e.video.videoWidth,
                                        n = e.video.videoHeight;
                                    isNaN(e.video.videoHeight) && (n = s / (4 / 3)), e.video.play(), e.isStreaming = !0, e.baseTexture.source = e.video, e.updateTexture(null, s, n), e.onAccess.dispatch(e)
                                } else window.setTimeout(t, 500);
                            i--
                        }
                        var i = 10;
                        t()
                    }
                },
                createVideoFromBlob: function(t) {
                    var e = this;
                    return this.video = document.createElement("video"), this.video.controls = !1, this.video.setAttribute("autoplay", "autoplay"), this.video.addEventListener("loadeddata", function(t) {
                        e.updateTexture(t)
                    }, !0), this.video.src = window.URL.createObjectURL(t), this.video.canplay = !0, this
                },
                createVideoFromURL: function(t, e) {
                    return void 0 === e && (e = !1), this.texture && (this.texture.valid = !1), this.video = document.createElement("video"), this.video.controls = !1, e && this.video.setAttribute("autoplay", "autoplay"), this.video.src = t, this.video.canplay = !0, this.video.load(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.key = t, this
                },
                updateTexture: function(t, e, i) {
                    var s = !1;
                    void 0 !== e && null !== e || (e = this.video.videoWidth, s = !0), void 0 !== i && null !== i || (i = this.video.videoHeight), this.width = e, this.height = i, this.baseTexture.source !== this.video && (this.baseTexture.source = this.video), this.baseTexture.forceLoaded(e, i), this.texture.frame.resize(e, i), this.texture.width = e, this.texture.height = i, this.texture.valid = !0, this.snapshot && this.snapshot.resize(e, i), s && null !== this.key && (this.onChangeSource.dispatch(this, e, i), this._autoplay && (this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate)))
                },
                complete: function() {
                    this.onComplete.dispatch(this)
                },
                play: function(t, e) {
                    return void 0 === t && (t = !1), void 0 === e && (e = 1), this.game.sound.onMute && (this.game.sound.onMute.add(this.setMute, this), this.game.sound.onUnMute.add(this.unsetMute, this), this.game.sound.mute && this.setMute()), this.game.onPause.add(this.setPause, this), this.game.onResume.add(this.setResume, this), this._endCallback = this.complete.bind(this), this.video.addEventListener("ended", this._endCallback, !0), this.video.addEventListener("webkitendfullscreen", this._endCallback, !0), this.video.loop = t ? "loop" : "", this.video.playbackRate = e, this.touchLocked ? this._pending = !0 : (this._pending = !1, null !== this.key && (4 !== this.video.readyState ? (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval)) : (this._playCallback = this.playHandler.bind(this), this.video.addEventListener("playing", this._playCallback, !0))), this.video.play(), this.onPlay.dispatch(this, t, e)), this
                },
                playHandler: function() {
                    this.video.removeEventListener("playing", this._playCallback, !0), this.updateTexture()
                },
                stop: function() {
                    return this.game.sound.onMute && (this.game.sound.onMute.remove(this.setMute, this), this.game.sound.onUnMute.remove(this.unsetMute, this)), this.game.onPause.remove(this.setPause, this), this.game.onResume.remove(this.setResume, this), this.isStreaming ? (this.video.mozSrcObject ? (this.video.mozSrcObject.stop(), this.video.src = null) : (this.video.src = "", this.videoStream.active ? this.videoStream.active = !1 : this.videoStream.getTracks ? this.videoStream.getTracks()
                        .forEach(function(t) {
                            t.stop()
                        }) : this.videoStream.stop()), this.videoStream = null, this.isStreaming = !1) : (this.video.removeEventListener("ended", this._endCallback, !0), this.video.removeEventListener("webkitendfullscreen", this._endCallback, !0), this.video.removeEventListener("playing", this._playCallback, !0), this.touchLocked ? this._pending = !1 : this.video.pause()), this
                },
                add: function(t) {
                    if (Array.isArray(t))
                        for (var e = 0; e < t.length; e++) t[e].loadTexture && t[e].loadTexture(this);
                    else t.loadTexture(this);
                    return this
                },
                addToWorld: function(t, e, i, s, n, a) {
                    n = n || 1, a = a || 1;
                    var o = this.game.add.image(t, e, this);
                    return o.anchor.set(i, s), o.scale.set(n, a), o
                },
                render: function() {
                    !this.disableTextureUpload && this.playing && this.baseTexture.dirty()
                },
                setMute: function() {
                    this._muted || (this._muted = !0, this.video.muted = !0)
                },
                unsetMute: function() {
                    this._muted && !this._codeMuted && (this._muted = !1, this.video.muted = !1)
                },
                setPause: function() {
                    this._paused || this.touchLocked || (this._paused = !0, this.video.pause())
                },
                setResume: function() {
                    !this._paused || this._codePaused || this.touchLocked || (this._paused = !1, this.video.ended || this.video.play())
                },
                changeSource: function(t, e) {
                    return void 0 === e && (e = !0), this.texture.valid = !1, this.video.pause(), this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval), this.video.src = t, this.video.load(), this._autoplay = e, e || (this.paused = !0), this
                },
                checkVideoProgress: function() {
                    4 === this.video.readyState ? this.updateTexture() : --this.retry > 0 && (this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))
                },
                setTouchLock: function() {
                    this.game.input.touch.addTouchLockCallback(this.unlock, this), this.touchLocked = !0
                },
                unlock: function() {
                    if (this.touchLocked = !1, this.video.play(), this.onPlay.dispatch(this, this.loop, this.playbackRate), this.key) {
                        var t = this.game.cache.getVideo(this.key);
                        t && !t.isBlob && (t.locked = !1)
                    }
                    return !0
                },
                grab: function(t, e, i) {
                    if (void 0 === t && (t = !1), void 0 === e && (e = 1), void 0 === i && (i = null), null !== this.snapshot) return t && this.snapshot.cls(), this.snapshot.copy(this.video, 0, 0, this.width, this.height, 0, 0, this.width, this.height, 0, 0, 0, 1, 1, e, i), this.snapshot
                },
                removeVideoElement: function() {
                    if (this.video) {
                        for (this.video.parentNode && this.video.parentNode.removeChild(this.video); this.video.hasChildNodes();) this.video.removeChild(this.video.firstChild);
                        this.video.removeAttribute("autoplay"), this.video.removeAttribute("src"), this.video = null
                    }
                },
                destroy: function() {
                    this.stop(), this.removeVideoElement(), this.touchLocked && this.game.input.touch.removeTouchLockCallback(this.unlock, this), this._retryID && window.clearTimeout(this._retryID)
                }
            }, Object.defineProperty(a.Video.prototype, "currentTime", {
                get: function() {
                    return this.video ? this.video.currentTime : 0
                },
                set: function(t) {
                    this.video.currentTime = t
                }
            }), Object.defineProperty(a.Video.prototype, "duration", {
                get: function() {
                    return this.video ? this.video.duration : 0
                }
            }), Object.defineProperty(a.Video.prototype, "progress", {
                get: function() {
                    return this.video ? this.video.currentTime / this.video.duration : 0
                }
            }), Object.defineProperty(a.Video.prototype, "mute", {
                get: function() {
                    return this._muted
                },
                set: function(t) {
                    if (t = t || null) {
                        if (this._muted) return;
                        this._codeMuted = !0, this.setMute()
                    } else {
                        if (!this._muted) return;
                        this._codeMuted = !1, this.unsetMute()
                    }
                }
            }), Object.defineProperty(a.Video.prototype, "paused", {
                get: function() {
                    return this._paused
                },
                set: function(t) {
                    if (t = t || null, !this.touchLocked)
                        if (t) {
                            if (this._paused) return;
                            this._codePaused = !0, this.setPause()
                        } else {
                            if (!this._paused) return;
                            this._codePaused = !1, this.setResume()
                        }
                }
            }), Object.defineProperty(a.Video.prototype, "volume", {
                get: function() {
                    return this.video ? this.video.volume : 1
                },
                set: function(t) {
                    t < 0 ? t = 0 : t > 1 && (t = 1), this.video && (this.video.volume = t)
                }
            }), Object.defineProperty(a.Video.prototype, "playbackRate", {
                get: function() {
                    return this.video ? this.video.playbackRate : 1
                },
                set: function(t) {
                    this.video && (this.video.playbackRate = t)
                }
            }), Object.defineProperty(a.Video.prototype, "loop", {
                get: function() {
                    return !!this.video && this.video.loop
                },
                set: function(t) {
                    t && this.video ? this.video.loop = "loop" : this.video && (this.video.loop = "")
                }
            }), Object.defineProperty(a.Video.prototype, "playing", {
                get: function() {
                    return !(this.video.paused && this.video.ended)
                }
            }), a.Video.prototype.constructor = a.Video, void 0 === PIXI.blendModes && (PIXI.blendModes = a.blendModes), void 0 === PIXI.scaleModes && (PIXI.scaleModes = a.scaleModes), void 0 === PIXI.Texture.emptyTexture && (PIXI.Texture.emptyTexture = new PIXI.Texture(new PIXI.BaseTexture)), void 0 === PIXI.DisplayObject._tempMatrix && (PIXI.DisplayObject._tempMatrix = new PIXI.Matrix), void 0 === PIXI.RenderTexture.tempMatrix && (PIXI.RenderTexture.tempMatrix = new PIXI.Matrix), PIXI.Graphics && void 0 === PIXI.Graphics.POLY && (PIXI.Graphics.POLY = a.POLYGON, PIXI.Graphics.RECT = a.RECTANGLE, PIXI.Graphics.CIRC = a.CIRCLE, PIXI.Graphics.ELIP = a.ELLIPSE, PIXI.Graphics.RREC = a.ROUNDEDRECTANGLE), PIXI.TextureSilentFail = !0, void 0 !== t && t.exports && (e = t.exports = a), e.Phaser = a, a
        })
        .call(this)
    })
    .call(e, i(62))
}, function(t, e) {
    function i() {
        throw new Error("setTimeout has not been defined")
    }

    function s() {
        throw new Error("clearTimeout has not been defined")
    }

    function n(t) {
        if (u === setTimeout) return setTimeout(t, 0);
        if ((u === i || !u) && setTimeout) return u = setTimeout, setTimeout(t, 0);
        try {
            return u(t, 0)
        } catch (e) {
            try {
                return u.call(null, t, 0)
            } catch (e) {
                return u.call(this, t, 0)
            }
        }
    }

    function a(t) {
        if (d === clearTimeout) return clearTimeout(t);
        if ((d === s || !d) && clearTimeout) return d = clearTimeout, clearTimeout(t);
        try {
            return d(t)
        } catch (e) {
            try {
                return d.call(null, t)
            } catch (e) {
                return d.call(this, t)
            }
        }
    }

    function o() {
        f && g && (f = !1, g.length ? p = g.concat(p) : y = -1, p.length && r())
    }

    function r() {
        if (!f) {
            var t = n(o);
            f = !0;
            for (var e = p.length; e;) {
                for (g = p, p = []; ++y < e;) g && g[y].run();
                y = -1, e = p.length
            }
            g = null, f = !1, a(t)
        }
    }

    function h(t, e) {
        this.fun = t, this.array = e
    }

    function l() {}
    var c = t.exports = {},
        u, d;
    ! function() {
        try {
            u = "function" == typeof setTimeout ? setTimeout : i
        } catch (t) {
            u = i
        }
        try {
            d = "function" == typeof clearTimeout ? clearTimeout : s
        } catch (t) {
            d = s
        }
    }();
    var p = [],
        f = !1,
        g, y = -1;
    c.nextTick = function(t) {
        var e = new Array(arguments.length - 1);
        if (arguments.length > 1)
            for (var i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
        p.push(new h(t, e)), 1 !== p.length || f || n(r)
    }, h.prototype.run = function() {
        this.fun.apply(null, this.array)
    }, c.title = "browser", c.browser = !0, c.env = {}, c.argv = [], c.version = "", c.versions = {}, c.on = l, c.addListener = l, c.once = l, c.off = l, c.removeListener = l, c.removeAllListeners = l, c.emit = l, c.prependListener = l, c.prependOnceListener = l, c.listeners = function(t) {
        return []
    }, c.binding = function(t) {
        throw new Error("process.binding is not supported")
    }, c.cwd = function() {
        return "/"
    }, c.chdir = function(t) {
        throw new Error("process.chdir is not supported")
    }, c.umask = function() {
        return 0
    }
}, function(t, e, i) {
    var s;
    ! function() {
        function n(t, e, i) {
            return t.call.apply(t.bind, arguments)
        }

        function a(t, e, i) {
            if (!t) throw Error();
            if (2 < arguments.length) {
                var s = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var i = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(i, s), t.apply(e, i)
                }
            }
            return function() {
                return t.apply(e, arguments)
            }
        }

        function o(t, e, i) {
            return o = Function.prototype.bind && -1 != Function.prototype.bind.toString()
                .indexOf("native code") ? n : a, o.apply(null, arguments)
        }

        function r(t, e) {
            this.a = t, this.o = e || t, this.c = this.o.document
        }

        function h(t, e, i, s) {
            if (e = t.c.createElement(e), i)
                for (var n in i) i.hasOwnProperty(n) && ("style" == n ? e.style.cssText = i[n] : e.setAttribute(n, i[n]));
            return s && e.appendChild(t.c.createTextNode(s)), e
        }

        function l(t, e, i) {
            t = t.c.getElementsByTagName(e)[0], t || (t = document.documentElement), t.insertBefore(i, t.lastChild)
        }

        function c(t) {
            t.parentNode && t.parentNode.removeChild(t)
        }

        function u(t, e, i) {
            e = e || [], i = i || [];
            for (var s = t.className.split(/\s+/), n = 0; n < e.length; n += 1) {
                for (var a = !1, o = 0; o < s.length; o += 1)
                    if (e[n] === s[o]) {
                        a = !0;
                        break
                    } a || s.push(e[n])
            }
            for (e = [], n = 0; n < s.length; n += 1) {
                for (a = !1, o = 0; o < i.length; o += 1)
                    if (s[n] === i[o]) {
                        a = !0;
                        break
                    } a || e.push(s[n])
            }
            t.className = e.join(" ")
                .replace(/\s+/g, " ")
                .replace(/^\s+|\s+$/, "")
        }

        function d(t, e) {
            for (var i = t.className.split(/\s+/), s = 0, n = i.length; s < n; s++)
                if (i[s] == e) return !0;
            return !1
        }

        function p(t) {
            return t.o.location.hostname || t.a.location.hostname
        }

        function f(t, e, i) {
            function s() {
                r && n && a && (r(o), r = null)
            }
            e = h(t, "link", {
                rel: "stylesheet",
                href: e,
                media: "all"
            });
            var n = !1,
                a = !0,
                o = null,
                r = i || null;
            at ? (e.onload = function() {
                n = !0, s()
            }, e.onerror = function() {
                n = !0, o = Error("Stylesheet failed to load"), s()
            }) : setTimeout(function() {
                n = !0, s()
            }, 0), l(t, "head", e)
        }

        function g(t, e, i, s) {
            var n = t.c.getElementsByTagName("head")[0];
            if (n) {
                var a = h(t, "script", {
                        src: e
                    }),
                    o = !1;
                return a.onload = a.onreadystatechange = function() {
                    o || this.readyState && "loaded" != this.readyState && "complete" != this.readyState || (o = !0, i && i(null), a.onload = a.onreadystatechange = null, "HEAD" == a.parentNode.tagName && n.removeChild(a))
                }, n.appendChild(a), setTimeout(function() {
                    o || (o = !0, i && i(Error("Script load timeout")))
                }, s || 5e3), a
            }
            return null
        }

        function y() {
            this.a = 0, this.c = null
        }

        function m(t) {
            return t.a++,
                function() {
                    t.a--, b(t)
                }
        }

        function v(t, e) {
            t.c = e, b(t)
        }

        function b(t) {
            0 == t.a && t.c && (t.c(), t.c = null)
        }

        function x(t) {
            this.a = t || "-"
        }

        function _(t, e) {
            this.c = t, this.f = 4, this.a = "n";
            var i = (e || "n4")
                .match(/^([nio])([1-9])$/i);
            i && (this.a = i[1], this.f = parseInt(i[2], 10))
        }

        function w(t) {
            return T(t) + " " + t.f + "00 300px " + C(t.c)
        }

        function C(t) {
            var e = [];
            t = t.split(/,\s*/);
            for (var i = 0; i < t.length; i++) {
                var s = t[i].replace(/['"]/g, ""); - 1 != s.indexOf(" ") || /^\d/.test(s) ? e.push("'" + s + "'") : e.push(s)
            }
            return e.join(",")
        }

        function P(t) {
            return t.a + t.f
        }

        function T(t) {
            var e = "normal";
            return "o" === t.a ? e = "oblique" : "i" === t.a && (e = "italic"), e
        }

        function S(t) {
            var e = 4,
                i = "n",
                s = null;
            return t && ((s = t.match(/(normal|oblique|italic)/i)) && s[1] && (i = s[1].substr(0, 1)
                .toLowerCase()), (s = t.match(/([1-9]00|normal|bold)/i)) && s[1] && (/bold/i.test(s[1]) ? e = 7 : /[1-9]00/.test(s[1]) && (e = parseInt(s[1].substr(0, 1), 10)))), i + e
        }

        function A(t, e) {
            this.c = t, this.f = t.o.document.documentElement, this.h = e, this.a = new x("-"), this.j = !1 !== e.events, this.g = !1 !== e.classes
        }

        function E(t) {
            t.g && u(t.f, [t.a.c("wf", "loading")]), M(t, "loading")
        }

        function I(t) {
            if (t.g) {
                var e = d(t.f, t.a.c("wf", "active")),
                    i = [],
                    s = [t.a.c("wf", "loading")];
                e || i.push(t.a.c("wf", "inactive")), u(t.f, i, s)
            }
            M(t, "inactive")
        }

        function M(t, e, i) {
            t.j && t.h[e] && (i ? t.h[e](i.c, P(i)) : t.h[e]())
        }

        function O() {
            this.c = {}
        }

        function B(t, e, i) {
            var s = [],
                n;
            for (n in e)
                if (e.hasOwnProperty(n)) {
                    var a = t.c[n];
                    a && s.push(a(e[n], i))
                } return s
        }

        function R(t, e) {
            this.c = t, this.f = e, this.a = h(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function k(t) {
            l(t.c, "body", t.a)
        }

        function D(t) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + C(t.c) + ";font-style:" + T(t) + ";font-weight:" + t.f + "00;"
        }

        function L(t, e, i, s, n, a) {
            this.g = t, this.j = e, this.a = s, this.c = i, this.f = n || 3e3, this.h = a || void 0
        }

        function F(t, e, i, s, n, a, o) {
            this.v = t, this.B = e, this.c = i, this.a = s, this.s = o || "BESbswy", this.f = {}, this.w = n || 3e3, this.u = a || null, this.m = this.j = this.h = this.g = null, this.g = new R(this.c, this.s), this.h = new R(this.c, this.s), this.j = new R(this.c, this.s), this.m = new R(this.c, this.s), t = new _(this.a.c + ",serif", P(this.a)), t = D(t), this.g.a.style.cssText = t, t = new _(this.a.c + ",sans-serif", P(this.a)), t = D(t), this.h.a.style.cssText = t, t = new _("serif", P(this.a)), t = D(t), this.j.a.style.cssText = t, t = new _("sans-serif", P(this.a)), t = D(t), this.m.a.style.cssText = t, k(this.g), k(this.h), k(this.j), k(this.m)
        }

        function G() {
            if (null === rt) {
                var t = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                rt = !!t && (536 > parseInt(t[1], 10) || 536 === parseInt(t[1], 10) && 11 >= parseInt(t[2], 10))
            }
            return rt
        }

        function U(t, e, i) {
            for (var s in ot)
                if (ot.hasOwnProperty(s) && e === t.f[ot[s]] && i === t.f[ot[s]]) return !0;
            return !1
        }

        function N(t) {
            var e = t.g.a.offsetWidth,
                i = t.h.a.offsetWidth,
                s;
            (s = e === t.f.serif && i === t.f["sans-serif"]) || (s = G() && U(t, e, i)), s ? nt() - t.A >= t.w ? G() && U(t, e, i) && (null === t.u || t.u.hasOwnProperty(t.a.c)) ? W(t, t.v) : W(t, t.B) : j(t) : W(t, t.v)
        }

        function j(t) {
            setTimeout(o(function() {
                N(this)
            }, t), 50)
        }

        function W(t, e) {
            setTimeout(o(function() {
                c(this.g.a), c(this.h.a), c(this.j.a), c(this.m.a), e(this.a)
            }, t), 0)
        }

        function X(t, e, i) {
            this.c = t, this.a = e, this.f = 0, this.m = this.j = !1, this.s = i
        }

        function H(t) {
            0 == --t.f && t.j && (t.m ? (t = t.a, t.g && u(t.f, [t.a.c("wf", "active")], [t.a.c("wf", "loading"), t.a.c("wf", "inactive")]), M(t, "active")) : I(t.a))
        }

        function V(t) {
            this.j = t, this.a = new O, this.h = 0, this.f = this.g = !0
        }

        function Y(t, e, i, s, n) {
            var a = 0 == --t.h;
            (t.f || t.g) && setTimeout(function() {
                var t = n || null,
                    r = s || null || {};
                if (0 === i.length && a) I(e.a);
                else {
                    e.f += i.length, a && (e.j = a);
                    var h, l = [];
                    for (h = 0; h < i.length; h++) {
                        var c = i[h],
                            d = r[c.c],
                            p = e.a,
                            f = c;
                        if (p.g && u(p.f, [p.a.c("wf", f.c, P(f)
                                .toString(), "loading")]), M(p, "fontloading", f), p = null, null === ht)
                            if (window.FontFace) {
                                var f = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    g = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                ht = f ? 42 < parseInt(f[1], 10) : !g
                            } else ht = !1;
                        p = ht ? new L(o(e.g, e), o(e.h, e), e.c, c, e.s, d) : new F(o(e.g, e), o(e.h, e), e.c, c, e.s, t, d), l.push(p)
                    }
                    for (h = 0; h < l.length; h++) l[h].start()
                }
            }, 0)
        }

        function q(t, e, i) {
            var s = [],
                n = i.timeout;
            E(e);
            var s = B(t.a, i, t.c),
                a = new X(t.c, e, n);
            for (t.h = s.length, e = 0, i = s.length; e < i; e++) s[e].load(function(e, i, s) {
                Y(t, a, e, i, s)
            })
        }

        function z(t, e) {
            this.c = t, this.a = e
        }

        function K(t, e) {
            this.c = t, this.a = e
        }

        function J(t, e) {
            this.c = t || lt, this.a = [], this.f = [], this.g = e || ""
        }

        function Z(t, e) {
            for (var i = e.length, s = 0; s < i; s++) {
                var n = e[s].split(":");
                3 == n.length && t.f.push(n.pop());
                var a = "";
                2 == n.length && "" != n[1] && (a = ":"), t.a.push(n.join(a))
            }
        }

        function Q(t) {
            if (0 == t.a.length) throw Error("No fonts to load!");
            if (-1 != t.c.indexOf("kit=")) return t.c;
            for (var e = t.a.length, i = [], s = 0; s < e; s++) i.push(t.a[s].replace(/ /g, "+"));
            return e = t.c + "?family=" + i.join("%7C"), 0 < t.f.length && (e += "&subset=" + t.f.join(",")), 0 < t.g.length && (e += "&text=" + encodeURIComponent(t.g)), e
        }

        function $(t) {
            this.f = t, this.a = [], this.c = {}
        }

        function tt(t) {
            for (var e = t.f.length, i = 0; i < e; i++) {
                var s = t.f[i].split(":"),
                    n = s[0].replace(/\+/g, " "),
                    a = ["n4"];
                if (2 <= s.length) {
                    var o, r = s[1];
                    if (o = [], r)
                        for (var r = r.split(","), h = r.length, l = 0; l < h; l++) {
                            var c;
                            if (c = r[l], c.match(/^[\w-]+$/)) {
                                var u = pt.exec(c.toLowerCase());
                                if (null == u) c = "";
                                else {
                                    if (c = u[2], c = null == c || "" == c ? "n" : dt[c], null == (u = u[1]) || "" == u) u = "4";
                                    else var d = ut[u],
                                        u = d || (isNaN(u) ? "4" : u.substr(0, 1));
                                    c = [c, u].join("")
                                }
                            } else c = "";
                            c && o.push(c)
                        }
                    0 < o.length && (a = o), 3 == s.length && (s = s[2], o = [], s = s ? s.split(",") : o, 0 < s.length && (s = ct[s[0]]) && (t.c[n] = s))
                }
                for (t.c[n] || (s = ct[n]) && (t.c[n] = s), s = 0; s < a.length; s += 1) t.a.push(new _(n, a[s]))
            }
        }

        function et(t, e) {
            this.c = t, this.a = e
        }

        function it(t, e) {
            this.c = t, this.a = e
        }

        function st(t, e) {
            this.c = t, this.f = e, this.a = []
        }
        var nt = Date.now || function() {
                return +new Date
            },
            at = !!window.FontFace;
        x.prototype.c = function(t) {
            for (var e = [], i = 0; i < arguments.length; i++) e.push(arguments[i].replace(/[\W_]+/g, "")
                .toLowerCase());
            return e.join(this.a)
        }, L.prototype.start = function() {
            var t = this.c.o.document,
                e = this,
                i = nt(),
                s = new Promise(function(s, n) {
                    function a() {
                        nt() - i >= e.f ? n() : t.fonts.load(w(e.a), e.h)
                            .then(function(t) {
                                1 <= t.length ? s() : setTimeout(a, 25)
                            }, function() {
                                n()
                            })
                    }
                    a()
                }),
                n = null,
                a = new Promise(function(t, i) {
                    n = setTimeout(i, e.f)
                });
            Promise.race([a, s])
                .then(function() {
                    n && (clearTimeout(n), n = null), e.g(e.a)
                }, function() {
                    e.j(e.a)
                })
        };
        var ot = {
                D: "serif",
                C: "sans-serif"
            },
            rt = null;
        F.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = nt(), N(this)
        };
        var ht = null;
        X.prototype.g = function(t) {
            var e = this.a;
            e.g && u(e.f, [e.a.c("wf", t.c, P(t)
                .toString(), "active")], [e.a.c("wf", t.c, P(t)
                .toString(), "loading"), e.a.c("wf", t.c, P(t)
                .toString(), "inactive")]), M(e, "fontactive", t), this.m = !0, H(this)
        }, X.prototype.h = function(t) {
            var e = this.a;
            if (e.g) {
                var i = d(e.f, e.a.c("wf", t.c, P(t)
                        .toString(), "active")),
                    s = [],
                    n = [e.a.c("wf", t.c, P(t)
                        .toString(), "loading")];
                i || s.push(e.a.c("wf", t.c, P(t)
                    .toString(), "inactive")), u(e.f, s, n)
            }
            M(e, "fontinactive", t), H(this)
        }, V.prototype.load = function(t) {
            this.c = new r(this.j, t.context || this.j), this.g = !1 !== t.events, this.f = !1 !== t.classes, q(this, new A(this.c, t), t)
        }, z.prototype.load = function(t) {
            function e() {
                if (a["__mti_fntLst" + s]) {
                    var i = a["__mti_fntLst" + s](),
                        n = [],
                        o;
                    if (i)
                        for (var r = 0; r < i.length; r++) {
                            var h = i[r].fontfamily;
                            void 0 != i[r].fontStyle && void 0 != i[r].fontWeight ? (o = i[r].fontStyle + i[r].fontWeight, n.push(new _(h, o))) : n.push(new _(h))
                        }
                    t(n)
                } else setTimeout(function() {
                    e()
                }, 50)
            }
            var i = this,
                s = i.a.projectId,
                n = i.a.version;
            if (s) {
                var a = i.c.o;
                g(this.c, (i.a.api || "https://fast.fonts.net/jsapi") + "/" + s + ".js" + (n ? "?v=" + n : ""), function(n) {
                        n ? t([]) : (a["__MonotypeConfiguration__" + s] = function() {
                            return i.a
                        }, e())
                    })
                    .id = "__MonotypeAPIScript__" + s
            } else t([])
        }, K.prototype.load = function(t) {
            var e, i, s = this.a.urls || [],
                n = this.a.families || [],
                a = this.a.testStrings || {},
                o = new y;
            for (e = 0, i = s.length; e < i; e++) f(this.c, s[e], m(o));
            var r = [];
            for (e = 0, i = n.length; e < i; e++)
                if (s = n[e].split(":"), s[1])
                    for (var h = s[1].split(","), l = 0; l < h.length; l += 1) r.push(new _(s[0], h[l]));
                else r.push(new _(s[0]));
            v(o, function() {
                t(r, a)
            })
        };
        var lt = "https://fonts.googleapis.com/css",
            ct = {
                latin: "BESbswy",
                "latin-ext": "çöüğş",
                cyrillic: "йяЖ",
                greek: "αβΣ",
                khmer: "កខគ",
                Hanuman: "កខគ"
            },
            ut = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            dt = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            pt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/,
            ft = {
                Arimo: !0,
                Cousine: !0,
                Tinos: !0
            };
        et.prototype.load = function(t) {
            var e = new y,
                i = this.c,
                s = new J(this.a.api, this.a.text),
                n = this.a.families;
            Z(s, n);
            var a = new $(n);
            tt(a), f(i, Q(s), m(e)), v(e, function() {
                t(a.a, a.c, ft)
            })
        }, it.prototype.load = function(t) {
            var e = this.a.id,
                i = this.c.o;
            e ? g(this.c, (this.a.api || "https://use.typekit.net") + "/" + e + ".js", function(e) {
                if (e) t([]);
                else if (i.Typekit && i.Typekit.config && i.Typekit.config.fn) {
                    e = i.Typekit.config.fn;
                    for (var s = [], n = 0; n < e.length; n += 2)
                        for (var a = e[n], o = e[n + 1], r = 0; r < o.length; r++) s.push(new _(a, o[r]));
                    try {
                        i.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch (t) {}
                    t(s)
                }
            }, 2e3) : t([])
        }, st.prototype.load = function(t) {
            var e = this.f.id,
                i = this.c.o,
                s = this;
            e ? (i.__webfontfontdeckmodule__ || (i.__webfontfontdeckmodule__ = {}), i.__webfontfontdeckmodule__[e] = function(e, i) {
                for (var n = 0, a = i.fonts.length; n < a; ++n) {
                    var o = i.fonts[n];
                    s.a.push(new _(o.name, S("font-weight:" + o.weight + ";font-style:" + o.style)))
                }
                t(s.a)
            }, g(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + p(this.c) + "/" + e + ".js", function(e) {
                e && t([])
            })) : t([])
        };
        var gt = new V(window);
        gt.a.c.custom = function(t, e) {
            return new K(e, t)
        }, gt.a.c.fontdeck = function(t, e) {
            return new st(e, t)
        }, gt.a.c.monotype = function(t, e) {
            return new z(e, t)
        }, gt.a.c.typekit = function(t, e) {
            return new it(e, t)
        }, gt.a.c.google = function(t, e) {
            return new et(e, t)
        };
        var yt = {
            load: o(gt.load, gt)
        };
        void 0 !== (s = function() {
            return yt
        }.call(e, i, e, t)) && (t.exports = s)
    }()
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(65);
    e.Boot = s.default;
    var n = i(26);
    e.Gameplay = n.default;
    var a = i(28);
    e.Menu = a.default;
    var o = i(23);
    e.Garage = o.default;
    var r = i(24);
    e.ChooseZone = r.default
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(66),
        a = i(4),
        o = i(32),
        r = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i
            }
            return s(e, t), e.prototype.init = function() {
                var t = this;
                this.game.canvas.oncontextmenu = function(t) {
                    t.preventDefault()
                }, this.game.input.maxPointers = 3, this.game.input.addPointer(), this.game.input.addPointer(), this.scale.scaleMode = Phaser.ScaleManager.USER_SCALE, this.scale.fullScreenScaleMode = Phaser.ScaleManager.USER_SCALE, window.addEventListener("resize", function() {
                    return e.mobileResizeCallback(t.game.scale)
                }), this.game.scale.onSizeChange.add(function() {
                    a.Constants.LANDSCAPE_LOCKED && !t.game.device.desktop ? t.game.width > t.game.height ? t.handleCorrect() : t.handleIncorrect() : a.Constants.PORTRAIT_LOCKED && !t.game.device.desktop && (t.game.width < t.game.height ? t.handleCorrect() : t.handleIncorrect()), t.game.state.getCurrentState()
                        .resize()
                }, this), e.mobileResizeCallback(this.game.scale), document.addEventListener("pause", function() {
                    t.game.sound.mute = !0
                }), document.addEventListener("resume", function() {
                    t.game.sound.mute = !1
                }), this.stage.disableVisibilityChange = !1, this.game.onPause.add(function() {
                    t.game.sound.mute = !0
                }), this.game.onResume.add(function() {
                    t.game.sound.mute = !1
                })
            }, e.mobileResizeCallback = function(t) {
                var i = window.innerWidth,
                    s = window.innerHeight;
                0 === s && (s = 1), 0 === i && (i = 1), e.setScaling(t.game);
                var n = 720 * a.Constants.GAME_SCALE,
                    o = 480 * a.Constants.GAME_SCALE,
                    r = 1;
                r /= i > s ? s / o : s / n, a.Constants.WIDTH = 720, a.Constants.HEIGHT = 480, a.Constants.CALCULATED_WIDTH = Math.ceil(i * r), a.Constants.CALCULATED_HEIGHT = Math.ceil(s * r), t.setGameSize(a.Constants.CALCULATED_WIDTH, a.Constants.CALCULATED_HEIGHT), t.setUserScale(1 / r, 1 / r), a.Constants.LANDSCAPE_LOCKED && !t.game.device.desktop && (t.game.width > t.game.height ? (document.getElementById("orientation")
                    .style.display = "none", document.getElementById("content")
                    .style.display = "block") : (document.getElementById("orientation")
                    .style.display = "block", document.getElementById("content")
                    .style.display = "none"))
            }, e.setScaling = function(t) {
                var e = window.innerWidth > window.innerHeight ? window.innerWidth : window.innerHeight;
                e *= t.device.pixelRatio, a.Constants.GAME_SCALE = 1
            }, e.prototype.preload = function() {
                var t = this;
                this.game.load.cacheBuster = 1551779817707;
                var e = "x" + a.Constants.GAME_SCALE + "/";
                a.Images.preloadList.forEach(function(i) {
                    t.game.load.image(i, "assets/images/" + e + i + ".png")
                }), a.JSONData.preloadList.forEach(function(e) {
                    t.game.load.json(e, "assets/levels/" + e + ".json")
                }), a.Atlases.preloadList.forEach(function(i) {
                    t.game.load.atlas(i, "assets/atlases/" + e + i + ".png", "assets/atlases/" + e + i + ".json")
                }), a.Sounds.preloadList.forEach(function(e) {
                    t.game.device.iOS ? t.game.load.audio(e, ["assets/sounds/" + e + ".m4a"]) : t.game.load.audio(e, ["assets/sounds/" + e + ".ogg", "assets/sounds/" + e + ".mp3"])
                })
            }, e.prototype.create = function() {
                n.default.hide(), this.game.state.start(o.default.Name)
            }, e.prototype.handleCorrect = function() {
                document.getElementById("orientation")
                    .style.display = "none", document.getElementById("content")
                    .style.display = "block"
            }, e.prototype.handleIncorrect = function() {
                document.getElementById("orientation")
                    .style.display = "block", document.getElementById("content")
                    .style.display = "none"
            }, e.Name = "boot", e
        }(Phaser.State);
    e.default = r
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.show = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "block")
        }, t.hide = function() {
            var t = document.getElementById("loader");
            t && (t.style.display = "none")
        }, t
    }();
    e.default = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.updated = [], this.restarted = [], this.objects = [], this.game = null
        }
        return t.prototype.start = function() {
            this.view.start(), this.physics.start()
        }, t.prototype.init = function(t) {
            this.game = t
        }, t.prototype.add = function(t) {
            this.objects.push(t), t.update && (this.updatedLen = this.updated.push(t)), t.restart && this.restarted.push(t), t.body && this.physics.add(t), t.graphic && this.view.add(t)
        }, t.prototype.update = function(t) {
            this.physics.update(t);
            for (var e = 0; e < this.updatedLen; e++) {
                this.updated[e].update(t)
            }
        }, t.prototype.restart = function() {
            for (var t = this.restarted.length, e = 0; e < t; e++) {
                this.restarted[e].restart()
            }
        }, t.prototype.release = function() {
            for (var t = this.objects.length, e = 0; e < t; e++) {
                this.objects[e].release()
            }
            this.objects.splice(0, t), this.restarted.splice(0, this.restarted.length), this.updated.splice(0, this.updatedLen), this.updatedLen = 0, this.view.release(), this.physics.release()
        }, t
    }();
    e.GameCore = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(0),
        n = function() {
            function t() {
                this.type = -1
            }
            return t.prototype.create = function(t) {
                void 0 === t && (t = null)
            }, t.prototype.release = function() {
                if (this.graphic) {
                    if (this.graphic.dispose) try {
                        this.graphic.dispose()
                    } catch (t) {}
                    this.graphic = null
                }
                if (this.body) {
                    try {
                        s.NapeUtil.disposeBody(this.body)
                    } catch (t) {}
                    this.body = null
                }
            }, t
        }();
    e.GameObject = n
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t(t) {
            this.game = null, this.game = t
        }
        return t.prototype.add = function(t) {}, t.prototype.release = function() {
            this.game = null, this.raceCamera = null
        }, t.prototype.update = function(t, e, i, s) {}, t.prototype.start = function() {}, t
    }();
    e.GameView = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.obj = null, this.bodyW = 64, this.bodyH = 32, this.bodyDensity = 1, this.bodyMassType = 0, this.wheelBackR = 16, this.wheelBackDx = 32, this.wheelBackDensity = 1, this.driverDensity = 0, this.driverDx = 32, this.driverDy = 0, this.driverW = 64, this.driverH = 64, this.axisBackY = 2, this.axisBackLen = 30, this.axisBackAngle = .5 * Math.PI, this.damperBackY = 0, this.damperBackLen = 32, this.damperBackFreq = 10, this.damperBackDamp = 1, this.wheelFrontR = 16, this.wheelFrontDx = 32, this.wheelFrontDensity = 1, this.axisFrontY = 0, this.axisFrontLen = 32, this.axisFrontAngle = .5 * Math.PI, this.damperFrontY = 2, this.damperFrontLen = 30, this.damperFrontFreq = 10, this.damperFrontDamp = 1, this.wd = 2, this.maxSpeed = 1e3, this.torque = 1e3, this.maxTorque = 2e3, this.flipTorque = 1e3, this.maxFlipSpeed = 3, this.boostForce = 1e3, this.skinId = 1, this.wheelBackFriction = 2, this.wheelFrontFriction = 2, this.maxSpeedPct = 5, this.torquePct = 5, this.wheelFrictionPct = 10, this.wheelRadiusValue = 1, this.boostValue = 1, this.handlingPct = 5, this.engineCount = 3, this.handlingCount = 3, this.boostCount = 3, this.wheelsCount = 3, this.wheels = 0, this.colorId = 1
        }
        return t.prototype.setData = function(t) {
            this.setData2(t), this.getData()
        }, t.prototype.setData2 = function(t) {
            this.bodyW = t.bodyW, this.bodyH = t.bodyH, this.bodyDensity = t.bodyDensity, this.bodyMassType = t.bodyMassType, this.wheelBackDx = t.wheelBackDx, this.wheelFrontDx = t.wheelFrontDx, this.driverDensity = t.driverDensity, this.driverDx = t.driverDx, this.driverDy = t.driverDy, this.driverW = t.driverW, this.driverH = t.driverH, this.wheelBackR = t.wheelBackR, this.wheelBackDensity = t.wheelBackDensity, this.wheelBackFriction = t.wheelBackFriction, this.axisBackAngle = t.axisBackAngle, this.axisBackY = t.axisBackY, this.axisBackLen = t.axisBackLen, this.damperBackY = t.damperBackY, this.damperBackLen = t.damperBackLen, this.damperBackFreq = t.damperBackFreq, this.damperBackDamp = t.damperBackDamp, this.wheelFrontR = t.wheelFrontR, this.wheelFrontDensity = t.wheelFrontDensity, this.wheelFrontFriction = t.wheelFrontFriction, this.axisFrontAngle = t.axisFrontAngle, this.axisFrontY = t.axisFrontY, this.axisFrontLen = t.axisFrontLen, this.damperFrontY = t.damperFrontY, this.damperFrontLen = t.damperFrontLen, this.damperFrontFreq = t.damperFrontFreq, this.damperFrontDamp = t.damperFrontDamp, this.wd = t.wd, this.maxSpeed = t.maxSpeed, this.torque = t.torque, this.maxTorque = t.maxTorque, this.flipTorque = t.flipTorque, this.maxFlipSpeed = t.maxFlipSpeed, this.boostForce = t.boostForce, this.skinId = t.skinId, this.maxSpeedPct = t.maxSpeedPct, this.torquePct = t.torquePct, this.wheelFrictionPct = t.wheelFrictionPct, this.wheelRadiusValue = t.wheelRadiusValue, this.boostValue = t.boostValue, this.handlingPct = t.handlingPct, this.engineCount = t.engineCount, this.handlingCount = t.handlingCount, this.boostCount = t.boostCount, this.wheelsCount = t.wheelsCount, this.wheels = t.wheels
        }, t.prototype.getData = function() {
            return null === this.obj && (this.obj = {}), this.obj.bodyW = this.bodyW, this.obj.bodyH = this.bodyH, this.obj.bodyDensity = this.bodyDensity, this.obj.bodyMassType = this.bodyMassType, this.obj.bodyMassType = this.bodyMassType, this.obj.wheelBackDx = this.wheelBackDx, this.obj.wheelFrontDx = this.wheelFrontDx, this.obj.driverDensity = this.driverDensity, this.obj.driverDx = this.driverDx, this.obj.driverDy = this.driverDy, this.obj.driverW = this.driverW, this.obj.driverH = this.driverH, this.obj.wheelBackR = this.wheelBackR, this.obj.wheelBackDensity = this.wheelBackDensity, this.obj.wheelBackFriction = this.wheelBackFriction, this.obj.axisBackAngle = this.axisBackAngle, this.obj.axisBackY = this.axisBackY, this.obj.axisBackLen = this.axisBackLen, this.obj.damperBackY = this.damperBackY, this.obj.damperBackLen = this.damperBackLen, this.obj.damperBackFreq = this.damperBackFreq, this.obj.damperBackDamp = this.damperBackDamp, this.obj.wheelFrontR = this.wheelFrontR, this.obj.wheelFrontDensity = this.wheelFrontDensity, this.obj.wheelFrontFriction = this.wheelFrontFriction, this.obj.axisFrontAngle = this.axisFrontAngle, this.obj.axisFrontY = this.axisFrontY, this.obj.axisFrontLen = this.axisFrontLen, this.obj.damperFrontY = this.damperFrontY, this.obj.damperFrontLen = this.damperFrontLen, this.obj.damperFrontFreq = this.damperFrontFreq, this.obj.damperFrontDamp = this.damperFrontDamp, this.obj.wd = this.wd, this.obj.maxSpeed = this.maxSpeed, this.obj.torque = this.torque, this.obj.maxTorque = this.maxTorque, this.obj.flipTorque = this.flipTorque, this.obj.maxFlipSpeed = this.maxFlipSpeed, this.obj.boostForce = this.boostForce, this.obj.skinId = this.skinId, this.obj.maxSpeedPct = this.maxSpeedPct, this.obj.torquePct = this.torquePct, this.obj.wheelFrictionPct = this.wheelFrictionPct, this.obj.wheelRadiusValue = this.wheelRadiusValue, this.obj.boostValue = this.boostValue, this.obj.handlingPct = this.handlingPct, this.obj.engineCount = this.engineCount, this.obj.handlingCount = this.handlingCount, this.obj.boostCount = this.boostCount, this.obj.wheelsCount = this.wheelsCount, this.obj.wheels = this.wheels, this.obj
        }, t.prototype.cloneWheel = function(t) {
            void 0 === t && (t = !0), t ? (this.wheelFrontR = this.wheelBackR, this.wheelFrontDensity = this.wheelBackDensity, this.wheelFrontFriction = this.wheelBackFriction, this.axisFrontY = this.axisBackY, this.axisFrontLen = this.axisBackLen, this.damperFrontY = this.damperBackY, this.damperFrontLen = this.damperBackLen, this.damperFrontFreq = this.damperBackFreq, this.damperFrontDamp = this.damperBackDamp) : (this.wheelBackR = this.wheelFrontR, this.wheelBackDensity = this.wheelFrontDensity, this.wheelBackFriction = this.wheelFrontFriction, this.axisBackY = this.axisFrontY, this.axisBackLen = this.axisFrontLen, this.damperBackY = this.damperFrontY, this.damperBackLen = this.damperFrontLen, this.damperBackFreq = this.damperFrontFreq, this.damperBackDamp = this.damperFrontDamp)
        }, t
    }();
    e.CarParams = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.engine = 0, this.wheel = 0, this.health = 0, this.weapon = 0
        }
        return t.prototype.isZero = function() {
            return 0 === this.engine && 0 === this.wheel && 0 === this.health && 0 === this.weapon
        }, t
    }();
    e.CarUpgrades = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = i(20),
        n = i(34),
        a = i(0),
        o = function() {
            function t() {
                this.player = {}, this.bots = [], this.cars = []
            }
            return t.prototype.reset = function() {
                this.player.x = .5 * s.default.GAME_W, this.player.y = .5 * s.default.GAME_H, this.bots.splice(0, this.bots.length), this.cars.splice(0, this.cars.length)
            }, t.prototype.add = function(t) {
                "PlayerWP" === t.className && (n.RacesData.data = new a.RaceData, this.player.x = t.params.x, this.player.y = t.params.y, n.RacesData.data.startX = this.player.x)
            }, t.prototype.setDrive = function(t) {
                for (var e = 0; e < this.cars.length; e++) this.cars[e].drive = t
            }, t.COLORS = [1, 3, 3, 1, 3, 1, 1, 1, 1, 1], t
        }();
    e.RaceCars = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.ammo = 100, this.maxAmmo = 100, this.speed = 1, this.damage = 60, this.count = 1
        }
        return t.prototype.reset = function(t, e) {
            void 0 === t && (t = null), void 0 === e && (e = 0), t && (this.maxAmmo = t.ammo + t.upg * e, this.speed = t.speed, this.damage = t.damage, this.count = t.count, this.life = t.life, this.radius = t.radius), this.ammo = this.maxAmmo
        }, t
    }();
    e.WeaponParams = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.skins = {}
        }
        return t
    }();
    e.LeagueVO = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t
    }();
    e.MapVO = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.assetsReady = !1, this.restarted = !1, this.gravityY = 1400, this.countdown = 0, this.timer = 0, this.startX = 0, this.finishX = 0, this.skinId = 1, this.delayForMaks = .2
        }
        return t.prototype.reset = function() {
            this.assetsReady = !1, this.restarted = !1, this.startX = this.finishX = 0, this.restart()
        }, t.prototype.restart = function() {
            this.flip = 0, this.delayForMaks = .2
        }, t
    }();
    e.RaceData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t(t, e) {
            this.width = t.width, this.dx = t.x, this.texture = e, this.point = new Phaser.Point(0, t.y)
        }
        return t
    }();
    e.BgElVo = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {
            this.req_id = 1
        }
        return t
    }();
    e.ShopCarVO = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t.cars = [], t.carsCount = 0, t
    }();
    e.ShopData = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = Phaser.Signal,
        n = nape.constraint.AngleJoint,
        a = nape.constraint.DistanceJoint,
        o = nape.constraint.LineJoint,
        r = nape.constraint.WeldJoint,
        h = nape.geom.GeomPoly,
        l = nape.geom.GeomPolyList,
        c = nape.geom.Vec2,
        u = nape.phys.Body,
        d = nape.phys.BodyType,
        p = nape.phys.Material,
        f = nape.shape.Circle,
        g = nape.shape.Polygon,
        y = i(0),
        m = i(3),
        v = i(7),
        b = i(11),
        x = i(5),
        _ = i(6),
        w = i(9),
        C = i(86),
        P = i(1),
        T = i(2),
        S = function() {
            function t() {
                this.complete = new s
            }
            return t.prototype.createAllCars = function() {
                this.cars = y.CarsData.cars, this.createPlayerCar(), this.carsCreated()
            }, t.prototype.carsCreated = function() {
                var t = y.CarsData.cars.cars;
                this.playerParams = null, t = null, this.complete.dispatch(this)
            }, t.prototype.dispose = function() {
                this.complete.removeAll()
            }, t.prototype.createPlayerCar = function() {
                this.playerParams = y.CarsData.params;
                var e = y.CarsData.cars.player.x,
                    i = y.CarsData.cars.player.y,
                    s = t.createCar(this.playerParams, e, i, !0, !1);
                s.controller = new y.PlayerController(s), s.frontWheel.graphic.createGroundParts(), s.backWheel.graphic.createGroundParts(), s.frame.graphic.createSmokeParts(), m.MaxGameCore.instance.car = s
            }, t.createWheel = function(t, e, i, s) {
                var r = i ? t.wheelBackFriction : t.wheelFrontFriction,
                    h = i ? t.wheelBackDensity : t.wheelFrontDensity,
                    l = new u(d.DYNAMIC);
                l.disableCCD = !0;
                var g = new p(0, r, r, h),
                    m = i ? t.wheelBackR : t.wheelFrontR,
                    x;
                x = new f(m, null, g, v.Filters.WHEEL), l.cbTypes.add(b.CbTypes.WHEEL), l.shapes.add(x), l.compound = e;
                var w;
                w = i ? -t.wheelBackDx : t.wheelFrontDx;
                var C = i ? t.axisBackY : t.axisFrontY,
                    P = i ? t.axisBackLen : t.axisFrontLen,
                    T = i ? t.damperBackY : t.damperFrontY,
                    S = i ? t.damperBackLen : t.damperFrontLen,
                    A = 2 * S,
                    E = i ? t.damperBackFreq : t.damperFrontFreq,
                    I = i ? t.damperBackDamp : t.damperFrontDamp;
                l.position.setxy(s.position.x + w, s.position.y + S);
                var M = c.fromPolar(1, i ? t.axisBackAngle : t.axisFrontAngle),
                    O = new o(s, l, c.weak(w, C), c.weak(), M, 0, P);
                O.compound = l.compound, M.dispose();
                var B = new a(s, l, c.weak(w, T), c.weak(), S, A);
                B.frequency = E, B.damping = I, B.ignore = !0, B.stiff = !1, B.compound = l.compound;
                var R = new y.WheelObject;
                if (!i) {
                    var k = new n(s, l, 0, 0, 1);
                    k.active = !1, k.stiff = !1, k.damping = 100, k.compound = l.compound, R.brakeJoint = k
                }
                return R.skinId = t.skinId, R.body = l, R.graphic = _.GraphicUtil.createCarWheelGraphic(t, i ? t.wheelBackR : t.wheelFrontR, i), R.material = g, R.lineJoint = O, R.distanceJoint = B, R.isPlayer = !0, R.create(), R
            }, t.createDriver = function(t, e, i) {
                var s = i.body,
                    n = new y.DriverObject,
                    a = new u(d.DYNAMIC),
                    o = new p(0, 0, 0, t.driverDensity, .001);
                a.shapes.add(new g(g.box(t.driverW, t.driverH, !0), o, v.Filters.NOTHING)), a.userData.dx = 0, a.userData.dy = t.driverDy, n.body = a, a.compound = e;
                var h = new r(s, a, c.weak(0, t.driverDy), c.weak(), 0);
                h.ignore = !0, h.compound = a.compound, n.weld = h, n.dx = t.driverDx, n.create();
                var l = y.CarsData.geom[1],
                    f = s.position.x,
                    m = s.position.y,
                    P = w.Materials.DEFAULT,
                    S = "driver_shin",
                    A = l[S],
                    E = new C.DriverPartObject;
                E.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), E.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), E.body.compound = e, E.create(A);
                var I = new C.DriverPartObject;
                I.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), I.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), I.body.compound = e, I.create(A), S = "driver_hip", A = l[S];
                var M = new C.DriverPartObject;
                M.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), M.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), M.body.compound = e, M.create(A);
                var O = new C.DriverPartObject;
                O.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), O.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), O.body.compound = e, O.create(A), S = "driver_corpse", A = l[S];
                var B = new C.DriverPartObject;
                B.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), B.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), B.body.compound = e, B.create(A), S = "driver_arm", A = l[S];
                var R = new C.DriverPartObject;
                R.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), R.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), R.body.compound = e, R.create(A);
                var k = new C.DriverPartObject;
                k.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), k.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), k.body.compound = e, k.create(A), S = "driver_forearm", A = l[S];
                var D = new C.DriverPartObject;
                D.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), D.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), D.body.compound = e, D.create(A);
                var L = new C.DriverPartObject;
                L.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), L.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER_PART, P), L.body.compound = e, L.create(A), S = "driver_head", A = l[S];
                var F = new C.DriverPartObject;
                F.graphic = _.GraphicUtil.createImage(f + A.x, m + A.y, A.r, T.AssetsStorage.instance.getByKey(S)), F.body = y.NapeUtil.createRectBodyWH(d.DYNAMIC, v.Filters.DRIVER_PART, !1, A.w, A.h, A.x + f, A.y + m, A.r, b.CbTypes.DRIVER, P), F.body.compound = e, F.create(A), 5 === y.Inventory.instance.skin && (n.head = F, n.head.trailAnimObject = new y.DecorObject(!1), n.head.trailAnimObject.graphic = _.GraphicUtil.game.make.sprite(0, 0, _.GraphicUtil.currentAtlass, "ghost_fire_head0000"), n.head.trailAnimObject.graphic.animations.add("ghost_fire_head", Phaser.Animation.generateFrameNames("ghost_fire_head", 0, 4, "", 4)), n.head.trailAnimObject.graphic.animations.getAnimation("ghost_fire_head")
                    .play(20, !0), n.head.trailAnimObject.graphic.anchor.set(.9, .48));
                var G = 10 * x.default.TO_RAD;
                return E.createJoints(M, l.hip_joint, f, m, G), I.createJoints(O, l.hip_joint, f, m, G), M.createJoints(B, l.corpse_joint, f, m, G), O.createJoints(B, l.corpse_joint, f, m, G), D.createJoints(R, l.forearm_joint, f, m, G), L.createJoints(k, l.forearm_joint, f, m, G), R.createJoints(B, l.arm_joint, f, m, G), k.createJoints(B, l.arm_joint, f, m, G), F.createJoints(B, l.head_joint, f, m, G), n.frameBody = i.body, n.connectArm(D, l.steer_joint, f, m, G), n.connectLeg(E, l.shin_joint, f, m, G), n.parts[0] = F, n.parts[1] = B, n.parts[2] = M, n.parts[3] = E, n.parts[4] = R, n.parts[5] = D, n.parts_mirror[0] = null, n.parts_mirror[1] = null, n.parts_mirror[2] = O, n.parts_mirror[3] = I, n.parts_mirror[4] = k, n.parts_mirror[5] = L, n
            }, t.createFrame = function(e, i, s, n) {
                var a = new y.FrameObject,
                    o = new u(d.DYNAMIC, c.weak(i, s));
                o.cbTypes.add(b.CbTypes.BODY_COLLIDER);
                var r = new p(0, 0, 0, e.bodyDensity, .001),
                    l;
                0 === e.bodyMassType ? (l = new g(g.box(.5 * e.bodyW, e.bodyH, !0), r, v.Filters.NOTHING), l.translate(c.weak(-e.wheelBackDx, 0)), o.shapes.add(l), l = new g(g.box(.5 * e.bodyW, e.bodyH, !0), r, v.Filters.NOTHING), l.translate(c.weak(e.wheelFrontDx, 0)), o.shapes.add(l)) : o.shapes.add(new g(g.box(e.bodyW, e.bodyH, !0), r, v.Filters.NOTHING));
                var f;
                f = v.Filters.BODY_COLLIDER;
                var m = y.CarsData.geom[1];
                if (m) {
                    var x = m.points;
                    if (null !== x) {
                        for (var C = [], P = x.length, T = 0; T < P; T++) C[C.length] = c.weak(x[T].x >> 0, x[T].y >> 0);
                        var S = new h(C);
                        if (S.isConvex()) l = new g(S, w.Materials.WIEGHTLESS, f), S.dispose(), o.shapes.add(l);
                        else {
                            for (S.convexDecomposition(!1, t.polyList), S.dispose(); !t.polyList.empty();) S = t.polyList.pop(), l = new g(S, w.Materials.WIEGHTLESS, f), o.shapes.add(l), S.dispose();
                            t.polyList.clear()
                        }
                    }
                }
                return o.align(), o.compound = n, o.userData.skinId = e.skinId, a.body = o, a.skinId = e.skinId, a.graphic = _.GraphicUtil.createCarFrameGraphic(e, m), a.create(e), a
            }, t.createCar = function(e, i, s, n, a) {
                var o = new y.BikeObject,
                    r = t.createFrame(e, i, s, o.compound);
                o.frame = r;
                var h;
                h = t.createWheel(e, o.compound, !0, r.body), o.backWheel = h, h = t.createWheel(e, o.compound, !1, r.body), o.frontWheel = h, o.brakeJoint = h.brakeJoint;
                var l;
                e.driverDensity > 0 && (l = t.createDriver(e, o.compound, r), o.driver = l), o.backWheel.brakeMaterial = o.backWheel.material.copy(), o.backWheel.brakeMaterial.dynamicFriction = o.backWheel.brakeMaterial.staticFriction = .1 * o.backWheel.material.staticFriction;
                var u = e.skinId,
                    d = y.CarsData.geom[1],
                    p;
                d.suspend_back && (p = new y.DecorObject(!0), p.graphic = _.GraphicUtil.createImage(0, 0, 0, T.AssetsStorage.instance.getByKey("suspend_back")), o.suspendBack = p, p.type = P.ObjectTypes.CAR, o.suspendBackLocal = c.get(d.suspend_back.x, d.suspend_back.y), o.suspendBackW = d.suspend_back_w), d.suspend_front && (p = new y.DecorObject(!0), p.graphic = _.GraphicUtil.createImage(0, 0, 0, T.AssetsStorage.instance.getByKey("suspend_front")), o.suspendFront = p, o.suspendFrontAngle = e.axisFrontAngle, p.type = P.ObjectTypes.CAR), o.create(e), o.x = i, o.y = s, o.rotation = 0;
                var f = m.MaxGameCore.instance;
                f.add(o.backWheel), f.add(o.frontWheel), o.suspendBack && f.add(o.suspendBack);
                var g = !1;
                return 3 !== y.Inventory.instance.skin && 2 !== y.Inventory.instance.skin || (g = !0, o.suspendFront && f.add(o.suspendFront)), f.add(o.frame), g || o.suspendFront && f.add(o.suspendFront), o.driver && (f.add(o.driver), o.driver.activateMirrorParts(!0), f.add(o.driver.parts_mirror[4]), f.add(o.driver.parts_mirror[5]), f.add(o.driver.parts_mirror[2]), f.add(o.driver.parts_mirror[3]), o.driver.activateMirrorParts(!1), 4 === u ? (f.add(o.driver.parts[2]), f.add(o.driver.parts[1]), f.add(o.driver.parts[0]), f.add(o.driver.parts[3]), f.add(o.driver.parts[4]), f.add(o.driver.parts[5])) : 2 === u ? (f.add(o.driver.parts[1]), f.add(o.driver.parts[0]), f.add(o.driver.parts[2]), f.add(o.driver.parts[3]), f.add(o.driver.parts[4]), f.add(o.driver.parts[5])) : (f.add(o.driver.parts[0]), f.add(o.driver.parts[1]), f.add(o.driver.parts[2]), f.add(o.driver.parts[3]), f.add(o.driver.parts[4]), f.add(o.driver.parts[5])), o.driver.parts_mirror[2].body.userData.handler = o, o.driver.parts_mirror[3].body.userData.handler = o, o.driver.parts_mirror[4].body.userData.handler = o, o.driver.parts_mirror[5].body.userData.handler = o, o.driver.parts[0].body.userData.handler = o, o.driver.parts[1].body.userData.handler = o, o.driver.parts[2].body.userData.handler = o, o.driver.parts[3].body.userData.handler = o, o.driver.parts[4].body.userData.handler = o, o.driver.parts[5].body.userData.handler = o), l && l.head && f.add(l.head.trailAnimObject), f.add(o), a || (o.id = y.CarsData.cars.cars.length, y.CarsData.cars.cars.push(o)), o
            }, Object.defineProperty(t, "instance", {
                get: function() {
                    return null === t._instance && (t._instance = new t), t._instance
                },
                enumerable: !0,
                configurable: !0
            }), t.polyList = new l, t
        }();
    e.CarBuilder = S
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.constraint.AngleJoint,
        a = nape.constraint.PivotJoint,
        o = nape.geom.Vec2,
        r = i(0),
        h = i(1),
        l = i(38),
        c = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.started = !1, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.body.userData.graphicEx = this.graphic, this.type = h.ObjectTypes.CAR, this.body.userData.dx = t.x, this.body.userData.dy = t.y, this.body.userData.dr = t.r, this.compound = this.body.compound, this.effector = new r.BodyEffector(this.body)
            }, e.prototype.restart = function() {
                if (this.body.allowMovement = this.body.allowRotation = !0, this.trail && this.trail.init(this.body.position.x, this.body.position.y), this.trailAnimObject) {
                    this.trailAnimObject.graphic.position.set(this.body.position.x, this.body.position.y)
                }
                this.started = !1
            }, e.prototype.connect = function(t) {
                this.pivotJoint && (this.pivotJoint.active = t), this.angleJoint && (this.angleJoint.active = t, t && (this.angleJointStiff.jointMin = this.basePhase - this.deltaAngle, this.angleJointStiff.jointMax = this.basePhase + this.deltaAngle), this.angleJointStiff.active = t), t && this.trail && this.trail.init(this.body.position.x, this.body.position.y), this.trailAnimObject && (this.trailAnimObject.graphic.visible = t)
            }, e.prototype.move = function(t, e) {
                this.angleJointStiff.jointMin = this.basePhase - this.deltaAngle + t * e, this.angleJointStiff.jointMax = this.basePhase + this.deltaAngle + t * e, this.angleJoint.jointMin = this.basePhase + t * e, this.angleJoint.jointMax = this.basePhase + t * e
            }, e.prototype.release = function() {
                this.compound = null, this.pivotJoint && (this.pivotJoint.body1 = null, this.pivotJoint.body2 = null, this.pivotJoint.compound = null, this.angleJoint.body1 = null, this.angleJoint.body2 = null, this.angleJoint.compound = null, this.angleJointStiff.body1 = null, this.angleJointStiff.body2 = null, this.angleJointStiff.compound = null), this.trail && (this.trail = null), this.trailAnimObject && (this.trailAnimObject = null), this.effector && this.effector.dispose(), this.effector = null, t.prototype.release.call(this)
            }, e.prototype.createJoints = function(t, e, i, s, r) {
                void 0 === r && (r = 0);
                var h = o.get(i + e.x, s + e.y),
                    l = this.body.worldPointToLocal(h),
                    c = t.body.worldPointToLocal(h);
                this.pivotJoint = new a(this.body, t.body, l, c), this.pivotJoint.compound = this.body.compound;
                var u = t.body.rotation - this.body.rotation;
                this.basePhase = u, this.deltaAngle = r, r > 0 && (this.angleJoint = new n(this.body, t.body, u, u, 1), this.angleJoint.stiff = !1, this.angleJoint.damping = 1, this.angleJoint.frequency = 10, this.angleJoint.compound = this.body.compound, this.angleJointStiff = new n(this.body, t.body, u - r, u + r, 1), this.angleJointStiff.compound = this.body.compound), l.dispose(), c.dispose(), h.dispose()
            }, e.prototype.disableMuscles = function() {
                this.angleJoint && (this.angleJoint.active = !1, this.angleJointStiff.jointMin = this.basePhase - 5 * this.deltaAngle, this.angleJointStiff.jointMax = this.basePhase + 5 * this.deltaAngle)
            }, e.prototype.createTrail = function() {
                this.trail = new l.TrailParticlesSystem, this.trail.init(this.body.position.x, this.body.position.y)
            }, e.prototype.update = function(t) {
                if (this.trailAnimObject) {
                    var e = this.trailAnimObject.graphic;
                    e.position.set(this.body.position.x + 6, this.body.position.y - 6);
                    var i = this.body.velocity,
                        s = i.length;
                    if ((this.started || s > 400) && (this.started = !0, s > 50)) {
                        var n = i.angle;
                        n > .25 * Math.PI ? n = .25 * Math.PI : n < -.25 * Math.PI && (n = -.25 * Math.PI), e.rotation = n
                    }
                }
                this.effector.update(t)
            }, e
        }(r.GameObject);
    e.DriverPartObject = c
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = Phaser.Signal,
        n = i(0),
        a = i(0),
        o = i(0),
        r = i(3),
        h = i(21),
        l = function() {
            function t() {
                this.complete = new s, this.handlers = {}
            }
            return t.prototype.start = function() {
                this.parseParams(), this.parseLayers(), this.buildBg(), r.MaxGameCore.instance.initialDeactivate(), this.complete.dispatch(this)
            }, t.prototype.parseParams = function() {
                var t = n.RacesData.map.settings;
                n.RacesData.data.gravityY = t.gravityY, o.MaxPhysics.space.gravity.setxy(0, n.RacesData.data.gravityY), n.RacesData.data.countdown = 0
            }, t.prototype.buildBg = function() {
                var t = new n.BgObject;
                t.create();
                var e = 1,
                    i = t.layer0.height;
                e = o.GraphicUtil.game.width / o.GraphicUtil.game.height >= h.default.WIDTH / h.default.HEIGHT ? o.GraphicUtil.game.width / h.default.WIDTH : o.GraphicUtil.game.height / h.default.HEIGHT, t.layer0.scale.set(1.5 * e), t.layer0.anchor.set(1, 0), t.layer0.x = h.default.CALCULATED_WIDTH / 2, r.MaxGameCore.instance.add(t)
            }, t.prototype.parseLayers = function() {
                r.MaxGameCore.instance;
                for (var t = n.RacesData.map, e = t.layers, i = e.length, s = 0; s < i; s++) this.parseLayer(e[s], s)
            }, t.prototype.parseLayer = function(t, e) {
                if (null !== t)
                    for (var i = t.length, s = 0; s < i; s++) {
                        var n = t[s],
                            a = this.getObject(n, e);
                        null !== a ? (a.create(n), r.MaxGameCore.instance.add(a)) : this.parseObject(n)
                    }
            }, t.prototype.parseObject = function(t) {
                "PlayerWP" === t.className && n.CarsData.cars.add(t)
            }, t.prototype.getObject = function(t, e) {
                var i = t.className;
                return i.indexOf("GroundPather") >= 0 ? new n.GroundObject : i.indexOf("BonesPather") >= 0 ? new n.GroundObject : i.indexOf("LandscapeShaper") >= 0 ? new n.ShaperObject : i.indexOf("WaterShaper") >= 0 ? new n.WaterObject : i.indexOf("GeyserE") >= 0 ? null : i.indexOf("MoverPather") >= 0 ? new n.MoverPatherObject : i.indexOf("DynamicPather") >= 0 || i.indexOf("PillarPather") >= 0 ? new n.PlankObject : 0 === i.indexOf("Glass") ? new n.GlassBlock : "TiltZone" === i || "BrakeZone" === i ? new n.WaypointObject : "Dec2_1" === i ? new n.DecorMultiObject(e <= 1) : 0 === i.indexOf("Dec") || 0 === i.indexOf("Sign") || 0 === i.indexOf("Pillar") ? null !== t.params.id && t.params.id >= 0 ? new a.DecorActObject(e <= 1) : new a.DecorObject(e <= 1) : "BarrelE" === i || "Plank0" === i || "PlankBone" === i || "PlankCandy" === i ? new a.DynamicBodyObject : 0 === i.indexOf("VecDec_") ? new a.VectorDecor : "ToggleE" === i ? new a.ToggleObject : "BoostE" === i ? new a.BoostObject : "SafePointE" === i ? new a.SafePointObject : "MotorJointE" === i ? new a.MotorObject : "PivotJointE" === i ? new a.PivotObject : "CameraZoneE" === i ? new o.CameraZone : "SpikesE" === i ? new o.SpikesObject : 0 === i.indexOf("Removed") ? new o.RemovedBodyObjects : 0 === i.indexOf("Tnt") ? new o.TntObject : "FinishZone" === i ? new o.FinishObject : null
            }, t.prototype.dispose = function() {
                this.complete.removeAll()
            }, t
        }();
    e.RaceBuilder = l
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(48),
        a = Phaser.Image,
        o = i(0),
        r = i(6),
        h = i(2),
        l = function(t) {
            function e(e, i) {
                var s = t.call(this, r.GraphicUtil.game, 0, 0) || this;
                s.parts = [], s.inputEnabled = !1, s.skinId = o.Inventory.instance.skin;
                var n = h.AssetsStorage.instance,
                    l = "bike_" + o.Inventory.instance.skin + "_base";
                return s.image = new a(s.game, 0, 0, r.GraphicUtil.currentAtlass, l + "0000"), s.image.anchor.set(h.AssetsList.FRAMES_ANCHORX[s.skinId - 1], h.AssetsList.FRAMES_ANCHORY[s.skinId - 1]), s.addChild(s.image), s.explodedImage = r.GraphicUtil.createImage(0, 0, 0, n.getByKey("Car" + s.skinId.toString() + "FrameExploded")), s.explodedImage.visible = !1, s.addChild(s.explodedImage), s.boostAnim = r.GraphicUtil.createMovieClip(null, n.getByKey("RocketAnim"), 30, !0), s.boostAnim.x = -43, s.boostAnim.y = -16, s.boostAnim.play(), s.addChildAt(s.boostAnim, 0), s
            }
            return s(e, t), e.prototype.update2 = function(t) {
                for (var i = 0; i < e.PART_COUNT; i++) {
                    this.parts[i].update2(t)
                }
            }, e.prototype.createSmokeParts = function() {
                for (var t = 0; t < e.PART_COUNT; t++) {
                    var i = new n.SmokePartClip;
                    this.parts[t] = i, this.parent.addChild(i)
                }
                this.partPos = 0
            }, e.prototype.emitSmoke = function(t, i, s) {
                this.parts[this.partPos].emit(t, i, s), ++this.partPos >= e.PART_COUNT && (this.partPos = 0)
            }, e.PART_COUNT = 60, e
        }(Phaser.Sprite);
    e.FrameGraphic = l
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(6),
        a = i(8),
        o = function(t) {
            function e() {
                var e = t.call(this, n.GraphicUtil.game) || this;
                e.anim = null;
                var i = "TrailCircle",
                    s = e.game.add.sprite(0, 0, n.GraphicUtil.currentAtlass, "TrailCircle0000");
                return s.anchor.set(.5), e.addChild(s), e.visible = !1, e.alpha = .3, e.anim = e.game.add.tween(e), e.anim.to({
                    alpha: 0
                }, 500, a.Easing.Linear.None, !1), e.anim.onComplete.add(e.animationComplete, e), e
            }
            return s(e, t), e.prototype.animationComplete = function() {
                this.visible = !1, this.alpha = .3
            }, e.prototype.emit = function(t, e) {
                this.visible = !0, this.x = t, this.y = e, this.anim.start()
            }, e
        }(Phaser.Group);
    e.TrailPart = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(49),
        a = i(0),
        o = function(t) {
            function e(e, i) {
                var s = t.call(this, a.GraphicUtil.game, 0, 0, a.GraphicUtil.currentAtlass, "Wheel_" + a.Inventory.instance.skin + "_00000") || this;
                return s.parts = [], s.parts2 = [], s.anchor.set(.5), s
            }
            return s(e, t), e.prototype.createGroundParts = function() {
                for (var t = 0; t < e.PART_COUNT; t++) {
                    var i = new n.GroundPartClip;
                    this.parts[t] = i, this.parent.addChild(i)
                }
                this.partPos = 0
            }, e.prototype.emitGround = function(t, i, s, n) {
                var a = this.parts[this.partPos],
                    o = e.PART_SPEED + e.PART_DELTA * Math.random(),
                    r = Math.random() * e.ANGLE_DELTA;
                r = n ? s - r : s + r;
                var h = 2 * Math.PI * Math.random();
                a.emit(t + 8 * Math.cos(h), i + 8 * Math.cos(h), o * Math.cos(r), o * Math.sin(r)), this.partPos++, this.partPos >= e.PART_COUNT && (this.partPos = 0), this.hasParts = !0
            }, e.prototype.update2 = function(t) {
                if (this.hasParts) {
                    this.hasParts = !1;
                    for (var i = 0; i < e.PART_COUNT; i++) {
                        var s = this.parts[i];
                        s.update2(t), s.anim.isPlaying && (this.hasParts = !0)
                    }
                }
            }, e.prototype.createAlienParts = function() {
                for (var t = 0; t < a.FrameGraphic.PART_COUNT; t++) {
                    var e = new a.TrailPart;
                    this.parts2[t] = e, this.parent.addChildAt(e, 0)
                }
                this.partPos2 = 0
            }, e.prototype.emitAlienBlur = function(t, e) {}, e.prototype.restart = function() {
                if (this.hasParts) {
                    for (var t = 0; t < e.PART_COUNT; t++) {
                        this.parts[t].visible = !1
                    }
                    this.hasParts = !1
                }
            }, e.PART_COUNT = 60, e.PART_SPEED = 128, e.PART_DELTA = 64, e.ANGLE_DELTA = .1 * Math.PI, e
        }(Phaser.Sprite);
    e.WheelGraphic = o
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t() {}
        return t
    }();
    e.BgEl = s
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = function(t) {
            function e(e, i, s) {
                var a = t.call(this, n.GraphicUtil.game) || this;
                return a.x = e.params.x - i, a.y = e.params.y - s, a
            }
            return s(e, t), e.prototype.dispose = function() {
                this.destroy()
            }, e
        }(Phaser.Group);
    e.LandscapeShape = a
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(50),
        a = nape.geom.Vec2,
        o = i(0),
        r = i(39),
        h = i(10),
        l = i(4),
        c = i(18),
        u = i(14),
        d = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.MIN_AC_BR_TIME = 1, e.MAX_VEL_TIME = 2, e.maxVelTimer = 0, e
            }
            return s(e, t), e.prototype.restart = function() {
                this.suspendBack && (this.suspendBack.graphic.visible = !0), this.suspendFront && (this.suspendFront.graphic.visible = !0), this.accelWithBrakeTimer = 0, this.maxVelTimer = 0, this.exploded = !1, t.prototype.restart.call(this)
            }, e.prototype.applyDrive = function(t, e, i) {
                var s = this.controller.accell,
                    n = this.controller.brake;
                this.accell = this.controller.accell;
                var a = this.accelTorque,
                    o = this.maxAngularVel;
                if (this.deltaTorque > 0 && s) {
                    var r = this.speed / this.wheelRadius;
                    if (r < o) {
                        var h = void 0,
                            l = .5,
                            c = 2.5,
                            u = 1 / 9,
                            d = 4,
                            p = .5 + 2.5 * r / o;
                        h = (1 / (p * p) - 1 / 9) / (4 - 1 / 9), a = this.accelTorque + h * this.deltaTorque
                    }
                }
                s && n ? this.accelWithBrakeTimer += t : (this.accelWithBrakeTimer > this.MIN_AC_BR_TIME && (this.maxVelTimer = this.MAX_VEL_TIME), this.accelWithBrakeTimer = 0), this.brakePart = this.accelWithBrakeTimer / this.MIN_AC_BR_TIME, this.brakePart > 1 && (this.brakePart = 1);
                var f;
                n ? (f = this.frontWheel.body, Math.abs(f.angularVel) < 1 && (this.brakeJoint.jointMin = this.brakeJoint.jointMax = f.rotation - this.frame.body.rotation, this.brakeJoint.active = !0), f.angularVel *= .25, this.backWheel.brake(!0), s || (this.backWheel.body.angularVel = 0)) : (this.brakeJoint.active = !1, this.backWheel.brake(!1)), s ? (f = this.backWheel.body, this.maxVelTimer > 0 ? (f.angularVel < 1.2 * o && f.applyAngularImpulse(1.5 * t * a), this.maxVelTimer -= t) : (f.angularVel < 0 && (f.angularVel *= .5), f.angularVel < o && f.applyAngularImpulse(t * a))) : this.maxVelTimer = 0
            }, e.prototype.explode = function() {
                if (!this.exploded) {
                    this.suspendBack && (this.suspendBack.graphic.visible = !1), this.suspendFront && (this.suspendFront.graphic.visible = !1), this.exploded = !0;
                    var t;
                    t = this.backWheel.body.position.sub(this.frame.body.position), t.normalise(), t.muleq(500), this.backWheel.connect(!1), this.backWheel.body.velocity.addeq(t), t.dispose(), t = this.frontWheel.body.position.sub(this.frame.body.position), t.normalise(), t.muleq(500), this.frontWheel.connect(!1), this.frontWheel.body.velocity.addeq(t), t.dispose(), t = a.fromPolar(100, -.5 * Math.PI), this.frame.body.velocity.addeq(t), t.dispose(), r.CarExplodeObject.get()
                        .activate(this.frame.body.position.x, this.frame.body.position.y), o.RacesData.data.camera.shake(), h.default.getInstance()
                        .play(l.Sounds.Explode2);
                    var e = this.frame.graphic;
                    e.image.visible = !1, e.explodedImage.visible = !0, this.driver.head && this.driver.head.trailAnimObject && this.driver.head.trailAnimObject.graphic && (this.driver.head.trailAnimObject.graphic.visible = !1), this.finished
                }
            }, e.prototype.processDriverSpikes = function() {
                this.driver.pricessSpikes()
            }, e.prototype.processDriverGround = function() {
                this.dead || (this._drive = !1, this.dead = !0, this.driver.connectDriver(!1), this.driver.disableMuscle(), this.driver.activateMirrorParts(!0), this.applyTilt(0, 0), this.callbackDie && this.callbackDie.call(this.callbackContext))
            }, e.prototype.review = function() {
                this.suspendBack && (this.suspendBack.graphic.visible = !0), this.suspendFront && (this.suspendFront.graphic.visible = !0), this.exploded = !1, this.brakeJoint && (this.brakeJoint.active = !1);
                var e = this.frame.graphic;
                e.image.visible = !0, e.explodedImage.visible = !1, this.driver.head && this.driver.head.trailAnimObject && this.driver.head.trailAnimObject.graphic && (this.driver.head.trailAnimObject.graphic.visible = !0), t.prototype.review.call(this)
            }, e
        }(n.CarObject);
    e.BikeObject = d
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(3),
        h = i(6),
        l = i(9),
        c = i(7),
        u = i(2),
        d = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.type = o.ObjectTypes.CAR, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = t;
                this.space = r.MaxGameCore.instance.getSpace(), this.graphic = h.GraphicUtil.createImageWithObj(null, u.AssetsStorage.instance.getByKey("car_corpse" + e.skinId.toString())), this.body = a.NapeUtil.createPolyBody(u.AssetsStorage.instance.getByKey("car_corpse_points" + e.skinId.toString()), l.Materials.DEFAULT, c.Filters.WITH_EARTH_ONLY, n.DYNAMIC), this.restart()
            }, e.prototype.activate = function(t, e, i, s) {
                this.body.position.set(t), this.body.rotation = e, this.body.velocity.set(i), this.body.angularVel = s, this.graphic.visible = !0, this.body.space = this.space
            }, e.prototype.restart = function() {
                this.deactivate()
            }, e.prototype.release = function() {
                t.prototype.release.call(this)
            }, e.prototype.deactivate = function() {
                this.graphic.visible = !1, this.body.space = null
            }, e
        }(a.GameObject);
    e.CorpseObject = d
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.constraint.AngleJoint,
        a = nape.constraint.PivotJoint,
        o = nape.geom.Vec2,
        r = i(0),
        h = i(5),
        l = i(19),
        c = i(10),
        u = i(4),
        d = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.parts = [], e.parts_mirror = [], e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null)
            }, e.prototype.move = function(t, e) {
                var i = this.dx * t;
                this.body.shapes.at(0)
                    .localCOM.x = i, this.parts[3].move(e, 30 * h.default.TO_RAD), this.parts[2].move(e, -45 * h.default.TO_RAD), this.parts[4].move(e, -45 * h.default.TO_RAD);
                var s = 15 * e * h.default.TO_RAD;
                this.angleJointLegStiff.jointMin = this.basePhaseLeg - this.deltaAngleLeg + s, this.angleJointLegStiff.jointMax = this.basePhaseLeg + this.deltaAngleLeg + s, this.angleJointLeg.jointMin = this.basePhaseLeg + s, this.angleJointLeg.jointMax = this.basePhaseLeg + s
            }, e.prototype.release = function() {
                this.frameBody = null, this.head && this.head.release(), this.head = null, this.pivotJointArm.body1 = null, this.pivotJointArm.body2 = null, this.pivotJointArm.compound = null, this.angleJointArm.body1 = null, this.angleJointArm.body2 = null, this.angleJointArm.compound = null, this.angleJointArmStiff.body1 = null, this.angleJointArmStiff.body2 = null, this.angleJointArmStiff.compound = null, this.pivotJointLeg.body1 = null, this.pivotJointLeg.body2 = null, this.pivotJointLeg.compound = null, this.angleJointLeg.body1 = null, this.angleJointLeg.body2 = null, this.angleJointLeg.compound = null, this.angleJointLegStiff.body1 = null, this.angleJointLegStiff.body2 = null, this.angleJointLegStiff.compound = null, this.weld.active = !1, this.weld.compound = null, this.weld.body1 = null, this.weld.body2 = null, this.weld = null, t.prototype.release.call(this)
            }, e.prototype.restart = function() {
                this.spiked = !1
            }, e.prototype.connect = function(t) {
                this.weld.active = t;
                for (var e = 0; e < this.parts.length; e++) {
                    this.parts[e].connect(t)
                }
            }, e.prototype.stop = function() {
                l.NapeUtil.stopBody(this.body);
                for (var t = 0; t < this.parts.length; t++) {
                    var e = this.parts[t];
                    l.NapeUtil.stopBody(e.body)
                }
            }, e.prototype.review = function(t) {
                this.spiked = !1, this.move(0, 0), this.body.position.x = t.x + this.body.userData.dx, this.body.position.y = t.y + this.body.userData.dy, this.body.rotation = 0;
                for (var e = 0; e < this.parts.length; e++) {
                    var i = this.parts[e].body;
                    i.position.x = t.x + i.userData.dx, i.position.y = t.y + i.userData.dy, i.rotation = i.userData.dr, i.allowMovement = i.allowRotation = !0, this.parts_mirror[e] && (i = this.parts_mirror[e].body, i.allowMovement = i.allowRotation = !0)
                }
            }, e.prototype.disableMuscle = function() {
                for (var t = this.parts.length, e = 0; e < t; e++) this.parts[e].disableMuscles()
            }, e.prototype.activateMirrorParts = function(t) {
                for (var e = this.parts.length, i = 0; i < e; i++) {
                    var s = this.parts[i],
                        n = this.parts_mirror[i];
                    n && (t && (l.NapeUtil.stopBody(n.body), n.body.position.set(s.body.position), n.body.rotation = s.body.rotation), n.body.compound = t ? n.compound : null, n.connect(t), n.graphic.visible = t)
                }
            }, e.prototype.connectArm = function(t, e, i, s, r) {
                var h = o.get(i + e.x, s + e.y),
                    l = this.frameBody.worldPointToLocal(h),
                    c = t.body.worldPointToLocal(h);
                this.pivotJointArm = new a(this.frameBody, t.body, l, c), this.pivotJointArm.compound = this.frameBody.compound;
                var u = t.body.rotation - this.frameBody.rotation;
                this.basePhaseArm = u, this.angleJointArm = new n(this.frameBody, t.body, u, u, 1), this.angleJointArm.stiff = !1, this.angleJointArm.damping = 50, this.angleJointArm.frequency = 50, this.angleJointArm.compound = this.frameBody.compound, this.deltaAngleArm = r, this.angleJointArmStiff = new n(this.frameBody, t.body, u - r, u + r, 1), this.angleJointArmStiff.compound = this.frameBody.compound, l.dispose(), c.dispose(), h.dispose()
            }, e.prototype.connectLeg = function(t, e, i, s, r) {
                var h = o.get(i + e.x, s + e.y),
                    l = this.frameBody.worldPointToLocal(h),
                    c = t.body.worldPointToLocal(h);
                this.pivotJointLeg = new a(this.frameBody, t.body, l, c), this.pivotJointLeg.compound = this.frameBody.compound;
                var u = t.body.rotation - this.frameBody.rotation;
                this.basePhaseLeg = u, this.angleJointLeg = new n(this.frameBody, t.body, u, u, 1), this.angleJointLeg.stiff = !1, this.angleJointLeg.damping = 100, this.angleJointLeg.frequency = 50, this.angleJointLeg.compound = this.frameBody.compound, this.deltaAngleLeg = r, this.angleJointLegStiff = new n(this.frameBody, t.body, u - r, u + r, 1), this.angleJointLegStiff.compound = this.frameBody.compound, l.dispose(), c.dispose(), h.dispose()
            }, e.prototype.connectDriver = function(t) {
                this.pivotJointArm && (this.pivotJointArm.active = t), this.angleJointArm && (this.angleJointArm.active = t), this.angleJointArmStiff && (this.angleJointArmStiff.active = t), this.pivotJointLeg && (this.pivotJointLeg.active = t), this.angleJointLeg && (this.angleJointLeg.active = t), this.angleJointLegStiff && (this.angleJointLegStiff.active = t)
            }, e.prototype.pricessSpikes = function() {
                this.spiked || (this.spiked = !0, c.default.getInstance()
                    .play(u.Sounds.DriverSpikes))
            }, e
        }(r.GameObject);
    e.DriverObject = d
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Ray,
        a = nape.geom.Vec2,
        o = i(0),
        r = i(19),
        h = i(3),
        l = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.END_GROUND_COLLISION_DELAY = .1, e.maxFlipVel = 3, e.fire = null, e.type = o.ObjectTypes.CAR, e
            }
            return s(e, t), e.prototype.create = function(e) {
                void 0 === e && (e = null), t.prototype.create.call(this, e), this.space = h.MaxGameCore.instance.getSpace();
                var i = e;
                this.wheelBackDx = i.wheelBackDx, this.wheelFrontDx = i.wheelFrontDx, this.wheelDy = Math.max(i.axisBackY + i.axisBackLen + i.wheelBackR, i.axisFrontY + i.axisFrontLen + i.wheelFrontR), this.ray = new n(a.weak(), a.weak(0, 1)), r.NapeUtil.setupStartPos(this.body), this.localSmokePos = a.get(-43, -16), this.localFirePos = a.get(5, -55), this.effector = new o.BodyEffector(this.body), this.restart()
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0);
                for (var e = !1, i = this.body.arbiters.iterator(); i.hasNext();) {
                    var s = i.next();
                    if (s.isCollisionArbiter()) {
                        if ((s.body1 === this.body ? s.body2 : s.body1)
                            .userData.isGround) {
                            e = !0;
                            break
                        }
                    }
                }
                e ? (this.endGroundCollisionDelay = 0, this.hasGround = !0) : this.hasGround && 0 === this.endGroundCollisionDelay && (this.endGroundCollisionDelay = this.END_GROUND_COLLISION_DELAY), this.hasGround && this.endGroundCollisionDelay > 0 && (this.endGroundCollisionDelay -= t, this.endGroundCollisionDelay <= 0 && (this.hasGround = !1)), this.graphic.update(t), this.effector.update(t)
            }, e.prototype.restart = function() {
                r.NapeUtil.stopBody(this.body), r.NapeUtil.resetStartPos(this.body), r.NapeUtil.clearUserData(this.body), r.NapeUtil.setupStartPos(this.body), this.effector.reset(), this.body.userData.reviewX = this.body.position.x, this.body.userData.reviewY = this.body.position.y
            }, e.prototype.release = function() {
                this.localSmokePos.dispose(), this.localSmokePos = null, this.localFirePos = null, r.NapeUtil.disposeBody(this.body), this.body = null, this.effector.dispose(), this.effector = null, t.prototype.release.call(this)
            }, e.prototype.review = function() {
                this.body.position.setxy(this.body.userData.reviewX, this.body.userData.reviewY), this.body.rotation = 0
            }, e
        }(o.GameObject);
    e.FrameObject = l
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Vec2,
        a = i(1),
        o = i(0),
        r = i(19),
        h = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.type = a.ObjectTypes.CAR_PART, e
            }
            return s(e, t), e.prototype.restart = function() {
                this.timer = 0, this.hide()
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.space = this.body.space, this.localPos = t, this.body.userData.graphicEx = this.graphic, this.restart()
            }, e.prototype.put = function(t) {
                var i = t.localPointToWorld(this.localPos, !1);
                this.body.position.set(i), i.dispose(), this.body.rotation = t.rotation % (2 * Math.PI);
                var s = -.25 * Math.PI - .5 * Math.PI * Math.random();
                this.localPos.x > 0 ? s += .25 * Math.PI : s -= .25 * Math.PI;
                var a = 250,
                    o = n.fromPolar(250, s);
                o.addeq(t.velocity), this.body.velocity.set(o), o.dispose(), this.body.angularVel = 2 * Math.random() - 1, this.body.space = this.space, this.graphic.visible = !0, this.graphic.position.set(this.body.position.x, this.body.position.y), this.graphic.rotation = this.body.rotation, this.timer = e.LIFE_TIME
            }, e.prototype.hide = function() {
                this.body.space = null, this.graphic.visible = !1
            }, e.prototype.release = function() {
                this.localPos = null, this.body.space = null, this.space = null, r.NapeUtil.disposeBody(this.body), this.body = null
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.timer > 0 && (this.timer -= t, this.timer <= 0 && (o.RaceCamera.inCamera(this.graphic.x, this.graphic.y, 32) ? this.timer = e.LIFE_TIME : this.hide()))
            }, e.LIFE_TIME = 2, e
        }(o.GameObject);
    e.PartObject = h
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(19),
        r = i(38),
        h = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.landFlyTime = 0, e.DISABLECCD_OFF_TIME = .25, e.DISABLECCD_ON_TIME = .05, e.hasGround = !1, e.endGroundCollisionDelay = 0, e.END_GROUND_COLLISION_DELAY = .25, e.START_SPIN_FRICTION = .01, e.START_SPIN_DELAY = 1, e.SMOKE_INIT_DELTA = 250, e.isPlayer = !0, e.braked = !1, e.type = a.ObjectTypes.CAR, e
            }
            return s(e, t), e.prototype.create = function(e) {
                void 0 === e && (e = null), t.prototype.create.call(this, e), this.friction = this.material.dynamicFriction, this.circle = this.body.shapes.at(0), this.radius = this.circle.radius, o.NapeUtil.setupStartPos(this.body), this.freq = this.distanceJoint.frequency, this.jointMax = this.distanceJoint.jointMax, this.jointMin = this.distanceJoint.jointMin, this.lineMax = this.lineJoint.jointMax, this.effector = new n.BodyEffector(this.body), this.restart()
            }, e.prototype.restart = function() {
                this.body.constraints.length > 0 && (this.body.constraints.at(0)
                    .active = !1, this.body.constraints.at(1)
                    .active = !1), this.flyTime = 0, this.material.staticFriction = this.material.dynamicFriction = this.friction, this.body.disableCCD = !0, this.disableOnDelay = 0, this.startSpinDelay = 0, o.NapeUtil.stopBody(this.body), o.NapeUtil.resetStartPos(this.body), this.body.constraints.length > 0 && (this.body.constraints.at(0)
                    .active = !0, this.body.constraints.at(1)
                    .active = !0), this.brakeJoint && (this.brakeJoint.active = !1), this.trail && this.trail.init(this.body.position.x, this.body.position.y), this.effector.reset()
            }, e.prototype.release = function() {
                this.lineJoint.compound = null, this.lineJoint.body1 = null, this.lineJoint.body2 = null, this.lineJoint = null, this.distanceJoint.compound = null, this.distanceJoint.body1 = null, this.distanceJoint.body2 = null, this.distanceJoint = null, o.NapeUtil.disposeBody(this.body), this.body = null, this.circle = null, this.trail = null, this.effector.dispose(), this.effector = null, t.prototype.release.call(this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.startSpinDelay > 0 && (this.startSpinDelay -= t, this.startSpinDelay <= 0 ? this.material.staticFriction = this.material.dynamicFriction = this.friction : this.startSpinDelay < .5 * this.START_SPIN_DELAY && (this.material.staticFriction = this.START_SPIN_FRICTION + (this.friction - this.START_SPIN_FRICTION) * (.5 * this.START_SPIN_DELAY - this.startSpinDelay) / (.5 * this.START_SPIN_DELAY), this.material.dynamicFriction = this.material.staticFriction));
                for (var e = !1, i = this.body.arbiters.iterator(), s = 0, n = 0, a; i.hasNext();) {
                    var o = i.next();
                    if (o.isCollisionArbiter()) {
                        if ((o.body1 === this.body ? o.body2 : o.body1)
                            .userData.isGround) {
                            e = !0;
                            var r = o.collisionArbiter.contacts.at(0)
                                .position;
                            s = r.x, n = r.y, a = o.collisionArbiter.normal.angle, o.body1 === this.body && (a += Math.PI);
                            break
                        }
                    }
                }
                if (e && this.graphic && this.isPlayer && 4 !== this.skinId) {
                    var h = this.body.velocity.length,
                        l = this.body.angularVel * this.radius;
                    Math.abs(l) - Math.abs(h) > this.SMOKE_INIT_DELTA && (this.graphic.emitGround(s, n, a, l > 0), this.graphic.emitGround(s, n, a, l > 0), this.graphic.emitGround(s, n, a, l > 0))
                }
                e ? (this.endGroundCollisionDelay = 0, this.hasGround = !0, this.landFlyTime = this.flyTime, this.flyTime = 0) : this.hasGround && 0 === this.endGroundCollisionDelay && (this.endGroundCollisionDelay = this.END_GROUND_COLLISION_DELAY), this.hasGround ? (this.disableOnDelay > 0 && (this.disableOnDelay -= t, this.disableOnDelay <= 0 && (this.disableOnDelay = 0, this.body.disableCCD = !0)), this.endGroundCollisionDelay > 0 && (this.endGroundCollisionDelay -= t, this.endGroundCollisionDelay <= 0 && (this.hasGround = !1))) : (this.flyTime += t, this.flyTime > this.DISABLECCD_OFF_TIME && (0 === this.disableOnDelay && (this.body.disableCCD = !1), this.disableOnDelay = this.DISABLECCD_ON_TIME)), this.isPlayer && this.graphic.update2(t), this.trail && this.trail.emit(this.body.position.x, this.body.position.y), this.effector.update(t)
            }, e.prototype.startSpin = function() {
                this.distanceJoint.frequency = this.freq, this.startSpinDelay = this.START_SPIN_DELAY
            }, e.prototype.brake = function(t) {
                t ? this.braked || (this.circle.material = this.brakeMaterial, this.body.shapes.remove(this.circle), this.body.shapes.add(this.circle)) : this.braked && (this.circle.material = this.material, this.body.shapes.remove(this.circle), this.body.shapes.add(this.circle)), this.braked = t
            }, e.prototype.connect = function(t) {
                this.body.constraints.length > 1 && (this.body.constraints.at(0)
                    .active = t, this.body.constraints.at(1)
                    .active = t), t && this.trail && this.trail.init(this.body.position.x, this.body.position.y)
            }, e.prototype.createTrail = function() {
                this.trail = new r.TrailParticlesSystem, this.trail.init(this.body.position.x, this.body.position.y)
            }, e
        }(n.GameObject);
    e.WheelObject = h
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(2),
        r = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.PART_1 = -.05, e.PART_2 = -.1, e.layer2W = 0, e.type = a.ObjectTypes.BG, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = o.AssetsStorage.instance;
                this.graphic = n.GraphicUtil.game.add.group();
                var i = new o.SpriteData(e.getByKey("Bg0"));
                this.layer0 = i.bitmapData, this.graphic.addChild(this.layer0), i = new o.SpriteData(e.getByKey("Bg1"));
                var s = null;
                i && (this.layer1 = i.bitmapData, this.layer1W = i.rect.width, this.layer1Rect = i.rect.clone(this.layer1Rect), this.graphic.addChild(this.layer1), s = i.bitmapData, s.x = this.layer1Rect.width - 1, this.layer1.addChild(s), s = i.bitmapData, s.x = 2 * (this.layer1Rect.width - 1), this.layer1.addChild(s), s = i.bitmapData, s.x = 3 * (this.layer1Rect.width - 1), this.layer1.addChild(s), s = i.bitmapData, s.x = 4 * (this.layer1Rect.width - 1), this.layer1.addChild(s), s = i.bitmapData, s.x = 5 * (this.layer1Rect.width - 1), this.layer1.addChild(s), 0 === n.RacesData.map.settings.theme ? this.layer1.y = 33 : 2 === n.RacesData.map.settings.theme ? this.layer1.y = 0 : this.layer1.y = 70), i = new o.SpriteData(e.getByKey("Bg2")), i && (this.layer2 = i.bitmapData, this.layer2W = i.rect.width, this.layer2Rect = i.rect.clone(this.layer2Rect), this.graphic.addChild(this.layer2), s = i.bitmapData, s.x = this.layer2Rect.width - 1, this.layer2.addChild(s), s = i.bitmapData, s.x = 2 * (this.layer2Rect.width - 1), this.layer2.addChild(s), s = i.bitmapData, s.x = 3 * (this.layer2Rect.width - 1), this.layer2.addChild(s), s = i.bitmapData, s.x = 4 * (this.layer2Rect.width - 1), this.layer2.addChild(s), s = i.bitmapData, s.x = 5 * (this.layer2Rect.width - 1), this.layer2.addChild(s), 0 === n.RacesData.map.settings.theme ? this.layer2.y = 80 : this.layer2.y = 130), this.startDx = Math.random() * this.layer2W
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0);
                var e = n.RacesData.TARGET_X + this.startDx;
                this.layer1 && this.updateLayer(e, this.PART_1, this.layer1, this.layer1W), this.layer2 && this.updateLayer(e, this.PART_2, this.layer2, this.layer2W)
            }, e.prototype.updateLayer = function(t, e, i, s) {
                var n = -t * e % s;
                i.x = -n
            }, e.prototype.restart = function() {}, e
        }(n.GameObject);
    e.BgObject = r
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(51),
        a = function(t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return s(e, t), e.prototype.create = function(e) {
                void 0 === e && (e = null), this.id = e.params.id, t.prototype.create.call(this, e)
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), this.graphic.visible = !t
            }, e.prototype.isActive = function() {
                return !0
            }, e
        }(n.DecorObject);
    e.DecorActObject = a
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(5),
        r = function(t) {
            function e(e) {
                var i = t.call(this) || this;
                return i.type = e ? a.ObjectTypes.LANDSCAPE : a.ObjectTypes.FRONT, i
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = t.className;
                2 === n.RacesData.map.settings.theme && (this.type = a.ObjectTypes.LANDSCAPE_BACK);
                var i = e.indexOf("_dup");
                i >= 0 && (e = e.substring(0, i));
                var s = n.GraphicUtil.game.add.group();
                if (s.x = t.params.x, s.y = t.params.y, t.params.scaleX && s.scale.set(t.params.scaleX, s.scale.y), t.params.scaleY && s.scale.set(s.scale.x, t.params.scaleY), s.rotation = t.params.rotation * o.default.TO_RAD, "Dec2_1" === e) {
                    var r = n.GraphicUtil.game.make.sprite(15, 32, n.GraphicUtil.currentAtlass, e + "0000");
                    r.anchor.set(.5, .8), s.addChild(r);
                    var h = null;
                    e += "_smoke", h = n.GraphicUtil.game.add.sprite(-70, -125, n.GraphicUtil.currentAtlass, e + "0000"), h.animations.add(e, Phaser.Animation.generateFrameNames(e, 0, 15, "", 4)), h.anchor.set(.5, 1), h.animations.getAnimation(e)
                        .play(20, !0), s.addChild(h), h = n.GraphicUtil.game.add.sprite(100, -108, n.GraphicUtil.currentAtlass, e + "0000"), h.animations.add(e, Phaser.Animation.generateFrameNames(e, 0, 15, "", 4)), h.anchor.set(.5, 1), h.scale.set(1, .5), h.animations.getAnimation(e)
                        .play(30, !0), s.addChild(h)
                }
                this.graphic = s
            }, e
        }(n.GameObject);
    e.DecorMultiObject = r
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(5),
        o = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.type = n.ObjectTypes.FRONT, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = t.className;
                if ("VecDec_0" === e) {
                    var i = "x" + e + "0000";
                    this.graphic = n.GraphicUtil.game.add.sprite(0, 0, n.GraphicUtil.currentAtlass, i), this.graphic.anchor.set(.5);
                    var s = this.graphic;
                    e = "xtop_prop";
                    var o = n.GraphicUtil.game.add.sprite(-65, -62, n.GraphicUtil.currentAtlass, "bg0000");
                    o.animations.add(e, Phaser.Animation.generateFrameNames(e, 0, 5, "", 4)), o.anchor.set(.5), o.animations.getAnimation(e)
                        .play(40, !0), s.addChild(o), e = "xback_prop", o = n.GraphicUtil.game.add.sprite(240, -39, n.GraphicUtil.currentAtlass, "bg0000"), o.animations.add(e, Phaser.Animation.generateFrameNames(e, 0, 5, "", 4)), o.anchor.set(.5), o.animations.getAnimation(e)
                        .play(40, !0), s.addChild(o), n.Drawing.setTransform(this.graphic, t.params.x, t.params.y, a.default.TO_RAD * t.params.rotation, 0, 0, t.params.scaleX, t.params.scaleY)
                }
            }, e
        }(n.GameObject);
    e.VectorDecor = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(53),
        a = nape.geom.Vec2,
        o = nape.phys.BodyType,
        r = i(0),
        h = i(52),
        l = i(3),
        c = i(6),
        u = i(11),
        d = i(7),
        p = i(20),
        f = i(1),
        g = i(5),
        y = i(9),
        m = i(2),
        v = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.switchOffDelay = 0, i.isCrashed = !1, e.lastCrackTime = 0, i
            }
            return s(e, t), e.getParts = function() {
                var t = e.pool[e.poolPos];
                return e.poolPos++, e.poolPos >= e.POOL_SIZE && (e.poolPos = 0), t
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.step = p.default.STEP, this.type = f.ObjectTypes.OBJECT, this.space = l.MaxGameCore.instance.getSpace();
                var e = t.params;
                this.safeId = e.safeId, this.ttl = e.ttl;
                var i = m.AssetsStorage.instance;
                this.className = t.className;
                var s = i.getByKey(this.className + "_data"),
                    n = e.x,
                    a = e.y,
                    h = t.params.rotation * g.default.TO_RAD,
                    v = d.Filters.GROUND;
                this.bodyW = s.w, this.bodyHHalf = .5 * s.h, this.body = r.NapeUtil.createRectBodyWH(o.STATIC, v, !1, s.w, s.h, n, a, h, null, y.Materials.DEFAULT), this.body.cbTypes.add(u.CbTypes.GLASS), this.body.cbTypes.add(u.CbTypes.GROUND), this.body.userData.collideCallback = this.processCollide, this.body.userData.collideCallbackContext = this, this.graphic = c.GraphicUtil.createImageWithObj(e, i.getByKey(this.className)), this.className.indexOf("Crashed") >= 0 && (this.createParts(this.className), this.isCrashed = !0, this.partScale = "GlassCrashed0" === this.className ? 1 : .5)
            }, e.prototype.createParts = function(t) {
                if (null === e.pool) {
                    e.pool = [];
                    for (var i = 0; i < e.POOL_SIZE; i++) {
                        for (var s = [], a = 0; a < e.VECTOR_SIZE; a++) {
                            var o = new n.GlassBlockPart(a, "GlassCrashed0_");
                            o.create(), l.MaxGameCore.instance.add(o), o.restart(), s[a] = o
                        }
                        e.pool[i] = s
                    }
                }
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.switchOffDelay > 0 && (this.switchOffDelay -= t, this.switchOffDelay <= 0 && this.switchOff())
            }, e.prototype.restart = function() {
                this.switchOffDelay = 0, this.collided = !1, this.body.space = this.space, this.graphic.visible = !0, this.graphic.alpha = 1, this.graphic.scale = 1
            }, e.prototype.release = function() {
                this.space = null, this.clearPool(), t.prototype.release.call(this)
            }, e.prototype.clearPool = function() {
                if (null !== e.pool) {
                    for (var t = 0; t < e.pool.length; t++) e.pool[t].splice(0, e.pool[t].length), e.pool[t] = null;
                    e.pool.splice(0, e.pool.length), e.pool = null
                }
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.switchOff = function() {
                this.body.space = null, this.graphic.visible = !1, this.isCrashed && this.crashGlass()
            }, e.prototype.processCollide = function(t) {
                this.collided || (this.collided = !0, this.isCrashed ? (this.collidePos = t.copy(), this.explodeX = this.collidePos.x, this.explodeY = this.collidePos.y + this.bodyHHalf, this.switchOffDelay = this.ttl) : this.ttl > e.ANIM_TIME || this.startAnim())
            }, e.prototype.startAnim = function() {
                this.isCrashed
            }, e.prototype.crashGlass = function() {
                r.RaceCamera.inCamera(this.explodeX, this.explodeY, 256) && h.GlassExplodeObject.get()
                    .activate(this.explodeX, this.explodeY);
                var t = e.getParts(),
                    i = t.length,
                    s = a.get();
                s.setxy(-.25 * this.bodyW + .5 * Math.random() * this.bodyW, this.bodyHHalf);
                var n = this.collidePos;
                n.y += 2 * this.bodyHHalf;
                for (var o = e.PARTS_DATA[this.className], l = this.body.rotation, c = 0; c < i; c++) {
                    var u = t[c];
                    s.setxy(o[c].x, o[c].y);
                    var d = this.body.localPointToWorld(s);
                    u.activate(d, l, this.partScale);
                    var p = a.get(u.body.position.x + .5 * Math.random() - n.x, u.body.position.y - n.y);
                    p.normalise(), p.length = 5, d.dispose(), u.body.applyImpulse(p, n), p.dispose()
                }
                s.dispose(), n.dispose()
            }, e.PARTS_DATA = {
                GlassCrashed0: [{
                    x: -47,
                    y: -6
                }, {
                    x: -35,
                    y: 2
                }, {
                    x: 13,
                    y: 2
                }, {
                    x: 48,
                    y: 2
                }, {
                    x: 47,
                    y: -4
                }, {
                    x: 4,
                    y: -4
                }],
                GlassCrashed1: [{
                    x: -23,
                    y: -6
                }, {
                    x: -17,
                    y: 2
                }, {
                    x: 7,
                    y: 2
                }, {
                    x: 25,
                    y: 2
                }, {
                    x: 24,
                    y: -4
                }, {
                    x: 3,
                    y: -4
                }]
            }, e.POOL_SIZE = 10, e.VECTOR_SIZE = 6, e.poolPos = 0, e.ANIM_TIME = .6, e
        }(r.GameObject);
    e.GlassBlock = v
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = Phaser.Point,
        a = i(0),
        o = i(1),
        r = i(5),
        h = i(54),
        l = i(6),
        c = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null);
                var e = t.params,
                    i = t.className,
                    s = i.indexOf("BonesPather") >= 0,
                    c = !1;
                s && (c = !0 === e.isPillar) && (e.physic = !1);
                var u = a.RacesData.map.settings.theme;
                if (3 === e.lineId && 0 === u ? this.type = o.ObjectTypes.FRONT : 3 === e.lineId && 1 === u ? this.type = o.ObjectTypes.OBJECT : this.type = o.ObjectTypes.LANDSCAPE, 0 !== e.rotation) {
                    var d = r.default.normalizeVertices(t);
                    t = d, e = d.params
                }
                var p = e.vertices,
                    f = p.length,
                    g = e.x,
                    y = e.y;
                (s && !c || !0 === e.physic) && (this.body = h.PhysicUtil.createGroundBody(t)), !0 === e.physic && (this.body = h.PhysicUtil.createGroundBody(t));
                var m = [],
                    v = 0,
                    b, x, _, w;
                for (w = 0; w < f; w++) {
                    b = p[w], 0 === w && (x = b.x, _ = b.y);
                    var C = new n(b.x - x, b.y - _);
                    m.push(C), C.y > v && (v = C.y)
                }
                if (g += x, y += _, s && (e.shape = !1, e.line = !0, e.lineId = 13), !0 !== e.shape && !0 !== e.line || (this.graphic = l.GraphicUtil.createGround(g, y, m, e.line, e.shape, v, e.lineId)), !0 === e.camera) {
                    f = m.length;
                    var P = e.cameraOffsetY;
                    for (w = 0; w < f; w++) m[w].x += g, m[w].y += y + P;
                    a.CameraPathes.instance.addPathByPoints(m)
                }
            }, e
        }(a.GameObject);
    e.GroundObject = c
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(1),
        o = i(5),
        r = i(3),
        h = i(9),
        l = i(7),
        c = i(11),
        u = i(6),
        d = i(8),
        p = i(2),
        f = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = a.ObjectTypes.LANDSCAPE, this.space = r.MaxGameCore.instance.getSpace();
                var e = t.params;
                if (this.safeId = e.safeId, 0 !== e.rotation) {
                    var i = o.default.normalizeVertices(t);
                    t = i, e = i.params
                }
                var s = e.vertices,
                    f = s.length,
                    g;
                if (0 !== e.rotation) {
                    var y = o.default.TO_RAD * e.rotation;
                    for (g = 0; g < f; g++) {
                        var m = s[g].x,
                            v = s[g].y;
                        if (0 === m && 0 === v);
                        else {
                            var b = Math.atan2(v, m),
                                x = Math.sqrt(m * m + v * v);
                            b += y, s[g].x = Math.cos(b) * x, s[g].y = Math.sin(b) * x
                        }
                    }
                }
                var _ = e.type,
                    w = 0,
                    C = 0;
                if (e.physic) {
                    var P = t.params.shapeH;
                    4 !== _ && 5 !== _ && 6 !== _ || (e.shapeH = 20, P = 20), this.body = 3 === _ || 7 === _ ? n.NapeUtil.createPatherBody(t, h.Materials.GROUND, l.Filters.NOTHING, P) : n.NapeUtil.createPatherBody(t, h.Materials.GROUND, l.Filters.GROUND, P), 4 === _ || 5 === _ || 6 === _ ? this.body.cbTypes.add(c.CbTypes.SPIKES) : this.body.cbTypes.add(c.CbTypes.GROUND), this.body.userData.isGround = !0, this.body.space = this.space, w = e.x - this.body.position.x, C = e.y - this.body.position.y
                }
                var T = t.className.indexOf("PillarPather") >= 0,
                    S;
                if (T || e.graphic) {
                    S = T ? "pillar_line" + _.toString() : 4 === _ || 5 === _ || 6 === _ ? "road_line9" : "road_line" + (_ + 5)
                        .toString();
                    var A = p.AssetsStorage.instance.getByKey(S);
                    if (A) {
                        var E = u.GraphicUtil.game.add.group();
                        E.inputEnableChildren = !1, f = s.length;
                        var I = [],
                            M = void 0,
                            O = void 0;
                        for (g = 0; g < f; g++) I[I.length] = new d.Point(s[g].x + w, s[g].y + C), T && (0 === g && (M = Math.atan2(s[g + 1].y - s[g].y, s[g + 1].x - s[g].x)), g === f - 2 && (O = Math.atan2(s[g + 1].y - s[g].y, s[g + 1].x - s[g].x)));
                        n.Drawing.drawBitmapPath2(A, E, I), this.body ? (E.x = this.body.position.x, E.y = this.body.position.y) : (E.x = e.x, E.y = e.y), this.graphic = E
                    }
                }
                this.body && this.body.isDynamic() && (n.NapeUtil.setupStartPos(this.body), this.body.userData.graphic = this.graphic)
            }, e.prototype.restart = function() {
                this.body && this.body.isDynamic() && (n.NapeUtil.stopBody(this.body), n.NapeUtil.resetStartPos(this.body))
            }, e.prototype.release = function() {
                this.space = null, t.prototype.release.call(this)
            }, e.prototype.review = function() {
                this.restart()
            }, e
        }(n.GameObject);
    e.PlankObject = f
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.constraint.PivotJoint,
        a = nape.geom.Vec2,
        o = nape.phys.BodyType,
        r = i(0),
        h = i(1),
        l = i(5),
        c = i(3),
        u = i(9),
        d = i(7),
        p = i(11),
        f = i(6),
        g = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.id = -1, e.removeOnToogle = !0, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), 1 === t.params.layer ? this.type = h.ObjectTypes.LANDSCAPE_SHAPE : this.type = h.ObjectTypes.LANDSCAPE;
                var e = t.params;
                if (0 !== e.rotation) {
                    var i = l.default.normalizeVertices(t);
                    t = i, e = i.params
                }
                this.id = e.id, this.safeId = e.safeId, null !== e.rem && !1 === e.rem && (this.removeOnToogle = !1), this.isStatic = e.isStatic, this.space = c.MaxGameCore.instance.getSpace();
                var s = e.x,
                    n = e.y;
                if (!0 === e.physic) {
                    var g = void 0;
                    1 === e.density ? g = u.Materials.GROUND : (g = u.Materials.GROUND.copy(), g.density = e.density);
                    var y = void 0;
                    y = !0 === e.plr ? d.Filters.PLAYER_ONLY : !0 === e.ignore ? d.Filters.NOTHING : d.Filters.GROUND, this.body = r.NapeUtil.createPolyBody(e, g, y, this.isStatic ? o.STATIC : o.DYNAMIC), this.body.userData.isGround = !0, this.body.cbTypes.add(p.CbTypes.GROUND), 3 === e.layer && this.body.cbTypes.add(p.CbTypes.SAW), this.body.align(), !0 === e.isWheel && (this.body.userData.isWheel = !0)
                }
                if (!0 === e.graphic) {
                    var m = 0,
                        v = 0;
                    this.body && (m = -this.body.position.x + s, v = -this.body.position.y + n);
                    var b = f.GraphicUtil.createLandscapeShape(t, m, v);
                    this.graphic = b
                }
                if (this.body) {
                    if (0 !== e.rotation) {
                        var x = a.get(s, n);
                        this.body.rotate(x, l.default.TO_RAD * e.rotation), x.dispose()
                    }
                    this.graphic && (this.graphic.x = this.body.position.x, this.graphic.y = this.body.position.y, this.graphic, r.LandscapeShape, this.graphic.rotation = this.body.rotation), this.body.space = c.MaxGameCore.instance.getSpace()
                }
                this.body && !this.isStatic && (r.NapeUtil.setupStartPos(this.body), this.graphic instanceof r.LandscapeShape ? this.body.userData.graphic = this.graphic : this.body.userData.graphicEx = this.graphic), this.removeOnToogle || this.id >= 0 && this.activate(!1)
            }, e.prototype.release = function() {
                if (e.textures) {
                    for (var i in e.textures) e.textures[i] && (e.textures[i] = null);
                    e.textures = null
                }
                this.space = null, t.prototype.release.call(this)
            }, e.prototype.activate = function(t) {
                if (void 0 === t && (t = !0), this.removeOnToogle) {
                    if (this.graphic && (this.graphic.visible = !1), this.body) {
                        for (var e = this.body.constraints.iterator(); e.hasNext();) {
                            var i = e.next();
                            i instanceof n && (i.active = !1)
                        }
                        this.body.space = null
                    }
                } else this.body && this.body.constraints.length <= 0 && (this.body.space = t ? this.space : null)
            }, e.prototype.restart = function() {
                var t, e;
                if (this.removeOnToogle) {
                    if (this.graphic && (this.graphic.visible = !0), this.body)
                        for (this.body.space = this.space, t = this.body.constraints.iterator(); t.hasNext();)(e = t.next()) instanceof n && (e.active = !0)
                } else this.id >= 0 && this.activate(!1);
                this.body && !this.isStatic && (r.NapeUtil.stopBody(this.body), r.NapeUtil.resetStartPos(this.body))
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.isActive = function() {
                return !0
            }, e
        }(r.GameObject);
    e.ShaperObject = g
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Vec2,
        a = nape.phys.BodyType,
        o = i(0),
        r = i(5),
        h = i(1),
        l = i(11),
        c = i(7),
        u = i(9),
        d = i(3),
        p = i(108),
        f = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.id = -1, e.bgShape = null, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = h.ObjectTypes.LANDSCAPE;
                var e = t.params;
                this.id = e.id;
                var i = e.x,
                    s = e.y,
                    f;
                f = u.Materials.GROUND;
                var g = c.Filters.WATER;
                this.body = o.NapeUtil.createPolyBody(e, f, g, a.STATIC), this.body.cbTypes.add(l.CbTypes.WATER), 3 === e.layer && this.body.cbTypes.add(l.CbTypes.SAW), this.body.align();
                var y = 0,
                    m = 0;
                if (this.body && (y = -this.body.position.x + i, m = -this.body.position.y + s), 0 === o.RacesData.map.settings.theme && (this.bgShape = new p.WaterShape(t, y, m, !0)), this.graphic = new p.WaterShape(t, y, m), this.body) {
                    if (0 !== e.rotation) {
                        var v = n.get(i, s);
                        this.body.rotate(v, r.default.TO_RAD * e.rotation), v.dispose()
                    }
                    this.graphic && (this.graphic.x = this.body.position.x, this.graphic.y = this.body.position.y, this.graphic instanceof o.LandscapeShape ? this.graphic.rotation = r.default.TO_DEG * this.body.rotation : this.graphic.rotation = this.body.rotation), this.body.space = d.MaxGameCore.instance.getSpace();
                    for (var b = 0; b < this.body.shapes.length; b++) {
                        var x = this.body.shapes.at(b);
                        x.fluidProperties.viscosity = t.params.viscosity, x.fluidProperties.density = t.params.density, x.fluidEnabled = !0
                    }
                }
            }, e.prototype.release = function() {
                this.bgShape && this.bgShape.dispose(), this.bgShape = null, t.prototype.release.call(this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.active && this.graphic.update2(t)
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), this.active = t
            }, e.prototype.isActive = function() {
                return !1
            }, e
        }(o.GameObject);
    e.WaterObject = f
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(8),
        o = function(t) {
            function e(e, i, s, a) {
                void 0 === a && (a = !1);
                var o = t.call(this, n.GraphicUtil.game) || this;
                return o.WAVE_SPEED = 50, o.waveX = 0, o.isBg = a, o.x = e.params.x - i, o.y = e.params.y - s, o.vertices = e.params.vertices, o.dx = i, o.dy = s, o.draw(), o
            }
            return s(e, t), e.prototype.draw = function() {
                var t = 16,
                    e = 4,
                    i = n.RacesData.map.settings.theme,
                    s = 1 === i,
                    o = this.isBg && 0 === i,
                    r = this;
                r.clear();
                var h = 0,
                    l = "tile_bg";
                s ? r.beginFill(8001280, 1) : o || (r.lineStyle(2, 12575231), r.beginFill(34815, .4));
                var c = this.vertices[0];
                if (o) {
                    var u = new Phaser.Graphics(this.game, 0, 0);
                    this.addChildAt(u, 0);
                    var d = new a.Point(115e3, 115e3);
                    u.beginFill(16776960, .3), u.moveTo(c.x + this.dx, c.y + this.dy - 4);
                    var p = this.vertices.length,
                        f = 0;
                    for (f = 0; f < p; f++) c = this.vertices[f], c.x + this.dx < d.x && (d.x = c.x + this.dx), c.y + this.dy - 4 < d.y && (d.y = c.y + this.dy - 4), u.lineTo(c.x + this.dx, c.y + this.dy - 4);
                    u.endFill();
                    var g = this.game.add.tileSprite(d.x, d.y, u.width, u.height, n.GraphicUtil.currentAtlass, l + "0000");
                    g.tilePosition.x = -this.dx % 256, g.tilePosition.y = -this.dy % 256, this.addChildAt(g, 0), n.GraphicUtil.masks.push(u), n.GraphicUtil.maskOwners.push(g);
                    var y = this.game.add.tileSprite(this.dx, this.dy - 4, u.width, 25, n.GraphicUtil.currentAtlass, "RoadLine0_Bg0000");
                    this.addChild(y)
                } else if (!s) {
                    r.moveTo(c.x + this.dx, c.y + this.dy + 0);
                    var m = this.vertices[1].x - this.vertices[0].x,
                        v = this.vertices[0].x,
                        b = this.vertices[0].y,
                        p = m / 16 >> 0,
                        x = m / p,
                        f = 0;
                    for (f = 0; f < p; f++) {
                        var _ = (f + 1) * x;
                        r.lineTo(v + _ + this.dx, b + 4 * Math.sin(.05 * (this.waveX + _)) + this.dy)
                    }
                    for (p = this.vertices.length, f = 2; f < p; f++) c = this.vertices[f], r.lineTo(c.x + this.dx, c.y + this.dy);
                    r.endFill()
                }
                if (o);
                else if (s) {
                    var d = new a.Point(115e3, 115e3);
                    r.beginFill(8001280, 1), r.moveTo(c.x + this.dx, c.y + this.dy);
                    var p = this.vertices.length,
                        f = 0;
                    for (f = 0; f < p; f++) c = this.vertices[f], c.x + this.dx < d.x && (d.x = c.x + this.dx), c.y + this.dy < d.y && (d.y = c.y + this.dy), r.lineTo(c.x + this.dx, c.y + this.dy);
                    r.endFill(), l = "LavaFill";
                    var g = this.game.add.tileSprite(this.dx, this.dy - 50, r.width, 168, n.GraphicUtil.currentAtlass, l + "0000");
                    this.addChild(g)
                }
            }, e.prototype.update2 = function(t) {
                this.waveX += t * this.WAVE_SPEED, this.draw()
            }, e.prototype.dispose = function() {
                this.vertices = null
            }, e
        }(Phaser.Graphics);
    e.WaterShape = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(7),
        h = i(6),
        l = i(11),
        c = i(2),
        u = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(e) {
                void 0 === e && (e = null), this.safeId = e.params.safeId, this.type = o.ObjectTypes.OBJECT, t.prototype.create.call(this, e);
                var i = e.params;
                this.body = a.NapeUtil.createCircleBody(n.STATIC, r.Filters.SENSOR, !0, 32, i.x, i.y, 0, l.CbTypes.BOOST), this.clip = h.GraphicUtil.createMovieClip(i, c.AssetsStorage.instance.getByKey("BoostAnim"), 15, !0), this.clip.play(), this.graphic = this.clip, this.body.userData.collideCallback = this.processCollide, this.body.userData.collideCallbackContext = this, this.body.userData.time = i.time, this.body.userData.force = i.force, this.collided = !1
            }, e.prototype.processCollide = function() {
                return !this.collided && (this.collided = !0, this.body.space = null, this.graphic.visible = !1, !0)
            }, e.prototype.restart = function() {
                this.collided = !1, this.graphic.visible = !0, this.body.space = a.NapePhysics.space
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.release = function() {
                t.prototype.release.call(this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.collided || this.clip.update(t)
            }, e
        }(a.GameObject);
    e.BoostObject = u
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(7),
        h = i(11),
        l = i(9),
        c = i(8),
        u = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.type = o.ObjectTypes.LANDSCAPE, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.body = a.NapeUtil.createRectBody(n.STATIC, r.Filters.SENSOR, !0, t.params, h.CbTypes.ZONE_FINISH, l.Materials.DEFAULT);
                var e = a.GraphicUtil.createGround(0, 0, [new c.Point(-.5 * t.params.width, -.5 * t.params.height), new c.Point(.5 * t.params.width, -.5 * t.params.height), new c.Point(.5 * t.params.width, .5 * t.params.height), new c.Point(-.5 * t.params.width, .5 * t.params.height)], !1, !0, 0, 100);
                e.x = t.params.x, e.y = t.params.y, this.graphic = e, a.RacesData.data.finishX = t.params.x
            }, e
        }(a.GameObject);
    e.FinishObject = u
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.constraint.MotorJoint,
        a = nape.constraint.PivotJoint,
        o = nape.geom.Vec2,
        r = i(0),
        h = i(1),
        l = i(3),
        c = i(11),
        u = i(6),
        d = i(5),
        p = i(2),
        f = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.isDynamic = !1, e
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = h.ObjectTypes.OBJECT, this.time = t.params.time, this.space = l.MaxGameCore.instance.getSpace(), this.id = t.params.id, this.safeId = t.params.safeId;
                var e = o.get(t.params.x, t.params.y);
                this.x = t.params.x, this.y = t.params.y;
                for (var i = r.NapeUtil.bodiesUnderPoint(this.space, e), s; !i.empty() && (s = i.pop(), !s.isDynamic());) s = null;
                if (s) {
                    i = r.NapeUtil.bodiesUnderPoint(this.space, e);
                    for (var f = void 0; !i.empty() && ((f = i.pop()) === s || f.cbTypes.has(c.CbTypes.TOGGLE));) f = null;
                    f || (f = this.space.world), f.isDynamic() && (this.isDynamic = !0);
                    var g = void 0;
                    f.userData.isWheel && (g = f, f = s, s = g), s.allowRotation = !1;
                    var y = s.worldPointToLocal(e),
                        m = f.worldPointToLocal(e);
                    this.pivot = new a(f, s, m, y), this.pivot.ignore = !0, this.pivot.space = this.space, this.motor = new n(f, s, t.params.rate * d.default.TO_RAD), this.motor.active = !1, this.motor.userData.id = this.id, this.motor.space = this.space, y.dispose(), m.dispose(), t.params.graphic > 0 && (this.graphic = u.GraphicUtil.createImageWithObj(t.params, p.AssetsStorage.instance.getByKey("Motor" + (t.params.graphic - 1)
                        .toString())), this.graphicRot = 0)
                }
                this.snd = !0 === t.params.snd, e.dispose()
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), this.active || this.motor && (this.motor.body2.allowRotation = !0, this.motor.active = t, this.timer = this.time, this.active = !0)
            }, e.prototype.restart = function() {
                this.motor && (this.motor.space = null, this.motor.space = this.space, this.pivot.space = null, this.pivot.space = this.space, this.motor.active = !1, this.motor.body2.allowRotation = !1), this.active = !1
            }, e.prototype.release = function() {
                this.pivot && (this.pivot.body1 = null, this.pivot.body2 = null, this.pivot.space = null, this.motor.body1 = null, this.motor.body2 = null, this.motor.space = null), this.space = null, t.prototype.release.call(this)
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0);
                var e = this.motor.body2;
                if (this.active && this.timer > 0 && (this.graphic && (this.graphicRot += t * this.motor.rate, this.graphic.rotation = this.graphicRot % (2 * Math.PI)), this.timer -= t, this.timer <= 0 && (this.motor.active = !1, e.angularVel = 0, e.allowRotation = !1)), this.graphic && this.isDynamic) {
                    var i = e.localPointToWorld(this.pivot.anchor2, !1);
                    this.graphic.x = i.x, this.graphic.y = i.y, i.dispose()
                }
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.isActive = function() {
                return !0
            }, e
        }(r.GameObject);
    e.MotorObject = f
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Vec2,
        a = nape.phys.Body,
        o = nape.phys.BodyType,
        r = nape.shape.Circle,
        h = i(0),
        l = i(3),
        c = i(9),
        u = i(7),
        d = i(5),
        p = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.cpId = -1, e.accelDist = 0, e.accel = 0, e.breaked = !1, e.dir = 1, e.prevDir = 1, e
            }
            return s(e, t), e.prototype.switchOn = function(t) {
                this.active && (this.stopOnPoint || this.stopOnEnd) || (this.dir += t, this.active = 0 !== this.dir, this.active ? this.checkChangePointDir() : (this.body.velocity.x = 0, this.body.velocity.y = 0, this.updateBodyGraphic()))
            }, e.prototype.switchOff = function(t) {
                if (this.stopOnEnd || this.stopOnPoint) {
                    if (0 !== this.dir) return;
                    this.dir += t, this.active = 0 !== this.dir, this.active ? this.checkChangePointDir() : (this.body.velocity.x = 0, this.body.velocity.y = 0, this.updateBodyGraphic())
                } else this.dir -= t, this.active = 0 !== this.dir, this.active ? this.checkChangePointDir() : (this.body.velocity.x = 0, this.body.velocity.y = 0, this.updateBodyGraphic())
            }, e.prototype.checkChangePointDir = function() {
                this.dir * this.prevDir < 0 && (this.pointDir *= -1, this.velocity.muleq(-1), this.timeToPoint = this.timeToPointTotal - this.timeToPoint), this.prevDir = this.dir
            }, e.prototype.release = function() {
                this.velocity.dispose(), this.velocity = null, this.body = null, t.prototype.release.call(this)
            }, e.prototype.restart = function() {
                this.startTime = this.baseStartTime, this.active = this.baseActive, this.angleSpeed = 0, this.baseActive ? this.dir = 1 : this.dir = 0, this.pointId = 0, this.pointDir = 1, this.body.userData.graphic && (this.body.userData.graphic.visible = !0), this.body.space = this.space;
                for (var t = 0, e = !1, i = 0; i < this.points.length; i++)
                    if (i > 0) {
                        var s = this.points[i].sub(this.points[i - 1]),
                            n = s.length;
                        if (t += n, !e && t >= this.position) {
                            this.pointId = i - 1;
                            var a = 1 - (t - this.position) / n;
                            this.body.position.x = this.points[i - 1].x + a * (this.points[i].x - this.points[i - 1].x), this.body.position.y = this.points[i - 1].y + a * (this.points[i].y - this.points[i - 1].y), this.calcVel(), e = !0
                        }
                        s.dispose()
                    } this.breaked = !1, this.body.type = o.KINEMATIC, this.body.allowRotation = !1, this.updateBodyGraphic()
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.space = l.MaxGameCore.instance.getSpace(), this.id = t.params.id, this.safeId = t.params.safeId;
                var e = null;
                if (t.params.body) this.body = new a(o.KINEMATIC, n.weak()), this.body.shapes.add(new r(16, null, c.Materials.DEFAULT, u.Filters.NOTHING)), this.body.space = this.space;
                else {
                    for (var i = n.get(t.params.x, t.params.y), s = h.NapeUtil.bodiesUnderPoint(this.space, i); !s.empty() && (e = s.pop(), !e.isDynamic());) e = null;
                    e && (this.body = e, e.type = o.KINEMATIC, h.NapeUtil.stopBody(e)), i.dispose()
                }
                this.speed = this.baseSpeed = t.params.speed, this.accelDist = null === t.params.accelDist ? 0 : t.params.accelDist, this.accelDist > 0 && (this.minSpeed = .05 * this.baseSpeed, this.accel = (this.baseSpeed * this.baseSpeed - this.minSpeed * this.minSpeed) / (2 * this.accelDist)), this.cycle = 1 === t.params.cycle, this.active = this.baseActive = 1 === t.params.active, this.startTime = this.baseStartTime = t.params.startTime, this.sideWait = t.params.sideWait ? t.params.sideWait : 0, this.sideAngle = t.params.sideAngle ? t.params.sideAngle * d.default.TO_RAD : 0, this.cpId = t.params.cpId, this.body.userData.correct = !0, this.space = this.body.space, this.baseRot = this.body.rotation, this.stopOnEnd = !0 === t.params.stopOnEnd, this.stopOnPoint = !0 === t.params.stopOnPoint, this.baseActive ? this.dir = 1 : this.dir = 0, this.pointId = 0, this.pointDir = 1;
                var p = t.params.vertices;
                this.points = new Array(p.length), this.position = t.params.position, this.velocity = n.get();
                for (var f = 0, g = !1, y = 0; y < this.points.length; y++)
                    if (this.points[y] = n.get(t.params.x + p[y].x, t.params.y + p[y].y), y > 0) {
                        var m = this.points[y].sub(this.points[y - 1]),
                            v = m.length;
                        if (f += v, !g && f >= this.position) {
                            this.pointId = y - 1;
                            var b = 1 - (f - this.position) / v;
                            this.body.position.x = this.points[y - 1].x + b * (this.points[y].x - this.points[y - 1].x), this.body.position.y = this.points[y - 1].y + b * (this.points[y].y - this.points[y - 1].y), this.calcVel(), g = !0
                        }
                        m.dispose()
                    } this.totalLength = f, this.body.userData.handler = this, this.body.userData.hasMover = !0
            }, e.prototype.calcVel = function() {
                var t = this.body.position,
                    e = this.getNextPoint(),
                    i = e.sub(t, !0),
                    s = i.angle;
                this.velocity.x = Math.cos(s) * this.speed, this.velocity.y = Math.sin(s) * this.speed;
                var n = i.length;
                this.timeToPointTotal = this.timeToPoint = n / this.speed
            }, e.prototype.calcAccelVel = function(t) {
                var e = 0,
                    i;
                if (this.pointDir > 0) {
                    for (i = 1; i <= this.pointId; i++) e += n.distance(this.points[i - 1], this.points[i]);
                    e += n.distance(this.points[this.pointId], this.body.position)
                } else {
                    for (i = this.points.length - 2; i >= this.pointId; i--) e += n.distance(this.points[i + 1], this.points[i]);
                    e += n.distance(this.points[this.pointId], this.body.position), e = this.totalLength - e
                }
                e < this.accelDist ? this.speed = this.minSpeed + e / this.accelDist * (this.baseSpeed - this.minSpeed) : e > this.totalLength - this.accelDist ? this.speed = this.minSpeed + (this.totalLength - e) / this.accelDist * (this.baseSpeed - this.minSpeed) : this.speed = this.baseSpeed;
                var s = this.body.position,
                    a = this.getNextPoint(),
                    o = a.sub(s, !0),
                    r = o.angle;
                this.velocity.x = Math.cos(r) * this.speed, this.velocity.y = Math.sin(r) * this.speed;
                var h = o.length;
                this.timeToPointTotal = this.timeToPoint = h / this.speed
            }, e.prototype.getNextPoint = function() {
                return this.pointDir > 0 ? this.pointId >= this.points.length - 1 ? this.points[0] : this.points[this.pointId + 1] : this.pointId <= 0 ? this.points[this.points.length - 1] : this.points[this.pointId - 1]
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.breaked || (this.active ? (!0 === this.body.userData.skipMove ? this.body.velocity.x = this.body.velocity.y = 0 : this.startTime > 0 ? (this.body.velocity.x = this.body.velocity.y = 0, this.startTime -= t, this.startTime <= 0 ? 0 !== this.sideAngle && 0 !== this.angleSpeed && (this.angleSpeed = 0, this.body.rotation = this.sideTarget) : 0 !== this.sideAngle && 0 !== this.angleSpeed && (this.body.rotation += this.angleSpeed * t)) : (this.timeToPoint > 0 ? this.accelDist > 0 && this.calcAccelVel(t) : (this.pointId += this.pointDir, 0 === this.pointId || this.pointId === this.points.length - 1 ? (this.sideWait > 0 && (this.startTime = this.sideWait, 0 !== this.sideAngle && (0 === this.pointId ? (this.sideTarget = this.baseRot, this.angleSpeed = -this.sideAngle / this.sideWait) : (this.sideTarget = this.baseRot + this.sideAngle, this.angleSpeed = this.sideAngle / this.sideWait))), this.cycle || (this.pointDir *= -1), this.stopOnEnd && (this.active = !1, this.dir = 0, null !== this.body && this.body.position.set(this.points[this.pointId]))) : (this.pointId < 0 || this.pointId > this.points.length - 1) && (this.pointDir > 0 ? this.pointId = 0 : this.pointId = this.points.length - 1), this.accelDist > 0 ? this.calcAccelVel(t) : this.calcVel(), this.stopOnPoint && (this.active = !1)), this.active ? (this.body.velocity.x = this.velocity.x, this.body.velocity.y = this.velocity.y) : (this.body.velocity.x = 0, this.body.velocity.y = 0), this.timeToPoint -= t), this.updateBodyGraphic()) : (this.body.allowMovement = !1, this.body.velocity.x = 0, this.body.velocity.y = 0))
            }, e.prototype.updateBodyGraphic = function() {
                var t = this.body.userData.graphic;
                t ? (t.x = this.body.position.x, t.y = this.body.position.y, t.rotation = this.body.rotation) : (t = this.body.userData.graphicEx) && (t.x = this.body.position.x, t.y = this.body.position.y, t.rotation = this.body.rotation)
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), t ? this.switchOn(1) : this.switchOff(1)
            }, e.prototype.isActive = function() {
                return !0
            }, e
        }(h.GameObject);
    e.MoverPatherObject = p
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.constraint.PivotJoint,
        a = nape.geom.Vec2,
        o = i(0),
        r = i(3),
        h = i(6),
        l = i(2),
        c = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.space = r.MaxGameCore.instance.getSpace();
                var e = t.params;
                this.id = e.id, this.safeId = e.safeId;
                for (var i = a.get(e.x, e.y), s = o.NapeUtil.bodiesUnderPoint(this.space, i), c = null, u = null, d = !0; !s.empty();) {
                    var p = s.pop();
                    if (p.isDynamic()) {
                        if (null === c) c = p;
                        else if (!0 !== c.userData.isPT && !0 === p.userData.isPT) u = c, c = p;
                        else if (null === u) {
                            if (u = p, !0 === u.userData.isPT) break
                        } else if (!0 !== u.userData.isPT && !0 === p.userData.isPT) {
                            u = p;
                            break
                        }
                    } else null === u && (u = p)
                }
                if (c) {
                    null === u && (u = this.space.world);
                    var f = c.worldPointToLocal(i),
                        g = u.worldPointToLocal(i);
                    this.pivot = new n(c, u, f, g), this.pivot.ignore = !0, this.pivot.space = this.space, f.dispose(), g.dispose();
                    var y = null === e.graphic ? 0 : e.graphic;
                    if (y > 0) {
                        var m = l.AssetsStorage.instance,
                            v = "Pivot" + (y - 1)
                            .toString();
                        this.graphic = h.GraphicUtil.createImageWithObj(e, m.getByKey(v)), this.graphic && (this.isDynamic = !(c.isStatic() || u.isStatic()), this.body2 = u)
                    }
                }
                i.dispose()
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), this.active || (this.pivot.active = !1, this.active = !0)
            }, e.prototype.restart = function() {
                this.pivot && (this.pivot.space = null, this.pivot.space = this.space, !0 !== this.pivot.userData.skipActive && (this.pivot.active = !0)), this.active = !1
            }, e.prototype.release = function() {
                this.pivot && (this.pivot.body1 = null, this.pivot.body2 = null, this.pivot.space = null), this.body2 = null, this.space = null, t.prototype.release.call(this)
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.isActive = function() {
                return !0
            }, e.prototype.update = function(t) {
                if (void 0 === t && (t = 0), this.isDynamic) {
                    var e = this.body2.localPointToWorld(this.pivot.anchor2, !1);
                    this.graphic.x = e.x, this.graphic.y = e.y, e.dispose()
                }
            }, e
        }(o.GameObject);
    e.PivotObject = c
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(55),
        a = i(3),
        o = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.INIT_TIME = 1, e.REMOVE_TIME = 1, e.initTimer = 0, e
            }
            return s(e, t), e.prototype.create = function(e) {
                void 0 === e && (e = null), t.prototype.create.call(this, e), this.space = a.MaxGameCore.instance.getSpace(), this.initTimer = this.INIT_TIME
            }, e.prototype.update = function(t) {
                void 0 === t && (t = 0), this.active ? this.timer > 0 && (this.timer -= t, this.timer <= 0 ? (this.body.space = null, this.graphic.visible = !1) : this.timer < .5 * this.REMOVE_TIME && (this.graphic.alpha = this.timer / (.5 * this.REMOVE_TIME))) : this.initTimer > 0 ? this.initTimer -= t : this.body.velocity.length > 100 && (this.active = !0, this.timer = this.REMOVE_TIME)
            }, e.prototype.activate = function(e) {
                void 0 === e && (e = !0), this.active || t.prototype.activate.call(this, e)
            }, e.prototype.restart = function() {
                this.initTimer = this.INIT_TIME, this.active = !1, this.graphic.alpha = 1, this.graphic.visible = !0, this.body.space = this.space, t.prototype.restart.call(this)
            }, e.prototype.release = function() {
                this.space = null, t.prototype.release.call(this)
            }, e
        }(n.DynamicBodyObject);
    e.RemovedBodyObjects = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(7),
        h = i(6),
        l = i(11),
        c = i(9),
        u = i(10),
        d = i(25),
        p = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = o.ObjectTypes.OBJECT, this.body = a.NapeUtil.createRectBody(n.STATIC, r.Filters.SENSOR, !0, t.params, l.CbTypes.SAFE_POINT, c.Materials.DEFAULT), this.body.userData.id = t.params.id, this.body.userData.collideCallback = this.processCollide, this.body.userData.collideCallbackContext = this, this.graphic = h.GraphicUtil.createMovieClip(t.params, "SafePointAnim")
            }, e.prototype.processCollide = function(t) {
                t.active || (t.active = !0, u.default.getInstance()
                    .play(d.default.SavePoint), t.graphic.animations.getAnimation("SafePointAnim")
                    .play(30, !1))
            }, e.prototype.restart = function() {
                this.active = !1;
                var t = this.graphic.animations.getAnimation("SafePointAnim");
                t.play(30, !1, !1), t.frame = 0, t.restart(), t.stop()
            }, e
        }(a.GameObject);
    e.SafePointObject = p
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(1),
        r = i(7),
        h = i(5),
        l = i(6),
        c = i(11),
        u = i(9),
        d = i(2),
        p = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.type = o.ObjectTypes.OBJECT;
                var e = d.AssetsStorage.instance,
                    i = t.className,
                    s = e.getByKey(i + "_data"),
                    p = t.params,
                    f = p.x,
                    g = p.y,
                    y = t.params.rotation * h.default.TO_RAD,
                    m = r.Filters.GROUND;
                this.body = a.NapeUtil.createRectBodyWH(n.STATIC, m, !1, s.w, s.h, f, g, y, c.CbTypes.SPIKES, u.Materials.DEFAULT), this.graphic = l.GraphicUtil.createImageWithObj(p, e.getByKey(i))
            }, e
        }(a.GameObject);
    e.SpikesObject = p
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.geom.Ray,
        a = nape.geom.Vec2,
        o = nape.phys.BodyType,
        r = i(0),
        h = i(1),
        l = i(6),
        c = i(7),
        u = i(3),
        d = i(5),
        p = i(9),
        f = i(39),
        g = i(2),
        y = i(10),
        m = i(4),
        v = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.id = t.params.id, this.safeId = t.params.safeId, this.type = h.ObjectTypes.OBJECT;
                var e = g.AssetsStorage.instance,
                    i = t.className,
                    s = e.getByKey(i + "_data"),
                    f = t.params,
                    y = f.x,
                    m = f.y;
                this.x = y, this.y = m, this.graphic = l.GraphicUtil.createImageWithObj(f, e.getByKey(i)), t.params.physic && (this.body = r.NapeUtil.createRectBodyWH(o.DYNAMIC, c.Filters.WITH_EARTH_ONLY, !1, s.w, s.h, y, m, d.default.TO_RAD * f.rotation, null, p.Materials.DEFAULT), this.body.userData.handler = this, this.body.userData.graphicEx = this.graphic, r.NapeUtil.setupStartPos(this.body)), this.space = u.MaxGameCore.instance.getSpace(), f.impulse > 0 ? (this.impulse = f.impulse, this.count = f.count, this.angle = 2 * Math.PI / this.count, this.ray = new n(a.weak(y, m), a.weak(1, 0)), this.radius = f.radius, this.ray.maxDistance = this.radius) : this.impulse = 0, this.stones = !0 === t.params.stones
            }, e.prototype.processCollide = function() {
                if (this.body && (this.body.space = null), this.impulse > 0)
                    for (var t = 0; t < this.count; t++) {
                        var e = t * this.angle;
                        this.ray.direction.angle = e;
                        var i = this.space.rayCast(this.ray);
                        if (i) {
                            var s = i.shape.body;
                            if (s.isDynamic()) {
                                var n = a.fromPolar(this.impulse * (this.radius - i.distance) / this.radius, e),
                                    o = this.ray.at(i.distance);
                                s.applyImpulse(n, o), o.dispose(), n.dispose()
                            }
                            i.dispose()
                        }
                    }
                if (this.active = !0, r.RaceCamera.inCamera(this.x, this.y, 256)) {
                    f.CarExplodeObject.get()
                        .activate(this.x, this.y, this.hideGraphic, null, this), r.RacesData.data.camera.shake(), y.default.getInstance()
                        .play(m.Sounds.Explode1), this.stones && y.default.getInstance()
                        .play(m.Sounds.Stones)
                } else this.graphic.visible = !1
            }, e.prototype.hideGraphic = function(t) {
                t.graphic.visible = !1
            }, e.prototype.applyDamage = function(t, e) {
                return void 0 === e && (e = null), this.processCollide(), !0
            }, e.prototype.release = function() {
                this.space = null, t.prototype.release.call(this)
            }, e.prototype.restart = function() {
                this.body && (r.NapeUtil.stopBody(this.body), r.NapeUtil.resetStartPos(this.body), this.body.space = this.space), this.active = !1, this.graphic.visible = !0, this.dead = !1
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), this.active || t && this.processCollide()
            }, e.prototype.review = function() {
                this.restart()
            }, e.prototype.isActive = function() {
                return !0
            }, e
        }(r.GameObject);
    e.TntObject = v
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(3),
        r = i(7),
        h = i(11),
        l = i(9),
        c = i(10),
        u = i(4),
        d = function(t) {
            function e() {
                var e = null !== t && t.apply(this, arguments) || this;
                return e.id_off = -1, e.sensCount = 0, e.sndId = -1, e
            }
            return s(e, t), e.prototype.restart = function() {
                this.active = !1, this.body.space = this.space, this.sensCount = 0
            }, e.prototype.dispose = function() {
                this.body.userData.collideCallback = null, this.body.userData.collideCallbackContext = null, this.body.space = null, this.body = null, this.space = null
            }, e.prototype.create = function(t) {
                void 0 === t && (t = null), this.space = o.MaxGameCore.instance.getSpace(), this.safeId = t.params.safeId, this.id = t.params.id, t.params.id_off && (this.id_off = t.params.id_off), this.body = a.NapeUtil.createRectBody(n.STATIC, r.Filters.TOGGLE, !0, t.params, h.CbTypes.TOGGLE, l.Materials.DEFAULT), !0 === t.params.off ? (this.deactivated = !0, this.body.cbTypes.add(h.CbTypes.TOGGLE_OFF)) : this.deactivated = !1, !0 === t.params.bot && (this.body.userData.bot = !0), this.body.userData.collideCallback = this.activate, this.body.userData.collideCallbackContext = this, this.sndId = t.params.sndId
            }, e.prototype.activate = function(t, e, i) {
                e || (i.id >= 0 && t && (o.MaxGameCore.instance.activate(i.id, !0), i.deactivated || (i.body.space = null), i.sensCount++), i.id_off >= 0 && t && (o.MaxGameCore.instance.activate(i.id_off, !1), i.deactivated || (i.body.space = null))), t || --i.sensCount <= 0 && o.MaxGameCore.instance.activate(i.id, t), t && (i.active || i.sndId >= 0 && c.default.getInstance()
                    .play(1 === i.sndId ? u.Sounds.Wendy : u.Sounds.FlySound()), i.active = !0)
            }, e.prototype.review = function() {
                this.restart()
            }, e
        }(a.GameObject);
    e.ToggleObject = d
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(0),
        a = i(20),
        o = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(t) {
                void 0 === t && (t = null), this.id = t.params.id;
                var i = t.params.width,
                    s = t.params.height,
                    n = i / s,
                    o = a.default.GAME_W / a.default.GAME_H;
                this.x = t.params.x, this.y = t.params.y, n === o ? (this.scale = a.default.GAME_W / i, this.move = e.STATIC) : n > o ? (this.move = e.HOR, this.scale = a.default.GAME_H / s, this.minMove = this.x - .5 * i + .5 * this.scale * i, this.maxMove = this.x + .5 * i - .5 * this.scale * i) : (this.move = e.VER, this.scale = a.default.GAME_W / i, this.minMove = this.y - .5 * s + .5 * this.scale * s, this.maxMove = this.y + .5 * s - .5 * this.scale * s)
            }, e.prototype.activate = function(t) {
                void 0 === t && (t = !0), t ? (e.focusedOnPoint = !1, e.current = this) : this.deactivate()
            }, e.prototype.deactivate = function() {
                e.current === this && (e.current = null)
            }, e.prototype.dispose = function() {
                e.current = null
            }, e.prototype.restart = function() {
                e.current = null
            }, e.prototype.isActive = function() {
                return !0
            }, e.STATIC = 0, e.HOR = 1, e.VER = 2, e.focusedOnPoint = !1, e
        }(n.GameObject);
    e.CameraZone = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.phys.BodyType,
        a = i(0),
        o = i(7),
        r = i(9),
        h = function(t) {
            function e() {
                return t.call(this) || this
            }
            return s(e, t), e.prototype.create = function(i) {
                void 0 === i && (i = null), t.prototype.create.call(this, i);
                var s, h = i.className;
                this.body = a.NapeUtil.createRectBody(n.STATIC, o.Filters.SENSOR, !0, i.params, void 0, r.Materials.DEFAULT), e.addCarsToUserData(this.body, i.params), "TiltZone" === h ? (this.body.userData.backChance = i.params.backChance, this.body.userData.frontChance = i.params.frontChance) : "BrakeZone" === h && (this.body.userData.chance = i.params.chance)
            }, e.addCarsToUserData = function(t, e) {
                var i = e.cars;
                if (null != i && i.length > 0) {
                    var s = i.split(",");
                    t.userData.cars = {};
                    for (var n = 0; n < s.length; n++) t.userData.cars[s[n]] = !0
                }
            }, e
        }(a.GameObject);
    e.WaypointObject = h
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = nape.callbacks.CbEvent,
        a = nape.callbacks.CbType,
        o = nape.callbacks.CbTypeList,
        r = nape.callbacks.InteractionListener,
        h = nape.callbacks.InteractionType,
        l = i(0),
        c = i(10),
        u = i(4),
        d = i(44),
        p = function(t) {
            function e() {
                var e = t.call(this) || this;
                return e.hasListeners = !1, e
            }
            return s(e, t), e.prototype.start = function() {
                t.prototype.start.call(this), l.RacesData.data = new l.RaceData, l.NapePhysics.space.gravity.setxy(0, l.RacesData.data.gravityY), this.hasListeners || this.setupListners()
            }, e.prototype.setupListners = function() {
                this.hasListeners = !0;
                var t;
                t = new r(n.BEGIN, h.SENSOR, l.CbTypes.BODY_COLLIDER, l.CbTypes.BOOST, this.onBoost), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.DRIVER_PART, l.CbTypes.BOOST, this.onBoost), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.WHEEL, l.CbTypes.BOOST, this.onBoost), t.space = l.NapePhysics.space;
                var i = new o;
                i.add(l.CbTypes.WHEEL), i.add(l.CbTypes.BODY_COLLIDER), t = new r(n.BEGIN, h.SENSOR, i, l.CbTypes.TOGGLE, e.onToggleSens), t.space = l.NapePhysics.space, t = new r(n.END, h.SENSOR, i, l.CbTypes.TOGGLE_OFF, e.onToggleSens), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, i, l.CbTypes.DESTOYED, this.onDestroyedSens), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.DRIVER, l.CbTypes.ZONE_FINISH, this.onFinish), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.DRIVER_PART, l.CbTypes.ZONE_FINISH, this.onFinish), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.DRIVER, l.CbTypes.SAFE_POINT, this.onCarSafePoint), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.SENSOR, l.CbTypes.DRIVER_PART, l.CbTypes.SAFE_POINT, this.onCarSafePoint), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, i, l.CbTypes.GLASS, this.onCarGlass), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER, l.CbTypes.GLASS, this.onCarGlass), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER_PART, l.CbTypes.GLASS, this.onCarGlass), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER, l.CbTypes.GROUND, this.onDriverGround), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, i, l.CbTypes.SPIKES, this.onCarSpikes), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER, l.CbTypes.SPIKES, this.onDriverSpikes), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER_PART, l.CbTypes.SPIKES, this.onDriverSpikes), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, i, l.CbTypes.SAW, this.onCarSaw), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER, l.CbTypes.SAW, this.onDriverSaw), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.DRIVER_PART, l.CbTypes.SAW, this.onDriverSaw), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.BARREL, a.ANY_BODY, this.onBarrelHit), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.COLLISION, l.CbTypes.WOOD, a.ANY_BODY, this.onWoodHit), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.FLUID, l.CbTypes.DRIVER, l.CbTypes.WATER, this.onWater), t.space = l.NapePhysics.space, t = new r(n.BEGIN, h.FLUID, l.CbTypes.DRIVER_PART, l.CbTypes.WATER, this.onWater), t.space = l.NapePhysics.space
            }, e.prototype.onWater = function(t) {
                t.int1.castBody.userData.handler.processDriverGround(), t.int1.castBody.userData.handler.explode()
            }, e.prototype.onWoodHit = function(t) {
                if (t.arbiters.at(0)
                    .collisionArbiter.normalImpulse()
                    .length > 400) {
                    var e = t.int1.castBody.position;
                    d.RaceCamera.inCamera(e.x, e.y, 0) && c.default.getInstance()
                        .play(u.Sounds.Wood)
                }
            }, e.prototype.onBarrelHit = function(t) {
                if (t.arbiters.at(0)
                    .collisionArbiter.normalImpulse()
                    .length > 400) {
                    var e = t.int1.castBody.position;
                    d.RaceCamera.inCamera(e.x, e.y, 0) && c.default.getInstance()
                        .play(Math.random() > .5 ? u.Sounds.Barrel1 : u.Sounds.Barrel2)
                }
            }, e.prototype.onDriverSaw = function(t) {
                var e = t.int1.castBody.userData.handler;
                e && (e.processDriverSpikes(), e.processDriverGround(), e.explode())
            }, e.prototype.onCarSaw = function(t) {
                t.int1.castBody.userData.handler.processDriverGround(), t.int1.castBody.userData.handler.explode()
            }, e.prototype.onCarSpikes = function(t) {
                t.int1.castBody.userData.handler.processDriverGround(), t.int1.castBody.userData.handler.explode()
            }, e.prototype.onDriverSpikes = function(t) {
                var e = t.int1.castBody.userData.handler;
                e && (e.processDriverGround(), e.processDriverSpikes()), l.NapeUtil.stopBody(t.int1.castBody), t.int1.castBody.allowMovement = t.int1.castBody.allowRotation = !1
            }, e.prototype.onDriverGround = function(t) {
                t.int1.castBody.userData.handler.processDriverGround(), t.int1.castBody.userData.handler.explode()
            }, e.prototype.onCarSafePoint = function(t) {
                var e = t.int2.castBody,
                    i = t.int1.castBody.userData.handler;
                if (i && !i.dead) {
                    i.setReviewPos(e.position.x, e.position.y, e.userData.id);
                    var s = t.int2.castBody.userData.collideCallbackContext;
                    t.int2.castBody.userData.collideCallback(s)
                }
            }, e.prototype.onCarGlass = function(t) {
                var e = t.int2.castBody.userData.collideCallback,
                    i = t.int2.castBody.userData.collideCallbackContext;
                e.call(i, t.arbiters.at(0)
                    .collisionArbiter.contacts.at(0)
                    .position)
            }, e.prototype.onFinish = function(t) {
                var e = t.int1.castBody.userData.handler;
                e && e.processFinish(t.int1.castBody.userData.collideCallbackContext)
            }, e.prototype.onDestroyedSens = function(t) {
                var e = t.int2.castBody,
                    i = t.int1.castBody,
                    s = e.userData.collideCallback;
                s(e.userData.collideCallbackContext) && s(i)
            }, e.prototype.onBoost = function(t) {
                var e = t.int2.castBody.userData,
                    i = e.collideCallback,
                    s = e.collideCallbackContext;
                if (i.call(s)) {
                    t.int1.castBody.userData.handler.addBoost(e.time, e.force)
                }
            }, e.onToggleSens = function(t) {
                if (t.event === n.BEGIN) {
                    var e = t.int2.castBody;
                    if (null === e.space) return;
                    var i = null === t.int1.castShape ? t.int1.castBody : t.int1.castShape.body,
                        s = e.userData.collideCallback,
                        a = e.userData.collideCallbackContext;
                    s(!0, i.userData.handler.dead, a)
                } else {
                    var s = t.int2.castBody.userData.collideCallback;
                    if (s) {
                        var a = t.int2.castBody.userData.collideCallbackContext;
                        s(!1, !1, a)
                    }
                }
            }, e.proccessZoneSens = function(t, e, i, s) {
                if (s) t.userData[i] = !1;
                else if (null === e.userData.cars || !0 === e.userData.cars[t.userData.skinId]) {
                    var n = e.userData.chance;
                    Math.random() < n && (t.userData[i] = !0)
                }
            }, e
        }(l.NapePhysics);
    e.MaxPhysics = p
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = function() {
        function t(t) {
            this.body = t, this.reset()
        }
        return t.prototype.update = function(t) {
            var e = this.body.userData.effectVelX,
                i = this.body.userData.effectVelY;
            if (0 !== e || 0 !== i) {
                var s = 2 * t * (e - this.body.velocity.x),
                    n = 2 * t * (i - this.body.velocity.y);
                this.body.velocity.x += s, this.body.velocity.y += n, this.body.userData.effectVelX = 0, this.body.userData.effectVelY = 0
            }
        }, t.prototype.reset = function() {
            this.body.userData.effectVelX = 0, this.body.userData.effectVelY = 0
        }, t.prototype.dispose = function() {
            this.body = null
        }, t
    }();
    e.BodyEffector = s
}, function(t, e, i) {
    "use strict";
    e.__esModule = !0;
    var s = nape.geom.Vec2,
        n = function() {
            function t(t) {
                this.timeLeft = 0, this.force = 0, this.body = t, this.compound = t.compound
            }
            return t.prototype.add = function(t, e) {
                var i = this.timeLeft <= 0;
                return i ? (this.force = e, this.timeLeft = t, this.anim.visible = !0) : (this.force = Math.max(this.force, e), this.timeLeft += t), i
            }, t.prototype.update = function(t, e) {
                if (this.timeLeft > 0) {
                    var i = this.compound.COM(),
                        n = this.body.rotation,
                        a = s.get(t * this.force * Math.cos(n), t * this.force * Math.sin(n));
                    if (this.body.applyImpulse(a, i), a.dispose(), i.dispose(), e || (this.body.angularVel *= .8), this.timeLeft -= t, this.timeLeft <= 0) return this.anim.visible = !1, !0
                }
                return !1
            }, t.prototype.dispose = function() {
                this.anim = null, this.body = null, this.compound = null
            }, t.prototype.restart = function() {
                this.anim.visible = !1, this.timeLeft = 0, this.force = 0
            }, t
        }();
    e.BoostEffector = n
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(56),
        a = i(36),
        o = function(t) {
            function e(e) {
                return t.call(this, e) || this
            }
            return s(e, t), e.prototype.getDrive = function() {
                var t = 0;
                return a.default.instance.isbtnDown ? (t--, this.brake = !0) : this.brake = !1, a.default.instance.isbtnUp ? (t++, this.accell = !0) : this.accell = !1, t
            }, e.prototype.getBoost = function() {
                return t.prototype.getBoost.call(this)
            }, e.prototype.getUseItem = function() {
                return this.car.itemId >= 0
            }, e.prototype.getTilt = function() {
                var t = 0;
                return a.default.instance.isbtnLeft && t--, a.default.instance.isbtnRight && t++, t
            }, e
        }(n.CarController);
    e.PlayerController = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0;
    var n = i(22),
        a = i(21),
        o = i(13),
        r = function(t) {
            function e(e, i, s) {
                void 0 === s && (s = n.default.Garage);
                var o = t.call(this, e, i, a.default.styleChooseLevel, function() {}, null, s) || this;
                return o.signalSelect = new Phaser.Signal, o.selected = !1, o.tween = null, o.tween2 = null, o.id = i, o.label.inputEnabled = !1, o.btn.onInputDown.add(o.onDown, o), o
            }
            return s(e, t), e.prototype.getSelect = function() {
                return this.selected
            }, e.prototype.getID = function() {
                return this.id
            }, e.prototype.setColor = function(t) {
                this.color = t
            }, e.prototype.setSelect = function(t) {
                this.selected = t, this.color >= 0 ? this.selectTint() : this.selectTween(), this.signalSelect.dispatch(this)
            }, e.prototype.selectTint = function() {
                this.selected ? (this.btn.tint = this.color, this.label.alpha = .7) : (this.label.alpha = 1, this.btn.tint = 16777215)
            }, e.prototype.selectTween = function() {
                this.selected ? (this.tween = this.game.add.tween(this.scale), this.tween.to({
                    x: 1.1,
                    y: 1.1
                }, 300, Phaser.Easing.Linear.None, !1), this.tween2 = this.game.add.tween(this.scale), this.tween2.to({
                    x: 1,
                    y: 1
                }, 300, Phaser.Easing.Linear.None, !1), this.tween2.onComplete.add(this.startTween1, this), this.tween.onComplete.add(this.startTween2, this), this.startTween1()) : (this.tween && (this.tween.stop(!1), this.game.tweens.remove(this.tween), this.tween2.stop(!1), this.game.tweens.remove(this.tween2)), this.scale.set(1), this.tween = null, this.tween2 = null)
            }, e.prototype.startTween1 = function() {
                this.tween.start()
            }, e.prototype.startTween2 = function() {
                this.tween2.start()
            }, e.prototype.onDown = function() {
                this.setSelect(!0)
            }, e.prototype.destroy = function(e) {
                this.signalSelect.removeAll(), this.signalSelect = null, t.prototype.destroy.call(this, e)
            }, e
        }(o.default);
    e.default = r
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(15),
        a = i(13),
        o = function(t) {
            function e(e, i, s, o, r, h) {
                void 0 === h && (h = null);
                var l = t.call(this, e) || this;
                return l._colorFront = "#000000", l._thickFront = 7, l._colorBack = "#FFFFFF", l._thickBack = 15, l._callback = null, l._context = null, l.inputEnableChildren = !0, l.btn = new a.default(e, i, s, o, r, h), l.label = new n.default(l.game, 0, 2, i, s), l.label.anchor.set(.5), null !== o && null !== r && (l.label.inputEnabled = !0, l.btn.label.inputEnabled = !0, l.btn.label.input.useHandCursor = !0, l._callback = o, l._context = r), l.addChild(l.btn), l.btn.label.parent.addChildAt(l.label, 0), l.game.add.existing(l), l
            }
            return s(e, t), e.prototype.drawRectHit = function() {
                var t = 1,
                    e = this.game.make.graphics();
                e.beginFill(16711680, 0), e.drawRect(1 * this.width / -2, 1 * this.height / -2, 1 * this.width, 1 * this.height), e.endFill(), e.inputEnabled = !0, this.btn.label.parent.inputEnableChildren = !0, this.btn.label.parent.onChildInputDown.add(this._callback, this._context), this.btn.label.parent.addChild(e)
            }, e.prototype.setProp = function(t, e, i, s) {
                void 0 === t && (t = null), void 0 === e && (e = null), void 0 === i && (i = null), void 0 === s && (s = null), null !== t && (this._colorFront = t), null !== i && (this._colorBack = i), null !== s && (this._thickBack = s), null !== e && (this._thickFront = e), this.btn.label.stroke = this._colorFront, this.btn.label.strokeThickness = this._thickFront, this.label.stroke = this._colorBack, this.label.strokeThickness = this._thickBack, this.game.device.desktop || null === this._callback || null === this._context || this.drawRectHit()
            }, e.prototype.setText = function(t) {
                this.label.setText(t), this.btn.setText(t)
            }, e.prototype.setFrames = function(t, e, i, s) {
                this.btn.setFrames(t, e, i, s)
            }, e.prototype.destroy = function(e) {
                this.btn = null, this.label = null, this._callback = null, this._context = null, t.prototype.destroy.call(this, e)
            }, Object.defineProperty(e.prototype, "enable", {
                get: function() {
                    return this.btn.enable
                },
                set: function(t) {
                    this.btn.enable = t
                },
                enumerable: !0,
                configurable: !0
            }), e
        }(Phaser.Group);
    e.default = o
}, function(t, e, i) {
    "use strict";
    var s = this && this.__extends || function() {
        var t = Object.setPrototypeOf || {
            __proto__: []
        }
        instanceof Array && function(t, e) {
            t.__proto__ = e
        } || function(t, e) {
            for (var i in e) e.hasOwnProperty(i) && (t[i] = e[i])
        };
        return function(e, i) {
            function s() {
                this.constructor = e
            }
            t(e, i), e.prototype = null === i ? Object.create(i) : (s.prototype = i.prototype, new s)
        }
    }();
    e.__esModule = !0, i(12), i(8);
    var n = i(4),
        a = i(27),
        o = i(16),
        r = i(32),
        h = i(15),
        l = function(t) {
            function e() {
                var i = t.call(this) || this;
                return i.name = e.Name, i.bike = null, i.logo = null, i.wait = null, i.mainParent = null, i
            }
            return s(e, t), e.prototype.preload = function() {
                t.prototype.preload.call(this), this.game.load.onFileComplete.add(this.fileComplete, this);
                var e = a.default.getInstance()
                    .checkDomain(document.URL.split("//")[1].split("/")[0]); - 1 === document.URL.indexOf("84.42.47.232") && -1 === document.URL.indexOf("192.168.10.38") || (e = !0), e ? this.preloadSplash() : this.preloadLock()
            }, e.prototype.init = function() {
                t.prototype.init.call(this), this.mainParent = this.game.add.group(), this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2, this.setPauseViewCar(this.mainParent)
            }, e.prototype.preloadLock = function() {
                this.game.load.atlas(n.Atlases.Garage, "assets/atlases/x1/" + n.Atlases.Garage + ".png", "assets/atlases/x1/" + n.Atlases.Garage + ".json")
            }, e.prototype.preloadSplash = function() {
                new o.default(this.game, 0, r.default.Name)
            }, e.prototype.createLock = function() {
                this.logo = this.game.add.image(0, -30, n.Atlases.Garage, "branding_l20000"), this.logo.anchor.set(.5), this.logo.inputEnabled = !0, this.logo.input.useHandCursor = !0, this.logo.events.onInputDown.add(this.opensitelockLink, this);
                var t = {
                        font: "25px Arial",
                        fill: "#A8DB2B"
                    },
                    e = {
                        font: "25px Arial",
                        fill: "#FFFFFF"
                    },
                    i = new h.default(this.game, 0, -200, "This is version is url-locked", t),
                    s = new h.default(this.game, 0, -160, a.default.getInstance()
                        .getUrlLock(), e),
                    o = new h.default(this.game, 0, 100, "Contact to license this game", t),
                    r = new h.default(this.game, 0, 140, "madpuffers@gmail.com", e);
                i.anchor.set(.5), s.anchor.set(.5), o.anchor.set(.5), r.anchor.set(.5), this.mainParent.addChild(this.logo), this.mainParent.addChild(i), this.mainParent.addChild(s), this.mainParent.addChild(o), this.mainParent.addChild(r)
            }, e.prototype.opensitelockLink = function() {
                window.open("http://" + a.default.getInstance()
                    .getUrlLock(), "_blank")
            }, e.prototype.createSplash = function() {}, e.prototype.fileComplete = function(t, e, i, s, n) {
                100 === t && this.game.load.onFileComplete.removeAll()
            }, e.prototype.setPauseViewCar = function(t) {
                null !== this.bike ? (this.bike.destroy(), this.bike = this.game.add.group(t)) : this.bike = this.game.add.group(t), this.bike.x = 0, this.bike.y = 10
            }, e.prototype.create = function() {
                t.prototype.create.call(this);
                var e = a.default.getInstance()
                    .checkDomain(document.URL.split("//")[1].split("/")[0]); - 1 === document.URL.indexOf("84.42.47.232") && -1 === document.URL.indexOf("192.168.10.38") || (e = !0), e ? this.createSplash() : this.createLock()
            }, e.prototype.resize = function() {
                var e = 1;
                e = this.game.width / n.Constants.WIDTH, e = e > 1 ? 1 : e, this.mainParent && (this.mainParent.x = this.game.width / 2, this.mainParent.y = this.game.height / 2), t.prototype.resize.call(this)
            }, e.prototype.shutdown = function() {
                t.prototype.shutdown.call(this)
            }, e.Name = "sitelock", e
        }(Phaser.State);
    e.default = l
}]);
